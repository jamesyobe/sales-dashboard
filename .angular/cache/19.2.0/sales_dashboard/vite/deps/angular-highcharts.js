import {
  AsyncSubject,
  Directive,
  ElementRef,
  Inject,
  Injectable,
  InjectionToken,
  Input,
  NgModule,
  setClassMetadata,
  ɵɵNgOnChangesFeature,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵinject
} from "./chunk-KUJ36N7J.js";
import {
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-SQCR6UNC.js";

// node_modules/highcharts/highcharts.js
var require_highcharts = __commonJS({
  "node_modules/highcharts/highcharts.js"(exports, module) {
    !/**
    * Highcharts JS v12.1.2 (2024-12-21)
    * @module highcharts/highcharts
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? (t._Highcharts = e(), module.exports = t._Highcharts) : "function" == typeof define && define.amd ? define("highcharts/highcharts", [], e) : "object" == typeof exports ? (t._Highcharts = e(), exports.highcharts = t._Highcharts) : (t.Highcharts && t.Highcharts.error(16, true), t.Highcharts = e());
    }("undefined" == typeof window ? exports : window, () => (() => {
      "use strict";
      let t, e;
      var i, s, o, r, a, n, h, l, d, c, p, g, u, f, m, x, y, b = {};
      b.d = (t10, e10) => {
        for (var i10 in e10) b.o(e10, i10) && !b.o(t10, i10) && Object.defineProperty(t10, i10, {
          enumerable: true,
          get: e10[i10]
        });
      }, b.o = (t10, e10) => Object.prototype.hasOwnProperty.call(t10, e10);
      var v = {};
      b.d(v, {
        default: () => lb
      }), function(t10) {
        t10.SVG_NS = "http://www.w3.org/2000/svg", t10.product = "Highcharts", t10.version = "12.1.2", t10.win = "undefined" != typeof window ? window : {}, t10.doc = t10.win.document, t10.svg = t10.doc && t10.doc.createElementNS && !!t10.doc.createElementNS(t10.SVG_NS, "svg").createSVGRect, t10.pageLang = t10.doc?.documentElement?.closest("[lang]")?.lang, t10.userAgent = t10.win.navigator && t10.win.navigator.userAgent || "", t10.isChrome = t10.win.chrome, t10.isFirefox = -1 !== t10.userAgent.indexOf("Firefox"), t10.isMS = /(edge|msie|trident)/i.test(t10.userAgent) && !t10.win.opera, t10.isSafari = !t10.isChrome && -1 !== t10.userAgent.indexOf("Safari"), t10.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(t10.userAgent), t10.isWebKit = -1 !== t10.userAgent.indexOf("AppleWebKit"), t10.deg2rad = 2 * Math.PI / 360, t10.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], t10.noop = function() {
        }, t10.supportsPassiveEvents = function() {
          let e10 = false;
          if (!t10.isMS) {
            let i10 = Object.defineProperty({}, "passive", {
              get: function() {
                e10 = true;
              }
            });
            t10.win.addEventListener && t10.win.removeEventListener && (t10.win.addEventListener("testPassive", t10.noop, i10), t10.win.removeEventListener("testPassive", t10.noop, i10));
          }
          return e10;
        }(), t10.charts = [], t10.composed = [], t10.dateFormats = {}, t10.seriesTypes = {}, t10.symbolSizes = {}, t10.chartCount = 0;
      }(i || (i = {}));
      let k = i, {
        charts: w,
        doc: M,
        win: S
      } = k;
      function T(t10, e10, i10, s10) {
        let o10 = e10 ? "Highcharts error" : "Highcharts warning";
        32 === t10 && (t10 = `${o10}: Deprecated member`);
        let r10 = I(t10), a10 = r10 ? `${o10} #${t10}: www.highcharts.com/errors/${t10}/` : t10.toString();
        if (void 0 !== s10) {
          let t11 = "";
          r10 && (a10 += "?"), G(s10, function(e11, i11) {
            t11 += `
 - ${i11}: ${e11}`, r10 && (a10 += encodeURI(i11) + "=" + encodeURI(e11));
          }), a10 += t11;
        }
        j(k, "displayError", {
          chart: i10,
          code: t10,
          message: a10,
          params: s10
        }, function() {
          if (e10) throw Error(a10);
          S.console && -1 === T.messages.indexOf(a10) && console.warn(a10);
        }), T.messages.push(a10);
      }
      function C(t10, e10) {
        return parseInt(t10, e10 || 10);
      }
      function A(t10) {
        return "string" == typeof t10;
      }
      function P(t10) {
        let e10 = Object.prototype.toString.call(t10);
        return "[object Array]" === e10 || "[object Array Iterator]" === e10;
      }
      function L(t10, e10) {
        return !!t10 && "object" == typeof t10 && (!e10 || !P(t10));
      }
      function O(t10) {
        return L(t10) && "number" == typeof t10.nodeType;
      }
      function E(t10) {
        let e10 = t10 && t10.constructor;
        return !!(L(t10, true) && !O(t10) && e10 && e10.name && "Object" !== e10.name);
      }
      function I(t10) {
        return "number" == typeof t10 && !isNaN(t10) && t10 < 1 / 0 && t10 > -1 / 0;
      }
      function D(t10) {
        return null != t10;
      }
      function B(t10, e10, i10) {
        let s10;
        let o10 = A(e10) && !D(i10), r10 = (e11, i11) => {
          D(e11) ? t10.setAttribute(i11, e11) : o10 ? (s10 = t10.getAttribute(i11)) || "class" !== i11 || (s10 = t10.getAttribute(i11 + "Name")) : t10.removeAttribute(i11);
        };
        return A(e10) ? r10(i10, e10) : G(e10, r10), s10;
      }
      function N(t10) {
        return P(t10) ? t10 : [t10];
      }
      function z(t10, e10) {
        let i10;
        for (i10 in t10 || (t10 = {}), e10) t10[i10] = e10[i10];
        return t10;
      }
      function R() {
        let t10 = arguments, e10 = t10.length;
        for (let i10 = 0; i10 < e10; i10++) {
          let e11 = t10[i10];
          if (null != e11) return e11;
        }
      }
      function W(t10, e10) {
        z(t10.style, e10);
      }
      function H(t10) {
        return Math.pow(10, Math.floor(Math.log(t10) / Math.LN10));
      }
      function X(t10, e10) {
        return t10 > 1e14 ? t10 : parseFloat(t10.toPrecision(e10 || 14));
      }
      (T || (T = {})).messages = [], Math.easeInOutSine = function(t10) {
        return -0.5 * (Math.cos(Math.PI * t10) - 1);
      };
      let F = Array.prototype.find ? function(t10, e10) {
        return t10.find(e10);
      } : function(t10, e10) {
        let i10;
        let s10 = t10.length;
        for (i10 = 0; i10 < s10; i10++) if (e10(t10[i10], i10)) return t10[i10];
      };
      function G(t10, e10, i10) {
        for (let s10 in t10) Object.hasOwnProperty.call(t10, s10) && e10.call(i10 || t10[s10], t10[s10], s10, t10);
      }
      function Y(t10, e10, i10) {
        function s10(e11, i11) {
          let s11 = t10.removeEventListener;
          s11 && s11.call(t10, e11, i11, false);
        }
        function o10(i11) {
          let o11, r11;
          t10.nodeName && (e10 ? (o11 = {})[e10] = true : o11 = i11, G(o11, function(t11, e11) {
            if (i11[e11]) for (r11 = i11[e11].length; r11--; ) s10(e11, i11[e11][r11].fn);
          }));
        }
        let r10 = "function" == typeof t10 && t10.prototype || t10;
        if (Object.hasOwnProperty.call(r10, "hcEvents")) {
          let t11 = r10.hcEvents;
          if (e10) {
            let r11 = t11[e10] || [];
            i10 ? (t11[e10] = r11.filter(function(t12) {
              return i10 !== t12.fn;
            }), s10(e10, i10)) : (o10(t11), t11[e10] = []);
          } else o10(t11), delete r10.hcEvents;
        }
      }
      function j(t10, e10, i10, s10) {
        if (i10 = i10 || {}, M.createEvent && (t10.dispatchEvent || t10.fireEvent && t10 !== k)) {
          let s11 = M.createEvent("Events");
          s11.initEvent(e10, true, true), i10 = z(s11, i10), t10.dispatchEvent ? t10.dispatchEvent(i10) : t10.fireEvent(e10, i10);
        } else if (t10.hcEvents) {
          i10.target || z(i10, {
            preventDefault: function() {
              i10.defaultPrevented = true;
            },
            target: t10,
            type: e10
          });
          let s11 = [], o10 = t10, r10 = false;
          for (; o10.hcEvents; ) Object.hasOwnProperty.call(o10, "hcEvents") && o10.hcEvents[e10] && (s11.length && (r10 = true), s11.unshift.apply(s11, o10.hcEvents[e10])), o10 = Object.getPrototypeOf(o10);
          r10 && s11.sort((t11, e11) => t11.order - e11.order), s11.forEach((e11) => {
            false === e11.fn.call(t10, i10) && i10.preventDefault();
          });
        }
        s10 && !i10.defaultPrevented && s10.call(t10, i10);
      }
      let U = function() {
        let e10 = Math.random().toString(36).substring(2, 9) + "-", i10 = 0;
        return function() {
          return "highcharts-" + (t ? "" : e10) + i10++;
        };
      }();
      S.jQuery && (S.jQuery.fn.highcharts = function() {
        let t10 = [].slice.call(arguments);
        if (this[0]) return t10[0] ? (new k[A(t10[0]) ? t10.shift() : "Chart"](this[0], t10[0], t10[1]), this) : w[B(this[0], "data-highcharts-chart")];
      });
      let $ = {
        addEvent: function(t10, e10, i10, s10 = {}) {
          let o10 = "function" == typeof t10 && t10.prototype || t10;
          Object.hasOwnProperty.call(o10, "hcEvents") || (o10.hcEvents = {});
          let r10 = o10.hcEvents;
          k.Point && t10 instanceof k.Point && t10.series && t10.series.chart && (t10.series.chart.runTrackerClick = true);
          let a10 = t10.addEventListener;
          a10 && a10.call(t10, e10, i10, !!k.supportsPassiveEvents && {
            passive: void 0 === s10.passive ? -1 !== e10.indexOf("touch") : s10.passive,
            capture: false
          }), r10[e10] || (r10[e10] = []);
          let n10 = {
            fn: i10,
            order: "number" == typeof s10.order ? s10.order : 1 / 0
          };
          return r10[e10].push(n10), r10[e10].sort((t11, e11) => t11.order - e11.order), function() {
            Y(t10, e10, i10);
          };
        },
        arrayMax: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] > i10 && (i10 = t10[e10]);
          return i10;
        },
        arrayMin: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] < i10 && (i10 = t10[e10]);
          return i10;
        },
        attr: B,
        clamp: function(t10, e10, i10) {
          return t10 > e10 ? t10 < i10 ? t10 : i10 : e10;
        },
        clearTimeout: function(t10) {
          D(t10) && clearTimeout(t10);
        },
        correctFloat: X,
        createElement: function(t10, e10, i10, s10, o10) {
          let r10 = M.createElement(t10);
          return e10 && z(r10, e10), o10 && W(r10, {
            padding: "0",
            border: "none",
            margin: "0"
          }), i10 && W(r10, i10), s10 && s10.appendChild(r10), r10;
        },
        crisp: function(t10, e10 = 0, i10) {
          let s10 = e10 % 2 / 2, o10 = i10 ? -1 : 1;
          return (Math.round(t10 * o10 - s10) + s10) * o10;
        },
        css: W,
        defined: D,
        destroyObjectProperties: function(t10, e10, i10) {
          G(t10, function(s10, o10) {
            s10 !== e10 && s10?.destroy && s10.destroy(), (s10?.destroy || !i10) && delete t10[o10];
          });
        },
        diffObjects: function(t10, e10, i10, s10) {
          let o10 = {};
          return !function t11(e11, o11, r10, a10) {
            let n10 = i10 ? o11 : e11;
            G(e11, function(i11, h10) {
              if (!a10 && s10 && s10.indexOf(h10) > -1 && o11[h10]) {
                i11 = N(i11), r10[h10] = [];
                for (let e12 = 0; e12 < Math.max(i11.length, o11[h10].length); e12++) o11[h10][e12] && (void 0 === i11[e12] ? r10[h10][e12] = o11[h10][e12] : (r10[h10][e12] = {}, t11(i11[e12], o11[h10][e12], r10[h10][e12], a10 + 1)));
              } else L(i11, true) && !i11.nodeType ? (r10[h10] = P(i11) ? [] : {}, t11(i11, o11[h10] || {}, r10[h10], a10 + 1), 0 !== Object.keys(r10[h10]).length || "colorAxis" === h10 && 0 === a10 || delete r10[h10]) : (e11[h10] !== o11[h10] || h10 in e11 && !(h10 in o11)) && "__proto__" !== h10 && "constructor" !== h10 && (r10[h10] = n10[h10]);
            });
          }(t10, e10, o10, 0), o10;
        },
        discardElement: function(t10) {
          t10 && t10.parentElement && t10.parentElement.removeChild(t10);
        },
        erase: function(t10, e10) {
          let i10 = t10.length;
          for (; i10--; ) if (t10[i10] === e10) {
            t10.splice(i10, 1);
            break;
          }
        },
        error: T,
        extend: z,
        extendClass: function(t10, e10) {
          let i10 = function() {
          };
          return i10.prototype = new t10(), z(i10.prototype, e10), i10;
        },
        find: F,
        fireEvent: j,
        getAlignFactor: (t10 = "") => ({
          center: 0.5,
          right: 1,
          middle: 0.5,
          bottom: 1
        })[t10] || 0,
        getClosestDistance: function(t10, e10) {
          let i10, s10, o10, r10;
          let a10 = !e10;
          return t10.forEach((t11) => {
            if (t11.length > 1) for (r10 = s10 = t11.length - 1; r10 > 0; r10--) (o10 = t11[r10] - t11[r10 - 1]) < 0 && !a10 ? (e10?.(), e10 = void 0) : o10 && (void 0 === i10 || o10 < i10) && (i10 = o10);
          }), i10;
        },
        getMagnitude: H,
        getNestedProperty: function(t10, e10) {
          let i10 = t10.split(".");
          for (; i10.length && D(e10); ) {
            let t11 = i10.shift();
            if (void 0 === t11 || "__proto__" === t11) return;
            if ("this" === t11) {
              let t12;
              return L(e10) && (t12 = e10["@this"]), t12 ?? e10;
            }
            let s10 = e10[t11.replace(/[\\'"]/g, "")];
            if (!D(s10) || "function" == typeof s10 || "number" == typeof s10.nodeType || s10 === S) return;
            e10 = s10;
          }
          return e10;
        },
        getStyle: function t10(e10, i10, s10) {
          let o10;
          if ("width" === i10) {
            let i11 = Math.min(e10.offsetWidth, e10.scrollWidth), s11 = e10.getBoundingClientRect && e10.getBoundingClientRect().width;
            return s11 < i11 && s11 >= i11 - 1 && (i11 = Math.floor(s11)), Math.max(0, i11 - (t10(e10, "padding-left", true) || 0) - (t10(e10, "padding-right", true) || 0));
          }
          if ("height" === i10) return Math.max(0, Math.min(e10.offsetHeight, e10.scrollHeight) - (t10(e10, "padding-top", true) || 0) - (t10(e10, "padding-bottom", true) || 0));
          let r10 = S.getComputedStyle(e10, void 0);
          return r10 && (o10 = r10.getPropertyValue(i10), R(s10, "opacity" !== i10) && (o10 = C(o10))), o10;
        },
        insertItem: function(t10, e10) {
          let i10;
          let s10 = t10.options.index, o10 = e10.length;
          for (i10 = t10.options.isInternal ? o10 : 0; i10 < o10 + 1; i10++) if (!e10[i10] || I(s10) && s10 < R(e10[i10].options.index, e10[i10]._i) || e10[i10].options.isInternal) {
            e10.splice(i10, 0, t10);
            break;
          }
          return i10;
        },
        isArray: P,
        isClass: E,
        isDOMElement: O,
        isFunction: function(t10) {
          return "function" == typeof t10;
        },
        isNumber: I,
        isObject: L,
        isString: A,
        merge: function(t10, ...e10) {
          let i10, s10 = [t10, ...e10], o10 = {}, r10 = function(t11, e11) {
            return "object" != typeof t11 && (t11 = {}), G(e11, function(i11, s11) {
              "__proto__" !== s11 && "constructor" !== s11 && (!L(i11, true) || E(i11) || O(i11) ? t11[s11] = e11[s11] : t11[s11] = r10(t11[s11] || {}, i11));
            }), t11;
          };
          true === t10 && (o10 = s10[1], s10 = Array.prototype.slice.call(s10, 2));
          let a10 = s10.length;
          for (i10 = 0; i10 < a10; i10++) o10 = r10(o10, s10[i10]);
          return o10;
        },
        normalizeTickInterval: function(t10, e10, i10, s10, o10) {
          let r10, a10 = t10;
          i10 = R(i10, H(t10));
          let n10 = t10 / i10;
          for (!e10 && (e10 = o10 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === s10 && (1 === i10 ? e10 = e10.filter(function(t11) {
            return t11 % 1 == 0;
          }) : i10 <= 0.1 && (e10 = [1 / i10]))), r10 = 0; r10 < e10.length && (a10 = e10[r10], (!o10 || !(a10 * i10 >= t10)) && (o10 || !(n10 <= (e10[r10] + (e10[r10 + 1] || e10[r10])) / 2))); r10++) ;
          return X(a10 * i10, -Math.round(Math.log(1e-3) / Math.LN10));
        },
        objectEach: G,
        offset: function(t10) {
          let e10 = M.documentElement, i10 = t10.parentElement || t10.parentNode ? t10.getBoundingClientRect() : {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          };
          return {
            top: i10.top + (S.pageYOffset || e10.scrollTop) - (e10.clientTop || 0),
            left: i10.left + (S.pageXOffset || e10.scrollLeft) - (e10.clientLeft || 0),
            width: i10.width,
            height: i10.height
          };
        },
        pad: function(t10, e10, i10) {
          return Array((e10 || 2) + 1 - String(t10).replace("-", "").length).join(i10 || "0") + t10;
        },
        pick: R,
        pInt: C,
        pushUnique: function(t10, e10) {
          return 0 > t10.indexOf(e10) && !!t10.push(e10);
        },
        relativeLength: function(t10, e10, i10) {
          return /%$/.test(t10) ? e10 * parseFloat(t10) / 100 + (i10 || 0) : parseFloat(t10);
        },
        removeEvent: Y,
        replaceNested: function(t10, ...e10) {
          let i10, s10;
          do
            for (s10 of (i10 = t10, e10)) t10 = t10.replace(s10[0], s10[1]);
          while (t10 !== i10);
          return t10;
        },
        splat: N,
        stableSort: function(t10, e10) {
          let i10, s10;
          let o10 = t10.length;
          for (s10 = 0; s10 < o10; s10++) t10[s10].safeI = s10;
          for (t10.sort(function(t11, s11) {
            return 0 === (i10 = e10(t11, s11)) ? t11.safeI - s11.safeI : i10;
          }), s10 = 0; s10 < o10; s10++) delete t10[s10].safeI;
        },
        syncTimeout: function(t10, e10, i10) {
          return e10 > 0 ? setTimeout(t10, e10, i10) : (t10.call(0, i10), -1);
        },
        timeUnits: {
          millisecond: 1,
          second: 1e3,
          minute: 6e4,
          hour: 36e5,
          day: 864e5,
          week: 6048e5,
          month: 24192e5,
          year: 314496e5
        },
        ucfirst: function(t10) {
          return A(t10) ? t10.substring(0, 1).toUpperCase() + t10.substring(1) : String(t10);
        },
        uniqueKey: U,
        useSerialIds: function(e10) {
          return t = R(e10, t);
        },
        wrap: function(t10, e10, i10) {
          let s10 = t10[e10];
          t10[e10] = function() {
            let t11 = arguments, e11 = this;
            return i10.apply(this, [function() {
              return s10.apply(e11, arguments.length ? arguments : t11);
            }].concat([].slice.call(arguments)));
          };
        }
      }, {
        pageLang: V,
        win: _
      } = k, {
        defined: q,
        error: Z,
        extend: K,
        isNumber: J,
        isObject: Q,
        isString: tt,
        merge: te,
        objectEach: ti,
        pad: ts,
        splat: to,
        timeUnits: tr,
        ucfirst: ta
      } = $, tn = k.isSafari && _.Intl && !_.Intl.DateTimeFormat.prototype.formatRange, th = (t10) => void 0 === t10.main, tl = (t10) => ["D", "L", "M", "X", "J", "V", "S"].indexOf(t10), td = class {
        constructor(t10) {
          this.options = {
            timezone: "UTC"
          }, this.variableTimezone = false, this.Date = _.Date, this.update(t10);
        }
        update(t10 = {}) {
          this.dTLCache = {}, this.options = t10 = te(true, this.options, t10);
          let {
            timezoneOffset: e10,
            useUTC: i10
          } = t10;
          this.Date = t10.Date || _.Date || Date;
          let s10 = t10.timezone;
          q(i10) && (s10 = i10 ? "UTC" : void 0), e10 && e10 % 60 == 0 && (s10 = "Etc/GMT" + (e10 > 0 ? "+" : "") + e10 / 60), this.variableTimezone = "UTC" !== s10 && s10?.indexOf("Etc/GMT") !== 0, this.timezone = s10, ["months", "shortMonths", "weekdays", "shortWeekdays"].forEach((t11) => {
            let e11 = /months/i.test(t11), i11 = /short/.test(t11), s11 = {
              timeZone: "UTC"
            };
            s11[e11 ? "month" : "weekday"] = i11 ? "short" : "long", this[t11] = (e11 ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map((t12) => this.dateFormat(s11, (e11 ? 31 : 1) * 24 * 36e5 * t12));
          });
        }
        toParts(t10) {
          let [e10, i10, s10, o10, r10, a10, n10] = this.dateTimeFormat({
            weekday: "narrow",
            day: "numeric",
            month: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
          }, t10, "es").split(/(?:, |\/|:)/g);
          return [o10, +s10 - 1, i10, r10, a10, n10, Math.floor(Number(t10) || 0) % 1e3, tl(e10)].map(Number);
        }
        dateTimeFormat(t10, e10, i10 = this.options.locale || V) {
          let s10 = JSON.stringify(t10) + i10;
          tt(t10) && (t10 = this.str2dtf(t10));
          let o10 = this.dTLCache[s10];
          if (!o10) {
            t10.timeZone ?? (t10.timeZone = this.timezone);
            try {
              o10 = new Intl.DateTimeFormat(i10, t10);
            } catch (e11) {
              /Invalid time zone/i.test(e11.message) ? (Z(34), t10.timeZone = "UTC", o10 = new Intl.DateTimeFormat(i10, t10)) : Z(e11.message, false);
            }
          }
          return this.dTLCache[s10] = o10, o10?.format(e10) || "";
        }
        str2dtf(t10, e10 = {}) {
          let i10 = {
            L: {
              fractionalSecondDigits: 3
            },
            S: {
              second: "2-digit"
            },
            M: {
              minute: "numeric"
            },
            H: {
              hour: "2-digit"
            },
            k: {
              hour: "numeric"
            },
            E: {
              weekday: "narrow"
            },
            a: {
              weekday: "short"
            },
            A: {
              weekday: "long"
            },
            d: {
              day: "2-digit"
            },
            e: {
              day: "numeric"
            },
            b: {
              month: "short"
            },
            B: {
              month: "long"
            },
            m: {
              month: "2-digit"
            },
            o: {
              month: "numeric"
            },
            y: {
              year: "2-digit"
            },
            Y: {
              year: "numeric"
            }
          };
          return Object.keys(i10).forEach((s10) => {
            -1 !== t10.indexOf(s10) && K(e10, i10[s10]);
          }), e10;
        }
        makeTime(t10, e10, i10 = 1, s10 = 0, o10, r10, a10) {
          let n10 = this.Date.UTC(t10, e10, i10, s10, o10 || 0, r10 || 0, a10 || 0);
          if ("UTC" !== this.timezone) {
            let t11 = this.getTimezoneOffset(n10);
            if (n10 += t11, -1 !== [2, 3, 8, 9, 10, 11].indexOf(e10) && (s10 < 5 || s10 > 20)) {
              let e11 = this.getTimezoneOffset(n10);
              t11 !== e11 ? n10 += e11 - t11 : t11 - 36e5 !== this.getTimezoneOffset(n10 - 36e5) || tn || (n10 -= 36e5);
            }
          }
          return n10;
        }
        parse(t10) {
          if (!tt(t10)) return t10 ?? void 0;
          let e10 = (t10 = t10.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t10), i10 = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(t10);
          e10 || i10 || (t10 += "Z");
          let s10 = Date.parse(t10);
          if (J(s10)) return s10 + (!e10 || i10 ? this.getTimezoneOffset(s10) : 0);
        }
        getTimezoneOffset(t10) {
          if ("UTC" !== this.timezone) {
            let [e10, i10, s10, o10, r10 = 0] = this.dateTimeFormat({
              timeZoneName: "shortOffset"
            }, t10, "en").split(/(GMT|:)/).map(Number), a10 = -(36e5 * (s10 + r10 / 60));
            if (J(a10)) return a10;
          }
          return 0;
        }
        dateFormat(t10, e10, i10) {
          let s10 = k.defaultOptions?.lang;
          if (!q(e10) || isNaN(e10)) return s10?.invalidDate || "";
          if (tt(t10 = t10 ?? "%Y-%m-%d %H:%M:%S")) {
            let i11;
            let s11 = /%\[([a-zA-Z]+)\]/g;
            for (; i11 = s11.exec(t10); ) t10 = t10.replace(i11[0], this.dateTimeFormat(i11[1], e10));
          }
          if (tt(t10) && -1 !== t10.indexOf("%")) {
            let i11 = this, [o10, r10, a10, n10, h10, l2, d2, c2] = this.toParts(e10), p2 = s10?.weekdays || this.weekdays, g2 = s10?.shortWeekdays || this.shortWeekdays, u2 = s10?.months || this.months, f2 = s10?.shortMonths || this.shortMonths;
            ti(K({
              a: g2 ? g2[c2] : p2[c2].substr(0, 3),
              A: p2[c2],
              d: ts(a10),
              e: ts(a10, 2, " "),
              w: c2,
              b: f2[r10],
              B: u2[r10],
              m: ts(r10 + 1),
              o: r10 + 1,
              y: o10.toString().substr(2, 2),
              Y: o10,
              H: ts(n10),
              k: n10,
              I: ts(n10 % 12 || 12),
              l: n10 % 12 || 12,
              M: ts(h10),
              p: n10 < 12 ? "AM" : "PM",
              P: n10 < 12 ? "am" : "pm",
              S: ts(l2),
              L: ts(d2, 3)
            }, k.dateFormats), function(s11, o11) {
              if (tt(t10)) for (; -1 !== t10.indexOf("%" + o11); ) t10 = t10.replace("%" + o11, "function" == typeof s11 ? s11.call(i11, e10) : s11);
            });
          } else if (Q(t10)) {
            let i11 = (this.getTimezoneOffset(e10) || 0) / 36e5, s11 = this.timezone || "Etc/GMT" + (i11 >= 0 ? "+" : "") + i11, {
              prefix: o10 = "",
              suffix: r10 = ""
            } = t10;
            t10 = o10 + this.dateTimeFormat(K({
              timeZone: s11
            }, t10), e10) + r10;
          }
          return i10 ? ta(t10) : t10;
        }
        resolveDTLFormat(t10) {
          return Q(t10, true) ? Q(t10, true) && th(t10) ? {
            main: t10
          } : t10 : {
            main: (t10 = to(t10))[0],
            from: t10[1],
            to: t10[2]
          };
        }
        getTimeTicks(t10, e10, i10, s10) {
          let o10 = this, r10 = [], a10 = {}, {
            count: n10 = 1,
            unitRange: h10
          } = t10, [l2, d2, c2, p2, g2, u2] = o10.toParts(e10), f2 = (e10 || 0) % 1e3, m2;
          if (s10 ?? (s10 = 1), q(e10)) {
            if (f2 = h10 >= tr.second ? 0 : n10 * Math.floor(f2 / n10), h10 >= tr.second && (u2 = h10 >= tr.minute ? 0 : n10 * Math.floor(u2 / n10)), h10 >= tr.minute && (g2 = h10 >= tr.hour ? 0 : n10 * Math.floor(g2 / n10)), h10 >= tr.hour && (p2 = h10 >= tr.day ? 0 : n10 * Math.floor(p2 / n10)), h10 >= tr.day && (c2 = h10 >= tr.month ? 1 : Math.max(1, n10 * Math.floor(c2 / n10))), h10 >= tr.month && (d2 = h10 >= tr.year ? 0 : n10 * Math.floor(d2 / n10)), h10 >= tr.year && (l2 -= l2 % n10), h10 === tr.week) {
              n10 && (e10 = o10.makeTime(l2, d2, c2, p2, g2, u2, f2));
              let t12 = tl(this.dateTimeFormat({
                timeZone: this.timezone,
                weekday: "narrow"
              }, e10, "es"));
              c2 += -t12 + s10 + (t12 < s10 ? -7 : 0);
            }
            e10 = o10.makeTime(l2, d2, c2, p2, g2, u2, f2), o10.variableTimezone && q(i10) && (m2 = i10 - e10 > 4 * tr.month || o10.getTimezoneOffset(e10) !== o10.getTimezoneOffset(i10));
            let t11 = e10, x2 = 1;
            for (; t11 < i10; ) r10.push(t11), h10 === tr.year ? t11 = o10.makeTime(l2 + x2 * n10, 0) : h10 === tr.month ? t11 = o10.makeTime(l2, d2 + x2 * n10) : m2 && (h10 === tr.day || h10 === tr.week) ? t11 = o10.makeTime(l2, d2, c2 + x2 * n10 * (h10 === tr.day ? 1 : 7)) : m2 && h10 === tr.hour && n10 > 1 ? t11 = o10.makeTime(l2, d2, c2, p2 + x2 * n10) : t11 += h10 * n10, x2++;
            r10.push(t11), h10 <= tr.hour && r10.length < 1e4 && r10.forEach((t12) => {
              t12 % 18e5 == 0 && "000000000" === o10.dateFormat("%H%M%S%L", t12) && (a10[t12] = "day");
            });
          }
          return r10.info = K(t10, {
            higherRanks: a10,
            totalRange: h10 * n10
          }), r10;
        }
        getDateFormat(t10, e10, i10, s10) {
          let o10 = this.dateFormat("%m-%d %H:%M:%S.%L", e10), r10 = "01-01 00:00:00.000", a10 = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          }, n10 = "millisecond", h10 = n10;
          for (n10 in tr) {
            if (t10 === tr.week && +this.dateFormat("%w", e10) === i10 && o10.substr(6) === r10.substr(6)) {
              n10 = "week";
              break;
            }
            if (tr[n10] > t10) {
              n10 = h10;
              break;
            }
            if (a10[n10] && o10.substr(a10[n10]) !== r10.substr(a10[n10])) break;
            "week" !== n10 && (h10 = n10);
          }
          return this.resolveDTLFormat(s10[n10]).main;
        }
      }, {
        isTouchDevice: tc
      } = k, {
        fireEvent: tp,
        merge: tg
      } = $, tu = {
        colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"],
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          locale: void 0,
          loading: "Loading...",
          months: void 0,
          shortMonths: void 0,
          weekdays: void 0,
          numericSymbols: ["k", "M", "G", "T", "P", "E"],
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1"
        },
        global: {
          buttonTheme: {
            fill: "#f7f7f7",
            padding: 8,
            r: 2,
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontSize: "0.8em",
              fontWeight: "normal"
            },
            states: {
              hover: {
                fill: "#e6e6e6"
              },
              select: {
                fill: "#e6e9ff",
                style: {
                  color: "#000000",
                  fontWeight: "bold"
                }
              },
              disabled: {
                style: {
                  color: "#cccccc"
                }
              }
            }
          }
        },
        time: {
          Date: void 0,
          timezone: "UTC",
          timezoneOffset: 0,
          useUTC: void 0
        },
        chart: {
          alignThresholds: false,
          panning: {
            enabled: false,
            type: "x"
          },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: {
            theme: {},
            position: {}
          },
          reflow: true,
          type: "line",
          zooming: {
            singleTouch: false,
            resetButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            }
          },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        },
        title: {
          style: {
            color: "#333333",
            fontWeight: "bold"
          },
          text: "Chart title",
          margin: 15,
          minScale: 0.67
        },
        subtitle: {
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: ""
        },
        caption: {
          margin: 15,
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        legend: {
          enabled: true,
          align: "center",
          alignColumns: true,
          className: "highcharts-no-tooltip",
          events: {},
          layout: "horizontal",
          itemMarginBottom: 2,
          itemMarginTop: 2,
          labelFormatter: function() {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            style: {
              fontSize: "0.8em"
            },
            activeColor: "#0022ff",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "0.8em",
            textDecoration: "none",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#666666",
            textDecoration: "line-through"
          },
          shadow: false,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: true,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontSize: "0.8em",
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: 0.5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: true,
          animation: {
            duration: 300,
            easing: (t10) => Math.sqrt(1 - Math.pow(t10 - 1, 2))
          },
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%[AebHMSL]",
            second: "%[AebHMS]",
            minute: "%[AebHM]",
            hour: "%[AebHM]",
            day: "%[AebY]",
            week: "Week from %[AebY]",
            month: "%[BY]",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: false,
          snap: tc ? 25 : 10,
          headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: "#ffffff",
          borderWidth: void 0,
          shadow: true,
          stickOnContact: false,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "0.8em"
          },
          useHTML: false
        },
        credits: {
          enabled: true,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "0.6em"
          },
          text: "Highcharts.com"
        }
      }, tf = new td(tu.time), tm = {
        defaultOptions: tu,
        defaultTime: tf,
        getOptions: function() {
          return tu;
        },
        setOptions: function(t10) {
          return tp(k, "setOptions", {
            options: t10
          }), tg(true, tu, t10), t10.time && tf.update(tu.time), t10.lang && "locale" in t10.lang && tf.update({
            locale: t10.lang.locale
          }), tu;
        }
      }, {
        isNumber: tx,
        merge: ty,
        pInt: tb,
        defined: tv
      } = $;
      class tk {
        static parse(t10) {
          return t10 ? new tk(t10) : tk.None;
        }
        constructor(t10) {
          let e10, i10, s10, o10;
          this.rgba = [NaN, NaN, NaN, NaN], this.input = t10;
          let r10 = k.Color;
          if (r10 && r10 !== tk) return new r10(t10);
          if ("object" == typeof t10 && void 0 !== t10.stops) this.stops = t10.stops.map((t11) => new tk(t11[1]));
          else if ("string" == typeof t10) for (this.input = t10 = tk.names[t10.toLowerCase()] || t10, s10 = tk.parsers.length; s10-- && !i10; ) (e10 = (o10 = tk.parsers[s10]).regex.exec(t10)) && (i10 = o10.parse(e10));
          i10 && (this.rgba = i10);
        }
        get(t10) {
          let e10 = this.input, i10 = this.rgba;
          if ("object" == typeof e10 && void 0 !== this.stops) {
            let i11 = ty(e10);
            return i11.stops = [].slice.call(i11.stops), this.stops.forEach((e11, s10) => {
              i11.stops[s10] = [i11.stops[s10][0], e11.get(t10)];
            }), i11;
          }
          return i10 && tx(i10[0]) ? "rgb" !== t10 && (t10 || 1 !== i10[3]) ? "a" === t10 ? `${i10[3]}` : "rgba(" + i10.join(",") + ")" : "rgb(" + i10[0] + "," + i10[1] + "," + i10[2] + ")" : e10;
        }
        brighten(t10) {
          let e10 = this.rgba;
          if (this.stops) this.stops.forEach(function(e11) {
            e11.brighten(t10);
          });
          else if (tx(t10) && 0 !== t10) for (let i10 = 0; i10 < 3; i10++) e10[i10] += tb(255 * t10), e10[i10] < 0 && (e10[i10] = 0), e10[i10] > 255 && (e10[i10] = 255);
          return this;
        }
        setOpacity(t10) {
          return this.rgba[3] = t10, this;
        }
        tweenTo(t10, e10) {
          let i10 = this.rgba, s10 = t10.rgba;
          if (!tx(i10[0]) || !tx(s10[0])) return t10.input || "none";
          let o10 = 1 !== s10[3] || 1 !== i10[3], r10 = (t11, s11) => t11 + (i10[s11] - t11) * (1 - e10), a10 = s10.slice(0, 3).map(r10).map(Math.round);
          return o10 && a10.push(r10(s10[3], 3)), (o10 ? "rgba(" : "rgb(") + a10.join(",") + ")";
        }
      }
      tk.names = {
        white: "#ffffff",
        black: "#000000"
      }, tk.parsers = [{
        regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
        parse: function(t10) {
          return [tb(t10[1]), tb(t10[2]), tb(t10[3]), parseFloat(t10[4], 10)];
        }
      }, {
        regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
        parse: function(t10) {
          return [tb(t10[1]), tb(t10[2]), tb(t10[3]), 1];
        }
      }, {
        regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
        parse: function(t10) {
          return [tb(t10[1] + t10[1], 16), tb(t10[2] + t10[2], 16), tb(t10[3] + t10[3], 16), tv(t10[4]) ? tb(t10[4] + t10[4], 16) / 255 : 1];
        }
      }, {
        regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
        parse: function(t10) {
          return [tb(t10[1], 16), tb(t10[2], 16), tb(t10[3], 16), tv(t10[4]) ? tb(t10[4], 16) / 255 : 1];
        }
      }], tk.None = new tk("");
      let {
        parse: tw
      } = tk, {
        win: tM
      } = k, {
        isNumber: tS,
        objectEach: tT
      } = $;
      class tC {
        constructor(t10, e10, i10) {
          this.pos = NaN, this.options = e10, this.elem = t10, this.prop = i10;
        }
        dSetter() {
          let t10 = this.paths, e10 = t10 && t10[0], i10 = t10 && t10[1], s10 = this.now || 0, o10 = [];
          if (1 !== s10 && e10 && i10) {
            if (e10.length === i10.length && s10 < 1) for (let t11 = 0; t11 < i10.length; t11++) {
              let r10 = e10[t11], a10 = i10[t11], n10 = [];
              for (let t12 = 0; t12 < a10.length; t12++) {
                let e11 = r10[t12], i11 = a10[t12];
                tS(e11) && tS(i11) && !("A" === a10[0] && (4 === t12 || 5 === t12)) ? n10[t12] = e11 + s10 * (i11 - e11) : n10[t12] = i11;
              }
              o10.push(n10);
            }
            else o10 = i10;
          } else o10 = this.toD || [];
          this.elem.attr("d", o10, void 0, true);
        }
        update() {
          let t10 = this.elem, e10 = this.prop, i10 = this.now, s10 = this.options.step;
          this[e10 + "Setter"] ? this[e10 + "Setter"]() : t10.attr ? t10.element && t10.attr(e10, i10, null, true) : t10.style[e10] = i10 + this.unit, s10 && s10.call(t10, i10, this);
        }
        run(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = function(t11) {
            return !r10.stopped && s10.step(t11);
          }, a10 = tM.requestAnimationFrame || function(t11) {
            setTimeout(t11, 13);
          }, n10 = function() {
            for (let t11 = 0; t11 < tC.timers.length; t11++) tC.timers[t11]() || tC.timers.splice(t11--, 1);
            tC.timers.length && a10(n10);
          };
          t10 !== e10 || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = t10, this.end = e10, this.unit = i10, this.now = this.start, this.pos = 0, r10.elem = this.elem, r10.prop = this.prop, r10() && 1 === tC.timers.push(r10) && a10(n10)) : (delete o10.curAnim[this.prop], o10.complete && 0 === Object.keys(o10.curAnim).length && o10.complete.call(this.elem));
        }
        step(t10) {
          let e10, i10;
          let s10 = +/* @__PURE__ */ new Date(), o10 = this.options, r10 = this.elem, a10 = o10.complete, n10 = o10.duration, h10 = o10.curAnim;
          return r10.attr && !r10.element ? e10 = false : t10 || s10 >= n10 + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h10[this.prop] = true, i10 = true, tT(h10, function(t11) {
            true !== t11 && (i10 = false);
          }), i10 && a10 && a10.call(r10), e10 = false) : (this.pos = o10.easing((s10 - this.startTime) / n10), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e10 = true), e10;
        }
        initPath(t10, e10, i10) {
          let s10 = t10.startX, o10 = t10.endX, r10 = i10.slice(), a10 = t10.isArea, n10 = a10 ? 2 : 1, h10 = e10 && i10.length > e10.length && i10.hasStackedCliffs, l2, d2, c2, p2, g2 = e10 && e10.slice();
          if (!g2 || h10) return [r10, r10];
          function u2(t11, e11) {
            for (; t11.length < d2; ) {
              let i11 = t11[0], s11 = e11[d2 - t11.length];
              if (s11 && "M" === i11[0] && ("C" === s11[0] ? t11[0] = ["C", i11[1], i11[2], i11[1], i11[2], i11[1], i11[2]] : t11[0] = ["L", i11[1], i11[2]]), t11.unshift(i11), a10) {
                let e12 = t11.pop();
                t11.push(t11[t11.length - 1], e12);
              }
            }
          }
          function f2(t11) {
            for (; t11.length < d2; ) {
              let e11 = t11[Math.floor(t11.length / n10) - 1].slice();
              if ("C" === e11[0] && (e11[1] = e11[5], e11[2] = e11[6]), a10) {
                let i11 = t11[Math.floor(t11.length / n10)].slice();
                t11.splice(t11.length / 2, 0, e11, i11);
              } else t11.push(e11);
            }
          }
          if (s10 && o10 && o10.length) {
            for (c2 = 0; c2 < s10.length; c2++) {
              if (s10[c2] === o10[0]) {
                l2 = c2;
                break;
              }
              if (s10[0] === o10[o10.length - s10.length + c2]) {
                l2 = c2, p2 = true;
                break;
              }
              if (s10[s10.length - 1] === o10[o10.length - s10.length + c2]) {
                l2 = s10.length - c2;
                break;
              }
            }
            void 0 === l2 && (g2 = []);
          }
          return g2.length && tS(l2) && (d2 = r10.length + l2 * n10, p2 ? (u2(g2, r10), f2(r10)) : (u2(r10, g2), f2(g2))), [g2, r10];
        }
        fillSetter() {
          tC.prototype.strokeSetter.apply(this, arguments);
        }
        strokeSetter() {
          this.elem.attr(this.prop, tw(this.start).tweenTo(tw(this.end), this.pos), void 0, true);
        }
      }
      tC.timers = [];
      let {
        defined: tA,
        getStyle: tP,
        isArray: tL,
        isNumber: tO,
        isObject: tE,
        merge: tI,
        objectEach: tD,
        pick: tB
      } = $;
      function tN(t10) {
        return tE(t10) ? tI({
          duration: 500,
          defer: 0
        }, t10) : {
          duration: t10 ? 500 : 0,
          defer: 0
        };
      }
      function tz(t10, e10) {
        let i10 = tC.timers.length;
        for (; i10--; ) tC.timers[i10].elem !== t10 || e10 && e10 !== tC.timers[i10].prop || (tC.timers[i10].stopped = true);
      }
      let tR = {
        animate: function(t10, e10, i10) {
          let s10, o10 = "", r10, a10, n10;
          tE(i10) || (n10 = arguments, i10 = {
            duration: n10[2],
            easing: n10[3],
            complete: n10[4]
          }), tO(i10.duration) || (i10.duration = 400), i10.easing = "function" == typeof i10.easing ? i10.easing : Math[i10.easing] || Math.easeInOutSine, i10.curAnim = tI(e10), tD(e10, function(n11, h10) {
            tz(t10, h10), a10 = new tC(t10, i10, h10), r10 = void 0, "d" === h10 && tL(e10.d) ? (a10.paths = a10.initPath(t10, t10.pathArray, e10.d), a10.toD = e10.d, s10 = 0, r10 = 1) : t10.attr ? s10 = t10.attr(h10) : (s10 = parseFloat(tP(t10, h10)) || 0, "opacity" !== h10 && (o10 = "px")), r10 || (r10 = n11), "string" == typeof r10 && r10.match("px") && (r10 = r10.replace(/px/g, "")), a10.run(s10, r10, o10);
          });
        },
        animObject: tN,
        getDeferredAnimation: function(t10, e10, i10) {
          let s10 = tN(e10), o10 = i10 ? [i10] : t10.series, r10 = 0, a10 = 0;
          return o10.forEach((t11) => {
            let i11 = tN(t11.options.animation);
            r10 = tE(e10) && tA(e10.defer) ? s10.defer : Math.max(r10, i11.duration + i11.defer), a10 = Math.min(s10.duration, i11.duration);
          }), t10.renderer.forExport && (r10 = 0), {
            defer: Math.max(0, r10 - a10),
            duration: Math.min(r10, a10)
          };
        },
        setAnimation: function(t10, e10) {
          e10.renderer.globalAnimation = tB(t10, e10.options.chart.animation, true);
        },
        stop: tz
      }, {
        SVG_NS: tW,
        win: tH
      } = k, {
        attr: tX,
        createElement: tF,
        css: tG,
        error: tY,
        isFunction: tj,
        isString: tU,
        objectEach: t$,
        splat: tV
      } = $, {
        trustedTypes: t_
      } = tH, tq = t_ && tj(t_.createPolicy) && t_.createPolicy("highcharts", {
        createHTML: (t10) => t10
      }), tZ = tq ? tq.createHTML("") : "";
      class tK {
        static filterUserAttributes(t10) {
          return t$(t10, (e10, i10) => {
            let s10 = true;
            -1 === tK.allowedAttributes.indexOf(i10) && (s10 = false), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i10) && (s10 = tU(e10) && tK.allowedReferences.some((t11) => 0 === e10.indexOf(t11))), s10 || (tY(33, false, void 0, {
              "Invalid attribute in config": `${i10}`
            }), delete t10[i10]), tU(e10) && t10[i10] && (t10[i10] = e10.replace(/</g, "&lt;"));
          }), t10;
        }
        static parseStyle(t10) {
          return t10.split(";").reduce((t11, e10) => {
            let i10 = e10.split(":").map((t12) => t12.trim()), s10 = i10.shift();
            return s10 && i10.length && (t11[s10.replace(/-([a-z])/g, (t12) => t12[1].toUpperCase())] = i10.join(":")), t11;
          }, {});
        }
        static setElementHTML(t10, e10) {
          t10.innerHTML = tK.emptyHTML, e10 && new tK(e10).addToDOM(t10);
        }
        constructor(t10) {
          this.nodes = "string" == typeof t10 ? this.parseMarkup(t10) : t10;
        }
        addToDOM(t10) {
          return function t11(e10, i10) {
            let s10;
            return tV(e10).forEach(function(e11) {
              let o10;
              let r10 = e11.tagName, a10 = e11.textContent ? k.doc.createTextNode(e11.textContent) : void 0, n10 = tK.bypassHTMLFiltering;
              if (r10) {
                if ("#text" === r10) o10 = a10;
                else if (-1 !== tK.allowedTags.indexOf(r10) || n10) {
                  let s11 = "svg" === r10 ? tW : i10.namespaceURI || tW, h10 = k.doc.createElementNS(s11, r10), l2 = e11.attributes || {};
                  t$(e11, function(t12, e12) {
                    "tagName" !== e12 && "attributes" !== e12 && "children" !== e12 && "style" !== e12 && "textContent" !== e12 && (l2[e12] = t12);
                  }), tX(h10, n10 ? l2 : tK.filterUserAttributes(l2)), e11.style && tG(h10, e11.style), a10 && h10.appendChild(a10), t11(e11.children || [], h10), o10 = h10;
                } else tY(33, false, void 0, {
                  "Invalid tagName in config": r10
                });
              }
              o10 && i10.appendChild(o10), s10 = o10;
            }), s10;
          }(this.nodes, t10);
        }
        parseMarkup(t10) {
          let e10;
          let i10 = [];
          t10 = t10.trim().replace(/ style=(["'])/g, " data-style=$1");
          try {
            e10 = new DOMParser().parseFromString(tq ? tq.createHTML(t10) : t10, "text/html");
          } catch (t11) {
          }
          if (!e10) {
            let i11 = tF("div");
            i11.innerHTML = t10, e10 = {
              body: i11
            };
          }
          let s10 = (t11, e11) => {
            let i11 = t11.nodeName.toLowerCase(), o10 = {
              tagName: i11
            };
            "#text" === i11 && (o10.textContent = t11.textContent || "");
            let r10 = t11.attributes;
            if (r10) {
              let t12 = {};
              [].forEach.call(r10, (e12) => {
                "data-style" === e12.name ? o10.style = tK.parseStyle(e12.value) : t12[e12.name] = e12.value;
              }), o10.attributes = t12;
            }
            if (t11.childNodes.length) {
              let e12 = [];
              [].forEach.call(t11.childNodes, (t12) => {
                s10(t12, e12);
              }), e12.length && (o10.children = e12);
            }
            e11.push(o10);
          };
          return [].forEach.call(e10.body.childNodes, (t11) => s10(t11, i10)), i10;
        }
      }
      tK.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "in2", "markerHeight", "markerWidth", "offset", "opacity", "operator", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "radius", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], tK.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], tK.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feComposite", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMorphology", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], tK.emptyHTML = tZ, tK.bypassHTMLFiltering = false;
      let {
        defaultOptions: tJ,
        defaultTime: tQ
      } = tm, {
        pageLang: t0
      } = k, {
        extend: t1,
        getNestedProperty: t2,
        isArray: t3,
        isNumber: t5,
        isObject: t6,
        isString: t9,
        pick: t4,
        ucfirst: t8
      } = $, t7 = {
        add: (t10, e10) => t10 + e10,
        divide: (t10, e10) => 0 !== e10 ? t10 / e10 : "",
        eq: (t10, e10) => t10 == e10,
        each: function(t10) {
          let e10 = arguments[arguments.length - 1];
          return !!t3(t10) && t10.map((i10, s10) => ei(e10.body, t1(t6(i10) ? i10 : {
            "@this": i10
          }, {
            "@index": s10,
            "@first": 0 === s10,
            "@last": s10 === t10.length - 1
          }))).join("");
        },
        ge: (t10, e10) => t10 >= e10,
        gt: (t10, e10) => t10 > e10,
        if: (t10) => !!t10,
        le: (t10, e10) => t10 <= e10,
        lt: (t10, e10) => t10 < e10,
        multiply: (t10, e10) => t10 * e10,
        ne: (t10, e10) => t10 != e10,
        subtract: (t10, e10) => t10 - e10,
        ucfirst: t8,
        unless: (t10) => !t10
      }, et = {}, ee = (t10) => /^["'].+["']$/.test(t10);
      function ei(t10 = "", e10, i10) {
        let s10 = /\{([\p{L}\d:\.,;\-\/<>\[\]%_@+"'’= #\(\)]+)\}/gu, o10 = /\(([\p{L}\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/gu, r10 = [], a10 = /f$/, n10 = /\.(\d)/, h10 = i10?.options.lang || tJ.lang, l2 = i10 && i10.time || tQ, d2 = i10 && i10.numberFormatter || es, c2 = (t11 = "") => {
          let i11;
          return "true" === t11 || "false" !== t11 && ((i11 = Number(t11)).toString() === t11 ? i11 : ee(t11) ? t11.slice(1, -1) : t2(t11, e10));
        }, p2, g2, u2 = 0, f2;
        for (; null !== (p2 = s10.exec(t10)); ) {
          let i11 = p2, s11 = o10.exec(p2[1]);
          s11 && (p2 = s11, f2 = true), g2 && g2.isBlock || (g2 = {
            ctx: e10,
            expression: p2[1],
            find: p2[0],
            isBlock: "#" === p2[1].charAt(0),
            start: p2.index,
            startInner: p2.index + p2[0].length,
            length: p2[0].length
          });
          let a11 = (g2.isBlock ? i11 : p2)[1].split(" ")[0].replace("#", "");
          t7[a11] && (g2.isBlock && a11 === g2.fn && u2++, g2.fn || (g2.fn = a11));
          let n11 = "else" === p2[1];
          if (g2.isBlock && g2.fn && (p2[1] === `/${g2.fn}` || n11)) {
            if (u2) !n11 && u2--;
            else {
              let e11 = g2.startInner, i12 = t10.substr(e11, p2.index - e11);
              void 0 === g2.body ? (g2.body = i12, g2.startInner = p2.index + p2[0].length) : g2.elseBody = i12, g2.find += i12 + p2[0], n11 || (r10.push(g2), g2 = void 0);
            }
          } else g2.isBlock || r10.push(g2);
          if (s11 && !g2?.isBlock) break;
        }
        return r10.forEach((s11) => {
          let r11, p3;
          let {
            body: g3,
            elseBody: u3,
            expression: f3,
            fn: m2
          } = s11;
          if (m2) {
            let t11 = [s11], o11 = [], a11 = f3.length, n11 = 0, h11;
            for (p3 = 0; p3 <= a11; p3++) {
              let t12 = f3.charAt(p3);
              h11 || '"' !== t12 && "'" !== t12 ? h11 === t12 && (h11 = "") : h11 = t12, h11 || " " !== t12 && p3 !== a11 || (o11.push(f3.substr(n11, p3 - n11)), n11 = p3 + 1);
            }
            for (p3 = t7[m2].length; p3--; ) t11.unshift(c2(o11[p3 + 1]));
            r11 = t7[m2].apply(e10, t11), s11.isBlock && "boolean" == typeof r11 && (r11 = ei(r11 ? g3 : u3, e10, i10));
          } else {
            let t11 = ee(f3) ? [f3] : f3.split(":");
            if (r11 = c2(t11.shift() || ""), t11.length && "number" == typeof r11) {
              let e11 = t11.join(":");
              if (a10.test(e11)) {
                let t12 = parseInt((e11.match(n10) || ["", "-1"])[1], 10);
                null !== r11 && (r11 = d2(r11, t12, h10.decimalPoint, e11.indexOf(",") > -1 ? h10.thousandsSep : ""));
              } else r11 = l2.dateFormat(e11, r11);
            }
            o10.lastIndex = 0, o10.test(s11.find) && t9(r11) && (r11 = `"${r11}"`);
          }
          t10 = t10.replace(s11.find, t4(r11, ""));
        }), f2 ? ei(t10, e10, i10) : t10;
      }
      function es(t10, e10, i10, s10) {
        e10 = +e10;
        let o10, r10, [a10, n10] = (t10 = +t10 || 0).toString().split("e").map(Number), h10 = this?.options?.lang || tJ.lang, l2 = (t10.toString().split(".")[1] || "").split("e")[0].length, d2 = e10, c2 = {};
        i10 ?? (i10 = h10.decimalPoint), s10 ?? (s10 = h10.thousandsSep), -1 === e10 ? e10 = Math.min(l2, 20) : t5(e10) ? e10 && n10 < 0 && ((r10 = e10 + n10) >= 0 ? (a10 = +a10.toExponential(r10).split("e")[0], e10 = r10) : (a10 = Math.floor(a10), t10 = e10 < 20 ? +(a10 * Math.pow(10, n10)).toFixed(e10) : 0, n10 = 0)) : e10 = 2, n10 && (e10 ?? (e10 = 2), t10 = a10), t5(e10) && e10 >= 0 && (c2.minimumFractionDigits = e10, c2.maximumFractionDigits = e10), "" === s10 && (c2.useGrouping = false);
        let p2 = s10 || i10, g2 = p2 ? "en" : this?.locale || h10.locale || t0, u2 = JSON.stringify(c2) + g2;
        return o10 = (et[u2] ?? (et[u2] = new Intl.NumberFormat(g2, c2))).format(t10), p2 && (o10 = o10.replace(/([,\.])/g, "_$1").replace(/_\,/g, s10 ?? ",").replace("_.", i10 ?? ".")), (e10 || 0 != +o10) && (!(n10 < 0) || d2) || (o10 = "0"), n10 && 0 != +o10 && (o10 += "e" + (n10 < 0 ? "" : "+") + n10), o10;
      }
      let eo = {
        dateFormat: function(t10, e10, i10) {
          return tQ.dateFormat(t10, e10, i10);
        },
        format: ei,
        helpers: t7,
        numberFormat: es
      };
      !function(t10) {
        let e10;
        t10.rendererTypes = {}, t10.getRendererType = function(i10 = e10) {
          return t10.rendererTypes[i10] || t10.rendererTypes[e10];
        }, t10.registerRendererType = function(i10, s10, o10) {
          t10.rendererTypes[i10] = s10, (!e10 || o10) && (e10 = i10, k.Renderer = s10);
        };
      }(s || (s = {}));
      let er = s, {
        clamp: ea,
        pick: en,
        pushUnique: eh,
        stableSort: el
      } = $;
      (o || (o = {})).distribute = function t10(e10, i10, s10) {
        let o10 = e10, r10 = o10.reducedLen || i10, a10 = (t11, e11) => t11.target - e11.target, n10 = [], h10 = e10.length, l2 = [], d2 = n10.push, c2, p2, g2, u2 = true, f2, m2, x2 = 0, y2;
        for (c2 = h10; c2--; ) x2 += e10[c2].size;
        if (x2 > r10) {
          for (el(e10, (t11, e11) => (e11.rank || 0) - (t11.rank || 0)), g2 = (y2 = e10[0].rank === e10[e10.length - 1].rank) ? h10 / 2 : -1, p2 = y2 ? g2 : h10 - 1; g2 && x2 > r10; ) f2 = e10[c2 = Math.floor(p2)], eh(l2, c2) && (x2 -= f2.size), p2 += g2, y2 && p2 >= e10.length && (g2 /= 2, p2 = g2);
          l2.sort((t11, e11) => e11 - t11).forEach((t11) => d2.apply(n10, e10.splice(t11, 1)));
        }
        for (el(e10, a10), e10 = e10.map((t11) => ({
          size: t11.size,
          targets: [t11.target],
          align: en(t11.align, 0.5)
        })); u2; ) {
          for (c2 = e10.length; c2--; ) f2 = e10[c2], m2 = (Math.min.apply(0, f2.targets) + Math.max.apply(0, f2.targets)) / 2, f2.pos = ea(m2 - f2.size * f2.align, 0, i10 - f2.size);
          for (c2 = e10.length, u2 = false; c2--; ) c2 > 0 && e10[c2 - 1].pos + e10[c2 - 1].size > e10[c2].pos && (e10[c2 - 1].size += e10[c2].size, e10[c2 - 1].targets = e10[c2 - 1].targets.concat(e10[c2].targets), e10[c2 - 1].align = 0.5, e10[c2 - 1].pos + e10[c2 - 1].size > i10 && (e10[c2 - 1].pos = i10 - e10[c2 - 1].size), e10.splice(c2, 1), u2 = true);
        }
        return d2.apply(o10, n10), c2 = 0, e10.some((e11) => {
          let r11 = 0;
          return (e11.targets || []).some(() => (o10[c2].pos = e11.pos + r11, void 0 !== s10 && Math.abs(o10[c2].pos - o10[c2].target) > s10) ? (o10.slice(0, c2 + 1).forEach((t11) => delete t11.pos), o10.reducedLen = (o10.reducedLen || i10) - 0.1 * i10, o10.reducedLen > 0.1 * i10 && t10(o10, i10, s10), true) : (r11 += o10[c2].size, c2++, false));
        }), el(o10, a10), o10;
      };
      let ed = o, {
        animate: ec,
        animObject: ep,
        stop: eg
      } = tR, {
        deg2rad: eu,
        doc: ef,
        svg: em,
        SVG_NS: ex,
        win: ey,
        isFirefox: eb
      } = k, {
        addEvent: ev,
        attr: ek,
        createElement: ew,
        crisp: eM,
        css: eS,
        defined: eT,
        erase: eC,
        extend: eA,
        fireEvent: eP,
        getAlignFactor: eL,
        isArray: eO,
        isFunction: eE,
        isNumber: eI,
        isObject: eD,
        isString: eB,
        merge: eN,
        objectEach: ez,
        pick: eR,
        pInt: eW,
        pushUnique: eH,
        replaceNested: eX,
        syncTimeout: eF,
        uniqueKey: eG
      } = $;
      class eY {
        _defaultGetter(t10) {
          let e10 = eR(this[t10 + "Value"], this[t10], this.element ? this.element.getAttribute(t10) : null, 0);
          return /^-?[\d\.]+$/.test(e10) && (e10 = parseFloat(e10)), e10;
        }
        _defaultSetter(t10, e10, i10) {
          i10.setAttribute(e10, t10);
        }
        add(t10) {
          let e10;
          let i10 = this.renderer, s10 = this.element;
          return t10 && (this.parentGroup = t10), void 0 !== this.textStr && "text" === this.element.nodeName && i10.buildText(this), this.added = true, (!t10 || t10.handleZ || this.zIndex) && (e10 = this.zIndexSetter()), e10 || (t10 ? t10.element : i10.box).appendChild(s10), this.onAdd && this.onAdd(), this;
        }
        addClass(t10, e10) {
          let i10 = e10 ? "" : this.attr("class") || "";
          return (t10 = (t10 || "").split(/ /g).reduce(function(t11, e11) {
            return -1 === i10.indexOf(e11) && t11.push(e11), t11;
          }, i10 ? [i10] : []).join(" ")) !== i10 && this.attr("class", t10), this;
        }
        afterSetters() {
          this.doTransform && (this.updateTransform(), this.doTransform = false);
        }
        align(t10, e10, i10, s10 = true) {
          let o10 = this.renderer, r10 = o10.alignedObjects, a10 = !!t10;
          t10 ? (this.alignOptions = t10, this.alignByTranslate = e10, this.alignTo = i10) : (t10 = this.alignOptions || {}, e10 = this.alignByTranslate, i10 = this.alignTo);
          let n10 = !i10 || eB(i10) ? i10 || "renderer" : void 0;
          n10 && (a10 && eH(r10, this), i10 = void 0);
          let h10 = eR(i10, o10[n10], o10), l2 = (h10.x || 0) + (t10.x || 0) + ((h10.width || 0) - (t10.width || 0)) * eL(t10.align), d2 = (h10.y || 0) + (t10.y || 0) + ((h10.height || 0) - (t10.height || 0)) * eL(t10.verticalAlign), c2 = {
            "text-align": t10?.align
          };
          return c2[e10 ? "translateX" : "x"] = Math.round(l2), c2[e10 ? "translateY" : "y"] = Math.round(d2), s10 && (this[this.placed ? "animate" : "attr"](c2), this.placed = true), this.alignAttr = c2, this;
        }
        alignSetter(t10) {
          let e10 = {
            left: "start",
            center: "middle",
            right: "end"
          };
          e10[t10] && (this.alignValue = t10, this.element.setAttribute("text-anchor", e10[t10]));
        }
        animate(t10, e10, i10) {
          let s10 = ep(eR(e10, this.renderer.globalAnimation, true)), o10 = s10.defer;
          return ef.hidden && (s10.duration = 0), 0 !== s10.duration ? (i10 && (s10.complete = i10), eF(() => {
            this.element && ec(this, t10, s10);
          }, o10)) : (this.attr(t10, void 0, i10 || s10.complete), ez(t10, function(t11, e11) {
            s10.step && s10.step.call(this, t11, {
              prop: e11,
              pos: 1,
              elem: this
            });
          }, this)), this;
        }
        applyTextOutline(t10) {
          let e10 = this.element;
          -1 !== t10.indexOf("contrast") && (t10 = t10.replace(/contrast/g, this.renderer.getContrast(e10.style.fill)));
          let i10 = t10.split(" "), s10 = i10[i10.length - 1], o10 = i10[0];
          if (o10 && "none" !== o10 && k.svg) {
            this.fakeTS = true, o10 = o10.replace(/(^[\d\.]+)(.*?)$/g, function(t12, e11, i12) {
              return 2 * Number(e11) + i12;
            }), this.removeTextOutline();
            let t11 = ef.createElementNS(ex, "tspan");
            ek(t11, {
              class: "highcharts-text-outline",
              fill: s10,
              stroke: s10,
              "stroke-width": o10,
              "stroke-linejoin": "round"
            });
            let i11 = e10.querySelector("textPath") || e10;
            [].forEach.call(i11.childNodes, (e11) => {
              let i12 = e11.cloneNode(true);
              i12.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((t12) => i12.removeAttribute(t12)), t11.appendChild(i12);
            });
            let r10 = 0;
            [].forEach.call(i11.querySelectorAll("text tspan"), (t12) => {
              r10 += Number(t12.getAttribute("dy"));
            });
            let a10 = ef.createElementNS(ex, "tspan");
            a10.textContent = "​", ek(a10, {
              x: Number(e10.getAttribute("x")),
              dy: -r10
            }), t11.appendChild(a10), i11.insertBefore(t11, i11.firstChild);
          }
        }
        attr(t10, e10, i10, s10) {
          let {
            element: o10
          } = this, r10 = eY.symbolCustomAttribs, a10, n10, h10 = this, l2;
          return "string" == typeof t10 && void 0 !== e10 && (a10 = t10, (t10 = {})[a10] = e10), "string" == typeof t10 ? h10 = (this[t10 + "Getter"] || this._defaultGetter).call(this, t10, o10) : (ez(t10, function(e11, i11) {
            l2 = false, s10 || eg(this, i11), this.symbolName && -1 !== r10.indexOf(i11) && (n10 || (this.symbolAttr(t10), n10 = true), l2 = true), this.rotation && ("x" === i11 || "y" === i11) && (this.doTransform = true), l2 || (this[i11 + "Setter"] || this._defaultSetter).call(this, e11, i11, o10);
          }, this), this.afterSetters()), i10 && i10.call(this), h10;
        }
        clip(t10) {
          if (t10 && !t10.clipPath) {
            let e10 = eG() + "-", i10 = this.renderer.createElement("clipPath").attr({
              id: e10
            }).add(this.renderer.defs);
            eA(t10, {
              clipPath: i10,
              id: e10,
              count: 0
            }), t10.add(i10);
          }
          return this.attr("clip-path", t10 ? `url(${this.renderer.url}#${t10.id})` : "none");
        }
        crisp(t10, e10) {
          e10 = Math.round(e10 || t10.strokeWidth || 0);
          let i10 = t10.x || this.x || 0, s10 = t10.y || this.y || 0, o10 = (t10.width || this.width || 0) + i10, r10 = (t10.height || this.height || 0) + s10, a10 = eM(i10, e10), n10 = eM(s10, e10);
          return eA(t10, {
            x: a10,
            y: n10,
            width: eM(o10, e10) - a10,
            height: eM(r10, e10) - n10
          }), eT(t10.strokeWidth) && (t10.strokeWidth = e10), t10;
        }
        complexColor(t10, e10, i10) {
          let s10 = this.renderer, o10, r10, a10, n10, h10, l2, d2, c2, p2, g2, u2 = [], f2;
          eP(this.renderer, "complexColor", {
            args: arguments
          }, function() {
            if (t10.radialGradient ? r10 = "radialGradient" : t10.linearGradient && (r10 = "linearGradient"), r10) {
              if (a10 = t10[r10], h10 = s10.gradients, l2 = t10.stops, p2 = i10.radialReference, eO(a10) && (t10[r10] = a10 = {
                x1: a10[0],
                y1: a10[1],
                x2: a10[2],
                y2: a10[3],
                gradientUnits: "userSpaceOnUse"
              }), "radialGradient" === r10 && p2 && !eT(a10.gradientUnits) && (n10 = a10, a10 = eN(a10, s10.getRadialAttr(p2, n10), {
                gradientUnits: "userSpaceOnUse"
              })), ez(a10, function(t11, e11) {
                "id" !== e11 && u2.push(e11, t11);
              }), ez(l2, function(t11) {
                u2.push(t11);
              }), h10[u2 = u2.join(",")]) g2 = h10[u2].attr("id");
              else {
                a10.id = g2 = eG();
                let t11 = h10[u2] = s10.createElement(r10).attr(a10).add(s10.defs);
                t11.radAttr = n10, t11.stops = [], l2.forEach(function(e11) {
                  0 === e11[1].indexOf("rgba") ? (d2 = (o10 = tk.parse(e11[1])).get("rgb"), c2 = o10.get("a")) : (d2 = e11[1], c2 = 1);
                  let i11 = s10.createElement("stop").attr({
                    offset: e11[0],
                    "stop-color": d2,
                    "stop-opacity": c2
                  }).add(t11);
                  t11.stops.push(i11);
                });
              }
              f2 = "url(" + s10.url + "#" + g2 + ")", i10.setAttribute(e10, f2), i10.gradient = u2, t10.toString = function() {
                return f2;
              };
            }
          });
        }
        css(t10) {
          let e10 = this.styles, i10 = {}, s10 = this.element, o10, r10 = !e10;
          if (e10 && ez(t10, function(t11, s11) {
            e10 && e10[s11] !== t11 && (i10[s11] = t11, r10 = true);
          }), r10) {
            e10 && (t10 = eA(e10, i10)), null === t10.width || "auto" === t10.width ? delete this.textWidth : "text" === s10.nodeName.toLowerCase() && t10.width && (o10 = this.textWidth = eW(t10.width)), eA(this.styles, t10), o10 && !em && this.renderer.forExport && delete t10.width;
            let r11 = eb && t10.fontSize || null;
            r11 && (eI(r11) || /^\d+$/.test(r11)) && (t10.fontSize += "px");
            let a10 = eN(t10);
            s10.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "whiteSpace", "width"].forEach((t11) => a10 && delete a10[t11]), a10.color && (a10.fill = a10.color)), eS(s10, a10);
          }
          return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t10.textOutline && this.applyTextOutline(t10.textOutline)), this;
        }
        dashstyleSetter(t10) {
          let e10, i10 = this["stroke-width"];
          if ("inherit" === i10 && (i10 = 1), t10 = t10 && t10.toLowerCase()) {
            let s10 = t10.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            for (e10 = s10.length; e10--; ) s10[e10] = "" + eW(s10[e10]) * eR(i10, NaN);
            t10 = s10.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t10);
          }
        }
        destroy() {
          let t10 = this, e10 = t10.element || {}, i10 = t10.renderer, s10 = e10.ownerSVGElement, o10 = "SPAN" === e10.nodeName && t10.parentGroup || void 0, r10, a10;
          if (e10.onclick = e10.onmouseout = e10.onmouseover = e10.onmousemove = e10.point = null, eg(t10), t10.clipPath && s10) {
            let e11 = t10.clipPath;
            [].forEach.call(s10.querySelectorAll("[clip-path],[CLIP-PATH]"), function(t11) {
              t11.getAttribute("clip-path").indexOf(e11.element.id) > -1 && t11.removeAttribute("clip-path");
            }), t10.clipPath = e11.destroy();
          }
          if (t10.connector = t10.connector?.destroy(), t10.stops) {
            for (a10 = 0; a10 < t10.stops.length; a10++) t10.stops[a10].destroy();
            t10.stops.length = 0, t10.stops = void 0;
          }
          for (t10.safeRemoveChild(e10); o10 && o10.div && 0 === o10.div.childNodes.length; ) r10 = o10.parentGroup, t10.safeRemoveChild(o10.div), delete o10.div, o10 = r10;
          t10.alignOptions && eC(i10.alignedObjects, t10), ez(t10, function(e11, i11) {
            t10[i11] && t10[i11].parentGroup === t10 && t10[i11].destroy && t10[i11].destroy(), delete t10[i11];
          });
        }
        dSetter(t10, e10, i10) {
          eO(t10) && ("string" == typeof t10[0] && (t10 = this.renderer.pathToSegments(t10)), this.pathArray = t10, t10 = t10.reduce((t11, e11, i11) => e11 && e11.join ? (i11 ? t11 + " " : "") + e11.join(" ") : (e11 || "").toString(), "")), /(NaN| {2}|^$)/.test(t10) && (t10 = "M 0 0"), this[e10] !== t10 && (i10.setAttribute(e10, t10), this[e10] = t10);
        }
        fillSetter(t10, e10, i10) {
          "string" == typeof t10 ? i10.setAttribute(e10, t10) : t10 && this.complexColor(t10, e10, i10);
        }
        hrefSetter(t10, e10, i10) {
          i10.setAttributeNS("http://www.w3.org/1999/xlink", e10, t10);
        }
        getBBox(t10, e10) {
          let i10, s10, o10, r10;
          let {
            alignValue: a10,
            element: n10,
            renderer: h10,
            styles: l2,
            textStr: d2
          } = this, {
            cache: c2,
            cacheKeys: p2
          } = h10, g2 = n10.namespaceURI === this.SVG_NS, u2 = eR(e10, this.rotation, 0), f2 = h10.styledMode ? n10 && eY.prototype.getStyle.call(n10, "font-size") : l2.fontSize;
          if (eT(d2) && (-1 === (r10 = d2.toString()).indexOf("<") && (r10 = r10.replace(/\d/g, "0")), r10 += ["", h10.rootFontSize, f2, u2, this.textWidth, a10, l2.lineClamp, l2.textOverflow, l2.fontWeight].join(",")), r10 && !t10 && (i10 = c2[r10]), !i10 || i10.polygon) {
            if (g2 || h10.forExport) {
              try {
                o10 = this.fakeTS && function(t12) {
                  let e11 = n10.querySelector(".highcharts-text-outline");
                  e11 && eS(e11, {
                    display: t12
                  });
                }, eE(o10) && o10("none"), i10 = n10.getBBox ? eA({}, n10.getBBox()) : {
                  width: n10.offsetWidth,
                  height: n10.offsetHeight,
                  x: 0,
                  y: 0
                }, eE(o10) && o10("");
              } catch (t12) {
              }
              (!i10 || i10.width < 0) && (i10 = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              });
            } else i10 = this.htmlGetBBox();
            s10 = i10.height, g2 && (i10.height = s10 = {
              "11px,17": 14,
              "13px,20": 16
            }[`${f2 || ""},${Math.round(s10)}`] || s10), u2 && (i10 = this.getRotatedBox(i10, u2));
            let t11 = {
              bBox: i10
            };
            eP(this, "afterGetBBox", t11), i10 = t11.bBox;
          }
          if (r10 && ("" === d2 || i10.height > 0)) {
            for (; p2.length > 250; ) delete c2[p2.shift()];
            c2[r10] || p2.push(r10), c2[r10] = i10;
          }
          return i10;
        }
        getRotatedBox(t10, e10) {
          let {
            x: i10,
            y: s10,
            width: o10,
            height: r10
          } = t10, {
            alignValue: a10,
            translateY: n10,
            rotationOriginX: h10 = 0,
            rotationOriginY: l2 = 0
          } = this, d2 = eL(a10), c2 = Number(this.element.getAttribute("y") || 0) - (n10 ? 0 : s10), p2 = e10 * eu, g2 = (e10 - 90) * eu, u2 = Math.cos(p2), f2 = Math.sin(p2), m2 = o10 * u2, x2 = o10 * f2, y2 = Math.cos(g2), b2 = Math.sin(g2), [[v2, k2], [w2, M2]] = [h10, l2].map((t11) => [t11 - t11 * u2, t11 * f2]), S2 = i10 + d2 * (o10 - m2) + v2 + M2 + c2 * y2, T2 = S2 + m2, C2 = T2 - r10 * y2, A2 = C2 - m2, P2 = s10 + c2 - d2 * x2 - k2 + w2 + c2 * b2, L2 = P2 + x2, O2 = L2 - r10 * b2, E2 = O2 - x2, I2 = Math.min(S2, T2, C2, A2), D2 = Math.min(P2, L2, O2, E2), B2 = Math.max(S2, T2, C2, A2) - I2, N2 = Math.max(P2, L2, O2, E2) - D2;
          return {
            x: I2,
            y: D2,
            width: B2,
            height: N2,
            polygon: [[S2, P2], [T2, L2], [C2, O2], [A2, E2]]
          };
        }
        getStyle(t10) {
          return ey.getComputedStyle(this.element || this, "").getPropertyValue(t10);
        }
        hasClass(t10) {
          return -1 !== ("" + this.attr("class")).split(" ").indexOf(t10);
        }
        hide() {
          return this.attr({
            visibility: "hidden"
          });
        }
        htmlGetBBox() {
          return {
            height: 0,
            width: 0,
            x: 0,
            y: 0
          };
        }
        constructor(t10, e10) {
          this.onEvents = {}, this.opacity = 1, this.SVG_NS = ex, this.element = "span" === e10 || "body" === e10 ? ew(e10) : ef.createElementNS(this.SVG_NS, e10), this.renderer = t10, this.styles = {}, eP(this, "afterInit");
        }
        on(t10, e10) {
          let {
            onEvents: i10
          } = this;
          return i10[t10] && i10[t10](), i10[t10] = ev(this.element, t10, e10), this;
        }
        opacitySetter(t10, e10, i10) {
          let s10 = Number(Number(t10).toFixed(3));
          this.opacity = s10, i10.setAttribute(e10, s10);
        }
        reAlign() {
          this.alignOptions?.width && "left" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = false, this.align());
        }
        removeClass(t10) {
          return this.attr("class", ("" + this.attr("class")).replace(eB(t10) ? RegExp(`(^| )${t10}( |$)`) : t10, " ").replace(/ +/g, " ").trim());
        }
        removeTextOutline() {
          let t10 = this.element.querySelector("tspan.highcharts-text-outline");
          t10 && this.safeRemoveChild(t10);
        }
        safeRemoveChild(t10) {
          let e10 = t10.parentNode;
          e10 && e10.removeChild(t10);
        }
        setRadialReference(t10) {
          let e10 = this.element.gradient && this.renderer.gradients[this.element.gradient];
          return this.element.radialReference = t10, e10 && e10.radAttr && e10.animate(this.renderer.getRadialAttr(t10, e10.radAttr)), this;
        }
        shadow(t10) {
          let {
            renderer: e10
          } = this, i10 = eN(this.parentGroup?.rotation === 90 ? {
            offsetX: -1,
            offsetY: -1
          } : {}, eD(t10) ? t10 : {}), s10 = e10.shadowDefinition(i10);
          return this.attr({
            filter: t10 ? `url(${e10.url}#${s10})` : "none"
          });
        }
        show(t10 = true) {
          return this.attr({
            visibility: t10 ? "inherit" : "visible"
          });
        }
        "stroke-widthSetter"(t10, e10, i10) {
          this[e10] = t10, i10.setAttribute(e10, t10);
        }
        strokeWidth() {
          if (!this.renderer.styledMode) return this["stroke-width"] || 0;
          let t10 = this.getStyle("stroke-width"), e10 = 0, i10;
          return /px$/.test(t10) ? e10 = eW(t10) : "" !== t10 && (ek(i10 = ef.createElementNS(ex, "rect"), {
            width: t10,
            "stroke-width": 0
          }), this.element.parentNode.appendChild(i10), e10 = i10.getBBox().width, i10.parentNode.removeChild(i10)), e10;
        }
        symbolAttr(t10) {
          let e10 = this;
          eY.symbolCustomAttribs.forEach(function(i10) {
            e10[i10] = eR(t10[i10], e10[i10]);
          }), e10.attr({
            d: e10.renderer.symbols[e10.symbolName](e10.x, e10.y, e10.width, e10.height, e10)
          });
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.textPxLength, this.textStr = t10, this.added && this.renderer.buildText(this), this.reAlign());
        }
        titleSetter(t10) {
          let e10 = this.element, i10 = e10.getElementsByTagName("title")[0] || ef.createElementNS(this.SVG_NS, "title");
          e10.insertBefore ? e10.insertBefore(i10, e10.firstChild) : e10.appendChild(i10), i10.textContent = eX(eR(t10, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        }
        toFront() {
          let t10 = this.element;
          return t10.parentNode.appendChild(t10), this;
        }
        translate(t10, e10) {
          return this.attr({
            translateX: t10,
            translateY: e10
          });
        }
        updateTransform(t10 = "transform") {
          let {
            element: e10,
            matrix: i10,
            rotation: s10 = 0,
            rotationOriginX: o10,
            rotationOriginY: r10,
            scaleX: a10,
            scaleY: n10,
            translateX: h10 = 0,
            translateY: l2 = 0
          } = this, d2 = ["translate(" + h10 + "," + l2 + ")"];
          eT(i10) && d2.push("matrix(" + i10.join(",") + ")"), s10 && (d2.push("rotate(" + s10 + " " + eR(o10, e10.getAttribute("x"), 0) + " " + eR(r10, e10.getAttribute("y") || 0) + ")"), this.text?.element.tagName === "SPAN" && this.text.attr({
            rotation: s10,
            rotationOriginX: (o10 || 0) - this.padding,
            rotationOriginY: (r10 || 0) - this.padding
          })), (eT(a10) || eT(n10)) && d2.push("scale(" + eR(a10, 1) + " " + eR(n10, 1) + ")"), d2.length && !(this.text || this).textPath && e10.setAttribute(t10, d2.join(" "));
        }
        visibilitySetter(t10, e10, i10) {
          "inherit" === t10 ? i10.removeAttribute(e10) : this[e10] !== t10 && i10.setAttribute(e10, t10), this[e10] = t10;
        }
        xGetter(t10) {
          return "circle" === this.element.nodeName && ("x" === t10 ? t10 = "cx" : "y" === t10 && (t10 = "cy")), this._defaultGetter(t10);
        }
        zIndexSetter(t10, e10) {
          let i10 = this.renderer, s10 = this.parentGroup, o10 = (s10 || i10).element || i10.box, r10 = this.element, a10 = o10 === i10.box, n10, h10, l2, d2 = false, c2, p2 = this.added, g2;
          if (eT(t10) ? (r10.setAttribute("data-z-index", t10), t10 = +t10, this[e10] === t10 && (p2 = false)) : eT(this[e10]) && r10.removeAttribute("data-z-index"), this[e10] = t10, p2) {
            for ((t10 = this.zIndex) && s10 && (s10.handleZ = true), g2 = (n10 = o10.childNodes).length - 1; g2 >= 0 && !d2; g2--) c2 = !eT(l2 = (h10 = n10[g2]).getAttribute("data-z-index")), h10 !== r10 && (t10 < 0 && c2 && !a10 && !g2 ? (o10.insertBefore(r10, n10[g2]), d2 = true) : (eW(l2) <= t10 || c2 && (!eT(t10) || t10 >= 0)) && (o10.insertBefore(r10, n10[g2 + 1]), d2 = true));
            d2 || (o10.insertBefore(r10, n10[a10 ? 3 : 0]), d2 = true);
          }
          return d2;
        }
      }
      eY.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], eY.prototype.strokeSetter = eY.prototype.fillSetter, eY.prototype.yGetter = eY.prototype.xGetter, eY.prototype.matrixSetter = eY.prototype.rotationOriginXSetter = eY.prototype.rotationOriginYSetter = eY.prototype.rotationSetter = eY.prototype.scaleXSetter = eY.prototype.scaleYSetter = eY.prototype.translateXSetter = eY.prototype.translateYSetter = eY.prototype.verticalAlignSetter = function(t10, e10) {
        this[e10] = t10, this.doTransform = true;
      };
      let ej = eY, {
        defined: eU,
        extend: e$,
        getAlignFactor: eV,
        isNumber: e_,
        merge: eq,
        pick: eZ,
        removeEvent: eK
      } = $;
      class eJ extends ej {
        constructor(t10, e10, i10, s10, o10, r10, a10, n10, h10, l2) {
          let d2;
          super(t10, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = false, this.textStr = e10, this.x = i10, this.y = s10, this.anchorX = r10, this.anchorY = a10, this.baseline = h10, this.className = l2, this.addClass("button" === l2 ? "highcharts-no-tooltip" : "highcharts-label"), l2 && this.addClass("highcharts-" + l2), this.text = t10.text(void 0, 0, 0, n10).attr({
            zIndex: 1
          }), "string" == typeof o10 && ((d2 = /^url\((.*?)\)$/.test(o10)) || this.renderer.symbols[o10]) && (this.symbolKey = o10), this.bBox = eJ.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t10.styledMode || d2, this.deferredAttr = {}, this.alignFactor = 0;
        }
        alignSetter(t10) {
          let e10 = eV(t10);
          this.textAlign = t10, e10 !== this.alignFactor && (this.alignFactor = e10, this.bBox && e_(this.xSetting) && this.attr({
            x: this.xSetting
          }));
        }
        anchorXSetter(t10, e10) {
          this.anchorX = t10, this.boxAttr(e10, Math.round(t10) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(t10, e10) {
          this.anchorY = t10, this.boxAttr(e10, t10 - this.ySetting);
        }
        boxAttr(t10, e10) {
          this.box ? this.box.attr(t10, e10) : this.deferredAttr[t10] = e10;
        }
        css(t10) {
          if (t10) {
            let e10 = {};
            t10 = eq(t10), eJ.textProps.forEach((i10) => {
              void 0 !== t10[i10] && (e10[i10] = t10[i10], delete t10[i10]);
            }), this.text.css(e10), "fontSize" in e10 || "fontWeight" in e10 ? this.updateTextPadding() : ("width" in e10 || "textOverflow" in e10) && this.updateBoxSize();
          }
          return ej.prototype.css.call(this, t10);
        }
        destroy() {
          eK(this.element, "mouseenter"), eK(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), ej.prototype.destroy.call(this);
        }
        fillSetter(t10, e10) {
          t10 && (this.needsBox = true), this.fill = t10, this.boxAttr(e10, t10);
        }
        getBBox(t10, e10) {
          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
          let {
            padding: i10,
            height: s10 = 0,
            translateX: o10 = 0,
            translateY: r10 = 0,
            width: a10 = 0
          } = this, n10 = eZ(this.paddingLeft, i10), h10 = e10 ?? (this.rotation || 0), l2 = {
            width: a10,
            height: s10,
            x: o10 + this.bBox.x - n10,
            y: r10 + this.bBox.y - i10 + this.baselineOffset
          };
          return h10 && (l2 = this.getRotatedBox(l2, h10)), l2;
        }
        getCrispAdjust() {
          return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        }
        heightSetter(t10) {
          this.heightSetting = t10, this.doUpdate = true;
        }
        afterSetters() {
          super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = false);
        }
        onAdd() {
          this.text.add(this), this.attr({
            text: eZ(this.textStr, ""),
            x: this.x || 0,
            y: this.y || 0
          }), this.box && eU(this.anchorX) && this.attr({
            anchorX: this.anchorX,
            anchorY: this.anchorY
          });
        }
        paddingSetter(t10, e10) {
          e_(t10) ? t10 !== this[e10] && (this[e10] = t10, this.updateTextPadding()) : this[e10] = void 0;
        }
        rSetter(t10, e10) {
          this.boxAttr(e10, t10);
        }
        strokeSetter(t10, e10) {
          this.stroke = t10, this.boxAttr(e10, t10);
        }
        "stroke-widthSetter"(t10, e10) {
          t10 && (this.needsBox = true), this["stroke-width"] = t10, this.boxAttr(e10, t10);
        }
        "text-alignSetter"(t10) {
          this.textAlign = this["text-align"] = t10, this.updateTextPadding();
        }
        textSetter(t10) {
          void 0 !== t10 && this.text.attr({
            text: t10
          }), this.updateTextPadding(), this.reAlign();
        }
        updateBoxSize() {
          let t10;
          let e10 = this.text, i10 = {}, s10 = this.padding, o10 = this.bBox = (!e_(this.widthSetting) || !e_(this.heightSetting) || this.textAlign) && eU(e10.textStr) ? e10.getBBox(void 0, 0) : eJ.emptyBBox;
          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o10.height || 0) + 2 * s10;
          let r10 = this.renderer.fontMetrics(e10);
          if (this.baselineOffset = s10 + Math.min((this.text.firstLineMetrics || r10).b, o10.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r10.h) / 2), this.needsBox && !e10.textPath) {
            if (!this.box) {
              let t11 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
              t11.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t11.add(this);
            }
            t10 = this.getCrispAdjust(), i10.x = t10, i10.y = (this.baseline ? -this.baselineOffset : 0) + t10, i10.width = Math.round(this.width), i10.height = Math.round(this.height), this.box.attr(e$(i10, this.deferredAttr)), this.deferredAttr = {};
          }
        }
        updateTextPadding() {
          let t10 = this.text, e10 = t10.styles.textAlign || this.textAlign;
          if (!t10.textPath) {
            this.updateBoxSize();
            let i10 = this.baseline ? 0 : this.baselineOffset, s10 = (this.paddingLeft ?? this.padding) + eV(e10) * (this.widthSetting ?? this.bBox.width);
            (s10 !== t10.x || i10 !== t10.y) && (t10.attr({
              align: e10,
              x: s10
            }), void 0 !== i10 && t10.attr("y", i10)), t10.x = s10, t10.y = i10;
          }
        }
        widthSetter(t10) {
          this.widthSetting = e_(t10) ? t10 : void 0, this.doUpdate = true;
        }
        getPaddedWidth() {
          let t10 = this.padding, e10 = eZ(this.paddingLeft, t10), i10 = eZ(this.paddingRight, t10);
          return (this.widthSetting || this.bBox.width || 0) + e10 + i10;
        }
        xSetter(t10) {
          this.x = t10, this.alignFactor && (t10 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true), this.xSetting = Math.round(t10), this.attr("translateX", this.xSetting);
        }
        ySetter(t10) {
          this.ySetting = this.y = Math.round(t10), this.attr("translateY", this.ySetting);
        }
      }
      eJ.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }, eJ.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineClamp", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"];
      let {
        defined: eQ,
        isNumber: e0,
        pick: e1
      } = $;
      function e2(t10, e10, i10, s10, o10) {
        let r10 = [];
        if (o10) {
          let a10 = o10.start || 0, n10 = e1(o10.r, i10), h10 = e1(o10.r, s10 || i10), l2 = 2e-4 / (o10.borderRadius ? 1 : Math.max(n10, 1)), d2 = Math.abs((o10.end || 0) - a10 - 2 * Math.PI) < l2, c2 = (o10.end || 0) - (d2 ? l2 : 0), p2 = o10.innerR, g2 = e1(o10.open, d2), u2 = Math.cos(a10), f2 = Math.sin(a10), m2 = Math.cos(c2), x2 = Math.sin(c2), y2 = e1(o10.longArc, c2 - a10 - Math.PI < l2 ? 0 : 1), b2 = ["A", n10, h10, 0, y2, e1(o10.clockwise, 1), t10 + n10 * m2, e10 + h10 * x2];
          b2.params = {
            start: a10,
            end: c2,
            cx: t10,
            cy: e10
          }, r10.push(["M", t10 + n10 * u2, e10 + h10 * f2], b2), eQ(p2) && ((b2 = ["A", p2, p2, 0, y2, eQ(o10.clockwise) ? 1 - o10.clockwise : 0, t10 + p2 * u2, e10 + p2 * f2]).params = {
            start: c2,
            end: a10,
            cx: t10,
            cy: e10
          }, r10.push(g2 ? ["M", t10 + p2 * m2, e10 + p2 * x2] : ["L", t10 + p2 * m2, e10 + p2 * x2], b2)), g2 || r10.push(["Z"]);
        }
        return r10;
      }
      function e3(t10, e10, i10, s10, o10) {
        return o10 && o10.r ? e5(t10, e10, i10, s10, o10) : [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
      }
      function e5(t10, e10, i10, s10, o10) {
        let r10 = o10?.r || 0;
        return [["M", t10 + r10, e10], ["L", t10 + i10 - r10, e10], ["A", r10, r10, 0, 0, 1, t10 + i10, e10 + r10], ["L", t10 + i10, e10 + s10 - r10], ["A", r10, r10, 0, 0, 1, t10 + i10 - r10, e10 + s10], ["L", t10 + r10, e10 + s10], ["A", r10, r10, 0, 0, 1, t10, e10 + s10 - r10], ["L", t10, e10 + r10], ["A", r10, r10, 0, 0, 1, t10 + r10, e10], ["Z"]];
      }
      let e6 = {
        arc: e2,
        callout: function(t10, e10, i10, s10, o10) {
          let r10 = Math.min(o10 && o10.r || 0, i10, s10), a10 = r10 + 6, n10 = o10 && o10.anchorX, h10 = o10 && o10.anchorY || 0, l2 = e5(t10, e10, i10, s10, {
            r: r10
          });
          if (!e0(n10) || n10 < i10 && n10 > 0 && h10 < s10 && h10 > 0) return l2;
          if (t10 + n10 > i10 - a10) {
            if (h10 > e10 + a10 && h10 < e10 + s10 - a10) l2.splice(3, 1, ["L", t10 + i10, h10 - 6], ["L", t10 + i10 + 6, h10], ["L", t10 + i10, h10 + 6], ["L", t10 + i10, e10 + s10 - r10]);
            else if (n10 < i10) {
              let o11 = h10 < e10 + a10, d2 = o11 ? e10 : e10 + s10;
              l2.splice(o11 ? 2 : 5, 0, ["L", n10, h10], ["L", t10 + i10 - r10, d2]);
            } else l2.splice(3, 1, ["L", t10 + i10, s10 / 2], ["L", n10, h10], ["L", t10 + i10, s10 / 2], ["L", t10 + i10, e10 + s10 - r10]);
          } else if (t10 + n10 < a10) {
            if (h10 > e10 + a10 && h10 < e10 + s10 - a10) l2.splice(7, 1, ["L", t10, h10 + 6], ["L", t10 - 6, h10], ["L", t10, h10 - 6], ["L", t10, e10 + r10]);
            else if (n10 > 0) {
              let i11 = h10 < e10 + a10, o11 = i11 ? e10 : e10 + s10;
              l2.splice(i11 ? 1 : 6, 0, ["L", n10, h10], ["L", t10 + r10, o11]);
            } else l2.splice(7, 1, ["L", t10, s10 / 2], ["L", n10, h10], ["L", t10, s10 / 2], ["L", t10, e10 + r10]);
          } else h10 > s10 && n10 < i10 - a10 ? l2.splice(5, 1, ["L", n10 + 6, e10 + s10], ["L", n10, e10 + s10 + 6], ["L", n10 - 6, e10 + s10], ["L", t10 + r10, e10 + s10]) : h10 < 0 && n10 > a10 && l2.splice(1, 1, ["L", n10 - 6, e10], ["L", n10, e10 - 6], ["L", n10 + 6, e10], ["L", i10 - r10, e10]);
          return l2;
        },
        circle: function(t10, e10, i10, s10) {
          return e2(t10 + i10 / 2, e10 + s10 / 2, i10 / 2, s10 / 2, {
            start: 0.5 * Math.PI,
            end: 2.5 * Math.PI,
            open: false
          });
        },
        diamond: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10 / 2], ["L", t10 + i10 / 2, e10 + s10], ["L", t10, e10 + s10 / 2], ["Z"]];
        },
        rect: e3,
        roundedRect: e5,
        square: e3,
        triangle: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
        },
        "triangle-down": function(t10, e10, i10, s10) {
          return [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10 / 2, e10 + s10], ["Z"]];
        }
      }, {
        doc: e9,
        SVG_NS: e4,
        win: e8
      } = k, {
        attr: e7,
        extend: it,
        fireEvent: ie,
        isString: ii,
        objectEach: is,
        pick: io
      } = $, ir = (t10, e10) => t10.substring(0, e10) + "…", ia = class {
        constructor(t10) {
          let e10 = t10.styles;
          this.renderer = t10.renderer, this.svgElement = t10, this.width = t10.textWidth, this.textLineHeight = e10 && e10.lineHeight, this.textOutline = e10 && e10.textOutline, this.ellipsis = !!(e10 && "ellipsis" === e10.textOverflow), this.lineClamp = e10?.lineClamp, this.noWrap = !!(e10 && "nowrap" === e10.whiteSpace);
        }
        buildSVG() {
          let t10 = this.svgElement, e10 = t10.element, i10 = t10.renderer, s10 = io(t10.textStr, "").toString(), o10 = -1 !== s10.indexOf("<"), r10 = e10.childNodes, a10 = !t10.added && i10.box, n10 = [s10, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, t10.getStyle("font-size"), t10.styles.lineClamp, this.width].join(",");
          if (n10 !== t10.textCache) {
            t10.textCache = n10, delete t10.actualWidth;
            for (let t11 = r10.length; t11--; ) e10.removeChild(r10[t11]);
            if (o10 || this.ellipsis || this.width || t10.textPath || -1 !== s10.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(s10))) {
              if ("" !== s10) {
                a10 && a10.appendChild(e10);
                let i11 = new tK(s10);
                this.modifyTree(i11.nodes), i11.addToDOM(e10), this.modifyDOM(), this.ellipsis && -1 !== (e10.textContent || "").indexOf("…") && t10.attr("title", this.unescapeEntities(t10.textStr || "", ["&lt;", "&gt;"])), a10 && a10.removeChild(e10);
              }
            } else e10.appendChild(e9.createTextNode(this.unescapeEntities(s10)));
            ii(this.textOutline) && t10.applyTextOutline && t10.applyTextOutline(this.textOutline);
          }
        }
        modifyDOM() {
          let t10;
          let e10 = this.svgElement, i10 = e7(e10.element, "x");
          for (e10.firstLineMetrics = void 0; t10 = e10.element.firstChild; ) if (/^[\s\u200B]*$/.test(t10.textContent || " ")) e10.element.removeChild(t10);
          else break;
          [].forEach.call(e10.element.querySelectorAll("tspan.highcharts-br"), (t11, s11) => {
            t11.nextSibling && t11.previousSibling && (0 === s11 && 1 === t11.previousSibling.nodeType && (e10.firstLineMetrics = e10.renderer.fontMetrics(t11.previousSibling)), e7(t11, {
              dy: this.getLineHeight(t11.nextSibling),
              x: i10
            }));
          });
          let s10 = this.width || 0;
          if (!s10) return;
          let o10 = (t11, o11) => {
            let r11 = t11.textContent || "", a10 = r11.replace(/([^\^])-/g, "$1- ").split(" "), n10 = !this.noWrap && (a10.length > 1 || e10.element.childNodes.length > 1), h10 = this.getLineHeight(o11), l2 = Math.max(0, s10 - 0.8 * h10), d2 = 0, c2 = e10.actualWidth;
            if (n10) {
              let r12 = [], n11 = [];
              for (; o11.firstChild && o11.firstChild !== t11; ) n11.push(o11.firstChild), o11.removeChild(o11.firstChild);
              for (; a10.length; ) if (a10.length && !this.noWrap && d2 > 0 && (r12.push(t11.textContent || ""), t11.textContent = a10.join(" ").replace(/- /g, "-")), this.truncate(t11, void 0, a10, 0 === d2 && c2 || 0, s10, l2, (t12, e11) => a10.slice(0, e11).join(" ").replace(/- /g, "-")), c2 = e10.actualWidth, d2++, this.lineClamp && d2 >= this.lineClamp) {
                a10.length && (this.truncate(t11, t11.textContent || "", void 0, 0, s10, l2, ir), t11.textContent = t11.textContent?.replace("…", "") + "…");
                break;
              }
              n11.forEach((e11) => {
                o11.insertBefore(e11, t11);
              }), r12.forEach((e11) => {
                o11.insertBefore(e9.createTextNode(e11), t11);
                let s11 = e9.createElementNS(e4, "tspan");
                s11.textContent = "​", e7(s11, {
                  dy: h10,
                  x: i10
                }), o11.insertBefore(s11, t11);
              });
            } else this.ellipsis && r11 && this.truncate(t11, r11, void 0, 0, s10, l2, ir);
          }, r10 = (t11) => {
            [].slice.call(t11.childNodes).forEach((i11) => {
              i11.nodeType === e8.Node.TEXT_NODE ? o10(i11, t11) : (-1 !== i11.className.baseVal.indexOf("highcharts-br") && (e10.actualWidth = 0), r10(i11));
            });
          };
          r10(e10.element);
        }
        getLineHeight(t10) {
          let e10 = t10.nodeType === e8.Node.TEXT_NODE ? t10.parentElement : t10;
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e10 || this.svgElement.element).h;
        }
        modifyTree(t10) {
          let e10 = (i10, s10) => {
            let {
              attributes: o10 = {},
              children: r10,
              style: a10 = {},
              tagName: n10
            } = i10, h10 = this.renderer.styledMode;
            if ("b" === n10 || "strong" === n10 ? h10 ? o10.class = "highcharts-strong" : a10.fontWeight = "bold" : ("i" === n10 || "em" === n10) && (h10 ? o10.class = "highcharts-emphasized" : a10.fontStyle = "italic"), a10 && a10.color && (a10.fill = a10.color), "br" === n10) {
              o10.class = "highcharts-br", i10.textContent = "​";
              let e11 = t10[s10 + 1];
              e11 && e11.textContent && (e11.textContent = e11.textContent.replace(/^ +/gm, ""));
            } else "a" === n10 && r10 && r10.some((t11) => "#text" === t11.tagName) && (i10.children = [{
              children: r10,
              tagName: "tspan"
            }]);
            "#text" !== n10 && "a" !== n10 && (i10.tagName = "tspan"), it(i10, {
              attributes: o10,
              style: a10
            }), r10 && r10.filter((t11) => "#text" !== t11.tagName).forEach(e10);
          };
          t10.forEach(e10), ie(this.svgElement, "afterModifyTree", {
            nodes: t10
          });
        }
        truncate(t10, e10, i10, s10, o10, r10, a10) {
          let n10, h10;
          let l2 = this.svgElement, {
            rotation: d2
          } = l2, c2 = [], p2 = i10 && !s10 ? 1 : 0, g2 = (e10 || i10 || "").length, u2 = g2;
          i10 || (o10 = r10);
          let f2 = function(e11, o11) {
            let r11 = o11 || e11, a11 = t10.parentNode;
            if (a11 && void 0 === c2[r11] && a11.getSubStringLength) try {
              c2[r11] = s10 + a11.getSubStringLength(0, i10 ? r11 + 1 : r11);
            } catch (t11) {
            }
            return c2[r11];
          };
          if (l2.rotation = 0, s10 + (h10 = f2(t10.textContent.length)) > o10) {
            for (; p2 <= g2; ) u2 = Math.ceil((p2 + g2) / 2), i10 && (n10 = a10(i10, u2)), h10 = f2(u2, n10 && n10.length - 1), p2 === g2 ? p2 = g2 + 1 : h10 > o10 ? g2 = u2 - 1 : p2 = u2;
            0 === g2 ? t10.textContent = "" : e10 && g2 === e10.length - 1 || (t10.textContent = n10 || a10(e10 || i10, u2)), this.ellipsis && h10 > o10 && this.truncate(t10, t10.textContent || "", void 0, 0, o10, r10, ir);
          }
          i10 && i10.splice(0, u2), l2.actualWidth = h10, l2.rotation = d2;
        }
        unescapeEntities(t10, e10) {
          return is(this.renderer.escapes, function(i10, s10) {
            e10 && -1 !== e10.indexOf(i10) || (t10 = t10.toString().replace(RegExp(i10, "g"), s10));
          }), t10;
        }
      }, {
        defaultOptions: ih
      } = tm, {
        charts: il,
        deg2rad: id,
        doc: ic,
        isFirefox: ip,
        isMS: ig,
        isWebKit: iu,
        noop: im,
        SVG_NS: ix,
        symbolSizes: iy,
        win: ib
      } = k, {
        addEvent: iv,
        attr: ik,
        createElement: iw,
        crisp: iM,
        css: iS,
        defined: iT,
        destroyObjectProperties: iC,
        extend: iA,
        isArray: iP,
        isNumber: iL,
        isObject: iO,
        isString: iE,
        merge: iI,
        pick: iD,
        pInt: iB,
        replaceNested: iN,
        uniqueKey: iz
      } = $;
      class iR {
        constructor(t10, e10, i10, s10, o10, r10, a10) {
          let n10, h10;
          let l2 = this.createElement("svg").attr({
            version: "1.1",
            class: "highcharts-root"
          }), d2 = l2.element;
          a10 || l2.css(this.getStyle(s10 || {})), t10.appendChild(d2), ik(t10, "dir", "ltr"), -1 === t10.innerHTML.indexOf("xmlns") && ik(d2, "xmlns", this.SVG_NS), this.box = d2, this.boxWrapper = l2, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(ic.createTextNode("Created with Highcharts 12.1.2")), this.defs = this.createElement("defs").add(), this.allowHTML = r10, this.forExport = o10, this.styledMode = a10, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l2.getStyle("font-size"), this.setSize(e10, i10, false), ip && t10.getBoundingClientRect && ((n10 = function() {
            iS(t10, {
              left: 0,
              top: 0
            }), h10 = t10.getBoundingClientRect(), iS(t10, {
              left: Math.ceil(h10.left) - h10.left + "px",
              top: Math.ceil(h10.top) - h10.top + "px"
            });
          })(), this.unSubPixelFix = iv(ib, "resize", n10));
        }
        definition(t10) {
          return new tK([t10]).addToDOM(this.defs.element);
        }
        getReferenceURL() {
          if ((ip || iu) && ic.getElementsByTagName("base").length) {
            if (!iT(e)) {
              let t10 = iz(), i10 = new tK([{
                tagName: "svg",
                attributes: {
                  width: 8,
                  height: 8
                },
                children: [{
                  tagName: "defs",
                  children: [{
                    tagName: "clipPath",
                    attributes: {
                      id: t10
                    },
                    children: [{
                      tagName: "rect",
                      attributes: {
                        width: 4,
                        height: 4
                      }
                    }]
                  }]
                }, {
                  tagName: "rect",
                  attributes: {
                    id: "hitme",
                    width: 8,
                    height: 8,
                    "clip-path": `url(#${t10})`,
                    fill: "rgba(0,0,0,0.001)"
                  }
                }]
              }]).addToDOM(ic.body);
              iS(i10, {
                position: "fixed",
                top: 0,
                left: 0,
                zIndex: 9e5
              });
              let s10 = ic.elementFromPoint(6, 6);
              e = "hitme" === (s10 && s10.id), ic.body.removeChild(i10);
            }
            if (e) return iN(ib.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
          }
          return "";
        }
        getStyle(t10) {
          return this.style = iA({
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
            fontSize: "1rem"
          }, t10), this.style;
        }
        setStyle(t10) {
          this.boxWrapper.css(this.getStyle(t10));
        }
        isHidden() {
          return !this.boxWrapper.getBBox().width;
        }
        destroy() {
          let t10 = this.defs;
          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), iC(this.gradients || {}), this.gradients = null, this.defs = t10.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
        }
        createElement(t10) {
          return new this.Element(this, t10);
        }
        getRadialAttr(t10, e10) {
          return {
            cx: t10[0] - t10[2] / 2 + (e10.cx || 0) * t10[2],
            cy: t10[1] - t10[2] / 2 + (e10.cy || 0) * t10[2],
            r: (e10.r || 0) * t10[2]
          };
        }
        shadowDefinition(t10) {
          let e10 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t10).map((e11) => `${e11}-${t10[e11]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i10 = iI({
            color: "#000000",
            offsetX: 1,
            offsetY: 1,
            opacity: 0.15,
            width: 5
          }, t10);
          return this.defs.element.querySelector(`#${e10}`) || this.definition({
            tagName: "filter",
            attributes: {
              id: e10,
              filterUnits: i10.filterUnits
            },
            children: this.getShadowFilterContent(i10)
          }), e10;
        }
        getShadowFilterContent(t10) {
          return [{
            tagName: "feDropShadow",
            attributes: {
              dx: t10.offsetX,
              dy: t10.offsetY,
              "flood-color": t10.color,
              "flood-opacity": Math.min(5 * t10.opacity, 1),
              stdDeviation: t10.width / 2
            }
          }];
        }
        buildText(t10) {
          new ia(t10).buildSVG();
        }
        getContrast(t10) {
          let e10 = tk.parse(t10).rgba.map((t11) => {
            let e11 = t11 / 255;
            return e11 <= 0.03928 ? e11 / 12.92 : Math.pow((e11 + 0.055) / 1.055, 2.4);
          }), i10 = 0.2126 * e10[0] + 0.7152 * e10[1] + 0.0722 * e10[2];
          return 1.05 / (i10 + 0.05) > (i10 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
        }
        button(t10, e10, i10, s10, o10 = {}, r10, a10, n10, h10, l2) {
          let d2 = this.label(t10, e10, i10, h10, void 0, void 0, l2, void 0, "button"), c2 = this.styledMode, p2 = arguments, g2 = 0;
          o10 = iI(ih.global.buttonTheme, o10), c2 && (delete o10.fill, delete o10.stroke, delete o10["stroke-width"]);
          let u2 = o10.states || {}, f2 = o10.style || {};
          delete o10.states, delete o10.style;
          let m2 = [tK.filterUserAttributes(o10)], x2 = [f2];
          return c2 || ["hover", "select", "disabled"].forEach((t11, e11) => {
            m2.push(iI(m2[0], tK.filterUserAttributes(p2[e11 + 5] || u2[t11] || {}))), x2.push(m2[e11 + 1].style), delete m2[e11 + 1].style;
          }), iv(d2.element, ig ? "mouseover" : "mouseenter", function() {
            3 !== g2 && d2.setState(1);
          }), iv(d2.element, ig ? "mouseout" : "mouseleave", function() {
            3 !== g2 && d2.setState(g2);
          }), d2.setState = (t11 = 0) => {
            if (1 !== t11 && (d2.state = g2 = t11), d2.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t11]), !c2) {
              d2.attr(m2[t11]);
              let e11 = x2[t11];
              iO(e11) && d2.css(e11);
            }
          }, d2.attr(m2[0]), !c2 && (d2.css(iA({
            cursor: "default"
          }, f2)), l2 && d2.text.css({
            pointerEvents: "none"
          })), d2.on("touchstart", (t11) => t11.stopPropagation()).on("click", function(t11) {
            3 !== g2 && s10.call(d2, t11);
          });
        }
        crispLine(t10, e10) {
          let [i10, s10] = t10;
          return iT(i10[1]) && i10[1] === s10[1] && (i10[1] = s10[1] = iM(i10[1], e10)), iT(i10[2]) && i10[2] === s10[2] && (i10[2] = s10[2] = iM(i10[2], e10)), t10;
        }
        path(t10) {
          let e10 = this.styledMode ? {} : {
            fill: "none"
          };
          return iP(t10) ? e10.d = t10 : iO(t10) && iA(e10, t10), this.createElement("path").attr(e10);
        }
        circle(t10, e10, i10) {
          let s10 = iO(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: i10
          }, o10 = this.createElement("circle");
          return o10.xSetter = o10.ySetter = function(t11, e11, i11) {
            i11.setAttribute("c" + e11, t11);
          }, o10.attr(s10);
        }
        arc(t10, e10, i10, s10, o10, r10) {
          let a10;
          iO(t10) ? (e10 = (a10 = t10).y, i10 = a10.r, s10 = a10.innerR, o10 = a10.start, r10 = a10.end, t10 = a10.x) : a10 = {
            innerR: s10,
            start: o10,
            end: r10
          };
          let n10 = this.symbol("arc", t10, e10, i10, i10, a10);
          return n10.r = i10, n10;
        }
        rect(t10, e10, i10, s10, o10, r10) {
          let a10 = iO(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: o10,
            width: Math.max(i10 || 0, 0),
            height: Math.max(s10 || 0, 0)
          }, n10 = this.createElement("rect");
          return this.styledMode || (void 0 !== r10 && (a10["stroke-width"] = r10, iA(a10, n10.crisp(a10))), a10.fill = "none"), n10.rSetter = function(t11, e11, i11) {
            n10.r = t11, ik(i11, {
              rx: t11,
              ry: t11
            });
          }, n10.rGetter = function() {
            return n10.r || 0;
          }, n10.attr(a10);
        }
        roundedRect(t10) {
          return this.symbol("roundedRect").attr(t10);
        }
        setSize(t10, e10, i10) {
          this.width = t10, this.height = e10, this.boxWrapper.animate({
            width: t10,
            height: e10
          }, {
            step: function() {
              this.attr({
                viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
              });
            },
            duration: iD(i10, true) ? void 0 : 0
          }), this.alignElements();
        }
        g(t10) {
          let e10 = this.createElement("g");
          return t10 ? e10.attr({
            class: "highcharts-" + t10
          }) : e10;
        }
        image(t10, e10, i10, s10, o10, r10) {
          let a10 = {
            preserveAspectRatio: "none"
          };
          iL(e10) && (a10.x = e10), iL(i10) && (a10.y = i10), iL(s10) && (a10.width = s10), iL(o10) && (a10.height = o10);
          let n10 = this.createElement("image").attr(a10), h10 = function(e11) {
            n10.attr({
              href: t10
            }), r10.call(n10, e11);
          };
          if (r10) {
            n10.attr({
              href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
            });
            let e11 = new ib.Image();
            iv(e11, "load", h10), e11.src = t10, e11.complete && h10({});
          } else n10.attr({
            href: t10
          });
          return n10;
        }
        symbol(t10, e10, i10, s10, o10, r10) {
          let a10, n10, h10, l2;
          let d2 = this, c2 = /^url\((.*?)\)$/, p2 = c2.test(t10), g2 = !p2 && (this.symbols[t10] ? t10 : "circle"), u2 = g2 && this.symbols[g2];
          if (u2) "number" == typeof e10 && (n10 = u2.call(this.symbols, e10 || 0, i10 || 0, s10 || 0, o10 || 0, r10)), a10 = this.path(n10), d2.styledMode || a10.attr("fill", "none"), iA(a10, {
            symbolName: g2 || void 0,
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }), r10 && iA(a10, r10);
          else if (p2) {
            h10 = t10.match(c2)[1];
            let s11 = a10 = this.image(h10);
            s11.imgwidth = iD(r10 && r10.width, iy[h10] && iy[h10].width), s11.imgheight = iD(r10 && r10.height, iy[h10] && iy[h10].height), l2 = (t11) => t11.attr({
              width: t11.width,
              height: t11.height
            }), ["width", "height"].forEach((t11) => {
              s11[`${t11}Setter`] = function(t12, e11) {
                this[e11] = t12;
                let {
                  alignByTranslate: i11,
                  element: s12,
                  width: o11,
                  height: a11,
                  imgwidth: n11,
                  imgheight: h11
                } = this, l3 = "width" === e11 ? n11 : h11, d3 = 1;
                r10 && "within" === r10.backgroundSize && o11 && a11 && n11 && h11 ? (d3 = Math.min(o11 / n11, a11 / h11), ik(s12, {
                  width: Math.round(n11 * d3),
                  height: Math.round(h11 * d3)
                })) : s12 && l3 && s12.setAttribute(e11, l3), !i11 && n11 && h11 && this.translate(((o11 || 0) - n11 * d3) / 2, ((a11 || 0) - h11 * d3) / 2);
              };
            }), iT(e10) && s11.attr({
              x: e10,
              y: i10
            }), s11.isImg = true, s11.symbolUrl = t10, iT(s11.imgwidth) && iT(s11.imgheight) ? l2(s11) : (s11.attr({
              width: 0,
              height: 0
            }), iw("img", {
              onload: function() {
                let t11 = il[d2.chartIndex];
                0 === this.width && (iS(this, {
                  position: "absolute",
                  top: "-999em"
                }), ic.body.appendChild(this)), iy[h10] = {
                  width: this.width,
                  height: this.height
                }, s11.imgwidth = this.width, s11.imgheight = this.height, s11.element && l2(s11), this.parentNode && this.parentNode.removeChild(this), d2.imgCount--, d2.imgCount || !t11 || t11.hasLoaded || t11.onload();
              },
              src: h10
            }), this.imgCount++);
          }
          return a10;
        }
        clipRect(t10, e10, i10, s10) {
          return this.rect(t10, e10, i10, s10, 0);
        }
        text(t10, e10, i10, s10) {
          let o10 = {};
          if (s10 && (this.allowHTML || !this.forExport)) return this.html(t10, e10, i10);
          o10.x = Math.round(e10 || 0), i10 && (o10.y = Math.round(i10)), iT(t10) && (o10.text = t10);
          let r10 = this.createElement("text").attr(o10);
          return s10 && (!this.forExport || this.allowHTML) || (r10.xSetter = function(t11, e11, i11) {
            let s11 = i11.getElementsByTagName("tspan"), o11 = i11.getAttribute(e11);
            for (let i12 = 0, r11; i12 < s11.length; i12++) (r11 = s11[i12]).getAttribute(e11) === o11 && r11.setAttribute(e11, t11);
            i11.setAttribute(e11, t11);
          }), r10;
        }
        fontMetrics(t10) {
          let e10 = iB(ej.prototype.getStyle.call(t10, "font-size") || 0), i10 = e10 < 24 ? e10 + 3 : Math.round(1.2 * e10), s10 = Math.round(0.8 * i10);
          return {
            h: i10,
            b: s10,
            f: e10
          };
        }
        rotCorr(t10, e10, i10) {
          let s10 = t10;
          return e10 && i10 && (s10 = Math.max(s10 * Math.cos(e10 * id), 4)), {
            x: -t10 / 3 * Math.sin(e10 * id),
            y: s10
          };
        }
        pathToSegments(t10) {
          let e10 = [], i10 = [], s10 = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          };
          for (let o10 = 0; o10 < t10.length; o10++) iE(i10[0]) && iL(t10[o10]) && i10.length === s10[i10[0].toUpperCase()] && t10.splice(o10, 0, i10[0].replace("M", "L").replace("m", "l")), "string" == typeof t10[o10] && (i10.length && e10.push(i10.slice(0)), i10.length = 0), i10.push(t10[o10]);
          return e10.push(i10.slice(0)), e10;
        }
        label(t10, e10, i10, s10, o10, r10, a10, n10, h10) {
          return new eJ(this, t10, e10, i10, s10, o10, r10, a10, n10, h10);
        }
        alignElements() {
          this.alignedObjects.forEach((t10) => t10.align());
        }
      }
      iA(iR.prototype, {
        Element: ej,
        SVG_NS: ix,
        escapes: {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "'": "&#39;",
          '"': "&quot;"
        },
        symbols: e6,
        draw: im
      }), er.registerRendererType("svg", iR, true);
      let {
        composed: iW
      } = k, {
        attr: iH,
        css: iX,
        createElement: iF,
        defined: iG,
        extend: iY,
        getAlignFactor: ij,
        isNumber: iU,
        pInt: i$,
        pushUnique: iV
      } = $;
      function i_(t10, e10, i10) {
        let s10 = this.div?.style || i10.style;
        ej.prototype[`${e10}Setter`].call(this, t10, e10, i10), s10 && (s10[e10] = t10);
      }
      let iq = (t10, e10) => {
        if (!t10.div) {
          let i10 = iH(t10.element, "class"), s10 = t10.css, o10 = iF("div", i10 ? {
            className: i10
          } : void 0, __spreadProps(__spreadValues({
            position: "absolute",
            left: `${t10.translateX || 0}px`,
            top: `${t10.translateY || 0}px`
          }, t10.styles), {
            display: t10.display,
            opacity: t10.opacity,
            visibility: t10.visibility
          }), t10.parentGroup?.div || e10);
          t10.classSetter = (t11, e11, i11) => {
            i11.setAttribute("class", t11), o10.className = t11;
          }, t10.translateXSetter = t10.translateYSetter = (e11, i11) => {
            t10[i11] = e11, o10.style["translateX" === i11 ? "left" : "top"] = `${e11}px`, t10.doTransform = true;
          }, t10.opacitySetter = t10.visibilitySetter = i_, t10.css = (e11) => (s10.call(t10, e11), e11.cursor && (o10.style.cursor = e11.cursor), e11.pointerEvents && (o10.style.pointerEvents = e11.pointerEvents), t10), t10.on = function() {
            return ej.prototype.on.apply({
              element: o10,
              onEvents: t10.onEvents
            }, arguments), t10;
          }, t10.div = o10;
        }
        return t10.div;
      };
      class iZ extends ej {
        static compose(t10) {
          iV(iW, this.compose) && (t10.prototype.html = function(t11, e10, i10) {
            return new iZ(this, "span").attr({
              text: t11,
              x: Math.round(e10),
              y: Math.round(i10)
            });
          });
        }
        constructor(t10, e10) {
          super(t10, e10), this.css(__spreadValues({
            position: "absolute"
          }, t10.styledMode ? {} : {
            fontFamily: t10.style.fontFamily,
            fontSize: t10.style.fontSize
          }));
        }
        getSpanCorrection(t10, e10, i10) {
          this.xCorr = -t10 * i10, this.yCorr = -e10;
        }
        css(t10) {
          let e10;
          let {
            element: i10
          } = this, s10 = "SPAN" === i10.tagName && t10 && "width" in t10, o10 = s10 && t10.width;
          return s10 && (delete t10.width, this.textWidth = i$(o10) || void 0, e10 = true), t10?.textOverflow === "ellipsis" && (t10.overflow = "hidden"), t10?.lineClamp && (t10.display = "-webkit-box", t10.WebkitLineClamp = t10.lineClamp, t10.WebkitBoxOrient = "vertical", t10.overflow = "hidden"), iU(Number(t10?.fontSize)) && (t10.fontSize = t10.fontSize + "px"), iY(this.styles, t10), iX(i10, t10), e10 && this.updateTransform(), this;
        }
        htmlGetBBox() {
          let {
            element: t10
          } = this;
          return {
            x: t10.offsetLeft,
            y: t10.offsetTop,
            width: t10.offsetWidth,
            height: t10.offsetHeight
          };
        }
        updateTransform() {
          if (!this.added) {
            this.alignOnAdd = true;
            return;
          }
          let {
            element: t10,
            renderer: e10,
            rotation: i10,
            rotationOriginX: s10,
            rotationOriginY: o10,
            scaleX: r10,
            scaleY: a10,
            styles: n10,
            textAlign: h10 = "left",
            textWidth: l2,
            translateX: d2 = 0,
            translateY: c2 = 0,
            x: p2 = 0,
            y: g2 = 0
          } = this, {
            display: u2 = "block",
            whiteSpace: f2
          } = n10;
          if (iX(t10, {
            marginLeft: `${d2}px`,
            marginTop: `${c2}px`
          }), "SPAN" === t10.tagName) {
            let n11;
            let d3 = [i10, h10, t10.innerHTML, l2, this.textAlign].join(","), c3 = -(this.parentGroup?.padding * 1) || 0;
            if (l2 !== this.oldTextWidth) {
              let e11 = this.textPxLength ? this.textPxLength : (iX(t10, {
                width: "",
                whiteSpace: f2 || "nowrap"
              }), t10.offsetWidth), s11 = l2 || 0;
              (s11 > this.oldTextWidth || e11 > s11) && (/[ \-]/.test(t10.textContent || t10.innerText) || "ellipsis" === t10.style.textOverflow) && (iX(t10, {
                width: e11 > s11 || i10 || r10 ? l2 + "px" : "auto",
                display: u2,
                whiteSpace: f2 || "normal"
              }), this.oldTextWidth = l2);
            }
            d3 !== this.cTT && (n11 = e10.fontMetrics(t10).b, iG(i10) && (i10 !== (this.oldRotation || 0) || h10 !== this.oldAlign) && this.setSpanRotation(i10, c3, c3), this.getSpanCorrection(!iG(i10) && !this.textWidth && this.textPxLength || t10.offsetWidth, n11, ij(h10)));
            let {
              xCorr: m2 = 0,
              yCorr: x2 = 0
            } = this, y2 = {
              left: `${p2 + m2}px`,
              top: `${g2 + x2}px`,
              textAlign: h10,
              transformOrigin: `${(s10 ?? p2) - m2 - p2 - c3}px ${(o10 ?? g2) - x2 - g2 - c3}px`
            };
            (r10 || a10) && (y2.transform = `scale(${r10 ?? 1},${a10 ?? 1})`), iX(t10, y2), this.cTT = d3, this.oldRotation = i10, this.oldAlign = h10;
          }
        }
        setSpanRotation(t10, e10, i10) {
          iX(this.element, {
            transform: `rotate(${t10}deg)`,
            transformOrigin: `${e10}% ${i10}px`
          });
        }
        add(t10) {
          let e10;
          let i10 = this.renderer.box.parentNode, s10 = [];
          if (this.parentGroup = t10, t10 && !(e10 = t10.div)) {
            let o10 = t10;
            for (; o10; ) s10.push(o10), o10 = o10.parentGroup;
            for (let t11 of s10.reverse()) e10 = iq(t11, i10);
          }
          return (e10 || i10).appendChild(this.element), this.added = true, this.alignOnAdd && this.updateTransform(), this;
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, tK.setElementHTML(this.element, t10 ?? ""), this.textStr = t10, this.doTransform = true);
        }
        alignSetter(t10) {
          this.alignValue = this.textAlign = t10, this.doTransform = true;
        }
        xSetter(t10, e10) {
          this[e10] = t10, this.doTransform = true;
        }
      }
      let iK = iZ.prototype;
      iK.visibilitySetter = iK.opacitySetter = i_, iK.ySetter = iK.rotationSetter = iK.rotationOriginXSetter = iK.rotationOriginYSetter = iK.xSetter, function(t10) {
        t10.xAxis = {
          alignTicks: true,
          allowDecimals: void 0,
          panningEnabled: true,
          zIndex: 2,
          zoomEnabled: true,
          dateTimeLabelFormats: {
            millisecond: {
              main: "%[HMSL]",
              range: false
            },
            second: {
              main: "%[HMS]",
              range: false
            },
            minute: {
              main: "%[HM]",
              range: false
            },
            hour: {
              main: "%[HM]",
              range: false
            },
            day: {
              main: "%[eb]"
            },
            week: {
              main: "%[eb]"
            },
            month: {
              main: "%[bY]"
            },
            year: {
              main: "%Y"
            }
          },
          endOnTick: false,
          gridLineDashStyle: "Solid",
          gridZIndex: 1,
          labels: {
            autoRotationLimit: 80,
            distance: 15,
            enabled: true,
            indentation: 10,
            overflow: "justify",
            reserveSpace: void 0,
            rotation: void 0,
            staggerLines: 0,
            step: 0,
            useHTML: false,
            zIndex: 7,
            style: {
              color: "#333333",
              cursor: "default",
              fontSize: "0.8em",
              textOverflow: "ellipsis"
            }
          },
          maxPadding: 0.01,
          minorGridLineDashStyle: "Solid",
          minorTickLength: 2,
          minorTickPosition: "outside",
          minorTicksPerMajor: 5,
          minPadding: 0.01,
          offset: void 0,
          reversed: void 0,
          reversedStacks: false,
          showEmpty: true,
          showFirstLabel: true,
          showLastLabel: true,
          startOfWeek: 1,
          startOnTick: false,
          tickLength: 10,
          tickPixelInterval: 100,
          tickmarkPlacement: "between",
          tickPosition: "outside",
          title: {
            align: "middle",
            useHTML: false,
            x: 0,
            y: 0,
            style: {
              color: "#666666",
              fontSize: "0.8em"
            }
          },
          visible: true,
          minorGridLineColor: "#f2f2f2",
          minorGridLineWidth: 1,
          minorTickColor: "#999999",
          lineColor: "#333333",
          lineWidth: 1,
          gridLineColor: "#e6e6e6",
          gridLineWidth: void 0,
          tickColor: "#333333"
        }, t10.yAxis = {
          reversedStacks: true,
          endOnTick: true,
          maxPadding: 0.05,
          minPadding: 0.05,
          tickPixelInterval: 72,
          showLastLabel: true,
          labels: {
            x: void 0
          },
          startOnTick: true,
          title: {
            text: "Values"
          },
          stackLabels: {
            animation: {},
            allowOverlap: false,
            enabled: false,
            crop: true,
            overflow: "justify",
            formatter: function() {
              let {
                numberFormatter: t11
              } = this.axis.chart;
              return t11(this.total || 0, -1);
            },
            style: {
              color: "#000000",
              fontSize: "0.7em",
              fontWeight: "bold",
              textOutline: "1px contrast"
            }
          },
          gridLineWidth: 1,
          lineWidth: 0
        };
      }(r || (r = {}));
      let iJ = r, {
        addEvent: iQ,
        isFunction: i0,
        objectEach: i1,
        removeEvent: i2
      } = $;
      (a || (a = {})).registerEventOptions = function(t10, e10) {
        t10.eventOptions = t10.eventOptions || {}, i1(e10.events, function(e11, i10) {
          t10.eventOptions[i10] !== e11 && (t10.eventOptions[i10] && (i2(t10, i10, t10.eventOptions[i10]), delete t10.eventOptions[i10]), i0(e11) && (t10.eventOptions[i10] = e11, iQ(t10, i10, e11, {
            order: 0
          })));
        });
      };
      let i3 = a, {
        deg2rad: i5
      } = k, {
        clamp: i6,
        correctFloat: i9,
        defined: i4,
        destroyObjectProperties: i8,
        extend: i7,
        fireEvent: st,
        getAlignFactor: se,
        isNumber: si,
        merge: ss,
        objectEach: so,
        pick: sr
      } = $, sa = class {
        constructor(t10, e10, i10, s10, o10) {
          this.isNew = true, this.isNewLabel = true, this.axis = t10, this.pos = e10, this.type = i10 || "", this.parameters = o10 || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, st(this, "init"), i10 || s10 || this.addLabel();
        }
        addLabel() {
          let t10 = this, e10 = t10.axis, i10 = e10.options, s10 = e10.chart, o10 = e10.categories, r10 = e10.logarithmic, a10 = e10.names, n10 = t10.pos, h10 = sr(t10.options && t10.options.labels, i10.labels), l2 = e10.tickPositions, d2 = n10 === l2[0], c2 = n10 === l2[l2.length - 1], p2 = (!h10.step || 1 === h10.step) && 1 === e10.tickInterval, g2 = l2.info, u2 = t10.label, f2, m2, x2, y2 = this.parameters.category || (o10 ? sr(o10[n10], a10[n10], n10) : n10);
          r10 && si(y2) && (y2 = i9(r10.lin2log(y2))), e10.dateTime && (g2 ? f2 = (m2 = s10.time.resolveDTLFormat(i10.dateTimeLabelFormats[!i10.grid && g2.higherRanks[n10] || g2.unitName])).main : si(y2) && (f2 = e10.dateTime.getXDateFormat(y2, i10.dateTimeLabelFormats || {}))), t10.isFirst = d2, t10.isLast = c2;
          let b2 = {
            axis: e10,
            chart: s10,
            dateTimeLabelFormat: f2,
            isFirst: d2,
            isLast: c2,
            pos: n10,
            tick: t10,
            tickPositionInfo: g2,
            value: y2
          };
          st(this, "labelFormat", b2);
          let v2 = (t11) => h10.formatter ? h10.formatter.call(t11, t11) : h10.format ? (t11.text = e10.defaultLabelFormatter.call(t11), eo.format(h10.format, t11, s10)) : e10.defaultLabelFormatter.call(t11), k2 = v2.call(b2, b2), w2 = m2 && m2.list;
          w2 ? t10.shortenLabel = function() {
            for (x2 = 0; x2 < w2.length; x2++) if (i7(b2, {
              dateTimeLabelFormat: w2[x2]
            }), u2.attr({
              text: v2.call(b2, b2)
            }), u2.getBBox().width < e10.getSlotWidth(t10) - 2 * (h10.padding || 0)) return;
            u2.attr({
              text: ""
            });
          } : t10.shortenLabel = void 0, p2 && e10._addedPlotLB && t10.moveLabel(k2, h10), i4(u2) || t10.movedLabel ? u2 && u2.textStr !== k2 && !p2 && (!u2.textWidth || h10.style.width || u2.styles.width || u2.css({
            width: null
          }), u2.attr({
            text: k2
          }), u2.textPxLength = u2.getBBox().width) : (t10.label = u2 = t10.createLabel(k2, h10), t10.rotation = 0);
        }
        createLabel(t10, e10, i10) {
          let s10 = this.axis, {
            renderer: o10,
            styledMode: r10
          } = s10.chart, a10 = i4(t10) && e10.enabled ? o10.text(t10, i10?.x, i10?.y, e10.useHTML).add(s10.labelGroup) : void 0;
          if (a10) {
            let t11 = e10.style.whiteSpace || "normal";
            r10 || a10.css(ss(e10.style, {
              whiteSpace: "nowrap"
            })), a10.textPxLength = a10.getBBox().width, r10 || a10.css({
              whiteSpace: t11
            });
          }
          return a10;
        }
        destroy() {
          i8(this, this.axis);
        }
        getPosition(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart, a10 = s10 && r10.oldChartHeight || r10.chartHeight, n10 = {
            x: t10 ? i9(o10.translate(e10 + i10, void 0, void 0, s10) + o10.transB) : o10.left + o10.offset + (o10.opposite ? (s10 && r10.oldChartWidth || r10.chartWidth) - o10.right - o10.left : 0),
            y: t10 ? a10 - o10.bottom + o10.offset - (o10.opposite ? o10.height : 0) : i9(a10 - o10.translate(e10 + i10, void 0, void 0, s10) - o10.transB)
          };
          return n10.y = i6(n10.y, -1e9, 1e9), st(this, "afterGetPosition", {
            pos: n10
          }), n10;
        }
        getLabelPosition(t10, e10, i10, s10, o10, r10, a10, n10) {
          let h10, l2;
          let d2 = this.axis, c2 = d2.transA, p2 = d2.isLinked && d2.linkedParent ? d2.linkedParent.reversed : d2.reversed, g2 = d2.staggerLines, u2 = d2.tickRotCorr || {
            x: 0,
            y: 0
          }, f2 = s10 || d2.reserveSpaceDefault ? 0 : -d2.labelOffset * ("center" === d2.labelAlign ? 0.5 : 1), m2 = o10.distance, x2 = {};
          return h10 = 0 === d2.side ? i10.rotation ? -m2 : -i10.getBBox().height : 2 === d2.side ? u2.y + m2 : Math.cos(i10.rotation * i5) * (u2.y - i10.getBBox(false, 0).height / 2), i4(o10.y) && (h10 = 0 === d2.side && d2.horiz ? o10.y + h10 : o10.y), t10 = t10 + sr(o10.x, [0, 1, 0, -1][d2.side] * m2) + f2 + u2.x - (r10 && s10 ? r10 * c2 * (p2 ? -1 : 1) : 0), e10 = e10 + h10 - (r10 && !s10 ? r10 * c2 * (p2 ? 1 : -1) : 0), g2 && (l2 = a10 / (n10 || 1) % g2, d2.opposite && (l2 = g2 - l2 - 1), e10 += l2 * (d2.labelOffset / g2)), x2.x = t10, x2.y = Math.round(e10), st(this, "afterGetLabelPosition", {
            pos: x2,
            tickmarkOffset: r10,
            index: a10
          }), x2;
        }
        getLabelSize() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        }
        getMarkPath(t10, e10, i10, s10, o10 = false, r10) {
          return r10.crispLine([["M", t10, e10], ["L", t10 + (o10 ? 0 : -i10), e10 + (o10 ? i10 : 0)]], s10);
        }
        handleOverflow(t10) {
          let e10 = this.axis, i10 = e10.options.labels, s10 = t10.x, o10 = e10.chart.chartWidth, r10 = e10.chart.spacing, a10 = sr(e10.labelLeft, Math.min(e10.pos, r10[3])), n10 = sr(e10.labelRight, Math.max(e10.isRadial ? 0 : e10.pos + e10.len, o10 - r10[1])), h10 = this.label, l2 = this.rotation, d2 = se(e10.labelAlign || h10.attr("align")), c2 = h10.getBBox().width, p2 = e10.getSlotWidth(this), g2 = p2, u2 = 1, f2, m2, x2;
          l2 || "justify" !== i10.overflow ? l2 < 0 && s10 - d2 * c2 < a10 ? x2 = Math.round(s10 / Math.cos(l2 * i5) - a10) : l2 > 0 && s10 + d2 * c2 > n10 && (x2 = Math.round((o10 - s10) / Math.cos(l2 * i5))) : (f2 = s10 - d2 * c2, m2 = s10 + (1 - d2) * c2, f2 < a10 ? g2 = t10.x + g2 * (1 - d2) - a10 : m2 > n10 && (g2 = n10 - t10.x + g2 * d2, u2 = -1), (g2 = Math.min(p2, g2)) < p2 && "center" === e10.labelAlign && (t10.x += u2 * (p2 - g2 - d2 * (p2 - Math.min(c2, g2)))), (c2 > g2 || e10.autoRotation && (h10.styles || {}).width) && (x2 = g2)), x2 && h10 && (this.shortenLabel ? this.shortenLabel() : h10.css(i7({}, {
            width: Math.floor(x2) + "px",
            lineClamp: e10.isRadial ? 0 : 1
          })));
        }
        moveLabel(t10, e10) {
          let i10 = this, s10 = i10.label, o10 = i10.axis, r10 = false, a10;
          s10 && s10.textStr === t10 ? (i10.movedLabel = s10, r10 = true, delete i10.label) : so(o10.ticks, function(e11) {
            r10 || e11.isNew || e11 === i10 || !e11.label || e11.label.textStr !== t10 || (i10.movedLabel = e11.label, r10 = true, e11.labelPos = i10.movedLabel.xy, delete e11.label);
          }), !r10 && (i10.labelPos || s10) && (a10 = i10.labelPos || s10.xy, i10.movedLabel = i10.createLabel(t10, e10, a10), i10.movedLabel && i10.movedLabel.attr({
            opacity: 0
          }));
        }
        render(t10, e10, i10) {
          let s10 = this.axis, o10 = s10.horiz, r10 = this.pos, a10 = sr(this.tickmarkOffset, s10.tickmarkOffset), n10 = this.getPosition(o10, r10, a10, e10), h10 = n10.x, l2 = n10.y, d2 = s10.pos, c2 = d2 + s10.len, p2 = o10 ? h10 : l2;
          !s10.chart.polar && this.isNew && (i9(p2) < d2 || p2 > c2) && (i10 = 0);
          let g2 = sr(i10, this.label && this.label.newOpacity, 1);
          i10 = sr(i10, 1), this.isActive = true, this.renderGridLine(e10, i10), this.renderMark(n10, i10), this.renderLabel(n10, e10, g2, t10), this.isNew = false, st(this, "afterRender");
        }
        renderGridLine(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = {}, r10 = this.pos, a10 = this.type, n10 = sr(this.tickmarkOffset, i10.tickmarkOffset), h10 = i10.chart.renderer, l2 = this.gridLine, d2, c2 = s10.gridLineWidth, p2 = s10.gridLineColor, g2 = s10.gridLineDashStyle;
          "minor" === this.type && (c2 = s10.minorGridLineWidth, p2 = s10.minorGridLineColor, g2 = s10.minorGridLineDashStyle), l2 || (i10.chart.styledMode || (o10.stroke = p2, o10["stroke-width"] = c2 || 0, o10.dashstyle = g2), a10 || (o10.zIndex = 1), t10 && (e10 = 0), this.gridLine = l2 = h10.path().attr(o10).addClass("highcharts-" + (a10 ? a10 + "-" : "") + "grid-line").add(i10.gridGroup)), l2 && (d2 = i10.getPlotLinePath({
            value: r10 + n10,
            lineWidth: l2.strokeWidth(),
            force: "pass",
            old: t10,
            acrossPanes: false
          })) && l2[t10 || this.isNew ? "attr" : "animate"]({
            d: d2,
            opacity: e10
          });
        }
        renderMark(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = i10.chart.renderer, r10 = this.type, a10 = i10.tickSize(r10 ? r10 + "Tick" : "tick"), n10 = t10.x, h10 = t10.y, l2 = sr(s10["minor" !== r10 ? "tickWidth" : "minorTickWidth"], !r10 && i10.isXAxis ? 1 : 0), d2 = s10["minor" !== r10 ? "tickColor" : "minorTickColor"], c2 = this.mark, p2 = !c2;
          a10 && (i10.opposite && (a10[0] = -a10[0]), c2 || (this.mark = c2 = o10.path().addClass("highcharts-" + (r10 ? r10 + "-" : "") + "tick").add(i10.axisGroup), i10.chart.styledMode || c2.attr({
            stroke: d2,
            "stroke-width": l2
          })), c2[p2 ? "attr" : "animate"]({
            d: this.getMarkPath(n10, h10, a10[0], c2.strokeWidth(), i10.horiz, o10),
            opacity: e10
          }));
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.horiz, a10 = o10.options, n10 = this.label, h10 = a10.labels, l2 = h10.step, d2 = sr(this.tickmarkOffset, o10.tickmarkOffset), c2 = t10.x, p2 = t10.y, g2 = true;
          n10 && si(c2) && (n10.xy = t10 = this.getLabelPosition(c2, p2, n10, r10, h10, d2, s10, l2), (!this.isFirst || this.isLast || a10.showFirstLabel) && (!this.isLast || this.isFirst || a10.showLastLabel) ? !r10 || h10.step || h10.rotation || e10 || 0 === i10 || this.handleOverflow(t10) : g2 = false, l2 && s10 % l2 && (g2 = false), g2 && si(t10.y) ? (t10.opacity = i10, n10[this.isNewLabel ? "attr" : "animate"](t10).show(true), this.isNewLabel = false) : (n10.hide(), this.isNewLabel = true));
        }
        replaceMovedLabel() {
          let t10 = this.label, e10 = this.axis;
          t10 && !this.isNew && (t10.animate({
            opacity: 0
          }, void 0, t10.destroy), delete this.label), e10.isDirty = true, this.label = this.movedLabel, delete this.movedLabel;
        }
      }, {
        animObject: sn
      } = tR, {
        xAxis: sh,
        yAxis: sl
      } = iJ, {
        defaultOptions: sd
      } = tm, {
        registerEventOptions: sc
      } = i3, {
        deg2rad: sp
      } = k, {
        arrayMax: sg,
        arrayMin: su,
        clamp: sf,
        correctFloat: sm,
        defined: sx,
        destroyObjectProperties: sy,
        erase: sb,
        error: sv,
        extend: sk,
        fireEvent: sw,
        getClosestDistance: sM,
        insertItem: sS,
        isArray: sT,
        isNumber: sC,
        isString: sA,
        merge: sP,
        normalizeTickInterval: sL,
        objectEach: sO,
        pick: sE,
        relativeLength: sI,
        removeEvent: sD,
        splat: sB,
        syncTimeout: sN
      } = $, sz = (t10, e10) => sL(e10, void 0, void 0, sE(t10.options.allowDecimals, e10 < 0.5 || void 0 !== t10.tickAmount), !!t10.tickAmount);
      sk(sd, {
        xAxis: sh,
        yAxis: sP(sh, sl)
      });
      class sR {
        constructor(t10, e10, i10) {
          this.init(t10, e10, i10);
        }
        init(t10, e10, i10 = this.coll) {
          let s10 = "xAxis" === i10, o10 = this.isZAxis || (t10.inverted ? !s10 : s10);
          this.chart = t10, this.horiz = o10, this.isXAxis = s10, this.coll = i10, sw(this, "init", {
            userOptions: e10
          }), this.opposite = sE(e10.opposite, this.opposite), this.side = sE(e10.side, this.side, o10 ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e10);
          let r10 = this.options, a10 = r10.labels;
          this.type ?? (this.type = r10.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r10.uniqueNames ?? true), sw(this, "afterSetType"), this.userOptions = e10, this.minPixelPadding = 0, this.reversed = sE(r10.reversed, this.reversed), this.visible = r10.visible, this.zoomEnabled = r10.zoomEnabled, this.hasNames = "category" === this.type || true === r10.categories, this.categories = sT(r10.categories) && r10.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = sx(r10.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r10.minRange || r10.maxZoom, this.range = r10.range, this.offset = r10.offset || 0, this.max = void 0, this.min = void 0;
          let n10 = sE(r10.crosshair, sB(t10.options.tooltip.crosshairs)[s10 ? 0 : 1]);
          this.crosshair = true === n10 ? {} : n10, -1 === t10.axes.indexOf(this) && (s10 ? t10.axes.splice(t10.xAxis.length, 0, this) : t10.axes.push(this), sS(this, t10[this.coll])), t10.orderItems(this.coll), this.series = this.series || [], t10.inverted && !this.isZAxis && s10 && !sx(this.reversed) && (this.reversed = true), this.labelRotation = sC(a10.rotation) ? a10.rotation : void 0, sc(this, r10), sw(this, "afterInit");
        }
        setOptions(t10) {
          let e10 = this.horiz ? {
            labels: {
              autoRotation: [-45],
              padding: 3
            },
            margin: 15
          } : {
            labels: {
              padding: 1
            },
            title: {
              rotation: 90 * this.side
            }
          };
          this.options = sP(e10, sd[this.coll], t10), sw(this, "afterSetOptions", {
            userOptions: t10
          });
        }
        defaultLabelFormatter() {
          let t10 = this.axis, {
            numberFormatter: e10
          } = this.chart, i10 = sC(this.value) ? this.value : NaN, s10 = t10.chart.time, o10 = t10.categories, r10 = this.dateTimeLabelFormat, a10 = sd.lang, n10 = a10.numericSymbols, h10 = a10.numericSymbolMagnitude || 1e3, l2 = t10.logarithmic ? Math.abs(i10) : t10.tickInterval, d2 = n10 && n10.length, c2, p2;
          if (o10) p2 = `${this.value}`;
          else if (r10) p2 = s10.dateFormat(r10, i10, true);
          else if (d2 && n10 && l2 >= 1e3) for (; d2-- && void 0 === p2; ) l2 >= (c2 = Math.pow(h10, d2 + 1)) && 10 * i10 % c2 == 0 && null !== n10[d2] && 0 !== i10 && (p2 = e10(i10 / c2, -1) + n10[d2]);
          return void 0 === p2 && (p2 = Math.abs(i10) >= 1e4 ? e10(i10, -1) : e10(i10, -1, void 0, "")), p2;
        }
        getSeriesExtremes() {
          let t10;
          let e10 = this;
          sw(this, "getSeriesExtremes", null, function() {
            e10.hasVisibleSeries = false, e10.dataMin = e10.dataMax = e10.threshold = void 0, e10.softThreshold = !e10.isXAxis, e10.series.forEach((i10) => {
              if (i10.reserveSpace()) {
                let s10 = i10.options, o10, r10 = s10.threshold, a10, n10;
                if (e10.hasVisibleSeries = true, e10.positiveValuesOnly && 0 >= (r10 || 0) && (r10 = void 0), e10.isXAxis) (o10 = i10.getColumn("x")).length && (o10 = e10.logarithmic ? o10.filter((t11) => t11 > 0) : o10, a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max, sC(a10) || a10 instanceof Date || (o10 = o10.filter(sC), a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max), o10.length && (e10.dataMin = Math.min(sE(e10.dataMin, a10), a10), e10.dataMax = Math.max(sE(e10.dataMax, n10), n10)));
                else {
                  let t11 = i10.applyExtremes();
                  sC(t11.dataMin) && (a10 = t11.dataMin, e10.dataMin = Math.min(sE(e10.dataMin, a10), a10)), sC(t11.dataMax) && (n10 = t11.dataMax, e10.dataMax = Math.max(sE(e10.dataMax, n10), n10)), sx(r10) && (e10.threshold = r10), (!s10.softThreshold || e10.positiveValuesOnly) && (e10.softThreshold = false);
                }
              }
            });
          }), sw(this, "afterGetSeriesExtremes");
        }
        translate(t10, e10, i10, s10, o10, r10) {
          let a10 = this.linkedParent || this, n10 = s10 && a10.old ? a10.old.min : a10.min;
          if (!sC(n10)) return NaN;
          let h10 = a10.minPixelPadding, l2 = (a10.isOrdinal || a10.brokenAxis?.hasBreaks || a10.logarithmic && o10) && a10.lin2val, d2 = 1, c2 = 0, p2 = s10 && a10.old ? a10.old.transA : a10.transA, g2 = 0;
          return p2 || (p2 = a10.transA), i10 && (d2 *= -1, c2 = a10.len), a10.reversed && (d2 *= -1, c2 -= d2 * (a10.sector || a10.len)), e10 ? (g2 = (t10 = t10 * d2 + c2 - h10) / p2 + n10, l2 && (g2 = a10.lin2val(g2))) : (l2 && (t10 = a10.val2lin(t10)), g2 = d2 * (t10 - n10) * p2 + c2 + d2 * h10 + (sC(r10) ? p2 * r10 : 0), a10.isRadial || (g2 = sm(g2))), g2;
        }
        toPixels(t10, e10) {
          return this.translate(this.chart?.time.parse(t10) ?? NaN, false, !this.horiz, void 0, true) + (e10 ? 0 : this.pos);
        }
        toValue(t10, e10) {
          return this.translate(t10 - (e10 ? 0 : this.pos), true, !this.horiz, void 0, true);
        }
        getPlotLinePath(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.left, o10 = e10.top, r10 = t10.old, a10 = t10.value, n10 = t10.lineWidth, h10 = r10 && i10.oldChartHeight || i10.chartHeight, l2 = r10 && i10.oldChartWidth || i10.chartWidth, d2 = e10.transB, c2 = t10.translatedValue, p2 = t10.force, g2, u2, f2, m2, x2;
          function y2(t11, e11, i11) {
            return "pass" !== p2 && (t11 < e11 || t11 > i11) && (p2 ? t11 = sf(t11, e11, i11) : x2 = true), t11;
          }
          let b2 = {
            value: a10,
            lineWidth: n10,
            old: r10,
            force: p2,
            acrossPanes: t10.acrossPanes,
            translatedValue: c2
          };
          return sw(this, "getPlotLinePath", b2, function(t11) {
            g2 = f2 = (c2 = sf(c2 = sE(c2, e10.translate(a10, void 0, void 0, r10)), -1e9, 1e9)) + d2, u2 = m2 = h10 - c2 - d2, sC(c2) ? e10.horiz ? (u2 = o10, m2 = h10 - e10.bottom + (e10.options.isInternal ? 0 : i10.scrollablePixelsY || 0), g2 = f2 = y2(g2, s10, s10 + e10.width)) : (g2 = s10, f2 = l2 - e10.right + (i10.scrollablePixelsX || 0), u2 = m2 = y2(u2, o10, o10 + e10.height)) : (x2 = true, p2 = false), t11.path = x2 && !p2 ? void 0 : i10.renderer.crispLine([["M", g2, u2], ["L", f2, m2]], n10 || 1);
          }), b2.path;
        }
        getLinearTickPositions(t10, e10, i10) {
          let s10, o10, r10;
          let a10 = sm(Math.floor(e10 / t10) * t10), n10 = sm(Math.ceil(i10 / t10) * t10), h10 = [];
          if (sm(a10 + t10) === a10 && (r10 = 20), this.single) return [e10];
          for (s10 = a10; s10 <= n10 && (h10.push(s10), (s10 = sm(s10 + t10, r10)) !== o10); ) o10 = s10;
          return h10;
        }
        getMinorTickInterval() {
          let {
            minorTicks: t10,
            minorTickInterval: e10
          } = this.options;
          return true === t10 ? sE(e10, "auto") : false !== t10 ? e10 : void 0;
        }
        getMinorTickPositions() {
          let t10 = this.options, e10 = this.tickPositions, i10 = this.minorTickInterval, s10 = this.pointRangePadding || 0, o10 = (this.min || 0) - s10, r10 = (this.max || 0) + s10, a10 = this.brokenAxis?.hasBreaks ? this.brokenAxis.unitLength : r10 - o10, n10 = [], h10;
          if (a10 && a10 / i10 < this.len / 3) {
            let s11 = this.logarithmic;
            if (s11) this.paddedTicks.forEach(function(t11, e11, o11) {
              e11 && n10.push.apply(n10, s11.getLogTickPositions(i10, o11[e11 - 1], o11[e11], true));
            });
            else if (this.dateTime && "auto" === this.getMinorTickInterval()) n10 = n10.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i10), o10, r10, t10.startOfWeek));
            else for (h10 = o10 + (e10[0] - o10) % i10; h10 <= r10 && h10 !== n10[0]; h10 += i10) n10.push(h10);
          }
          return 0 !== n10.length && this.trimTicks(n10), n10;
        }
        adjustForMinRange() {
          let t10 = this.options, e10 = this.logarithmic, i10 = this.chart.time, {
            max: s10,
            min: o10,
            minRange: r10
          } = this, a10, n10, h10, l2;
          this.isXAxis && void 0 === r10 && !e10 && (r10 = sx(t10.min) || sx(t10.max) || sx(t10.floor) || sx(t10.ceiling) ? null : Math.min(5 * (sM(this.series.map((t11) => {
            let e11 = t11.getColumn("x");
            return t11.xIncrement ? e11.slice(0, 2) : e11;
          })) || 0), this.dataMax - this.dataMin)), sC(s10) && sC(o10) && sC(r10) && s10 - o10 < r10 && (n10 = this.dataMax - this.dataMin >= r10, a10 = (r10 - s10 + o10) / 2, h10 = [o10 - a10, i10.parse(t10.min) ?? o10 - a10], n10 && (h10[2] = e10 ? e10.log2lin(this.dataMin) : this.dataMin), l2 = [(o10 = sg(h10)) + r10, i10.parse(t10.max) ?? o10 + r10], n10 && (l2[2] = e10 ? e10.log2lin(this.dataMax) : this.dataMax), (s10 = su(l2)) - o10 < r10 && (h10[0] = s10 - r10, h10[1] = i10.parse(t10.min) ?? s10 - r10, o10 = sg(h10))), this.minRange = r10, this.min = o10, this.max = s10;
        }
        getClosest() {
          let t10, e10;
          if (this.categories) e10 = 1;
          else {
            let i10 = [];
            this.series.forEach(function(t11) {
              let s10 = t11.closestPointRange, o10 = t11.getColumn("x");
              1 === o10.length ? i10.push(o10[0]) : t11.sorted && sx(s10) && t11.reserveSpace() && (e10 = sx(e10) ? Math.min(e10, s10) : s10);
            }), i10.length && (i10.sort((t11, e11) => t11 - e11), t10 = sM([i10]));
          }
          return t10 && e10 ? Math.min(t10, e10) : t10 || e10;
        }
        nameToX(t10) {
          let e10 = sT(this.options.categories), i10 = e10 ? this.categories : this.names, s10 = t10.options.x, o10;
          return t10.series.requireSorting = false, sx(s10) || (s10 = this.uniqueNames && i10 ? e10 ? i10.indexOf(t10.name) : sE(i10.keys[t10.name], -1) : t10.series.autoIncrement()), -1 === s10 ? !e10 && i10 && (o10 = i10.length) : sC(s10) && (o10 = s10), void 0 !== o10 ? (this.names[o10] = t10.name, this.names.keys[t10.name] = o10) : t10.x && (o10 = t10.x), o10;
        }
        updateNames() {
          let t10 = this, e10 = this.names;
          e10.length > 0 && (Object.keys(e10.keys).forEach(function(t11) {
            delete e10.keys[t11];
          }), e10.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e11) => {
            e11.xIncrement = null, (!e11.points || e11.isDirtyData) && (t10.max = Math.max(t10.max || 0, e11.dataTable.rowCount - 1), e11.processData(), e11.generatePoints());
            let i10 = e11.getColumn("x").slice();
            e11.data.forEach((e12, s10) => {
              let o10 = i10[s10];
              e12?.options && void 0 !== e12.name && void 0 !== (o10 = t10.nameToX(e12)) && o10 !== e12.x && (i10[s10] = e12.x = o10);
            }), e11.dataTable.setColumn("x", i10);
          }));
        }
        setAxisTranslation() {
          let t10 = this, e10 = t10.max - t10.min, i10 = t10.linkedParent, s10 = !!t10.categories, o10 = t10.isXAxis, r10 = t10.axisPointRange || 0, a10, n10 = 0, h10 = 0, l2, d2 = t10.transA;
          (o10 || s10 || r10) && (a10 = t10.getClosest(), i10 ? (n10 = i10.minPointOffset, h10 = i10.pointRangePadding) : t10.series.forEach(function(e11) {
            let i11 = s10 ? 1 : o10 ? sE(e11.options.pointRange, a10, 0) : t10.axisPointRange || 0, l3 = e11.options.pointPlacement;
            if (r10 = Math.max(r10, i11), !t10.single || s10) {
              let t11 = e11.is("xrange") ? !o10 : o10;
              n10 = Math.max(n10, t11 && sA(l3) ? 0 : i11 / 2), h10 = Math.max(h10, t11 && "on" === l3 ? 0 : i11);
            }
          }), l2 = t10.ordinal && t10.ordinal.slope && a10 ? t10.ordinal.slope / a10 : 1, t10.minPointOffset = n10 *= l2, t10.pointRangePadding = h10 *= l2, t10.pointRange = Math.min(r10, t10.single && s10 ? 1 : e10), o10 && a10 && (t10.closestPointRange = a10)), t10.translationSlope = t10.transA = d2 = t10.staticScale || t10.len / (e10 + h10 || 1), t10.transB = t10.horiz ? t10.left : t10.bottom, t10.minPixelPadding = d2 * n10, sw(this, "afterSetAxisTranslation");
        }
        minFromRange() {
          let {
            max: t10,
            min: e10
          } = this;
          return sC(t10) && sC(e10) && t10 - e10 || void 0;
        }
        setTickInterval(t10) {
          let {
            categories: e10,
            chart: i10,
            dataMax: s10,
            dataMin: o10,
            dateTime: r10,
            isXAxis: a10,
            logarithmic: n10,
            options: h10,
            softThreshold: l2
          } = this, d2 = i10.time, c2 = sC(this.threshold) ? this.threshold : void 0, p2 = this.minRange || 0, {
            ceiling: g2,
            floor: u2,
            linkedTo: f2,
            softMax: m2,
            softMin: x2
          } = h10, y2 = sC(f2) && i10[this.coll]?.[f2], b2 = h10.tickPixelInterval, v2 = h10.maxPadding, k2 = h10.minPadding, w2 = 0, M2, S2 = sC(h10.tickInterval) && h10.tickInterval >= 0 ? h10.tickInterval : void 0, T2, C2, A2, P2;
          if (r10 || e10 || y2 || this.getTickAmount(), A2 = sE(this.userMin, d2.parse(h10.min)), P2 = sE(this.userMax, d2.parse(h10.max)), y2 ? (this.linkedParent = y2, M2 = y2.getExtremes(), this.min = sE(M2.min, M2.dataMin), this.max = sE(M2.max, M2.dataMax), this.type !== y2.type && sv(11, true, i10)) : (l2 && sx(c2) && sC(s10) && sC(o10) && (o10 >= c2 ? (T2 = c2, k2 = 0) : s10 <= c2 && (C2 = c2, v2 = 0)), this.min = sE(A2, T2, o10), this.max = sE(P2, C2, s10)), sC(this.max) && sC(this.min) && (n10 && (this.positiveValuesOnly && !t10 && 0 >= Math.min(this.min, sE(o10, this.min)) && sv(10, true, i10), this.min = sm(n10.log2lin(this.min), 16), this.max = sm(n10.log2lin(this.max), 16)), this.range && sC(o10) && (this.userMin = this.min = A2 = Math.max(o10, this.minFromRange() || 0), this.userMax = P2 = this.max, this.range = void 0)), sw(this, "foundExtremes"), this.adjustForMinRange(), sC(this.min) && sC(this.max)) {
            if (!sC(this.userMin) && sC(x2) && x2 < this.min && (this.min = A2 = x2), !sC(this.userMax) && sC(m2) && m2 > this.max && (this.max = P2 = m2), e10 || this.axisPointRange || this.stacking?.usePercentage || y2 || !(w2 = this.max - this.min) || (!sx(A2) && k2 && (this.min -= w2 * k2), sx(P2) || !v2 || (this.max += w2 * v2)), !sC(this.userMin) && sC(u2) && (this.min = Math.max(this.min, u2)), !sC(this.userMax) && sC(g2) && (this.max = Math.min(this.max, g2)), l2 && sC(o10) && sC(s10)) {
              let t11 = c2 || 0;
              !sx(A2) && this.min < t11 && o10 >= t11 ? this.min = h10.minRange ? Math.min(t11, this.max - p2) : t11 : !sx(P2) && this.max > t11 && s10 <= t11 && (this.max = h10.minRange ? Math.max(t11, this.min + p2) : t11);
            }
            !i10.polar && this.min > this.max && (sx(h10.min) ? this.max = this.min : sx(h10.max) && (this.min = this.max)), w2 = this.max - this.min;
          }
          if (this.min !== this.max && sC(this.min) && sC(this.max) ? y2 && !S2 && b2 === y2.options.tickPixelInterval ? this.tickInterval = S2 = y2.tickInterval : this.tickInterval = sE(S2, this.tickAmount ? w2 / Math.max(this.tickAmount - 1, 1) : void 0, e10 ? 1 : w2 * b2 / Math.max(this.len, b2)) : this.tickInterval = 1, a10 && !t10) {
            let t11 = this.min !== this.old?.min || this.max !== this.old?.max;
            this.series.forEach(function(e11) {
              e11.forceCrop = e11.forceCropping?.(), e11.processData(t11);
            }), sw(this, "postProcessData", {
              hasExtremesChanged: t11
            });
          }
          this.setAxisTranslation(), sw(this, "initialAxisTranslation"), this.pointRange && !S2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
          let L2 = sE(h10.minTickInterval, r10 && !this.series.some((t11) => !t11.sorted) ? this.closestPointRange : 0);
          !S2 && this.tickInterval < L2 && (this.tickInterval = L2), r10 || n10 || S2 || (this.tickInterval = sz(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
        }
        setTickPositions() {
          let t10 = this.options, e10 = t10.tickPositions, i10 = t10.tickPositioner, s10 = this.getMinorTickInterval(), o10 = !this.isPanning, r10 = o10 && t10.startOnTick, a10 = o10 && t10.endOnTick, n10 = [], h10;
          if (this.tickmarkOffset = this.categories && "between" === t10.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0, this.single = this.min === this.max && sx(this.min) && !this.tickAmount && (this.min % 1 == 0 || false !== t10.allowDecimals), e10) n10 = e10.slice();
          else if (sC(this.min) && sC(this.max)) {
            if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) n10 = [this.min, this.max], sv(19, false, this.chart);
            else if (this.dateTime) n10 = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t10.units), this.min, this.max, t10.startOfWeek, this.ordinal?.positions, this.closestPointRange, true);
            else if (this.logarithmic) n10 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
            else {
              let t11 = this.tickInterval, e11 = t11;
              for (; e11 <= 2 * t11; ) if (n10 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && n10.length > this.tickAmount) this.tickInterval = sz(this, e11 *= 1.1);
              else break;
            }
            n10.length > this.len && (n10 = [n10[0], n10[n10.length - 1]])[0] === n10[1] && (n10.length = 1), i10 && (this.tickPositions = n10, (h10 = i10.apply(this, [this.min, this.max])) && (n10 = h10));
          }
          this.tickPositions = n10, this.minorTickInterval = "auto" === s10 && this.tickInterval ? this.tickInterval / t10.minorTicksPerMajor : s10, this.paddedTicks = n10.slice(0), this.trimTicks(n10, r10, a10), !this.isLinked && sC(this.min) && sC(this.max) && (this.single && n10.length < 2 && !this.categories && !this.series.some((t11) => t11.is("heatmap") && "between" === t11.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), e10 || h10 || this.adjustTickAmount()), sw(this, "afterSetTickPositions");
        }
        trimTicks(t10, e10, i10) {
          let s10 = t10[0], o10 = t10[t10.length - 1], r10 = !this.isOrdinal && this.minPointOffset || 0;
          if (sw(this, "trimTicks"), !this.isLinked) {
            if (e10 && s10 !== -1 / 0) this.min = s10;
            else for (; this.min - r10 > t10[0]; ) t10.shift();
            if (i10) this.max = o10;
            else for (; this.max + r10 < t10[t10.length - 1]; ) t10.pop();
            0 === t10.length && sx(s10) && !this.options.tickPositions && t10.push((o10 + s10) / 2);
          }
        }
        alignToOthers() {
          let t10;
          let e10 = this, i10 = e10.chart, s10 = [this], o10 = e10.options, r10 = i10.options.chart, a10 = "yAxis" === this.coll && r10.alignThresholds, n10 = [];
          if (e10.thresholdAlignment = void 0, (false !== r10.alignTicks && o10.alignTicks || a10) && false !== o10.startOnTick && false !== o10.endOnTick && !e10.logarithmic) {
            let o11 = (t11) => {
              let {
                horiz: e11,
                options: i11
              } = t11;
              return [e11 ? i11.left : i11.top, i11.width, i11.height, i11.pane].join(",");
            }, r11 = o11(this);
            i10[this.coll].forEach(function(i11) {
              let {
                series: a11
              } = i11;
              a11.length && a11.some((t11) => t11.visible) && i11 !== e10 && o11(i11) === r11 && (t10 = true, s10.push(i11));
            });
          }
          if (t10 && a10) {
            s10.forEach((t12) => {
              let i11 = t12.getThresholdAlignment(e10);
              sC(i11) && n10.push(i11);
            });
            let t11 = n10.length > 1 ? n10.reduce((t12, e11) => t12 += e11, 0) / n10.length : void 0;
            s10.forEach((e11) => {
              e11.thresholdAlignment = t11;
            });
          }
          return t10;
        }
        getThresholdAlignment(t10) {
          if ((!sC(this.dataMin) || this !== t10 && this.series.some((t11) => t11.isDirty || t11.isDirtyData)) && this.getSeriesExtremes(), sC(this.threshold)) {
            let t11 = sf((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
            return this.options.reversed && (t11 = 1 - t11), t11;
          }
        }
        getTickAmount() {
          let t10 = this.options, e10 = t10.tickPixelInterval, i10 = t10.tickAmount;
          sx(t10.tickInterval) || i10 || !(this.len < e10) || this.isRadial || this.logarithmic || !t10.startOnTick || !t10.endOnTick || (i10 = 2), !i10 && this.alignToOthers() && (i10 = Math.ceil(this.len / e10) + 1), i10 < 4 && (this.finalTickAmt = i10, i10 = 5), this.tickAmount = i10;
        }
        adjustTickAmount() {
          let t10 = this, {
            finalTickAmt: e10,
            max: i10,
            min: s10,
            options: o10,
            tickPositions: r10,
            tickAmount: a10,
            thresholdAlignment: n10
          } = t10, h10 = r10?.length, l2 = sE(t10.threshold, t10.softThreshold ? 0 : null), d2, c2, p2 = t10.tickInterval, g2, u2 = () => r10.push(sm(r10[r10.length - 1] + p2)), f2 = () => r10.unshift(sm(r10[0] - p2));
          if (sC(n10) && (g2 = n10 < 0.5 ? Math.ceil(n10 * (a10 - 1)) : Math.floor(n10 * (a10 - 1)), o10.reversed && (g2 = a10 - 1 - g2)), t10.hasData() && sC(s10) && sC(i10)) {
            let n11 = () => {
              t10.transA *= (h10 - 1) / (a10 - 1), t10.min = o10.startOnTick ? r10[0] : Math.min(s10, r10[0]), t10.max = o10.endOnTick ? r10[r10.length - 1] : Math.max(i10, r10[r10.length - 1]);
            };
            if (sC(g2) && sC(t10.threshold)) {
              for (; r10[g2] !== l2 || r10.length !== a10 || r10[0] > s10 || r10[r10.length - 1] < i10; ) {
                for (r10.length = 0, r10.push(t10.threshold); r10.length < a10; ) void 0 === r10[g2] || r10[g2] > t10.threshold ? f2() : u2();
                if (p2 > 8 * t10.tickInterval) break;
                p2 *= 2;
              }
              n11();
            } else if (h10 < a10) {
              for (; r10.length < a10; ) r10.length % 2 || s10 === l2 ? u2() : f2();
              n11();
            }
            if (sx(e10)) {
              for (c2 = d2 = r10.length; c2--; ) (3 === e10 && c2 % 2 == 1 || e10 <= 2 && c2 > 0 && c2 < d2 - 1) && r10.splice(c2, 1);
              t10.finalTickAmt = void 0;
            }
          }
        }
        setScale() {
          let {
            coll: t10,
            stacking: e10
          } = this, i10 = false, s10 = false;
          this.series.forEach((t11) => {
            i10 = i10 || t11.isDirtyData || t11.isDirty, s10 = s10 || t11.xAxis && t11.xAxis.isDirty || false;
          }), this.setAxisSize();
          let o10 = this.len !== (this.old && this.old.len);
          o10 || i10 || s10 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e10 && "yAxis" === t10 && e10.buildStacks(), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e10 && "xAxis" === t10 && e10.buildStacks(), this.isDirty || (this.isDirty = o10 || this.min !== this.old?.min || this.max !== this.old?.max)) : e10 && e10.cleanStacks(), i10 && delete this.allExtremes, sw(this, "afterSetScale");
        }
        setExtremes(t10, e10, i10 = true, s10, o10) {
          let r10 = this.chart;
          this.series.forEach((t11) => {
            delete t11.kdTree;
          }), t10 = r10.time.parse(t10), e10 = r10.time.parse(e10), sw(this, "setExtremes", o10 = sk(o10, {
            min: t10,
            max: e10
          }), (t11) => {
            this.userMin = t11.min, this.userMax = t11.max, this.eventArgs = t11, i10 && r10.redraw(s10);
          });
        }
        setAxisSize() {
          let t10 = this.chart, e10 = this.options, i10 = e10.offsets || [0, 0, 0, 0], s10 = this.horiz, o10 = this.width = Math.round(sI(sE(e10.width, t10.plotWidth - i10[3] + i10[1]), t10.plotWidth)), r10 = this.height = Math.round(sI(sE(e10.height, t10.plotHeight - i10[0] + i10[2]), t10.plotHeight)), a10 = this.top = Math.round(sI(sE(e10.top, t10.plotTop + i10[0]), t10.plotHeight, t10.plotTop)), n10 = this.left = Math.round(sI(sE(e10.left, t10.plotLeft + i10[3]), t10.plotWidth, t10.plotLeft));
          this.bottom = t10.chartHeight - r10 - a10, this.right = t10.chartWidth - o10 - n10, this.len = Math.max(s10 ? o10 : r10, 0), this.pos = s10 ? n10 : a10;
        }
        getExtremes() {
          let t10 = this.logarithmic;
          return {
            min: t10 ? sm(t10.lin2log(this.min)) : this.min,
            max: t10 ? sm(t10.lin2log(this.max)) : this.max,
            dataMin: this.dataMin,
            dataMax: this.dataMax,
            userMin: this.userMin,
            userMax: this.userMax
          };
        }
        getThreshold(t10) {
          let e10 = this.logarithmic, i10 = e10 ? e10.lin2log(this.min) : this.min, s10 = e10 ? e10.lin2log(this.max) : this.max;
          return null === t10 || t10 === -1 / 0 ? t10 = i10 : t10 === 1 / 0 ? t10 = s10 : i10 > t10 ? t10 = i10 : s10 < t10 && (t10 = s10), this.translate(t10, 0, 1, 0, 1);
        }
        autoLabelAlign(t10) {
          let e10 = (sE(t10, 0) - 90 * this.side + 720) % 360, i10 = {
            align: "center"
          };
          return sw(this, "autoLabelAlign", i10, function(t11) {
            e10 > 15 && e10 < 165 ? t11.align = "right" : e10 > 195 && e10 < 345 && (t11.align = "left");
          }), i10.align;
        }
        tickSize(t10) {
          let e10 = this.options, i10 = sE(e10["tick" === t10 ? "tickWidth" : "minorTickWidth"], "tick" === t10 && this.isXAxis && !this.categories ? 1 : 0), s10 = e10["tick" === t10 ? "tickLength" : "minorTickLength"], o10;
          i10 && s10 && ("inside" === e10[t10 + "Position"] && (s10 = -s10), o10 = [s10, i10]);
          let r10 = {
            tickSize: o10
          };
          return sw(this, "afterTickSize", r10), r10.tickSize;
        }
        labelMetrics() {
          let t10 = this.chart.renderer, e10 = this.ticks, i10 = e10[Object.keys(e10)[0]] || {};
          return this.chart.renderer.fontMetrics(i10.label || i10.movedLabel || t10.box);
        }
        unsquish() {
          let t10 = this.options.labels, e10 = t10.padding || 0, i10 = this.horiz, s10 = this.tickInterval, o10 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s10), r10 = t10.rotation, a10 = sm(0.8 * this.labelMetrics().h), n10 = Math.max(this.max - this.min, 0), h10 = function(t11) {
            let i11 = (t11 + 2 * e10) / (o10 || 1);
            return (i11 = i11 > 1 ? Math.ceil(i11) : 1) * s10 > n10 && t11 !== 1 / 0 && o10 !== 1 / 0 && n10 && (i11 = Math.ceil(n10 / s10)), sm(i11 * s10);
          }, l2 = s10, d2, c2 = Number.MAX_VALUE, p2;
          if (i10) {
            if (!t10.staggerLines && (sC(r10) ? p2 = [r10] : o10 < t10.autoRotationLimit && (p2 = t10.autoRotation)), p2) {
              let t11, e11;
              for (let i11 of p2) (i11 === r10 || i11 && i11 >= -90 && i11 <= 90) && (e11 = (t11 = h10(Math.abs(a10 / Math.sin(sp * i11)))) + Math.abs(i11 / 360)) < c2 && (c2 = e11, d2 = i11, l2 = t11);
            }
          } else l2 = h10(0.75 * a10);
          return this.autoRotation = p2, this.labelRotation = sE(d2, sC(r10) ? r10 : 0), t10.step ? s10 : l2;
        }
        getSlotWidth(t10) {
          let e10 = this.chart, i10 = this.horiz, s10 = this.options.labels, o10 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), r10 = e10.margin[3];
          if (t10 && sC(t10.slotWidth)) return t10.slotWidth;
          if (i10 && s10.step < 2 && !this.isRadial) return s10.rotation ? 0 : (this.staggerLines || 1) * this.len / o10;
          if (!i10) {
            let t11 = s10.style.width;
            if (void 0 !== t11) return parseInt(String(t11), 10);
            if (r10) return r10 - e10.spacing[3];
          }
          return 0.33 * e10.chartWidth;
        }
        renderUnsquish() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.tickPositions, s10 = this.ticks, o10 = this.options.labels, r10 = o10.style, a10 = this.horiz, n10 = this.getSlotWidth(), h10 = Math.max(1, Math.round(n10 - (a10 ? 2 * (o10.padding || 0) : o10.distance || 0))), l2 = {}, d2 = this.labelMetrics(), c2 = r10.lineClamp, p2, g2 = c2 ?? (Math.floor(this.len / (i10.length * d2.h)) || 1), u2 = 0;
          sA(o10.rotation) || (l2.rotation = o10.rotation || 0), i10.forEach(function(t11) {
            let e11 = s10[t11];
            e11.movedLabel && e11.replaceMovedLabel();
            let i11 = e11.label?.textPxLength || 0;
            i11 > u2 && (u2 = i11);
          }), this.maxLabelLength = u2, this.autoRotation ? u2 > h10 && u2 > d2.h ? l2.rotation = this.labelRotation : this.labelRotation = 0 : n10 && (p2 = h10), l2.rotation && (p2 = u2 > 0.5 * t10.chartHeight ? 0.33 * t10.chartHeight : u2, c2 || (g2 = 1)), this.labelAlign = o10.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l2.align = this.labelAlign), i10.forEach(function(t11) {
            let e11 = s10[t11], i11 = e11 && e11.label, o11 = r10.width, a11 = {};
            i11 && (i11.attr(l2), e11.shortenLabel ? e11.shortenLabel() : p2 && !o11 && "nowrap" !== r10.whiteSpace && (p2 < (i11.textPxLength || 0) || "SPAN" === i11.element.tagName) ? i11.css(sk(a11, {
              width: `${p2}px`,
              lineClamp: g2
            })) : !i11.styles.width || a11.width || o11 || i11.css({
              width: "auto"
            }), e11.rotation = l2.rotation);
          }, this), this.tickRotCorr = e10.rotCorr(d2.b, this.labelRotation || 0, 0 !== this.side);
        }
        hasData() {
          return this.series.some(function(t10) {
            return t10.hasData();
          }) || this.options.showEmpty && sx(this.min) && sx(this.max);
        }
        addTitle(t10) {
          let e10;
          let i10 = this.chart.renderer, s10 = this.horiz, o10 = this.opposite, r10 = this.options.title, a10 = this.chart.styledMode;
          this.axisTitle || ((e10 = r10.textAlign) || (e10 = (s10 ? {
            low: "left",
            middle: "center",
            high: "right"
          } : {
            low: o10 ? "right" : "left",
            middle: "center",
            high: o10 ? "left" : "right"
          })[r10.align]), this.axisTitle = i10.text(r10.text || "", 0, 0, r10.useHTML).attr({
            zIndex: 7,
            rotation: r10.rotation || 0,
            align: e10
          }).addClass("highcharts-axis-title"), a10 || this.axisTitle.css(sP(r10.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true), a10 || r10.style.width || this.isRadial || this.axisTitle.css({
            width: this.len + "px"
          }), this.axisTitle[t10 ? "show" : "hide"](t10);
        }
        generateTick(t10) {
          let e10 = this.ticks;
          e10[t10] ? e10[t10].addLabel() : e10[t10] = new sa(this, t10);
        }
        createGroups() {
          let {
            axisParent: t10,
            chart: e10,
            coll: i10,
            options: s10
          } = this, o10 = e10.renderer, r10 = (e11, r11, a10) => o10.g(e11).attr({
            zIndex: a10
          }).addClass(`highcharts-${i10.toLowerCase()}${r11} ` + (this.isRadial ? `highcharts-radial-axis${r11} ` : "") + (s10.className || "")).add(t10);
          this.axisGroup || (this.gridGroup = r10("grid", "-grid", s10.gridZIndex), this.axisGroup = r10("axis", "", s10.zIndex), this.labelGroup = r10("axis-labels", "-labels", s10.labels.zIndex));
        }
        getOffset() {
          let t10 = this, {
            chart: e10,
            horiz: i10,
            options: s10,
            side: o10,
            ticks: r10,
            tickPositions: a10,
            coll: n10
          } = t10, h10 = e10.inverted && !t10.isZAxis ? [1, 0, 3, 2][o10] : o10, l2 = t10.hasData(), d2 = s10.title, c2 = s10.labels, p2 = sC(s10.crossing), g2 = e10.axisOffset, u2 = e10.clipOffset, f2 = [-1, 1, 1, -1][o10], m2, x2 = 0, y2, b2 = 0, v2 = 0, k2, w2;
          if (t10.showAxis = m2 = l2 || s10.showEmpty, t10.staggerLines = t10.horiz && c2.staggerLines || void 0, t10.createGroups(), l2 || t10.isLinked ? (a10.forEach(function(e11) {
            t10.generateTick(e11);
          }), t10.renderUnsquish(), t10.reserveSpaceDefault = 0 === o10 || 2 === o10 || {
            1: "left",
            3: "right"
          }[o10] === t10.labelAlign, sE(c2.reserveSpace, !p2 && null, "center" === t10.labelAlign || null, t10.reserveSpaceDefault) && a10.forEach(function(t11) {
            v2 = Math.max(r10[t11].getLabelSize(), v2);
          }), t10.staggerLines && (v2 *= t10.staggerLines), t10.labelOffset = v2 * (t10.opposite ? -1 : 1)) : sO(r10, function(t11, e11) {
            t11.destroy(), delete r10[e11];
          }), d2?.text && false !== d2.enabled && (t10.addTitle(m2), m2 && !p2 && false !== d2.reserveSpace && (t10.titleOffset = x2 = t10.axisTitle.getBBox()[i10 ? "height" : "width"], b2 = sx(y2 = d2.offset) ? 0 : sE(d2.margin, i10 ? 5 : 10))), t10.renderLine(), t10.offset = f2 * sE(s10.offset, g2[o10] ? g2[o10] + (s10.margin || 0) : 0), t10.tickRotCorr = t10.tickRotCorr || {
            x: 0,
            y: 0
          }, w2 = 0 === o10 ? -t10.labelMetrics().h : 2 === o10 ? t10.tickRotCorr.y : 0, k2 = Math.abs(v2) + b2, v2 && (k2 -= w2, k2 += f2 * (i10 ? sE(c2.y, t10.tickRotCorr.y + f2 * c2.distance) : sE(c2.x, f2 * c2.distance))), t10.axisTitleMargin = sE(y2, k2), t10.getMaxLabelDimensions && (t10.maxLabelDimensions = t10.getMaxLabelDimensions(r10, a10)), "colorAxis" !== n10 && u2) {
            let e11 = this.tickSize("tick");
            g2[o10] = Math.max(g2[o10], (t10.axisTitleMargin || 0) + x2 + f2 * t10.offset, k2, a10 && a10.length && e11 ? e11[0] + f2 * t10.offset : 0);
            let i11 = !t10.axisLine || s10.offset ? 0 : t10.axisLine.strokeWidth() / 2;
            u2[h10] = Math.max(u2[h10], i11);
          }
          sw(this, "afterGetOffset");
        }
        getLinePath(t10) {
          let e10 = this.chart, i10 = this.opposite, s10 = this.offset, o10 = this.horiz, r10 = this.left + (i10 ? this.width : 0) + s10, a10 = e10.chartHeight - this.bottom - (i10 ? this.height : 0) + s10;
          return i10 && (t10 *= -1), e10.renderer.crispLine([["M", o10 ? this.left : r10, o10 ? a10 : this.top], ["L", o10 ? e10.chartWidth - this.right : r10, o10 ? a10 : e10.chartHeight - this.bottom]], t10);
        }
        renderLine() {
          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
            stroke: this.options.lineColor,
            "stroke-width": this.options.lineWidth,
            zIndex: 7
          }));
        }
        getTitlePosition(t10) {
          let e10 = this.horiz, i10 = this.left, s10 = this.top, o10 = this.len, r10 = this.options.title, a10 = e10 ? i10 : s10, n10 = this.opposite, h10 = this.offset, l2 = r10.x, d2 = r10.y, c2 = this.chart.renderer.fontMetrics(t10), p2 = t10 ? Math.max(t10.getBBox(false, 0).height - c2.h - 1, 0) : 0, g2 = {
            low: a10 + (e10 ? 0 : o10),
            middle: a10 + o10 / 2,
            high: a10 + (e10 ? o10 : 0)
          }[r10.align], u2 = (e10 ? s10 + this.height : i10) + (e10 ? 1 : -1) * (n10 ? -1 : 1) * (this.axisTitleMargin || 0) + [-p2, p2, c2.f, -p2][this.side], f2 = {
            x: e10 ? g2 + l2 : u2 + (n10 ? this.width : 0) + h10 + l2,
            y: e10 ? u2 + d2 - (n10 ? this.height : 0) + h10 : g2 + d2
          };
          return sw(this, "afterGetTitlePosition", {
            titlePosition: f2
          }), f2;
        }
        renderMinorTick(t10, e10) {
          let i10 = this.minorTicks;
          i10[t10] || (i10[t10] = new sa(this, t10, "minor")), e10 && i10[t10].isNew && i10[t10].render(null, true), i10[t10].render(null, false, 1);
        }
        renderTick(t10, e10, i10) {
          let s10 = this.isLinked, o10 = this.ticks;
          (!s10 || t10 >= this.min && t10 <= this.max || this.grid && this.grid.isColumn) && (o10[t10] || (o10[t10] = new sa(this, t10)), i10 && o10[t10].isNew && o10[t10].render(e10, true, -1), o10[t10].render(e10));
        }
        render() {
          let t10, e10;
          let i10 = this, s10 = i10.chart, o10 = i10.logarithmic, r10 = s10.renderer, a10 = i10.options, n10 = i10.isLinked, h10 = i10.tickPositions, l2 = i10.axisTitle, d2 = i10.ticks, c2 = i10.minorTicks, p2 = i10.alternateBands, g2 = a10.stackLabels, u2 = a10.alternateGridColor, f2 = a10.crossing, m2 = i10.tickmarkOffset, x2 = i10.axisLine, y2 = i10.showAxis, b2 = sn(r10.globalAnimation);
          if (i10.labelEdge.length = 0, i10.overlap = false, [d2, c2, p2].forEach(function(t11) {
            sO(t11, function(t12) {
              t12.isActive = false;
            });
          }), sC(f2)) {
            let t11 = this.isXAxis ? s10.yAxis[0] : s10.xAxis[0], e11 = [1, -1, -1, 1][this.side];
            if (t11) {
              let s11 = t11.toPixels(f2, true);
              i10.horiz && (s11 = t11.len - s11), i10.offset = e11 * s11;
            }
          }
          if (i10.hasData() || n10) {
            let r11 = i10.chart.hasRendered && i10.old && sC(i10.old.min);
            i10.minorTickInterval && !i10.categories && i10.getMinorTickPositions().forEach(function(t11) {
              i10.renderMinorTick(t11, r11);
            }), h10.length && (h10.forEach(function(t11, e11) {
              i10.renderTick(t11, e11, r11);
            }), m2 && (0 === i10.min || i10.single) && (d2[-1] || (d2[-1] = new sa(i10, -1, null, true)), d2[-1].render(-1))), u2 && h10.forEach(function(r12, a11) {
              e10 = void 0 !== h10[a11 + 1] ? h10[a11 + 1] + m2 : i10.max - m2, a11 % 2 == 0 && r12 < i10.max && e10 <= i10.max + (s10.polar ? -m2 : m2) && (p2[r12] || (p2[r12] = new k.PlotLineOrBand(i10, {})), t10 = r12 + m2, p2[r12].options = {
                from: o10 ? o10.lin2log(t10) : t10,
                to: o10 ? o10.lin2log(e10) : e10,
                color: u2,
                className: "highcharts-alternate-grid"
              }, p2[r12].render(), p2[r12].isActive = true);
            }), i10._addedPlotLB || (i10._addedPlotLB = true, (a10.plotLines || []).concat(a10.plotBands || []).forEach(function(t11) {
              i10.addPlotBandOrLine(t11);
            }));
          }
          [d2, c2, p2].forEach(function(t11) {
            let e11 = [], i11 = b2.duration;
            sO(t11, function(t12, i12) {
              t12.isActive || (t12.render(i12, false, 0), t12.isActive = false, e11.push(i12));
            }), sN(function() {
              let i12 = e11.length;
              for (; i12--; ) t11[e11[i12]] && !t11[e11[i12]].isActive && (t11[e11[i12]].destroy(), delete t11[e11[i12]]);
            }, t11 !== p2 && s10.hasRendered && i11 ? i11 : 0);
          }), x2 && (x2[x2.isPlaced ? "animate" : "attr"]({
            d: this.getLinePath(x2.strokeWidth())
          }), x2.isPlaced = true, x2[y2 ? "show" : "hide"](y2)), l2 && y2 && (l2[l2.isNew ? "attr" : "animate"](i10.getTitlePosition(l2)), l2.isNew = false), g2 && g2.enabled && i10.stacking && i10.stacking.renderStackTotals(), i10.old = {
            len: i10.len,
            max: i10.max,
            min: i10.min,
            transA: i10.transA,
            userMax: i10.userMax,
            userMin: i10.userMin
          }, i10.isDirty = false, sw(this, "afterRender");
        }
        redraw() {
          this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t10) {
            t10.render();
          })), this.series.forEach(function(t10) {
            t10.isDirty = true;
          });
        }
        getKeepProps() {
          return this.keepProps || sR.keepProps;
        }
        destroy(t10) {
          let e10 = this, i10 = e10.plotLinesAndBands, s10 = this.eventOptions;
          if (sw(this, "destroy", {
            keepEvents: t10
          }), t10 || sD(e10), [e10.ticks, e10.minorTicks, e10.alternateBands].forEach(function(t11) {
            sy(t11);
          }), i10) {
            let t11 = i10.length;
            for (; t11--; ) i10[t11].destroy();
          }
          for (let t11 in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(t12) {
            e10[t12] && (e10[t12] = e10[t12].destroy());
          }), e10.plotLinesAndBandsGroups) e10.plotLinesAndBandsGroups[t11] = e10.plotLinesAndBandsGroups[t11].destroy();
          sO(e10, function(t11, i11) {
            -1 === e10.getKeepProps().indexOf(i11) && delete e10[i11];
          }), this.eventOptions = s10;
        }
        drawCrosshair(t10, e10) {
          let i10 = this.crosshair, s10 = sE(i10 && i10.snap, true), o10 = this.chart, r10, a10, n10, h10 = this.cross, l2;
          if (sw(this, "drawCrosshair", {
            e: t10,
            point: e10
          }), t10 || (t10 = this.cross && this.cross.e), i10 && false !== (sx(e10) || !s10)) {
            if (s10 ? sx(e10) && (a10 = sE("colorAxis" !== this.coll ? e10.crosshairPos : null, this.isXAxis ? e10.plotX : this.len - e10.plotY)) : a10 = t10 && (this.horiz ? t10.chartX - this.pos : this.len - t10.chartY + this.pos), sx(a10) && (l2 = {
              value: e10 && (this.isXAxis ? e10.x : sE(e10.stackY, e10.y)),
              translatedValue: a10
            }, o10.polar && sk(l2, {
              isCrosshair: true,
              chartX: t10 && t10.chartX,
              chartY: t10 && t10.chartY,
              point: e10
            }), r10 = this.getPlotLinePath(l2) || null), !sx(r10)) {
              this.hideCrosshair();
              return;
            }
            n10 = this.categories && !this.isRadial, h10 || (this.cross = h10 = o10.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (n10 ? "category " : "thin ") + (i10.className || "")).attr({
              zIndex: sE(i10.zIndex, 2)
            }).add(), !o10.styledMode && (h10.attr({
              stroke: i10.color || (n10 ? tk.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"),
              "stroke-width": sE(i10.width, 1)
            }).css({
              "pointer-events": "none"
            }), i10.dashStyle && h10.attr({
              dashstyle: i10.dashStyle
            }))), h10.show().attr({
              d: r10
            }), n10 && !i10.width && h10.attr({
              "stroke-width": this.transA
            }), this.cross.e = t10;
          } else this.hideCrosshair();
          sw(this, "afterDrawCrosshair", {
            e: t10,
            point: e10
          });
        }
        hideCrosshair() {
          this.cross && this.cross.hide(), sw(this, "afterHideCrosshair");
        }
        update(t10, e10) {
          let i10 = this.chart;
          t10 = sP(this.userOptions, t10), this.destroy(true), this.init(i10, t10), i10.isDirtyBox = true, sE(e10, true) && i10.redraw();
        }
        remove(t10) {
          let e10 = this.chart, i10 = this.coll, s10 = this.series, o10 = s10.length;
          for (; o10--; ) s10[o10] && s10[o10].remove(false);
          sb(e10.axes, this), sb(e10[i10] || [], this), e10.orderItems(i10), this.destroy(), e10.isDirtyBox = true, sE(t10, true) && e10.redraw();
        }
        setTitle(t10, e10) {
          this.update({
            title: t10
          }, e10);
        }
        setCategories(t10, e10) {
          this.update({
            categories: t10
          }, e10);
        }
      }
      sR.keepProps = ["coll", "extKey", "hcEvents", "len", "names", "series", "userMax", "userMin"];
      let {
        addEvent: sW,
        getMagnitude: sH,
        normalizeTickInterval: sX,
        timeUnits: sF
      } = $;
      !function(t10) {
        function e10() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function i10() {
          if ("datetime" !== this.type) {
            this.dateTime = void 0;
            return;
          }
          this.dateTime || (this.dateTime = new s10(this));
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("dateTime") || (t11.keepProps.push("dateTime"), t11.prototype.getTimeTicks = e10, sW(t11, "afterSetType", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          normalizeTimeTickInterval(t11, e11) {
            let i11 = e11 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], s11 = i11[i11.length - 1], o10 = sF[s11[0]], r10 = s11[1], a10;
            for (a10 = 0; a10 < i11.length && (o10 = sF[(s11 = i11[a10])[0]], r10 = s11[1], !i11[a10 + 1] || !(t11 <= (o10 * r10[r10.length - 1] + sF[i11[a10 + 1][0]]) / 2)); a10++) ;
            o10 === sF.year && t11 < 5 * o10 && (r10 = [1, 2, 5]);
            let n10 = sX(t11 / o10, r10, "year" === s11[0] ? Math.max(sH(t11 / o10), 1) : 1);
            return {
              unitRange: o10,
              count: n10,
              unitName: s11[0]
            };
          }
          getXDateFormat(t11, e11) {
            let {
              axis: i11
            } = this, s11 = i11.chart.time;
            return i11.closestPointRange ? s11.getDateFormat(i11.closestPointRange, t11, i11.options.startOfWeek, e11) || s11.resolveDTLFormat(e11.year).main : s11.resolveDTLFormat(e11.day).main;
          }
        }
        t10.Additions = s10;
      }(n || (n = {}));
      let sG = n, {
        addEvent: sY,
        normalizeTickInterval: sj,
        pick: sU
      } = $;
      !function(t10) {
        function e10() {
          "logarithmic" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s10(this));
        }
        function i10() {
          let t11 = this.logarithmic;
          t11 && (this.lin2val = function(e11) {
            return t11.lin2log(e11);
          }, this.val2lin = function(e11) {
            return t11.log2lin(e11);
          });
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("logarithmic") || (t11.keepProps.push("logarithmic"), sY(t11, "afterSetType", e10), sY(t11, "afterInit", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          getLogTickPositions(t11, e11, i11, s11) {
            let o10 = this.axis, r10 = o10.len, a10 = o10.options, n10 = [];
            if (s11 || (this.minorAutoInterval = void 0), t11 >= 0.5) t11 = Math.round(t11), n10 = o10.getLinearTickPositions(t11, e11, i11);
            else if (t11 >= 0.08) {
              let o11, r11, a11, h10, l2, d2, c2;
              let p2 = Math.floor(e11);
              for (o11 = t11 > 0.3 ? [1, 2, 4] : t11 > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r11 = p2; r11 < i11 + 1 && !c2; r11++) for (a11 = 0, h10 = o11.length; a11 < h10 && !c2; a11++) (l2 = this.log2lin(this.lin2log(r11) * o11[a11])) > e11 && (!s11 || d2 <= i11) && void 0 !== d2 && n10.push(d2), d2 > i11 && (c2 = true), d2 = l2;
            } else {
              let h10 = this.lin2log(e11), l2 = this.lin2log(i11), d2 = s11 ? o10.getMinorTickInterval() : a10.tickInterval, c2 = a10.tickPixelInterval / (s11 ? 5 : 1), p2 = s11 ? r10 / o10.tickPositions.length : r10;
              t11 = sj(t11 = sU("auto" === d2 ? null : d2, this.minorAutoInterval, (l2 - h10) * c2 / (p2 || 1))), n10 = o10.getLinearTickPositions(t11, h10, l2).map(this.log2lin), s11 || (this.minorAutoInterval = t11 / 5);
            }
            return s11 || (o10.tickInterval = t11), n10;
          }
          lin2log(t11) {
            return Math.pow(10, t11);
          }
          log2lin(t11) {
            return Math.log(t11) / Math.LN10;
          }
        }
        t10.Additions = s10;
      }(h || (h = {}));
      let s$ = h, {
        erase: sV,
        extend: s_,
        isNumber: sq
      } = $;
      !function(t10) {
        let e10;
        function i10(t11) {
          return this.addPlotBandOrLine(t11, "plotBands");
        }
        function s10(t11, i11) {
          let s11 = this.userOptions, o11 = new e10(this, t11);
          if (this.visible && (o11 = o11.render()), o11) {
            if (this._addedPlotLB || (this._addedPlotLB = true, (s11.plotLines || []).concat(s11.plotBands || []).forEach((t12) => {
              this.addPlotBandOrLine(t12);
            })), i11) {
              let e11 = s11[i11] || [];
              e11.push(t11), s11[i11] = e11;
            }
            this.plotLinesAndBands.push(o11);
          }
          return o11;
        }
        function o10(t11) {
          return this.addPlotBandOrLine(t11, "plotLines");
        }
        function r10(t11, e11, i11) {
          i11 = i11 || this.options;
          let s11 = this.getPlotLinePath({
            value: e11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), o11 = [], r11 = this.horiz, a11 = !sq(this.min) || !sq(this.max) || t11 < this.min && e11 < this.min || t11 > this.max && e11 > this.max, n11 = this.getPlotLinePath({
            value: t11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), h11, l2 = 1, d2;
          if (n11 && s11) for (a11 && (d2 = n11.toString() === s11.toString(), l2 = 0), h11 = 0; h11 < n11.length; h11 += 2) {
            let t12 = n11[h11], e12 = n11[h11 + 1], i12 = s11[h11], a12 = s11[h11 + 1];
            ("M" === t12[0] || "L" === t12[0]) && ("M" === e12[0] || "L" === e12[0]) && ("M" === i12[0] || "L" === i12[0]) && ("M" === a12[0] || "L" === a12[0]) && (r11 && i12[1] === t12[1] ? (i12[1] += l2, a12[1] += l2) : r11 || i12[2] !== t12[2] || (i12[2] += l2, a12[2] += l2), o11.push(["M", t12[1], t12[2]], ["L", e12[1], e12[2]], ["L", a12[1], a12[2]], ["L", i12[1], i12[2]], ["Z"])), o11.isFlat = d2;
          }
          return o11;
        }
        function a10(t11) {
          this.removePlotBandOrLine(t11);
        }
        function n10(t11) {
          let e11 = this.plotLinesAndBands, i11 = this.options, s11 = this.userOptions;
          if (e11) {
            let o11 = e11.length;
            for (; o11--; ) e11[o11].id === t11 && e11[o11].destroy();
            [i11.plotLines || [], s11.plotLines || [], i11.plotBands || [], s11.plotBands || []].forEach(function(e12) {
              for (o11 = e12.length; o11--; ) (e12[o11] || {}).id === t11 && sV(e12, e12[o11]);
            });
          }
        }
        function h10(t11) {
          this.removePlotBandOrLine(t11);
        }
        t10.compose = function(t11, l2) {
          let d2 = l2.prototype;
          return d2.addPlotBand || (e10 = t11, s_(d2, {
            addPlotBand: i10,
            addPlotLine: o10,
            addPlotBandOrLine: s10,
            getPlotBandPath: r10,
            removePlotBand: a10,
            removePlotLine: h10,
            removePlotBandOrLine: n10
          })), l2;
        };
      }(l || (l = {}));
      let sZ = l, {
        addEvent: sK,
        arrayMax: sJ,
        arrayMin: sQ,
        defined: s0,
        destroyObjectProperties: s1,
        erase: s2,
        fireEvent: s3,
        merge: s5,
        objectEach: s6,
        pick: s9
      } = $;
      class s4 {
        static compose(t10, e10) {
          return sK(t10, "afterInit", function() {
            this.labelCollectors.push(() => {
              let t11 = [];
              for (let e11 of this.axes) for (let {
                label: i10,
                options: s10
              } of e11.plotLinesAndBands) i10 && !s10?.label?.allowOverlap && t11.push(i10);
              return t11;
            });
          }), sZ.compose(s4, e10);
        }
        constructor(t10, e10) {
          this.axis = t10, this.options = e10, this.id = e10.id;
        }
        render() {
          s3(this, "render");
          let {
            axis: t10,
            options: e10
          } = this, {
            horiz: i10,
            logarithmic: s10
          } = t10, {
            color: o10,
            events: r10,
            zIndex: a10 = 0
          } = e10, {
            renderer: n10,
            time: h10
          } = t10.chart, l2 = {}, d2 = h10.parse(e10.to), c2 = h10.parse(e10.from), p2 = h10.parse(e10.value), g2 = e10.borderWidth, u2 = e10.label, {
            label: f2,
            svgElem: m2
          } = this, x2 = [], y2, b2 = s0(c2) && s0(d2), v2 = s0(p2), k2 = !m2, w2 = {
            class: "highcharts-plot-" + (b2 ? "band " : "line ") + (e10.className || "")
          }, M2 = b2 ? "bands" : "lines";
          if (!t10.chart.styledMode && (v2 ? (w2.stroke = o10 || "#999999", w2["stroke-width"] = s9(e10.width, 1), e10.dashStyle && (w2.dashstyle = e10.dashStyle)) : b2 && (w2.fill = o10 || "#e6e9ff", g2 && (w2.stroke = e10.borderColor, w2["stroke-width"] = g2))), l2.zIndex = a10, M2 += "-" + a10, (y2 = t10.plotLinesAndBandsGroups[M2]) || (t10.plotLinesAndBandsGroups[M2] = y2 = n10.g("plot-" + M2).attr(l2).add()), m2 || (this.svgElem = m2 = n10.path().attr(w2).add(y2)), s0(p2)) x2 = t10.getPlotLinePath({
            value: s10?.log2lin(p2) ?? p2,
            lineWidth: m2.strokeWidth(),
            acrossPanes: e10.acrossPanes
          });
          else {
            if (!(s0(c2) && s0(d2))) return;
            x2 = t10.getPlotBandPath(s10?.log2lin(c2) ?? c2, s10?.log2lin(d2) ?? d2, e10);
          }
          return !this.eventsAdded && r10 && (s6(r10, (t11, e11) => {
            m2?.on(e11, (t12) => {
              r10[e11].apply(this, [t12]);
            });
          }), this.eventsAdded = true), (k2 || !m2.d) && x2?.length ? m2.attr({
            d: x2
          }) : m2 && (x2 ? (m2.show(), m2.animate({
            d: x2
          })) : m2.d && (m2.hide(), f2 && (this.label = f2 = f2.destroy()))), u2 && (s0(u2.text) || s0(u2.formatter)) && x2?.length && t10.width > 0 && t10.height > 0 && !x2.isFlat ? (u2 = s5(__spreadValues({
            align: i10 && b2 ? "center" : void 0,
            x: i10 ? !b2 && 4 : 10,
            verticalAlign: !i10 && b2 ? "middle" : void 0,
            y: i10 ? b2 ? 16 : 10 : b2 ? 6 : -4,
            rotation: i10 && !b2 ? 90 : 0
          }, b2 ? {
            inside: true
          } : {}), u2), this.renderLabel(u2, x2, b2, a10)) : f2 && f2.hide(), this;
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart.renderer, a10 = t10.inside, n10 = this.label;
          n10 || (this.label = n10 = r10.text(this.getLabelText(t10), 0, 0, t10.useHTML).attr({
            align: t10.textAlign || t10.align,
            rotation: t10.rotation,
            class: "highcharts-plot-" + (i10 ? "band" : "line") + "-label " + (t10.className || ""),
            zIndex: s10
          }), o10.chart.styledMode || n10.css(s5({
            fontSize: "0.8em",
            textOverflow: i10 && !a10 ? "" : "ellipsis"
          }, t10.style)), n10.add());
          let h10 = e10.xBounds || [e10[0][1], e10[1][1], i10 ? e10[2][1] : e10[0][1]], l2 = e10.yBounds || [e10[0][2], e10[1][2], i10 ? e10[2][2] : e10[0][2]], d2 = sQ(h10), c2 = sQ(l2), p2 = sJ(h10) - d2;
          n10.align(t10, false, {
            x: d2,
            y: c2,
            width: p2,
            height: sJ(l2) - c2
          }), (!n10.alignValue || "left" === n10.alignValue || s0(a10)) && n10.css({
            width: (t10.style?.width || (i10 && a10 ? p2 : 90 === n10.rotation ? o10.height - (n10.alignAttr.y - o10.top) : (t10.clip ? o10.width : o10.chart.chartWidth) - (n10.alignAttr.x - o10.left))) + "px"
          }), n10.show(true);
        }
        getLabelText(t10) {
          return s0(t10.formatter) ? t10.formatter.call(this) : t10.text;
        }
        destroy() {
          s2(this.axis.plotLinesAndBands, this), delete this.axis, s1(this);
        }
      }
      let {
        animObject: s8
      } = tR, {
        format: s7
      } = eo, {
        composed: ot,
        dateFormats: oe,
        doc: oi,
        isSafari: os
      } = k, {
        distribute: oo
      } = ed, {
        addEvent: or,
        clamp: oa,
        css: on,
        discardElement: oh,
        extend: ol,
        fireEvent: od,
        isArray: oc,
        isNumber: op,
        isObject: og,
        isString: ou,
        merge: of,
        pick: om,
        pushUnique: ox,
        splat: oy,
        syncTimeout: ob
      } = $;
      class ov {
        constructor(t10, e10, i10) {
          this.allowShared = true, this.crosshairs = [], this.distance = 0, this.isHidden = true, this.isSticky = false, this.options = {}, this.outside = false, this.chart = t10, this.init(t10, e10), this.pointer = i10;
        }
        bodyFormatter(t10) {
          return t10.map((t11) => {
            let e10 = t11.series.tooltipOptions, i10 = t11.formatPrefix || "point";
            return (e10[i10 + "Formatter"] || t11.tooltipFormatter).call(t11, e10[i10 + "Format"] || "");
          });
        }
        cleanSplit(t10) {
          this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.tt;
            i10 && (!i10.isActive || t10 ? e10.tt = i10.destroy() : i10.isActive = false);
          });
        }
        defaultFormatter(t10) {
          let e10;
          let i10 = this.points || oy(this);
          return (e10 = (e10 = [t10.headerFooterFormatter(i10[0])]).concat(t10.bodyFormatter(i10))).push(t10.headerFooterFormatter(i10[0], true)), e10;
        }
        destroy() {
          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), oh(this.container)), $.clearTimeout(this.hideTimer);
        }
        getAnchor(t10, e10) {
          let i10;
          let {
            chart: s10,
            pointer: o10
          } = this, r10 = s10.inverted, a10 = s10.plotTop, n10 = s10.plotLeft;
          if ((t10 = oy(t10))[0].series && t10[0].series.yAxis && !t10[0].series.yAxis.options.reversedStacks && (t10 = t10.slice().reverse()), this.followPointer && e10) void 0 === e10.chartX && (e10 = o10.normalize(e10)), i10 = [e10.chartX - n10, e10.chartY - a10];
          else if (t10[0].tooltipPos) i10 = t10[0].tooltipPos;
          else {
            let s11 = 0, o11 = 0;
            t10.forEach(function(t11) {
              let e11 = t11.pos(true);
              e11 && (s11 += e11[0], o11 += e11[1]);
            }), s11 /= t10.length, o11 /= t10.length, this.shared && t10.length > 1 && e10 && (r10 ? s11 = e10.chartX : o11 = e10.chartY), i10 = [s11 - n10, o11 - a10];
          }
          return i10.map(Math.round);
        }
        getClassName(t10, e10, i10) {
          let s10 = this.options, o10 = t10.series, r10 = o10.options;
          return [s10.className, "highcharts-label", i10 && "highcharts-tooltip-header", e10 ? "highcharts-tooltip-box" : "highcharts-tooltip", !i10 && "highcharts-color-" + om(t10.colorIndex, o10.colorIndex), r10 && r10.className].filter(ou).join(" ");
        }
        getLabel({
          anchorX: t10,
          anchorY: e10
        } = {
          anchorX: 0,
          anchorY: 0
        }) {
          let i10 = this, s10 = this.chart.styledMode, o10 = this.options, r10 = this.split && this.allowShared, a10 = this.container, n10 = this.chart.renderer;
          if (this.label) {
            let t11 = !this.label.hasClass("highcharts-label");
            (!r10 && t11 || r10 && !t11) && this.destroy();
          }
          if (!this.label) {
            if (this.outside) {
              let t11 = this.chart, e11 = t11.options.chart.style, i11 = er.getRendererType();
              this.container = a10 = k.doc.createElement("div"), a10.className = "highcharts-tooltip-container " + (t11.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), on(a10, {
                position: "absolute",
                top: "1px",
                pointerEvents: "none",
                zIndex: Math.max(this.options.style.zIndex || 0, (e11 && e11.zIndex || 0) + 3)
              }), this.renderer = n10 = new i11(a10, 0, 0, e11, void 0, void 0, n10.styledMode);
            }
            if (r10 ? this.label = n10.g("tooltip") : (this.label = n10.label("", t10, e10, o10.shape, void 0, void 0, o10.useHTML, void 0, "tooltip").attr({
              padding: o10.padding,
              r: o10.borderRadius
            }), s10 || this.label.attr({
              fill: o10.backgroundColor,
              "stroke-width": o10.borderWidth || 0
            }).css(o10.style).css({
              pointerEvents: o10.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
            })), i10.outside) {
              let t11 = this.label;
              [t11.xSetter, t11.ySetter].forEach((e11, s11) => {
                t11[s11 ? "ySetter" : "xSetter"] = (o11) => {
                  e11.call(t11, i10.distance), t11[s11 ? "y" : "x"] = o11, a10 && (a10.style[s11 ? "top" : "left"] = `${o11}px`);
                };
              });
            }
            this.label.attr({
              zIndex: 8
            }).shadow(o10.shadow).add();
          }
          return a10 && !a10.parentElement && k.doc.body.appendChild(a10), this.label;
        }
        getPlayingField() {
          let {
            body: t10,
            documentElement: e10
          } = oi, {
            chart: i10,
            distance: s10,
            outside: o10
          } = this;
          return {
            width: o10 ? Math.max(t10.scrollWidth, e10.scrollWidth, t10.offsetWidth, e10.offsetWidth, e10.clientWidth) - 2 * s10 - 2 : i10.chartWidth,
            height: o10 ? Math.max(t10.scrollHeight, e10.scrollHeight, t10.offsetHeight, e10.offsetHeight, e10.clientHeight) : i10.chartHeight
          };
        }
        getPosition(t10, e10, i10) {
          let {
            distance: s10,
            chart: o10,
            outside: r10,
            pointer: a10
          } = this, {
            inverted: n10,
            plotLeft: h10,
            plotTop: l2,
            polar: d2
          } = o10, {
            plotX: c2 = 0,
            plotY: p2 = 0
          } = i10, g2 = {}, u2 = n10 && i10.h || 0, {
            height: f2,
            width: m2
          } = this.getPlayingField(), x2 = a10.getChartPosition(), y2 = (t11) => t11 * x2.scaleX, b2 = (t11) => t11 * x2.scaleY, v2 = (i11) => {
            let a11 = "x" === i11;
            return [i11, a11 ? m2 : f2, a11 ? t10 : e10].concat(r10 ? [a11 ? y2(t10) : b2(e10), a11 ? x2.left - s10 + y2(c2 + h10) : x2.top - s10 + b2(p2 + l2), 0, a11 ? m2 : f2] : [a11 ? t10 : e10, a11 ? c2 + h10 : p2 + l2, a11 ? h10 : l2, a11 ? h10 + o10.plotWidth : l2 + o10.plotHeight]);
          }, k2 = v2("y"), w2 = v2("x"), M2, S2 = !!i10.negative;
          !d2 && o10.hoverSeries?.yAxis?.reversed && (S2 = !S2);
          let T2 = !this.followPointer && om(i10.ttBelow, !d2 && !n10 === S2), C2 = function(t11, e11, i11, o11, a11, n11, h11) {
            let l3 = r10 ? "y" === t11 ? b2(s10) : y2(s10) : s10, d3 = (i11 - o11) / 2, c3 = o11 < a11 - s10, p3 = a11 + s10 + o11 < e11, f3 = a11 - l3 - i11 + d3, m3 = a11 + l3 - d3;
            if (T2 && p3) g2[t11] = m3;
            else if (!T2 && c3) g2[t11] = f3;
            else if (c3) g2[t11] = Math.min(h11 - o11, f3 - u2 < 0 ? f3 : f3 - u2);
            else {
              if (!p3) return false;
              g2[t11] = Math.max(n11, m3 + u2 + i11 > e11 ? m3 : m3 + u2);
            }
          }, A2 = function(t11, e11, i11, o11, r11) {
            if (r11 < s10 || r11 > e11 - s10) return false;
            r11 < i11 / 2 ? g2[t11] = 1 : r11 > e11 - o11 / 2 ? g2[t11] = e11 - o11 - 2 : g2[t11] = r11 - i11 / 2;
          }, P2 = function(t11) {
            [k2, w2] = [w2, k2], M2 = t11;
          }, L2 = () => {
            false !== C2.apply(0, k2) ? false !== A2.apply(0, w2) || M2 || (P2(true), L2()) : M2 ? g2.x = g2.y = 0 : (P2(true), L2());
          };
          return (n10 && !d2 || this.len > 1) && P2(), L2(), g2;
        }
        hide(t10) {
          let e10 = this;
          $.clearTimeout(this.hideTimer), t10 = om(t10, this.options.hideDelay), this.isHidden || (this.hideTimer = ob(function() {
            let i10 = e10.getLabel();
            e10.getLabel().animate({
              opacity: 0
            }, {
              duration: t10 ? 150 : t10,
              complete: () => {
                i10.hide(), e10.container && e10.container.remove();
              }
            }), e10.isHidden = true;
          }, t10));
        }
        init(t10, e10) {
          this.chart = t10, this.options = e10, this.crosshairs = [], this.isHidden = true, this.split = e10.split && !t10.inverted && !t10.polar, this.shared = e10.shared || this.split, this.outside = om(e10.outside, !!(t10.scrollablePixelsX || t10.scrollablePixelsY));
        }
        shouldStickOnContact(t10) {
          return !!(!this.followPointer && this.options.stickOnContact && (!t10 || this.pointer.inClass(t10.target, "highcharts-tooltip")));
        }
        move(t10, e10, i10, s10) {
          let o10 = this, r10 = s8(!o10.isHidden && o10.options.animation), a10 = o10.followPointer || (o10.len || 0) > 1, n10 = {
            x: t10,
            y: e10
          };
          a10 || (n10.anchorX = i10, n10.anchorY = s10), r10.step = () => o10.drawTracker(), o10.getLabel().animate(n10, r10);
        }
        refresh(t10, e10) {
          let {
            chart: i10,
            options: s10,
            pointer: o10,
            shared: r10
          } = this, a10 = oy(t10), n10 = a10[0], h10 = s10.format, l2 = s10.formatter || this.defaultFormatter, d2 = i10.styledMode, c2 = this.allowShared;
          if (!s10.enabled || !n10.series) return;
          $.clearTimeout(this.hideTimer), this.allowShared = !(!oc(t10) && t10.series && t10.series.noSharedTooltip), c2 = c2 && !this.allowShared, this.followPointer = !this.split && n10.series.tooltipOptions.followPointer;
          let p2 = this.getAnchor(t10, e10), g2 = p2[0], u2 = p2[1];
          r10 && this.allowShared && (o10.applyInactiveState(a10), a10.forEach((t11) => t11.setState("hover")), n10.points = a10), this.len = a10.length;
          let f2 = ou(h10) ? s7(h10, n10, i10) : l2.call(n10, this);
          n10.points = void 0;
          let m2 = n10.series;
          if (this.distance = om(m2.tooltipOptions.distance, 16), false === f2) this.hide();
          else {
            if (this.split && this.allowShared) this.renderSplit(f2, a10);
            else {
              let t11 = g2, r11 = u2;
              if (e10 && o10.isDirectTouch && (t11 = e10.chartX - i10.plotLeft, r11 = e10.chartY - i10.plotTop), i10.polar || false === m2.options.clip || a10.some((e11) => o10.isDirectTouch || e11.series.shouldShowTooltip(t11, r11))) {
                let t12 = this.getLabel(c2 && this.tt || {});
                (!s10.style.width || d2) && t12.css({
                  width: (this.outside ? this.getPlayingField() : i10.spacingBox).width + "px"
                }), t12.attr({
                  class: this.getClassName(n10),
                  text: f2 && f2.join ? f2.join("") : f2
                }), this.outside && t12.attr({
                  x: oa(t12.x || 0, 0, this.getPlayingField().width - (t12.width || 0) - 1)
                }), d2 || t12.attr({
                  stroke: s10.borderColor || n10.color || m2.color || "#666666"
                }), this.updatePosition({
                  plotX: g2,
                  plotY: u2,
                  negative: n10.negative,
                  ttBelow: n10.ttBelow,
                  h: p2[2] || 0
                });
              } else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show(), this.isHidden = false;
          }
          od(this, "refresh");
        }
        renderSplit(t10, e10) {
          let i10 = this, {
            chart: s10,
            chart: {
              chartWidth: o10,
              chartHeight: r10,
              plotHeight: a10,
              plotLeft: n10,
              plotTop: h10,
              scrollablePixelsY: l2 = 0,
              scrollablePixelsX: d2,
              styledMode: c2
            },
            distance: p2,
            options: g2,
            options: {
              positioner: u2
            },
            pointer: f2
          } = i10, {
            scrollLeft: m2 = 0,
            scrollTop: x2 = 0
          } = s10.scrollablePlotArea?.scrollingContainer || {}, y2 = i10.outside && "number" != typeof d2 ? oi.documentElement.getBoundingClientRect() : {
            left: m2,
            right: m2 + o10,
            top: x2,
            bottom: x2 + r10
          }, b2 = i10.getLabel(), v2 = this.renderer || s10.renderer, k2 = !!(s10.xAxis[0] && s10.xAxis[0].opposite), {
            left: w2,
            top: M2
          } = f2.getChartPosition(), S2 = h10 + x2, T2 = 0, C2 = a10 - l2;
          function A2(t11, e11, s11, o11, r11 = true) {
            let a11, n11;
            return s11 ? (a11 = k2 ? 0 : C2, n11 = oa(t11 - o11 / 2, y2.left, y2.right - o11 - (i10.outside ? w2 : 0))) : (a11 = e11 - S2, n11 = oa(n11 = r11 ? t11 - o11 - p2 : t11 + p2, r11 ? n11 : y2.left, y2.right)), {
              x: n11,
              y: a11
            };
          }
          ou(t10) && (t10 = [false, t10]);
          let P2 = t10.slice(0, e10.length + 1).reduce(function(t11, s11, o11) {
            if (false !== s11 && "" !== s11) {
              let r11 = e10[o11 - 1] || {
                isHeader: true,
                plotX: e10[0].plotX,
                plotY: a10,
                series: {}
              }, l3 = r11.isHeader, d3 = l3 ? i10 : r11.series, f3 = d3.tt = function(t12, e11, s12) {
                let o12 = t12, {
                  isHeader: r12,
                  series: a11
                } = e11;
                if (!o12) {
                  let t13 = {
                    padding: g2.padding,
                    r: g2.borderRadius
                  };
                  c2 || (t13.fill = g2.backgroundColor, t13["stroke-width"] = g2.borderWidth ?? 1), o12 = v2.label("", 0, 0, g2[r12 ? "headerShape" : "shape"], void 0, void 0, g2.useHTML).addClass(i10.getClassName(e11, true, r12)).attr(t13).add(b2);
                }
                return o12.isActive = true, o12.attr({
                  text: s12
                }), c2 || o12.css(g2.style).attr({
                  stroke: g2.borderColor || e11.color || a11.color || "#333333"
                }), o12;
              }(d3.tt, r11, s11.toString()), m3 = f3.getBBox(), x3 = m3.width + f3.strokeWidth();
              l3 && (T2 = m3.height, C2 += T2, k2 && (S2 -= T2));
              let {
                anchorX: w3,
                anchorY: M3
              } = function(t12) {
                let e11, i11;
                let {
                  isHeader: s12,
                  plotX: o12 = 0,
                  plotY: r12 = 0,
                  series: l4
                } = t12;
                if (s12) e11 = Math.max(n10 + o12, n10), i11 = h10 + a10 / 2;
                else {
                  let {
                    xAxis: t13,
                    yAxis: s13
                  } = l4;
                  e11 = t13.pos + oa(o12, -p2, t13.len + p2), l4.shouldShowTooltip(0, s13.pos - h10 + r12, {
                    ignoreX: true
                  }) && (i11 = s13.pos + r12);
                }
                return {
                  anchorX: e11 = oa(e11, y2.left - p2, y2.right + p2),
                  anchorY: i11
                };
              }(r11);
              if ("number" == typeof M3) {
                let e11 = m3.height + 1, s12 = u2 ? u2.call(i10, x3, e11, r11) : A2(w3, M3, l3, x3);
                t11.push({
                  align: u2 ? 0 : void 0,
                  anchorX: w3,
                  anchorY: M3,
                  boxWidth: x3,
                  point: r11,
                  rank: om(s12.rank, l3 ? 1 : 0),
                  size: e11,
                  target: s12.y,
                  tt: f3,
                  x: s12.x
                });
              } else f3.isActive = false;
            }
            return t11;
          }, []);
          !u2 && P2.some((t11) => {
            let {
              outside: e11
            } = i10, s11 = (e11 ? w2 : 0) + t11.anchorX;
            return s11 < y2.left && s11 + t11.boxWidth < y2.right || s11 < w2 - y2.left + t11.boxWidth && y2.right - s11 > s11;
          }) && (P2 = P2.map((t11) => {
            let {
              x: e11,
              y: i11
            } = A2(t11.anchorX, t11.anchorY, t11.point.isHeader, t11.boxWidth, false);
            return ol(t11, {
              target: i11,
              x: e11
            });
          })), i10.cleanSplit(), oo(P2, C2);
          let L2 = {
            left: w2,
            right: w2
          };
          P2.forEach(function(t11) {
            let {
              x: e11,
              boxWidth: s11,
              isHeader: o11
            } = t11;
            !o11 && (i10.outside && w2 + e11 < L2.left && (L2.left = w2 + e11), !o11 && i10.outside && L2.left + s11 > L2.right && (L2.right = w2 + e11));
          }), P2.forEach(function(t11) {
            let {
              x: e11,
              anchorX: s11,
              anchorY: o11,
              pos: r11,
              point: {
                isHeader: a11
              }
            } = t11, n11 = {
              visibility: void 0 === r11 ? "hidden" : "inherit",
              x: e11,
              y: (r11 || 0) + S2,
              anchorX: s11,
              anchorY: o11
            };
            if (i10.outside && e11 < s11) {
              let t12 = w2 - L2.left;
              t12 > 0 && (a11 || (n11.x = e11 + t12, n11.anchorX = s11 + t12), a11 && (n11.x = (L2.right - L2.left) / 2, n11.anchorX = s11 + t12));
            }
            t11.tt.attr(n11);
          });
          let {
            container: O2,
            outside: E2,
            renderer: I2
          } = i10;
          if (E2 && O2 && I2) {
            let {
              width: t11,
              height: e11,
              x: i11,
              y: s11
            } = b2.getBBox();
            I2.setSize(t11 + i11, e11 + s11, false), O2.style.left = L2.left + "px", O2.style.top = M2 + "px";
          }
          os && b2.attr({
            opacity: 1 === b2.opacity ? 0.999 : 1
          });
        }
        drawTracker() {
          if (!this.shouldStickOnContact()) {
            this.tracker && (this.tracker = this.tracker.destroy());
            return;
          }
          let t10 = this.chart, e10 = this.label, i10 = this.shared ? t10.hoverPoints : t10.hoverPoint;
          if (!e10 || !i10) return;
          let s10 = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }, o10 = this.getAnchor(i10), r10 = e10.getBBox();
          o10[0] += t10.plotLeft - (e10.translateX || 0), o10[1] += t10.plotTop - (e10.translateY || 0), s10.x = Math.min(0, o10[0]), s10.y = Math.min(0, o10[1]), s10.width = o10[0] < 0 ? Math.max(Math.abs(o10[0]), r10.width - o10[0]) : Math.max(Math.abs(o10[0]), r10.width), s10.height = o10[1] < 0 ? Math.max(Math.abs(o10[1]), r10.height - Math.abs(o10[1])) : Math.max(Math.abs(o10[1]), r10.height), this.tracker ? this.tracker.attr(s10) : (this.tracker = e10.renderer.rect(s10).addClass("highcharts-tracker").add(e10), t10.styledMode || this.tracker.attr({
            fill: "rgba(0,0,0,0)"
          }));
        }
        styledModeFormat(t10) {
          return t10.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
        }
        headerFooterFormatter(t10, e10) {
          let i10 = t10.series, s10 = i10.tooltipOptions, o10 = i10.xAxis, r10 = o10 && o10.dateTime, a10 = {
            isFooter: e10,
            point: t10
          }, n10 = s10.xDateFormat || "", h10 = s10[e10 ? "footerFormat" : "headerFormat"];
          return od(this, "headerFormatter", a10, function(e11) {
            if (r10 && !n10 && op(t10.key) && (n10 = r10.getXDateFormat(t10.key, s10.dateTimeLabelFormats)), r10 && n10) {
              if (og(n10)) {
                let t11 = n10;
                oe[0] = (e12) => i10.chart.time.dateFormat(t11, e12), n10 = "%0";
              }
              (t10.tooltipDateKeys || ["key"]).forEach((t11) => {
                h10 = h10.replace(RegExp("point\\." + t11 + "([ \\)}])", ""), `(point.${t11}:${n10})$1`);
              });
            }
            i10.chart.styledMode && (h10 = this.styledModeFormat(h10)), e11.text = s7(h10, t10, this.chart);
          }), a10.text || "";
        }
        update(t10) {
          this.destroy(), this.init(this.chart, of(true, this.options, t10));
        }
        updatePosition(t10) {
          let {
            chart: e10,
            container: i10,
            distance: s10,
            options: o10,
            pointer: r10,
            renderer: a10
          } = this, {
            height: n10 = 0,
            width: h10 = 0
          } = this.getLabel(), {
            left: l2,
            top: d2,
            scaleX: c2,
            scaleY: p2
          } = r10.getChartPosition(), g2 = (o10.positioner || this.getPosition).call(this, h10, n10, t10), u2 = k.doc, f2 = (t10.plotX || 0) + e10.plotLeft, m2 = (t10.plotY || 0) + e10.plotTop, x2;
          a10 && i10 && (o10.positioner && (g2.x += l2 - s10, g2.y += d2 - s10), x2 = (o10.borderWidth || 0) + 2 * s10 + 2, a10.setSize(oa(h10 + x2, 0, u2.documentElement.clientWidth) - 1, n10 + x2, false), (1 !== c2 || 1 !== p2) && (on(i10, {
            transform: `scale(${c2}, ${p2})`
          }), f2 *= c2, m2 *= p2), f2 += l2 - g2.x, m2 += d2 - g2.y), this.move(Math.round(g2.x), Math.round(g2.y || 0), f2, m2);
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          ox(ot, "Core.Tooltip") && or(e10, "afterInit", function() {
            let e11 = this.chart;
            e11.options.tooltip && (e11.tooltip = new t10(e11, e11.options.tooltip, this));
          });
        };
      }(ov || (ov = {}));
      let ok = ov, {
        animObject: ow
      } = tR, {
        defaultOptions: oM
      } = tm, {
        format: oS
      } = eo, {
        addEvent: oT,
        crisp: oC,
        erase: oA,
        extend: oP,
        fireEvent: oL,
        getNestedProperty: oO,
        isArray: oE,
        isFunction: oI,
        isNumber: oD,
        isObject: oB,
        merge: oN,
        pick: oz,
        syncTimeout: oR,
        removeEvent: oW,
        uniqueKey: oH
      } = $;
      class oX {
        animateBeforeDestroy() {
          let t10 = this, e10 = {
            x: t10.startXPos,
            opacity: 0
          }, i10 = t10.getGraphicalProps();
          i10.singular.forEach(function(i11) {
            t10[i11] = t10[i11].animate("dataLabel" === i11 ? {
              x: t10[i11].startXPos,
              y: t10[i11].startYPos,
              opacity: 0
            } : e10);
          }), i10.plural.forEach(function(e11) {
            t10[e11].forEach(function(e12) {
              e12.element && e12.animate(oP({
                x: t10.startXPos
              }, e12.startYPos ? {
                x: e12.startXPos,
                y: e12.startYPos
              } : {}));
            });
          });
        }
        applyOptions(t10, e10) {
          let i10 = this.series, s10 = i10.options.pointValKey || i10.pointValKey;
          return oP(this, t10 = oX.prototype.optionsToObject.call(this, t10)), this.options = this.options ? oP(this.options, t10) : t10, t10.group && delete this.group, t10.dataLabels && delete this.dataLabels, s10 && (this.y = oX.prototype.getNestedProperty.call(this, s10)), this.selected && (this.state = "select"), "name" in this && void 0 === e10 && i10.xAxis && i10.xAxis.hasNames && (this.x = i10.xAxis.nameToX(this)), void 0 === this.x && i10 ? this.x = e10 ?? i10.autoIncrement() : oD(t10.x) && i10.options.relativeXValue ? this.x = i10.autoIncrement(t10.x) : "string" == typeof this.x && (e10 ?? (e10 = i10.chart.time.parse(this.x)), oD(e10) && (this.x = e10)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
        }
        destroy() {
          if (!this.destroyed) {
            let t10 = this, e10 = t10.series, i10 = e10.chart, s10 = e10.options.dataSorting, o10 = i10.hoverPoints, r10 = ow(t10.series.chart.renderer.globalAnimation), a10 = () => {
              for (let e11 in (t10.graphic || t10.graphics || t10.dataLabel || t10.dataLabels) && (oW(t10), t10.destroyElements()), t10) delete t10[e11];
            };
            t10.legendItem && i10.legend.destroyItem(t10), o10 && (t10.setState(), oA(o10, t10), o10.length || (i10.hoverPoints = null)), t10 === i10.hoverPoint && t10.onMouseOut(), s10 && s10.enabled ? (this.animateBeforeDestroy(), oR(a10, r10.duration)) : a10(), i10.pointCount--;
          }
          this.destroyed = true;
        }
        destroyElements(t10) {
          let e10 = this, i10 = e10.getGraphicalProps(t10);
          i10.singular.forEach(function(t11) {
            e10[t11] = e10[t11].destroy();
          }), i10.plural.forEach(function(t11) {
            e10[t11].forEach(function(t12) {
              t12 && t12.element && t12.destroy();
            }), delete e10[t11];
          });
        }
        firePointEvent(t10, e10, i10) {
          let s10 = this, o10 = this.series.options;
          s10.manageEvent(t10), "click" === t10 && o10.allowPointSelect && (i10 = function(t11) {
            !s10.destroyed && s10.select && s10.select(null, t11.ctrlKey || t11.metaKey || t11.shiftKey);
          }), oL(s10, t10, e10, i10);
        }
        getClassName() {
          return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
        }
        getGraphicalProps(t10) {
          let e10, i10;
          let s10 = this, o10 = [], r10 = {
            singular: [],
            plural: []
          };
          for ((t10 = t10 || {
            graphic: 1,
            dataLabel: 1
          }).graphic && o10.push("graphic", "connector"), t10.dataLabel && o10.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i10 = o10.length; i10--; ) s10[e10 = o10[i10]] && r10.singular.push(e10);
          return ["graphic", "dataLabel"].forEach(function(e11) {
            let i11 = e11 + "s";
            t10[e11] && s10[i11] && r10.plural.push(i11);
          }), r10;
        }
        getNestedProperty(t10) {
          return t10 ? 0 === t10.indexOf("custom.") ? oO(t10, this.options) : this[t10] : void 0;
        }
        getZone() {
          let t10 = this.series, e10 = t10.zones, i10 = t10.zoneAxis || "y", s10, o10 = 0;
          for (s10 = e10[0]; this[i10] >= s10.value; ) s10 = e10[++o10];
          return this.nonZonedColor || (this.nonZonedColor = this.color), s10 && s10.color && !this.options.color ? this.color = s10.color : this.color = this.nonZonedColor, s10;
        }
        hasNewShapeType() {
          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
        }
        constructor(t10, e10, i10) {
          this.formatPrefix = "point", this.visible = true, this.point = this, this.series = t10, this.applyOptions(e10, i10), this.id ?? (this.id = oH()), this.resolveColor(), t10.chart.pointCount++, oL(this, "afterInit");
        }
        isValid() {
          return (oD(this.x) || this.x instanceof Date) && oD(this.y);
        }
        optionsToObject(t10) {
          let e10 = this.series, i10 = e10.options.keys, s10 = i10 || e10.pointArrayMap || ["y"], o10 = s10.length, r10 = {}, a10, n10 = 0, h10 = 0;
          if (oD(t10) || null === t10) r10[s10[0]] = t10;
          else if (oE(t10)) for (!i10 && t10.length > o10 && ("string" == (a10 = typeof t10[0]) ? e10.xAxis?.dateTime ? r10.x = e10.chart.time.parse(t10[0]) : r10.name = t10[0] : "number" === a10 && (r10.x = t10[0]), n10++); h10 < o10; ) i10 && void 0 === t10[n10] || (s10[h10].indexOf(".") > 0 ? oX.prototype.setNestedProperty(r10, t10[n10], s10[h10]) : r10[s10[h10]] = t10[n10]), n10++, h10++;
          else "object" == typeof t10 && (r10 = t10, t10.dataLabels && (e10.hasDataLabels = () => true), t10.marker && (e10._hasPointMarkers = true));
          return r10;
        }
        pos(t10, e10 = this.plotY) {
          if (!this.destroyed) {
            let {
              plotX: i10,
              series: s10
            } = this, {
              chart: o10,
              xAxis: r10,
              yAxis: a10
            } = s10, n10 = 0, h10 = 0;
            if (oD(i10) && oD(e10)) return t10 && (n10 = r10 ? r10.pos : o10.plotLeft, h10 = a10 ? a10.pos : o10.plotTop), o10.inverted && r10 && a10 ? [a10.len - e10 + h10, r10.len - i10 + n10] : [i10 + n10, e10 + h10];
          }
        }
        resolveColor() {
          let t10 = this.series, e10 = t10.chart.options.chart, i10 = t10.chart.styledMode, s10, o10, r10 = e10.colorCount, a10;
          delete this.nonZonedColor, t10.options.colorByPoint ? (i10 || (s10 = (o10 = t10.options.colors || t10.chart.options.colors)[t10.colorCounter], r10 = o10.length), a10 = t10.colorCounter, t10.colorCounter++, t10.colorCounter === r10 && (t10.colorCounter = 0)) : (i10 || (s10 = t10.color), a10 = t10.colorIndex), this.colorIndex = oz(this.options.colorIndex, a10), this.color = oz(this.options.color, s10);
        }
        setNestedProperty(t10, e10, i10) {
          return i10.split(".").reduce(function(t11, i11, s10, o10) {
            let r10 = o10.length - 1 === s10;
            return t11[i11] = r10 ? e10 : oB(t11[i11], true) ? t11[i11] : {}, t11[i11];
          }, t10), t10;
        }
        shouldDraw() {
          return !this.isNull;
        }
        tooltipFormatter(t10) {
          let {
            chart: e10,
            pointArrayMap: i10 = ["y"],
            tooltipOptions: s10
          } = this.series, {
            valueDecimals: o10 = "",
            valuePrefix: r10 = "",
            valueSuffix: a10 = ""
          } = s10;
          return e10.styledMode && (t10 = e10.tooltip?.styledModeFormat(t10) || t10), i10.forEach((e11) => {
            e11 = "{point." + e11, (r10 || a10) && (t10 = t10.replace(RegExp(e11 + "}", "g"), r10 + e11 + "}" + a10)), t10 = t10.replace(RegExp(e11 + "}", "g"), e11 + ":,." + o10 + "f}");
          }), oS(t10, this, e10);
        }
        update(t10, e10, i10, s10) {
          let o10;
          let r10 = this, a10 = r10.series, n10 = r10.graphic, h10 = a10.chart, l2 = a10.options;
          function d2() {
            r10.applyOptions(t10);
            let s11 = n10 && r10.hasMockGraphic, d3 = null === r10.y ? !s11 : s11;
            n10 && d3 && (r10.graphic = n10.destroy(), delete r10.hasMockGraphic), oB(t10, true) && (n10 && n10.element && t10 && t10.marker && void 0 !== t10.marker.symbol && (r10.graphic = n10.destroy()), t10?.dataLabels && r10.dataLabel && (r10.dataLabel = r10.dataLabel.destroy())), o10 = r10.index;
            let c2 = {};
            for (let t11 of a10.dataColumnKeys()) c2[t11] = r10[t11];
            a10.dataTable.setRow(c2, o10), l2.data[o10] = oB(l2.data[o10], true) || oB(t10, true) ? r10.options : oz(t10, l2.data[o10]), a10.isDirty = a10.isDirtyData = true, !a10.fixedBox && a10.hasCartesianSeries && (h10.isDirtyBox = true), "point" === l2.legendType && (h10.isDirtyLegend = true), e10 && h10.redraw(i10);
          }
          e10 = oz(e10, true), false === s10 ? d2() : r10.firePointEvent("update", {
            options: t10
          }, d2);
        }
        remove(t10, e10) {
          this.series.removePoint(this.series.data.indexOf(this), t10, e10);
        }
        select(t10, e10) {
          let i10 = this, s10 = i10.series, o10 = s10.chart;
          t10 = oz(t10, !i10.selected), this.selectedStaging = t10, i10.firePointEvent(t10 ? "select" : "unselect", {
            accumulate: e10
          }, function() {
            i10.selected = i10.options.selected = t10, s10.options.data[s10.data.indexOf(i10)] = i10.options, i10.setState(t10 && "select"), e10 || o10.getSelectedPoints().forEach(function(t11) {
              let e11 = t11.series;
              t11.selected && t11 !== i10 && (t11.selected = t11.options.selected = false, e11.options.data[e11.data.indexOf(t11)] = t11.options, t11.setState(o10.hoverPoints && e11.options.inactiveOtherPoints ? "inactive" : ""), t11.firePointEvent("unselect"));
            });
          }), delete this.selectedStaging;
        }
        onMouseOver(t10) {
          let {
            inverted: e10,
            pointer: i10
          } = this.series.chart;
          i10 && (t10 = t10 ? i10.normalize(t10) : i10.getChartCoordinatesFromPoint(this, e10), i10.runPointActions(t10, this));
        }
        onMouseOut() {
          let t10 = this.series.chart;
          this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t10.hoverPoints || []).forEach(function(t11) {
            t11.setState();
          }), t10.hoverPoints = t10.hoverPoint = null;
        }
        manageEvent(t10) {
          let e10 = oN(this.series.options.point, this.options), i10 = e10.events?.[t10];
          oI(i10) && (!this.hcEvents?.[t10] || this.hcEvents?.[t10]?.map((t11) => t11.fn).indexOf(i10) === -1) ? (this.importedUserEvent?.(), this.importedUserEvent = oT(this, t10, i10), this.hcEvents && (this.hcEvents[t10].userEvent = true)) : this.importedUserEvent && !i10 && this.hcEvents?.[t10] && this.hcEvents?.[t10].userEvent && (oW(this, t10), delete this.hcEvents[t10], Object.keys(this.hcEvents) || delete this.importedUserEvent);
        }
        setState(t10, e10) {
          let i10 = this.series, s10 = this.state, o10 = i10.options.states[t10 || "normal"] || {}, r10 = oM.plotOptions[i10.type].marker && i10.options.marker, a10 = r10 && false === r10.enabled, n10 = r10 && r10.states && r10.states[t10 || "normal"] || {}, h10 = false === n10.enabled, l2 = this.marker || {}, d2 = i10.chart, c2 = r10 && i10.markerAttribs, p2 = i10.halo, g2, u2, f2, m2 = i10.stateMarkerGraphic, x2;
          if ((t10 = t10 || "") === this.state && !e10 || this.selected && "select" !== t10 || false === o10.enabled || t10 && (h10 || a10 && false === n10.enabled) || t10 && l2.states && l2.states[t10] && false === l2.states[t10].enabled) return;
          if (this.state = t10, c2 && (g2 = i10.markerAttribs(this, t10)), this.graphic && !this.hasMockGraphic) {
            if (s10 && this.graphic.removeClass("highcharts-point-" + s10), t10 && this.graphic.addClass("highcharts-point-" + t10), !d2.styledMode) {
              u2 = i10.pointAttribs(this, t10), f2 = oz(d2.options.chart.animation, o10.animation);
              let e11 = u2.opacity;
              i10.options.inactiveOtherPoints && oD(e11) && (this.dataLabels || []).forEach(function(t11) {
                t11 && !t11.hasClass("highcharts-data-label-hidden") && (t11.animate({
                  opacity: e11
                }, f2), t11.connector && t11.connector.animate({
                  opacity: e11
                }, f2));
              }), this.graphic.animate(u2, f2);
            }
            g2 && this.graphic.animate(g2, oz(d2.options.chart.animation, n10.animation, r10.animation)), m2 && m2.hide();
          } else t10 && n10 && (x2 = l2.symbol || i10.symbol, m2 && m2.currentSymbol !== x2 && (m2 = m2.destroy()), g2 && (m2 ? m2[e10 ? "animate" : "attr"]({
            x: g2.x,
            y: g2.y
          }) : x2 && (i10.stateMarkerGraphic = m2 = d2.renderer.symbol(x2, g2.x, g2.y, g2.width, g2.height, oN(r10, n10)).add(i10.markerGroup), m2.currentSymbol = x2)), !d2.styledMode && m2 && "inactive" !== this.state && m2.attr(i10.pointAttribs(this, t10))), m2 && (m2[t10 && this.isInside ? "show" : "hide"](), m2.element.point = this, m2.addClass(this.getClassName(), true));
          let y2 = o10.halo, b2 = this.graphic || m2, v2 = b2 && b2.visibility || "inherit";
          y2 && y2.size && b2 && "hidden" !== v2 && !this.isCluster ? (p2 || (i10.halo = p2 = d2.renderer.path().add(b2.parentGroup)), p2.show()[e10 ? "animate" : "attr"]({
            d: this.haloPath(y2.size)
          }), p2.attr({
            class: "highcharts-halo highcharts-color-" + oz(this.colorIndex, i10.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: v2,
            zIndex: -1
          }), p2.point = this, d2.styledMode || p2.attr(oP({
            fill: this.color || i10.color,
            "fill-opacity": y2.opacity
          }, tK.filterUserAttributes(y2.attributes || {})))) : p2?.point?.haloPath && !p2.point.destroyed && p2.animate({
            d: p2.point.haloPath(0)
          }, null, p2.hide), oL(this, "afterSetState", {
            state: t10
          });
        }
        haloPath(t10) {
          let e10 = this.pos();
          return e10 ? this.series.chart.renderer.symbols.circle(oC(e10[0], 1) - t10, e10[1] - t10, 2 * t10, 2 * t10) : [];
        }
      }
      let oF = oX, {
        parse: oG
      } = tk, {
        charts: oY,
        composed: oj,
        isTouchDevice: oU
      } = k, {
        addEvent: o$,
        attr: oV,
        css: o_,
        extend: oq,
        find: oZ,
        fireEvent: oK,
        isNumber: oJ,
        isObject: oQ,
        objectEach: o0,
        offset: o1,
        pick: o2,
        pushUnique: o3,
        splat: o5
      } = $;
      class o6 {
        applyInactiveState(t10) {
          let e10 = [], i10;
          (t10 || []).forEach(function(t11) {
            i10 = t11.series, e10.push(i10), i10.linkedParent && e10.push(i10.linkedParent), i10.linkedSeries && (e10 = e10.concat(i10.linkedSeries)), i10.navigatorSeries && e10.push(i10.navigatorSeries);
          }), this.chart.series.forEach(function(t11) {
            -1 === e10.indexOf(t11) ? t11.setState("inactive", true) : t11.options.inactiveOtherPoints && t11.setAllPointsToState("inactive");
          });
        }
        destroy() {
          let t10 = this;
          this.eventsToUnbind.forEach((t11) => t11()), this.eventsToUnbind = [], !k.chartCount && (o6.unbindDocumentMouseUp.forEach((t11) => t11.unbind()), o6.unbindDocumentMouseUp.length = 0, o6.unbindDocumentTouchEnd && (o6.unbindDocumentTouchEnd = o6.unbindDocumentTouchEnd())), clearInterval(t10.tooltipTimeout), o0(t10, function(e10, i10) {
            t10[i10] = void 0;
          });
        }
        getSelectionMarkerAttrs(t10, e10) {
          let i10 = {
            args: {
              chartX: t10,
              chartY: e10
            },
            attrs: {},
            shapeType: "rect"
          };
          return oK(this, "getSelectionMarkerAttrs", i10, (i11) => {
            let s10;
            let {
              chart: o10,
              zoomHor: r10,
              zoomVert: a10
            } = this, {
              mouseDownX: n10 = 0,
              mouseDownY: h10 = 0
            } = o10, l2 = i11.attrs;
            l2.x = o10.plotLeft, l2.y = o10.plotTop, l2.width = r10 ? 1 : o10.plotWidth, l2.height = a10 ? 1 : o10.plotHeight, r10 && (s10 = t10 - n10, l2.width = Math.max(1, Math.abs(s10)), l2.x = (s10 > 0 ? 0 : s10) + n10), a10 && (s10 = e10 - h10, l2.height = Math.max(1, Math.abs(s10)), l2.y = (s10 > 0 ? 0 : s10) + h10);
          }), i10;
        }
        drag(t10) {
          let {
            chart: e10
          } = this, {
            mouseDownX: i10 = 0,
            mouseDownY: s10 = 0
          } = e10, {
            panning: o10,
            panKey: r10,
            selectionMarkerFill: a10
          } = e10.options.chart, n10 = e10.plotLeft, h10 = e10.plotTop, l2 = e10.plotWidth, d2 = e10.plotHeight, c2 = oQ(o10) ? o10.enabled : o10, p2 = r10 && t10[`${r10}Key`], g2 = t10.chartX, u2 = t10.chartY, f2, m2 = this.selectionMarker;
          if ((!m2 || !m2.touch) && (g2 < n10 ? g2 = n10 : g2 > n10 + l2 && (g2 = n10 + l2), u2 < h10 ? u2 = h10 : u2 > h10 + d2 && (u2 = h10 + d2), this.hasDragged = Math.sqrt(Math.pow(i10 - g2, 2) + Math.pow(s10 - u2, 2)), this.hasDragged > 10)) {
            f2 = e10.isInsidePlot(i10 - n10, s10 - h10, {
              visiblePlotOnly: true
            });
            let {
              shapeType: r11,
              attrs: l3
            } = this.getSelectionMarkerAttrs(g2, u2);
            (e10.hasCartesianSeries || e10.mapView) && this.hasZoom && f2 && !p2 && !m2 && (this.selectionMarker = m2 = e10.renderer[r11](), m2.attr({
              class: "highcharts-selection-marker",
              zIndex: 7
            }).add(), e10.styledMode || m2.attr({
              fill: a10 || oG("#334eff").setOpacity(0.25).get()
            })), m2 && m2.attr(l3), f2 && !m2 && c2 && e10.pan(t10, o10);
          }
        }
        dragStart(t10) {
          let e10 = this.chart;
          e10.mouseIsDown = t10.type, e10.cancelClick = false, e10.mouseDownX = t10.chartX, e10.mouseDownY = t10.chartY;
        }
        getSelectionBox(t10) {
          let e10 = {
            args: {
              marker: t10
            },
            result: t10.getBBox()
          };
          return oK(this, "getSelectionBox", e10), e10.result;
        }
        drop(t10) {
          let e10;
          let {
            chart: i10,
            selectionMarker: s10
          } = this;
          for (let t11 of i10.axes) t11.isPanning && (t11.isPanning = false, (t11.options.startOnTick || t11.options.endOnTick || t11.series.some((t12) => t12.boosted)) && (t11.forceRedraw = true, t11.setExtremes(t11.userMin, t11.userMax, false), e10 = true));
          if (e10 && i10.redraw(), s10 && t10) {
            if (this.hasDragged) {
              let e11 = this.getSelectionBox(s10);
              i10.transform({
                axes: i10.axes.filter((t11) => t11.zoomEnabled && ("xAxis" === t11.coll && this.zoomX || "yAxis" === t11.coll && this.zoomY)),
                selection: __spreadValues({
                  originalEvent: t10,
                  xAxis: [],
                  yAxis: []
                }, e11),
                from: e11
              });
            }
            oJ(i10.index) && (this.selectionMarker = s10.destroy());
          }
          i10 && oJ(i10.index) && (o_(i10.container, {
            cursor: i10._cursor
          }), i10.cancelClick = this.hasDragged > 10, i10.mouseIsDown = false, this.hasDragged = 0, this.pinchDown = []);
        }
        findNearestKDPoint(t10, e10, i10) {
          let s10;
          return t10.forEach(function(t11) {
            let o10 = !(t11.noSharedTooltip && e10) && 0 > t11.options.findNearestPointBy.indexOf("y"), r10 = t11.searchPoint(i10, o10);
            oQ(r10, true) && r10.series && (!oQ(s10, true) || function(t12, i11) {
              let s11 = t12.distX - i11.distX, o11 = t12.dist - i11.dist, r11 = i11.series.group?.zIndex - t12.series.group?.zIndex;
              return 0 !== s11 && e10 ? s11 : 0 !== o11 ? o11 : 0 !== r11 ? r11 : t12.series.index > i11.series.index ? -1 : 1;
            }(s10, r10) > 0) && (s10 = r10);
          }), s10;
        }
        getChartCoordinatesFromPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = t10.series, o10 = t10.shapeArgs;
          if (i10 && s10) {
            let r10 = t10.clientX ?? t10.plotX ?? 0, a10 = t10.plotY || 0;
            return t10.isNode && o10 && oJ(o10.x) && oJ(o10.y) && (r10 = o10.x, a10 = o10.y), e10 ? {
              chartX: s10.len + s10.pos - a10,
              chartY: i10.len + i10.pos - r10
            } : {
              chartX: r10 + i10.pos,
              chartY: a10 + s10.pos
            };
          }
          if (o10 && o10.x && o10.y) return {
            chartX: o10.x,
            chartY: o10.y
          };
        }
        getChartPosition() {
          if (this.chartPosition) return this.chartPosition;
          let {
            container: t10
          } = this.chart, e10 = o1(t10);
          this.chartPosition = {
            left: e10.left,
            top: e10.top,
            scaleX: 1,
            scaleY: 1
          };
          let {
            offsetHeight: i10,
            offsetWidth: s10
          } = t10;
          return s10 > 2 && i10 > 2 && (this.chartPosition.scaleX = e10.width / s10, this.chartPosition.scaleY = e10.height / i10), this.chartPosition;
        }
        getCoordinates(t10) {
          let e10 = {
            xAxis: [],
            yAxis: []
          };
          for (let i10 of this.chart.axes) e10[i10.isXAxis ? "xAxis" : "yAxis"].push({
            axis: i10,
            value: i10.toValue(t10[i10.horiz ? "chartX" : "chartY"])
          });
          return e10;
        }
        getHoverData(t10, e10, i10, s10, o10, r10) {
          let a10 = [], n10 = function(t11) {
            return t11.visible && !(!o10 && t11.directTouch) && o2(t11.options.enableMouseTracking, true);
          }, h10 = e10, l2, d2 = {
            chartX: r10 ? r10.chartX : void 0,
            chartY: r10 ? r10.chartY : void 0,
            shared: o10
          };
          oK(this, "beforeGetHoverData", d2), l2 = h10 && !h10.stickyTracking ? [h10] : i10.filter((t11) => t11.stickyTracking && (d2.filter || n10)(t11));
          let c2 = s10 && t10 || !r10 ? t10 : this.findNearestKDPoint(l2, o10, r10);
          return h10 = c2 && c2.series, c2 && (o10 && !h10.noSharedTooltip ? (l2 = i10.filter(function(t11) {
            return d2.filter ? d2.filter(t11) : n10(t11) && !t11.noSharedTooltip;
          })).forEach(function(t11) {
            let e11 = oZ(t11.points, function(t12) {
              return t12.x === c2.x && !t12.isNull;
            });
            oQ(e11) && (t11.boosted && t11.boost && (e11 = t11.boost.getPoint(e11)), a10.push(e11));
          }) : a10.push(c2)), oK(this, "afterGetHoverData", d2 = {
            hoverPoint: c2
          }), {
            hoverPoint: d2.hoverPoint,
            hoverSeries: h10,
            hoverPoints: a10
          };
        }
        getPointFromEvent(t10) {
          let e10 = t10.target, i10;
          for (; e10 && !i10; ) i10 = e10.point, e10 = e10.parentNode;
          return i10;
        }
        onTrackerMouseOut(t10) {
          let e10 = this.chart, i10 = t10.relatedTarget, s10 = e10.hoverSeries;
          this.isDirectTouch = false, !s10 || !i10 || s10.stickyTracking || this.inClass(i10, "highcharts-tooltip") || this.inClass(i10, "highcharts-series-" + s10.index) && this.inClass(i10, "highcharts-tracker") || s10.onMouseOut();
        }
        inClass(t10, e10) {
          let i10 = t10, s10;
          for (; i10; ) {
            if (s10 = oV(i10, "class")) {
              if (-1 !== s10.indexOf(e10)) return true;
              if (-1 !== s10.indexOf("highcharts-container")) return false;
            }
            i10 = i10.parentElement;
          }
        }
        constructor(t10, e10) {
          this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e10, this.chart = t10, this.runChartClick = !!e10.chart.events?.click, this.pinchDown = [], this.setDOMEvents(), oK(this, "afterInit");
        }
        normalize(t10, e10) {
          let i10 = t10.touches, s10 = i10 ? i10.length ? i10.item(0) : o2(i10.changedTouches, t10.changedTouches)[0] : t10;
          e10 || (e10 = this.getChartPosition());
          let o10 = s10.pageX - e10.left, r10 = s10.pageY - e10.top;
          return oq(t10, {
            chartX: Math.round(o10 /= e10.scaleX),
            chartY: Math.round(r10 /= e10.scaleY)
          });
        }
        onContainerClick(t10) {
          let e10 = this.chart, i10 = e10.hoverPoint, s10 = this.normalize(t10), o10 = e10.plotLeft, r10 = e10.plotTop;
          !e10.cancelClick && (i10 && this.inClass(s10.target, "highcharts-tracker") ? (oK(i10.series, "click", oq(s10, {
            point: i10
          })), e10.hoverPoint && i10.firePointEvent("click", s10)) : (oq(s10, this.getCoordinates(s10)), e10.isInsidePlot(s10.chartX - o10, s10.chartY - r10, {
            visiblePlotOnly: true
          }) && oK(e10, "click", s10)));
        }
        onContainerMouseDown(t10) {
          let e10 = (1 & (t10.buttons || t10.button)) == 1;
          t10 = this.normalize(t10), k.isFirefox && 0 !== t10.button && this.onContainerMouseMove(t10), (void 0 === t10.button || e10) && (this.zoomOption(t10), e10 && t10.preventDefault?.(), this.dragStart(t10));
        }
        onContainerMouseLeave(t10) {
          let {
            pointer: e10
          } = oY[o2(o6.hoverChartIndex, -1)] || {};
          t10 = this.normalize(t10), this.onContainerMouseMove(t10), e10 && !this.inClass(t10.relatedTarget, "highcharts-tooltip") && (e10.reset(), e10.chartPosition = void 0);
        }
        onContainerMouseEnter() {
          delete this.chartPosition;
        }
        onContainerMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.normalize(t10);
          this.setHoverChartIndex(t10), ("mousedown" === e10.mouseIsDown || this.touchSelect(s10)) && this.drag(s10), !e10.openMenu && (this.inClass(s10.target, "highcharts-tracker") || e10.isInsidePlot(s10.chartX - e10.plotLeft, s10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          })) && !(i10 && i10.shouldStickOnContact(s10)) && (this.inClass(s10.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(s10));
        }
        onDocumentTouchEnd(t10) {
          this.onDocumentMouseUp(t10);
        }
        onContainerTouchMove(t10) {
          this.touchSelect(t10) ? this.onContainerMouseMove(t10) : this.touch(t10);
        }
        onContainerTouchStart(t10) {
          this.touchSelect(t10) ? this.onContainerMouseDown(t10) : (this.zoomOption(t10), this.touch(t10, true));
        }
        onDocumentMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.chartPosition, o10 = this.normalize(t10, s10);
          !s10 || e10.isInsidePlot(o10.chartX - e10.plotLeft, o10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          }) || i10 && i10.shouldStickOnContact(o10) || o10.target !== e10.container.ownerDocument && this.inClass(o10.target, "highcharts-tracker") || this.reset();
        }
        onDocumentMouseUp(t10) {
          oY[o2(o6.hoverChartIndex, -1)]?.pointer?.drop(t10);
        }
        pinch(t10) {
          let e10 = this, {
            chart: i10,
            hasZoom: s10,
            lastTouches: o10
          } = e10, r10 = [].map.call(t10.touches || [], (t11) => e10.normalize(t11)), a10 = r10.length, n10 = 1 === a10 && (e10.inClass(t10.target, "highcharts-tracker") && i10.runTrackerClick || e10.runChartClick), h10 = i10.tooltip, l2 = 1 === a10 && o2(h10?.options.followTouchMove, true);
          a10 > 1 ? e10.initiated = true : l2 && (e10.initiated = false), s10 && e10.initiated && !n10 && false !== t10.cancelable && t10.preventDefault(), "touchstart" === t10.type ? (e10.pinchDown = r10, e10.res = true, i10.mouseDownX = t10.chartX) : l2 ? this.runPointActions(e10.normalize(t10)) : o10 && (oK(i10, "touchpan", {
            originalEvent: t10,
            touches: r10
          }, () => {
            let e11 = (t11) => {
              let e12 = t11[0], i11 = t11[1] || e12;
              return {
                x: e12.chartX,
                y: e12.chartY,
                width: i11.chartX - e12.chartX,
                height: i11.chartY - e12.chartY
              };
            };
            i10.transform({
              axes: i10.axes.filter((t11) => t11.zoomEnabled && (this.zoomHor && t11.horiz || this.zoomVert && !t11.horiz)),
              to: e11(r10),
              from: e11(o10),
              trigger: t10.type
            });
          }), e10.res && (e10.res = false, this.reset(false, 0))), e10.lastTouches = r10;
        }
        reset(t10, e10) {
          let i10 = this.chart, s10 = i10.hoverSeries, o10 = i10.hoverPoint, r10 = i10.hoverPoints, a10 = i10.tooltip, n10 = a10 && a10.shared ? r10 : o10;
          t10 && n10 && o5(n10).forEach(function(e11) {
            e11.series.isCartesian && void 0 === e11.plotX && (t10 = false);
          }), t10 ? a10 && n10 && o5(n10).length && (a10.refresh(n10), a10.shared && r10 ? r10.forEach(function(t11) {
            t11.setState(t11.state, true), t11.series.isCartesian && (t11.series.xAxis.crosshair && t11.series.xAxis.drawCrosshair(null, t11), t11.series.yAxis.crosshair && t11.series.yAxis.drawCrosshair(null, t11));
          }) : o10 && (o10.setState(o10.state, true), i10.axes.forEach(function(t11) {
            t11.crosshair && o10.series[t11.coll] === t11 && t11.drawCrosshair(null, o10);
          }))) : (o10 && o10.onMouseOut(), r10 && r10.forEach(function(t11) {
            t11.setState();
          }), s10 && s10.onMouseOut(), a10 && a10.hide(e10), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i10.axes.forEach(function(t11) {
            t11.hideCrosshair();
          }), i10.hoverPoints = i10.hoverPoint = void 0);
        }
        runPointActions(t10, e10, i10) {
          let s10 = this.chart, o10 = s10.series, r10 = s10.tooltip && s10.tooltip.options.enabled ? s10.tooltip : void 0, a10 = !!r10 && r10.shared, n10 = e10 || s10.hoverPoint, h10 = n10 && n10.series || s10.hoverSeries, l2 = (!t10 || "touchmove" !== t10.type) && (!!e10 || h10 && h10.directTouch && this.isDirectTouch), d2 = this.getHoverData(n10, h10, o10, l2, a10, t10);
          n10 = d2.hoverPoint, h10 = d2.hoverSeries;
          let c2 = d2.hoverPoints, p2 = h10 && h10.tooltipOptions.followPointer && !h10.tooltipOptions.split, g2 = a10 && h10 && !h10.noSharedTooltip;
          if (n10 && (i10 || n10 !== s10.hoverPoint || r10 && r10.isHidden)) {
            if ((s10.hoverPoints || []).forEach(function(t11) {
              -1 === c2.indexOf(t11) && t11.setState();
            }), s10.hoverSeries !== h10 && h10.onMouseOver(), this.applyInactiveState(c2), (c2 || []).forEach(function(t11) {
              t11.setState("hover");
            }), s10.hoverPoint && s10.hoverPoint.firePointEvent("mouseOut"), !n10.series) return;
            s10.hoverPoints = c2, s10.hoverPoint = n10, n10.firePointEvent("mouseOver", void 0, () => {
              r10 && n10 && r10.refresh(g2 ? c2 : n10, t10);
            });
          } else if (p2 && r10 && !r10.isHidden) {
            let e11 = r10.getAnchor([{}], t10);
            s10.isInsidePlot(e11[0], e11[1], {
              visiblePlotOnly: true
            }) && r10.updatePosition({
              plotX: e11[0],
              plotY: e11[1]
            });
          }
          this.unDocMouseMove || (this.unDocMouseMove = o$(s10.container.ownerDocument, "mousemove", (t11) => oY[o6.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(t11)), this.eventsToUnbind.push(this.unDocMouseMove)), s10.axes.forEach(function(e11) {
            let i11;
            let o11 = o2((e11.crosshair || {}).snap, true);
            !o11 || (i11 = s10.hoverPoint) && i11.series[e11.coll] === e11 || (i11 = oZ(c2, (t11) => t11.series && t11.series[e11.coll] === e11)), i11 || !o11 ? e11.drawCrosshair(t10, i11) : e11.hideCrosshair();
          });
        }
        setDOMEvents() {
          let t10 = this.chart.container, e10 = t10.ownerDocument;
          t10.onmousedown = this.onContainerMouseDown.bind(this), t10.onmousemove = this.onContainerMouseMove.bind(this), t10.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(o$(t10, "mouseenter", this.onContainerMouseEnter.bind(this)), o$(t10, "mouseleave", this.onContainerMouseLeave.bind(this))), o6.unbindDocumentMouseUp.some((t11) => t11.doc === e10) || o6.unbindDocumentMouseUp.push({
            doc: e10,
            unbind: o$(e10, "mouseup", this.onDocumentMouseUp.bind(this))
          });
          let i10 = this.chart.renderTo.parentElement;
          for (; i10 && "BODY" !== i10.tagName; ) this.eventsToUnbind.push(o$(i10, "scroll", () => {
            delete this.chartPosition;
          })), i10 = i10.parentElement;
          this.eventsToUnbind.push(o$(t10, "touchstart", this.onContainerTouchStart.bind(this), {
            passive: false
          }), o$(t10, "touchmove", this.onContainerTouchMove.bind(this), {
            passive: false
          })), o6.unbindDocumentTouchEnd || (o6.unbindDocumentTouchEnd = o$(e10, "touchend", this.onDocumentTouchEnd.bind(this), {
            passive: false
          })), this.setPointerCapture(), o$(this.chart, "redraw", this.setPointerCapture.bind(this));
        }
        setPointerCapture() {
          if (!oU) return;
          let t10 = this.pointerCaptureEventsToUnbind, e10 = this.chart, i10 = e10.container, s10 = o2(e10.options.tooltip?.followTouchMove, true) && e10.series.some((t11) => t11.options.findNearestPointBy.indexOf("y") > -1);
          !this.hasPointerCapture && s10 ? (t10.push(o$(i10, "pointerdown", (t11) => {
            t11.target?.hasPointerCapture(t11.pointerId) && t11.target?.releasePointerCapture(t11.pointerId);
          }), o$(i10, "pointermove", (t11) => {
            e10.pointer?.getPointFromEvent(t11)?.onMouseOver(t11);
          })), e10.styledMode || o_(i10, {
            "touch-action": "none"
          }), i10.className += " highcharts-no-touch-action", this.hasPointerCapture = true) : this.hasPointerCapture && !s10 && (t10.forEach((t11) => t11()), t10.length = 0, e10.styledMode || o_(i10, {
            "touch-action": o2(e10.options.chart.style?.["touch-action"], "manipulation")
          }), i10.className = i10.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = false);
        }
        setHoverChartIndex(t10) {
          let e10 = this.chart, i10 = k.charts[o2(o6.hoverChartIndex, -1)];
          if (i10 && i10 !== e10) {
            let s10 = {
              relatedTarget: e10.container
            };
            t10 && !t10?.relatedTarget && Object.assign({}, t10, s10), i10.pointer?.onContainerMouseLeave(t10 || s10);
          }
          i10 && i10.mouseIsDown || (o6.hoverChartIndex = e10.index);
        }
        touch(t10, e10) {
          let i10;
          let {
            chart: s10,
            pinchDown: o10 = []
          } = this;
          this.setHoverChartIndex(), 1 === (t10 = this.normalize(t10)).touches.length ? s10.isInsidePlot(t10.chartX - s10.plotLeft, t10.chartY - s10.plotTop, {
            visiblePlotOnly: true
          }) && !s10.openMenu ? (e10 && this.runPointActions(t10), "touchmove" === t10.type && (i10 = !!o10[0] && Math.pow(o10[0].chartX - t10.chartX, 2) + Math.pow(o10[0].chartY - t10.chartY, 2) >= 16), o2(i10, true) && this.pinch(t10)) : e10 && this.reset() : 2 === t10.touches.length && this.pinch(t10);
        }
        touchSelect(t10) {
          return !!(this.chart.zooming.singleTouch && t10.touches && 1 === t10.touches.length);
        }
        zoomOption(t10) {
          let e10 = this.chart, i10 = e10.inverted, s10 = e10.zooming.type || "", o10, r10;
          /touch/.test(t10.type) && (s10 = o2(e10.zooming.pinchType, s10)), this.zoomX = o10 = /x/.test(s10), this.zoomY = r10 = /y/.test(s10), this.zoomHor = o10 && !i10 || r10 && i10, this.zoomVert = r10 && !i10 || o10 && i10, this.hasZoom = o10 || r10;
        }
      }
      o6.unbindDocumentMouseUp = [], function(t10) {
        t10.compose = function(e10) {
          o3(oj, "Core.Pointer") && o$(e10, "beforeRender", function() {
            this.pointer = new t10(this, this.options);
          });
        };
      }(o6 || (o6 = {}));
      let o9 = o6, {
        fireEvent: o4,
        isArray: o8,
        objectEach: o7,
        uniqueKey: rt
      } = $, re = class {
        constructor(t10 = {}) {
          this.autoId = !t10.id, this.columns = {}, this.id = t10.id || rt(), this.modified = this, this.rowCount = 0, this.versionTag = rt();
          let e10 = 0;
          o7(t10.columns || {}, (t11, i10) => {
            this.columns[i10] = t11.slice(), e10 = Math.max(e10, t11.length);
          }), this.applyRowCount(e10);
        }
        applyRowCount(t10) {
          this.rowCount = t10, o7(this.columns, (e10) => {
            o8(e10) && (e10.length = t10);
          });
        }
        getColumn(t10, e10) {
          return this.columns[t10];
        }
        getColumns(t10, e10) {
          return (t10 || Object.keys(this.columns)).reduce((t11, e11) => (t11[e11] = this.columns[e11], t11), {});
        }
        getRow(t10, e10) {
          return (e10 || Object.keys(this.columns)).map((e11) => this.columns[e11]?.[t10]);
        }
        setColumn(t10, e10 = [], i10 = 0, s10) {
          this.setColumns({
            [t10]: e10
          }, i10, s10);
        }
        setColumns(t10, e10, i10) {
          let s10 = this.rowCount;
          o7(t10, (t11, e11) => {
            this.columns[e11] = t11.slice(), s10 = t11.length;
          }), this.applyRowCount(s10), i10?.silent || (o4(this, "afterSetColumns"), this.versionTag = rt());
        }
        setRow(t10, e10 = this.rowCount, i10, s10) {
          let {
            columns: o10
          } = this, r10 = i10 ? this.rowCount + 1 : e10 + 1;
          o7(t10, (t11, a10) => {
            let n10 = o10[a10] || s10?.addColumns !== false && Array(r10);
            n10 && (i10 ? n10.splice(e10, 0, t11) : n10[e10] = t11, o10[a10] = n10);
          }), r10 > this.rowCount && this.applyRowCount(r10), s10?.silent || (o4(this, "afterSetRows"), this.versionTag = rt());
        }
      }, {
        extend: ri,
        merge: rs,
        pick: ro
      } = $;
      !function(t10) {
        function e10(t11, e11, i10) {
          let s10 = this.legendItem = this.legendItem || {}, {
            chart: o10,
            options: r10
          } = this, {
            baseline: a10 = 0,
            symbolWidth: n10,
            symbolHeight: h10
          } = t11, l2 = this.symbol || "circle", d2 = h10 / 2, c2 = o10.renderer, p2 = s10.group, g2 = a10 - Math.round((t11.fontMetrics?.b || h10) * (i10 ? 0.4 : 0.3)), u2 = {}, f2, m2 = r10.marker, x2 = 0;
          if (o10.styledMode || (u2["stroke-width"] = Math.min(r10.lineWidth || 0, 24), r10.dashStyle ? u2.dashstyle = r10.dashStyle : "square" === r10.linecap || (u2["stroke-linecap"] = "round")), s10.line = c2.path().addClass("highcharts-graph").attr(u2).add(p2), i10 && (s10.area = c2.path().addClass("highcharts-area").add(p2)), u2["stroke-linecap"] && (x2 = Math.min(s10.line.strokeWidth(), n10) / 2), n10) {
            let t12 = [["M", x2, g2], ["L", n10 - x2, g2]];
            s10.line.attr({
              d: t12
            }), s10.area?.attr({
              d: [...t12, ["L", n10 - x2, a10], ["L", x2, a10]]
            });
          }
          if (m2 && false !== m2.enabled && n10) {
            let t12 = Math.min(ro(m2.radius, d2), d2);
            0 === l2.indexOf("url") && (m2 = rs(m2, {
              width: h10,
              height: h10
            }), t12 = 0), s10.symbol = f2 = c2.symbol(l2, n10 / 2 - t12, g2 - t12, 2 * t12, 2 * t12, ri({
              context: "legend"
            }, m2)).addClass("highcharts-point").add(p2), f2.isMarker = true;
          }
        }
        t10.areaMarker = function(t11, i10) {
          e10.call(this, t11, i10, true);
        }, t10.lineMarker = e10, t10.rectangle = function(t11, e11) {
          let i10 = e11.legendItem || {}, s10 = t11.options, o10 = t11.symbolHeight, r10 = s10.squareSymbol, a10 = r10 ? o10 : t11.symbolWidth;
          i10.symbol = this.chart.renderer.rect(r10 ? (t11.symbolWidth - o10) / 2 : 0, t11.baseline - o10 + 1, a10, o10, ro(t11.options.symbolRadius, o10 / 2)).addClass("highcharts-point").attr({
            zIndex: 3
          }).add(i10.group);
        };
      }(d || (d = {}));
      let rr = d, {
        defaultOptions: ra
      } = tm, {
        extend: rn,
        extendClass: rh,
        merge: rl
      } = $;
      !function(t10) {
        function e10(e11, i10) {
          let s10 = ra.plotOptions || {}, o10 = i10.defaultOptions, r10 = i10.prototype;
          return r10.type = e11, r10.pointClass || (r10.pointClass = oF), !t10.seriesTypes[e11] && (o10 && (s10[e11] = o10), t10.seriesTypes[e11] = i10, true);
        }
        t10.seriesTypes = k.seriesTypes, t10.registerSeriesType = e10, t10.seriesType = function(i10, s10, o10, r10, a10) {
          let n10 = ra.plotOptions || {};
          if (s10 = s10 || "", n10[i10] = rl(n10[s10], o10), delete t10.seriesTypes[i10], e10(i10, rh(t10.seriesTypes[s10] || function() {
          }, r10)), t10.seriesTypes[i10].prototype.type = i10, a10) {
            class e11 extends oF {
            }
            rn(e11.prototype, a10), t10.seriesTypes[i10].prototype.pointClass = e11;
          }
          return t10.seriesTypes[i10];
        };
      }(c || (c = {}));
      let rd = c, {
        animObject: rc,
        setAnimation: rp
      } = tR, {
        defaultOptions: rg
      } = tm, {
        registerEventOptions: ru
      } = i3, {
        svg: rf,
        win: rm
      } = k, {
        seriesTypes: rx
      } = rd, {
        arrayMax: ry,
        arrayMin: rb,
        clamp: rv,
        correctFloat: rk,
        crisp: rw,
        defined: rM,
        destroyObjectProperties: rS,
        diffObjects: rT,
        erase: rC,
        error: rA,
        extend: rP,
        find: rL,
        fireEvent: rO,
        getClosestDistance: rE,
        getNestedProperty: rI,
        insertItem: rD,
        isArray: rB,
        isNumber: rN,
        isString: rz,
        merge: rR,
        objectEach: rW,
        pick: rH,
        removeEvent: rX,
        syncTimeout: rF
      } = $;
      class rG {
        constructor() {
          this.zoneAxis = "y";
        }
        init(t10, e10) {
          let i10;
          rO(this, "init", {
            options: e10
          }), this.dataTable ?? (this.dataTable = new re());
          let s10 = t10.series;
          this.eventsToUnbind = [], this.chart = t10, this.options = this.setOptions(e10);
          let o10 = this.options, r10 = false !== o10.visible;
          this.linkedSeries = [], this.bindAxes(), rP(this, {
            name: o10.name,
            state: "",
            visible: r10,
            selected: true === o10.selected
          }), ru(this, o10);
          let a10 = o10.events;
          (a10 && a10.click || o10.point && o10.point.events && o10.point.events.click || o10.allowPointSelect) && (t10.runTrackerClick = true), this.getColor(), this.getSymbol(), this.isCartesian && (t10.hasCartesianSeries = true), s10.length && (i10 = s10[s10.length - 1]), this._i = rH(i10 && i10._i, -1) + 1, this.opacity = this.options.opacity, t10.orderItems("series", rD(this, s10)), o10.dataSorting && o10.dataSorting.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o10.data, false), rO(this, "afterInit");
        }
        is(t10) {
          return rx[t10] && this instanceof rx[t10];
        }
        bindAxes() {
          let t10;
          let e10 = this, i10 = e10.options, s10 = e10.chart;
          rO(this, "bindAxes", null, function() {
            (e10.axisTypes || []).forEach(function(o10) {
              (s10[o10] || []).forEach(function(s11) {
                t10 = s11.options, (rH(i10[o10], 0) === s11.index || void 0 !== i10[o10] && i10[o10] === t10.id) && (rD(e10, s11.series), e10[o10] = s11, s11.isDirty = true);
              }), e10[o10] || e10.optionalAxis === o10 || rA(18, true, s10);
            });
          }), rO(this, "afterBindAxes");
        }
        hasData() {
          return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;
        }
        hasMarkerChanged(t10, e10) {
          let i10 = t10.marker, s10 = e10.marker || {};
          return i10 && (s10.enabled && !i10.enabled || s10.symbol !== i10.symbol || s10.height !== i10.height || s10.width !== i10.width);
        }
        autoIncrement(t10) {
          let e10;
          let i10 = this.options, {
            pointIntervalUnit: s10,
            relativeXValue: o10
          } = this.options, r10 = this.chart.time, a10 = this.xIncrement ?? r10.parse(i10.pointStart) ?? 0;
          if (this.pointInterval = e10 = rH(this.pointInterval, i10.pointInterval, 1), o10 && rN(t10) && (e10 *= t10), s10) {
            let t11 = r10.toParts(a10);
            "day" === s10 ? t11[2] += e10 : "month" === s10 ? t11[1] += e10 : "year" === s10 && (t11[0] += e10), e10 = r10.makeTime.apply(r10, t11) - a10;
          }
          return o10 && rN(t10) ? a10 + e10 : (this.xIncrement = a10 + e10, a10);
        }
        setDataSortingOptions() {
          let t10 = this.options;
          rP(this, {
            requireSorting: false,
            sorted: false,
            enabledDataSorting: true,
            allowDG: false
          }), rM(t10.pointRange) || (t10.pointRange = 1);
        }
        setOptions(t10) {
          let e10;
          let i10 = this.chart, s10 = i10.options.plotOptions, o10 = i10.userOptions || {}, r10 = rR(t10), a10 = i10.styledMode, n10 = {
            plotOptions: s10,
            userOptions: r10
          };
          rO(this, "setOptions", n10);
          let h10 = n10.plotOptions[this.type], l2 = o10.plotOptions || {}, d2 = l2.series || {}, c2 = rg.plotOptions[this.type] || {}, p2 = l2[this.type] || {};
          this.userOptions = n10.userOptions;
          let g2 = rR(h10, s10.series, p2, r10);
          this.tooltipOptions = rR(rg.tooltip, rg.plotOptions.series?.tooltip, c2?.tooltip, i10.userOptions.tooltip, l2.series?.tooltip, p2.tooltip, r10.tooltip), this.stickyTracking = rH(r10.stickyTracking, p2.stickyTracking, d2.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || g2.stickyTracking), null === h10.marker && delete g2.marker, this.zoneAxis = g2.zoneAxis || "y";
          let u2 = this.zones = (g2.zones || []).map((t11) => __spreadValues({}, t11));
          return (g2.negativeColor || g2.negativeFillColor) && !g2.zones && (e10 = {
            value: g2[this.zoneAxis + "Threshold"] || g2.threshold || 0,
            className: "highcharts-negative"
          }, a10 || (e10.color = g2.negativeColor, e10.fillColor = g2.negativeFillColor), u2.push(e10)), u2.length && rM(u2[u2.length - 1].value) && u2.push(a10 ? {} : {
            color: this.color,
            fillColor: this.fillColor
          }), rO(this, "afterSetOptions", {
            options: g2
          }), g2;
        }
        getName() {
          return rH(this.options.name, "Series " + (this.index + 1));
        }
        getCyclic(t10, e10, i10) {
          let s10, o10;
          let r10 = this.chart, a10 = `${t10}Index`, n10 = `${t10}Counter`, h10 = i10?.length || r10.options.chart.colorCount;
          !e10 && (rM(o10 = rH("color" === t10 ? this.options.colorIndex : void 0, this[a10])) ? s10 = o10 : (r10.series.length || (r10[n10] = 0), s10 = r10[n10] % h10, r10[n10] += 1), i10 && (e10 = i10[s10])), void 0 !== s10 && (this[a10] = s10), this[t10] = e10;
        }
        getColor() {
          this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || rg.plotOptions[this.type].color, this.chart.options.colors);
        }
        getPointsCollection() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        }
        getSymbol() {
          let t10 = this.options.marker;
          this.getCyclic("symbol", t10.symbol, this.chart.options.symbols);
        }
        getColumn(t10, e10) {
          return (e10 ? this.dataTable.modified : this.dataTable).getColumn(t10, true) || [];
        }
        findPointIndex(t10, e10) {
          let i10, s10, o10;
          let r10 = t10.id, a10 = t10.x, n10 = this.points, h10 = this.options.dataSorting;
          if (r10) {
            let t11 = this.chart.get(r10);
            t11 instanceof oF && (i10 = t11);
          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            let e11 = (e12) => !e12.touched && e12.index === t10.index;
            if (h10 && h10.matchByName ? e11 = (e12) => !e12.touched && e12.name === t10.name : this.options.relativeXValue && (e11 = (e12) => !e12.touched && e12.options.x === t10.x), !(i10 = rL(n10, e11))) return;
          }
          return i10 && void 0 !== (o10 = i10 && i10.index) && (s10 = true), void 0 === o10 && rN(a10) && (o10 = this.getColumn("x").indexOf(a10, e10)), -1 !== o10 && void 0 !== o10 && this.cropped && (o10 = o10 >= this.cropStart ? o10 - this.cropStart : o10), !s10 && rN(o10) && n10[o10] && n10[o10].touched && (o10 = void 0), o10;
        }
        updateData(t10, e10) {
          let i10 = this.options, s10 = i10.dataSorting, o10 = this.points, r10 = [], a10 = this.requireSorting, n10 = t10.length === o10.length, h10, l2, d2, c2, p2 = true;
          if (this.xIncrement = null, t10.forEach(function(t11, e11) {
            let l3;
            let d3 = rM(t11) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, t11) || {}, p3 = d3.x;
            d3.id || rN(p3) ? (-1 === (l3 = this.findPointIndex(d3, c2)) || void 0 === l3 ? r10.push(t11) : o10[l3] && t11 !== i10.data[l3] ? (o10[l3].update(t11, false, null, false), o10[l3].touched = true, a10 && (c2 = l3 + 1)) : o10[l3] && (o10[l3].touched = true), (!n10 || e11 !== l3 || s10 && s10.enabled || this.hasDerivedData) && (h10 = true)) : r10.push(t11);
          }, this), h10) for (l2 = o10.length; l2--; ) (d2 = o10[l2]) && !d2.touched && d2.remove && d2.remove(false, e10);
          else !n10 || s10 && s10.enabled ? p2 = false : (t10.forEach(function(t11, e11) {
            t11 === o10[e11].y || o10[e11].destroyed || o10[e11].update(t11, false, null, false);
          }), r10.length = 0);
          if (o10.forEach(function(t11) {
            t11 && (t11.touched = false);
          }), !p2) return false;
          r10.forEach(function(t11) {
            this.addPoint(t11, false, null, null, false);
          }, this);
          let g2 = this.getColumn("x");
          return null === this.xIncrement && g2.length && (this.xIncrement = ry(g2), this.autoIncrement()), true;
        }
        dataColumnKeys() {
          return ["x", ...this.pointArrayMap || ["y"]];
        }
        setData(t10, e10 = true, i10, s10) {
          let o10 = this.points, r10 = o10 && o10.length || 0, a10 = this.options, n10 = this.chart, h10 = a10.dataSorting, l2 = this.xAxis, d2 = a10.turboThreshold, c2 = this.dataTable, p2 = this.dataColumnKeys(), g2 = this.pointValKey || "y", u2 = (this.pointArrayMap || []).length, f2 = a10.keys, m2, x2, y2 = 0, b2 = 1, v2;
          n10.options.chart.allowMutatingData || (a10.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v2 = rR(true, t10));
          let k2 = (t10 = v2 || t10 || []).length;
          if (h10 && h10.enabled && (t10 = this.sortData(t10)), n10.options.chart.allowMutatingData && false !== s10 && k2 && r10 && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x2 = this.updateData(t10, i10)), !x2) {
            this.xIncrement = null, this.colorCounter = 0;
            let e11 = d2 && k2 > d2;
            if (e11) {
              let i11 = this.getFirstValidPoint(t10), s11 = this.getFirstValidPoint(t10, k2 - 1, -1), o11 = (t11) => !!(rB(t11) && (f2 || rN(t11[0])));
              if (rN(i11) && rN(s11)) {
                let e12 = [], i12 = [];
                for (let s12 of t10) e12.push(this.autoIncrement()), i12.push(s12);
                c2.setColumns({
                  x: e12,
                  [g2]: i12
                });
              } else if (o11(i11) && o11(s11)) {
                if (u2) {
                  let e12 = i11.length === u2 ? 1 : 0, s12 = Array(p2.length).fill(0).map(() => []);
                  for (let i12 of t10) {
                    e12 && s12[0].push(this.autoIncrement());
                    for (let t11 = e12; t11 <= u2; t11++) s12[t11]?.push(i12[t11 - e12]);
                  }
                  c2.setColumns(p2.reduce((t11, e13, i12) => (t11[e13] = s12[i12], t11), {}));
                } else {
                  f2 && (y2 = f2.indexOf("x"), b2 = f2.indexOf("y"), y2 = y2 >= 0 ? y2 : 0, b2 = b2 >= 0 ? b2 : 1), 1 === i11.length && (b2 = 0);
                  let e12 = [], s12 = [];
                  if (y2 === b2) for (let i12 of t10) e12.push(this.autoIncrement()), s12.push(i12[b2]);
                  else for (let i12 of t10) e12.push(i12[y2]), s12.push(i12[b2]);
                  c2.setColumns({
                    x: e12,
                    [g2]: s12
                  });
                }
              } else e11 = false;
            }
            if (!e11) {
              let e12 = p2.reduce((t11, e13) => (t11[e13] = [], t11), {});
              for (m2 = 0; m2 < k2; m2++) {
                let i11 = this.pointClass.prototype.applyOptions.apply({
                  series: this
                }, [t10[m2]]);
                for (let t11 of p2) e12[t11][m2] = i11[t11];
              }
              c2.setColumns(e12);
            }
            for (rz(this.getColumn("y")[0]) && rA(14, true, n10), this.data = [], this.options.data = this.userOptions.data = t10, m2 = r10; m2--; ) o10[m2]?.destroy();
            l2 && (l2.minRange = l2.userMinRange), this.isDirty = n10.isDirtyBox = true, this.isDirtyData = !!o10, i10 = false;
          }
          "point" === a10.legendType && (this.processData(), this.generatePoints()), e10 && n10.redraw(i10);
        }
        sortData(t10) {
          let e10 = this, i10 = e10.options.dataSorting.sortKey || "y", s10 = function(t11, e11) {
            return rM(e11) && t11.pointClass.prototype.optionsToObject.call({
              series: t11
            }, e11) || {};
          };
          return t10.forEach(function(i11, o10) {
            t10[o10] = s10(e10, i11), t10[o10].index = o10;
          }, this), t10.concat().sort((t11, e11) => {
            let s11 = rI(i10, t11), o10 = rI(i10, e11);
            return o10 < s11 ? -1 : o10 > s11 ? 1 : 0;
          }).forEach(function(t11, e11) {
            t11.x = e11;
          }, this), e10.linkedSeries && e10.linkedSeries.forEach(function(e11) {
            let i11 = e11.options, o10 = i11.data;
            i11.dataSorting && i11.dataSorting.enabled || !o10 || (o10.forEach(function(i12, r10) {
              o10[r10] = s10(e11, i12), t10[r10] && (o10[r10].x = t10[r10].x, o10[r10].index = r10);
            }), e11.setData(o10, false));
          }), t10;
        }
        getProcessedData(t10) {
          let e10 = this, {
            dataTable: i10,
            isCartesian: s10,
            options: o10,
            xAxis: r10
          } = e10, a10 = o10.cropThreshold, n10 = t10 || e10.getExtremesFromAll, h10 = r10?.logarithmic, l2 = i10.rowCount, d2, c2, p2 = 0, g2, u2, f2, m2 = e10.getColumn("x"), x2 = i10, y2 = false;
          return r10 && (u2 = (g2 = r10.getExtremes()).min, f2 = g2.max, y2 = !!(r10.categories && !r10.names.length), s10 && e10.sorted && !n10 && (!a10 || l2 > a10 || e10.forceCrop) && (m2[l2 - 1] < u2 || m2[0] > f2 ? x2 = new re() : e10.getColumn(e10.pointValKey || "y").length && (m2[0] < u2 || m2[l2 - 1] > f2) && (x2 = (d2 = this.cropData(i10, u2, f2)).modified, p2 = d2.start, c2 = true))), m2 = x2.getColumn("x") || [], {
            modified: x2,
            cropped: c2,
            cropStart: p2,
            closestPointRange: rE([h10 ? m2.map(h10.log2lin) : m2], () => e10.requireSorting && !y2 && rA(15, false, e10.chart))
          };
        }
        processData(t10) {
          let e10 = this.xAxis, i10 = this.dataTable;
          if (this.isCartesian && !this.isDirty && !e10.isDirty && !this.yAxis.isDirty && !t10) return false;
          let s10 = this.getProcessedData();
          i10.modified = s10.modified, this.cropped = s10.cropped, this.cropStart = s10.cropStart, this.closestPointRange = this.basePointRange = s10.closestPointRange, rO(this, "afterProcessData");
        }
        cropData(t10, e10, i10) {
          let s10 = t10.getColumn("x", true) || [], o10 = s10.length, r10 = {}, a10, n10, h10 = 0, l2 = o10;
          for (a10 = 0; a10 < o10; a10++) if (s10[a10] >= e10) {
            h10 = Math.max(0, a10 - 1);
            break;
          }
          for (n10 = a10; n10 < o10; n10++) if (s10[n10] > i10) {
            l2 = n10 + 1;
            break;
          }
          for (let e11 of this.dataColumnKeys()) {
            let i11 = t10.getColumn(e11, true);
            i11 && (r10[e11] = i11.slice(h10, l2));
          }
          return {
            modified: new re({
              columns: r10
            }),
            start: h10,
            end: l2
          };
        }
        generatePoints() {
          let t10 = this.options, e10 = this.processedData || t10.data, i10 = this.dataTable.modified, s10 = this.getColumn("x", true), o10 = this.pointClass, r10 = i10.rowCount, a10 = this.cropStart || 0, n10 = this.hasGroupedData, h10 = t10.keys, l2 = [], d2 = t10.dataGrouping && t10.dataGrouping.groupAll ? a10 : 0, c2 = this.xAxis?.categories, p2 = this.pointArrayMap || ["y"], g2 = this.dataColumnKeys(), u2, f2, m2, x2, y2 = this.data, b2;
          if (!y2 && !n10) {
            let t11 = [];
            t11.length = e10?.length || 0, y2 = this.data = t11;
          }
          for (h10 && n10 && (this.options.keys = false), x2 = 0; x2 < r10; x2++) f2 = a10 + x2, n10 ? ((m2 = new o10(this, i10.getRow(x2, g2) || [])).dataGroup = this.groupMap[d2 + x2], m2.dataGroup?.options && (m2.options = m2.dataGroup.options, rP(m2, m2.dataGroup.options), delete m2.dataLabels)) : (m2 = y2[f2], b2 = e10 ? e10[f2] : i10.getRow(x2, p2), m2 || void 0 === b2 || (y2[f2] = m2 = new o10(this, b2, s10[x2]))), m2 && (m2.index = n10 ? d2 + x2 : f2, l2[x2] = m2, m2.category = c2?.[m2.x] ?? m2.x, m2.key = m2.name ?? m2.category);
          if (this.options.keys = h10, y2 && (r10 !== (u2 = y2.length) || n10)) for (x2 = 0; x2 < u2; x2++) x2 !== a10 || n10 || (x2 += r10), y2[x2] && (y2[x2].destroyElements(), y2[x2].plotX = void 0);
          this.data = y2, this.points = l2, rO(this, "afterGeneratePoints");
        }
        getXExtremes(t10) {
          return {
            min: rb(t10),
            max: ry(t10)
          };
        }
        getExtremes(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = e10 || this.getExtremesFromAll || this.options.getExtremesFromAll, r10 = o10 && this.cropped ? this.dataTable : this.dataTable.modified, a10 = r10.rowCount, n10 = t10 || this.stackedYData, h10 = n10 ? [n10] : (this.keysAffectYAxis || this.pointArrayMap || ["y"])?.map((t11) => r10.getColumn(t11, true) || []) || [], l2 = this.getColumn("x", true), d2 = [], c2 = this.requireSorting && !this.is("column") ? 1 : 0, p2 = !!s10 && s10.positiveValuesOnly, g2 = o10 || this.cropped || !i10, u2, f2, m2, x2 = 0, y2 = 0;
          for (i10 && (x2 = (u2 = i10.getExtremes()).min, y2 = u2.max), m2 = 0; m2 < a10; m2++) if (f2 = l2[m2], g2 || (l2[m2 + c2] || f2) >= x2 && (l2[m2 - c2] || f2) <= y2) for (let t11 of h10) {
            let e11 = t11[m2];
            rN(e11) && (e11 > 0 || !p2) && d2.push(e11);
          }
          let b2 = {
            activeYData: d2,
            dataMin: rb(d2),
            dataMax: ry(d2)
          };
          return rO(this, "afterGetExtremes", {
            dataExtremes: b2
          }), b2;
        }
        applyExtremes() {
          let t10 = this.getExtremes();
          return this.dataMin = t10.dataMin, this.dataMax = t10.dataMax, t10;
        }
        getFirstValidPoint(t10, e10 = 0, i10 = 1) {
          let s10 = t10.length, o10 = e10;
          for (; o10 >= 0 && o10 < s10; ) {
            if (rM(t10[o10])) return t10[o10];
            o10 += i10;
          }
        }
        translate() {
          this.generatePoints();
          let t10 = this.options, e10 = t10.stacking, i10 = this.xAxis, s10 = this.enabledDataSorting, o10 = this.yAxis, r10 = this.points, a10 = r10.length, n10 = this.pointPlacementToXValue(), h10 = !!n10, l2 = t10.threshold, d2 = t10.startFromThreshold ? l2 : 0, c2, p2, g2, u2, f2 = Number.MAX_VALUE;
          function m2(t11) {
            return rv(t11, -1e9, 1e9);
          }
          for (c2 = 0; c2 < a10; c2++) {
            let t11;
            let a11 = r10[c2], x2 = a11.x, y2, b2, v2 = a11.y, k2 = a11.low, w2 = e10 && o10.stacking?.stacks[(this.negStacks && v2 < (d2 ? 0 : l2) ? "-" : "") + this.stackKey];
            p2 = i10.translate(x2, false, false, false, true, n10), a11.plotX = rN(p2) ? rk(m2(p2)) : void 0, e10 && this.visible && w2 && w2[x2] && (u2 = this.getStackIndicator(u2, x2, this.index), !a11.isNull && u2.key && (b2 = (y2 = w2[x2]).points[u2.key]), y2 && rB(b2) && (k2 = b2[0], v2 = b2[1], k2 === d2 && u2.key === w2[x2].base && (k2 = rH(rN(l2) ? l2 : o10.min)), o10.positiveValuesOnly && rM(k2) && k2 <= 0 && (k2 = void 0), a11.total = a11.stackTotal = rH(y2.total), a11.percentage = rM(a11.y) && y2.total ? a11.y / y2.total * 100 : void 0, a11.stackY = v2, this.irregularWidths || y2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a11.yBottom = rM(k2) ? m2(o10.translate(k2, false, true, false, true)) : void 0, this.dataModify && (v2 = this.dataModify.modifyValue(v2, c2)), rN(v2) && void 0 !== a11.plotX && (t11 = rN(t11 = o10.translate(v2, false, true, false, true)) ? m2(t11) : void 0), a11.plotY = t11, a11.isInside = this.isPointInside(a11), a11.clientX = h10 ? rk(i10.translate(x2, false, false, false, true, n10)) : p2, a11.negative = (a11.y || 0) < (l2 || 0), a11.isNull || false === a11.visible || (void 0 !== g2 && (f2 = Math.min(f2, Math.abs(p2 - g2))), g2 = p2), a11.zone = this.zones.length ? a11.getZone() : void 0, !a11.graphic && this.group && s10 && (a11.isNew = true);
          }
          this.closestPointRangePx = f2, rO(this, "afterTranslate");
        }
        getValidPoints(t10, e10, i10) {
          let s10 = this.chart;
          return (t10 || this.points || []).filter(function(t11) {
            let {
              plotX: o10,
              plotY: r10
            } = t11;
            return !!((i10 || !t11.isNull && rN(r10)) && (!e10 || s10.isInsidePlot(o10, r10, {
              inverted: s10.inverted
            }))) && false !== t11.visible;
          });
        }
        getClipBox() {
          let {
            chart: t10,
            xAxis: e10,
            yAxis: i10
          } = this, {
            x: s10,
            y: o10,
            width: r10,
            height: a10
          } = rR(t10.clipBox);
          return e10 && e10.len !== t10.plotSizeX && (r10 = e10.len), i10 && i10.len !== t10.plotSizeY && (a10 = i10.len), t10.inverted && !this.invertible && ([r10, a10] = [a10, r10]), {
            x: s10,
            y: o10,
            width: r10,
            height: a10
          };
        }
        getSharedClipKey() {
          return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
        }
        setClip() {
          let {
            chart: t10,
            group: e10,
            markerGroup: i10
          } = this, s10 = t10.sharedClips, o10 = t10.renderer, r10 = this.getClipBox(), a10 = this.getSharedClipKey(), n10 = s10[a10];
          n10 ? n10.animate(r10) : s10[a10] = n10 = o10.clipRect(r10), e10 && e10.clip(false === this.options.clip ? void 0 : n10), i10 && i10.clip();
        }
        animate(t10) {
          let {
            chart: e10,
            group: i10,
            markerGroup: s10
          } = this, o10 = e10.inverted, r10 = rc(this.options.animation), a10 = [this.getSharedClipKey(), r10.duration, r10.easing, r10.defer].join(","), n10 = e10.sharedClips[a10], h10 = e10.sharedClips[a10 + "m"];
          if (t10 && i10) {
            let t11 = this.getClipBox();
            if (n10) n10.attr("height", t11.height);
            else {
              t11.width = 0, o10 && (t11.x = e10.plotHeight), n10 = e10.renderer.clipRect(t11), e10.sharedClips[a10] = n10;
              let i11 = {
                x: -99,
                y: -99,
                width: o10 ? e10.plotWidth + 199 : 99,
                height: o10 ? 99 : e10.plotHeight + 199
              };
              h10 = e10.renderer.clipRect(i11), e10.sharedClips[a10 + "m"] = h10;
            }
            i10.clip(n10), s10?.clip(h10);
          } else if (n10 && !n10.hasClass("highcharts-animating")) {
            let t11 = this.getClipBox(), i11 = r10.step;
            (s10?.element.childNodes.length || e10.series.length > 1) && (r10.step = function(t12, e11) {
              i11 && i11.apply(e11, arguments), "width" === e11.prop && h10?.element && h10.attr(o10 ? "height" : "width", t12 + 99);
            }), n10.addClass("highcharts-animating").animate(t11, r10);
          }
        }
        afterAnimate() {
          this.setClip(), rW(this.chart.sharedClips, (t10, e10, i10) => {
            t10 && !this.chart.container.querySelector(`[clip-path="url(#${t10.id})"]`) && (t10.destroy(), delete i10[e10]);
          }), this.finishedAnimating = true, rO(this, "afterAnimate");
        }
        drawPoints(t10 = this.points) {
          let e10, i10, s10, o10, r10, a10, n10;
          let h10 = this.chart, l2 = h10.styledMode, {
            colorAxis: d2,
            options: c2
          } = this, p2 = c2.marker, g2 = this[this.specialGroup || "markerGroup"], u2 = this.xAxis, f2 = rH(p2.enabled, !u2 || !!u2.isRadial || null, this.closestPointRangePx >= p2.enabledThreshold * p2.radius);
          if (false !== p2.enabled || this._hasPointMarkers) for (e10 = 0; e10 < t10.length; e10++) if (o10 = (s10 = (i10 = t10[e10]).graphic) ? "animate" : "attr", r10 = i10.marker || {}, a10 = !!i10.marker, (f2 && void 0 === r10.enabled || r10.enabled) && !i10.isNull && false !== i10.visible) {
            let t11 = rH(r10.symbol, this.symbol, "rect");
            n10 = this.markerAttribs(i10, i10.selected && "select"), this.enabledDataSorting && (i10.startXPos = u2.reversed ? -(n10.width || 0) : u2.width);
            let e11 = false !== i10.isInside;
            if (!s10 && e11 && ((n10.width || 0) > 0 || i10.hasImage) && (i10.graphic = s10 = h10.renderer.symbol(t11, n10.x, n10.y, n10.width, n10.height, a10 ? r10 : p2).add(g2), this.enabledDataSorting && h10.hasRendered && (s10.attr({
              x: i10.startXPos
            }), o10 = "animate")), s10 && "animate" === o10 && s10[e11 ? "show" : "hide"](e11).animate(n10), s10) {
              let t12 = this.pointAttribs(i10, l2 || !i10.selected ? void 0 : "select");
              l2 ? d2 && s10.css({
                fill: t12.fill
              }) : s10[o10](t12);
            }
            s10 && s10.addClass(i10.getClassName(), true);
          } else s10 && (i10.graphic = s10.destroy());
        }
        markerAttribs(t10, e10) {
          let i10 = this.options, s10 = i10.marker, o10 = t10.marker || {}, r10 = o10.symbol || s10.symbol, a10 = {}, n10, h10, l2 = rH(o10.radius, s10 && s10.radius);
          e10 && (n10 = s10.states[e10], l2 = rH((h10 = o10.states && o10.states[e10]) && h10.radius, n10 && n10.radius, l2 && l2 + (n10 && n10.radiusPlus || 0))), t10.hasImage = r10 && 0 === r10.indexOf("url"), t10.hasImage && (l2 = 0);
          let d2 = t10.pos();
          return rN(l2) && d2 && (i10.crisp && (d2[0] = rw(d2[0], t10.hasImage ? 0 : "rect" === r10 ? s10?.lineWidth || 0 : 1)), a10.x = d2[0] - l2, a10.y = d2[1] - l2), l2 && (a10.width = a10.height = 2 * l2), a10;
        }
        pointAttribs(t10, e10) {
          let i10 = this.options.marker, s10 = t10 && t10.options, o10 = s10 && s10.marker || {}, r10 = s10 && s10.color, a10 = t10 && t10.color, n10 = t10 && t10.zone && t10.zone.color, h10, l2, d2 = this.color, c2, p2, g2 = rH(o10.lineWidth, i10.lineWidth), u2 = 1;
          return d2 = r10 || n10 || a10 || d2, c2 = o10.fillColor || i10.fillColor || d2, p2 = o10.lineColor || i10.lineColor || d2, e10 = e10 || "normal", h10 = i10.states[e10] || {}, g2 = rH((l2 = o10.states && o10.states[e10] || {}).lineWidth, h10.lineWidth, g2 + rH(l2.lineWidthPlus, h10.lineWidthPlus, 0)), c2 = l2.fillColor || h10.fillColor || c2, {
            stroke: p2 = l2.lineColor || h10.lineColor || p2,
            "stroke-width": g2,
            fill: c2,
            opacity: u2 = rH(l2.opacity, h10.opacity, u2)
          };
        }
        destroy(t10) {
          let e10, i10, s10;
          let o10 = this, r10 = o10.chart, a10 = /AppleWebKit\/533/.test(rm.navigator.userAgent), n10 = o10.data || [];
          for (rO(o10, "destroy", {
            keepEventsForUpdate: t10
          }), this.removeEvents(t10), (o10.axisTypes || []).forEach(function(t11) {
            (s10 = o10[t11]) && s10.series && (rC(s10.series, o10), s10.isDirty = s10.forceRedraw = true);
          }), o10.legendItem && o10.chart.legend.destroyItem(o10), e10 = n10.length; e10--; ) (i10 = n10[e10]) && i10.destroy && i10.destroy();
          for (let t11 of o10.zones) rS(t11, void 0, true);
          $.clearTimeout(o10.animationTimeout), rW(o10, function(t11, e11) {
            t11 instanceof ej && !t11.survive && t11[a10 && "group" === e11 ? "hide" : "destroy"]();
          }), r10.hoverSeries === o10 && (r10.hoverSeries = void 0), rC(r10.series, o10), r10.orderItems("series"), rW(o10, function(e11, i11) {
            t10 && "hcEvents" === i11 || delete o10[i11];
          });
        }
        applyZones() {
          let {
            area: t10,
            chart: e10,
            graph: i10,
            zones: s10,
            points: o10,
            xAxis: r10,
            yAxis: a10,
            zoneAxis: n10
          } = this, {
            inverted: h10,
            renderer: l2
          } = e10, d2 = this[`${n10}Axis`], {
            isXAxis: c2,
            len: p2 = 0,
            minPointOffset: g2 = 0
          } = d2 || {}, u2 = (i10?.strokeWidth() || 0) / 2 + 1, f2 = (t11, e11 = 0, i11 = 0) => {
            h10 && (i11 = p2 - i11);
            let {
              translated: s11 = 0,
              lineClip: o11
            } = t11, r11 = i11 - s11;
            o11?.push(["L", e11, Math.abs(r11) < u2 ? i11 - u2 * (r11 <= 0 ? -1 : 1) : s11]);
          };
          if (s10.length && (i10 || t10) && d2 && rN(d2.min)) {
            let e11 = d2.getExtremes().max + g2, u3 = (t11) => {
              t11.forEach((e12, i11) => {
                ("M" === e12[0] || "L" === e12[0]) && (t11[i11] = [e12[0], c2 ? p2 - e12[1] : e12[1], c2 ? e12[2] : p2 - e12[2]]);
              });
            };
            if (s10.forEach((t11) => {
              t11.lineClip = [], t11.translated = rv(d2.toPixels(rH(t11.value, e11), true) || 0, 0, p2);
            }), i10 && !this.showLine && i10.hide(), t10 && t10.hide(), "y" === n10 && o10.length < r10.len) for (let t11 of o10) {
              let {
                plotX: e12,
                plotY: i11,
                zone: o11
              } = t11, r11 = o11 && s10[s10.indexOf(o11) - 1];
              o11 && f2(o11, e12, i11), r11 && f2(r11, e12, i11);
            }
            let m2 = [], x2 = d2.toPixels(d2.getExtremes().min - g2, true);
            s10.forEach((e12) => {
              let s11 = e12.lineClip || [], o11 = Math.round(e12.translated || 0);
              r10.reversed && s11.reverse();
              let {
                clip: n11,
                simpleClip: d3
              } = e12, p3 = 0, g3 = 0, f3 = r10.len, y2 = a10.len;
              c2 ? (p3 = o11, f3 = x2) : (g3 = o11, y2 = x2);
              let b2 = [["M", p3, g3], ["L", f3, g3], ["L", f3, y2], ["L", p3, y2], ["Z"]], v2 = [b2[0], ...s11, b2[1], b2[2], ...m2, b2[3], b2[4]];
              m2 = s11.reverse(), x2 = o11, h10 && (u3(v2), t10 && u3(b2)), n11 ? (n11.animate({
                d: v2
              }), d3?.animate({
                d: b2
              })) : (n11 = e12.clip = l2.path(v2), t10 && (d3 = e12.simpleClip = l2.path(b2))), i10 && e12.graph?.clip(n11), t10 && e12.area?.clip(d3);
            });
          } else this.visible && (i10 && i10.show(), t10 && t10.show());
        }
        plotGroup(t10, e10, i10, s10, o10) {
          let r10 = this[t10], a10 = !r10, n10 = {
            visibility: i10,
            zIndex: s10 || 0.1
          };
          return rM(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n10.opacity = this.opacity), r10 || (this[t10] = r10 = this.chart.renderer.g().add(o10)), r10.addClass("highcharts-" + e10 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (rM(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r10.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true), r10.attr(n10)[a10 ? "attr" : "animate"](this.getPlotBox(e10)), r10;
        }
        getPlotBox(t10) {
          let e10 = this.xAxis, i10 = this.yAxis, s10 = this.chart, o10 = s10.inverted && !s10.polar && e10 && this.invertible && "series" === t10;
          return s10.inverted && (e10 = i10, i10 = this.xAxis), {
            translateX: e10 ? e10.left : s10.plotLeft,
            translateY: i10 ? i10.top : s10.plotTop,
            rotation: o10 ? 90 : 0,
            rotationOriginX: o10 ? (e10.len - i10.len) / 2 : 0,
            rotationOriginY: o10 ? (e10.len + i10.len) / 2 : 0,
            scaleX: o10 ? -1 : 1,
            scaleY: 1
          };
        }
        removeEvents(t10) {
          let {
            eventsToUnbind: e10
          } = this;
          t10 || rX(this), e10.length && (e10.forEach((t11) => {
            t11();
          }), e10.length = 0);
        }
        render() {
          let t10 = this, {
            chart: e10,
            options: i10,
            hasRendered: s10
          } = t10, o10 = rc(i10.animation), r10 = t10.visible ? "inherit" : "hidden", a10 = i10.zIndex, n10 = e10.seriesGroup, h10 = t10.finishedAnimating ? 0 : o10.duration;
          rO(this, "render"), t10.plotGroup("group", "series", r10, a10, n10), t10.markerGroup = t10.plotGroup("markerGroup", "markers", r10, a10, n10), false !== i10.clip && t10.setClip(), h10 && t10.animate?.(true), t10.drawGraph && (t10.drawGraph(), t10.applyZones()), t10.visible && t10.drawPoints(), t10.drawDataLabels?.(), t10.redrawPoints?.(), i10.enableMouseTracking && t10.drawTracker?.(), h10 && t10.animate?.(), s10 || (h10 && o10.defer && (h10 += o10.defer), t10.animationTimeout = rF(() => {
            t10.afterAnimate();
          }, h10 || 0)), t10.isDirty = false, t10.hasRendered = true, rO(t10, "afterRender");
        }
        redraw() {
          let t10 = this.isDirty || this.isDirtyData;
          this.translate(), this.render(), t10 && delete this.kdTree;
        }
        reserveSpace() {
          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
        }
        searchPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = this.chart.inverted;
          return this.searchKDTree({
            clientX: o10 ? i10.len - t10.chartY + i10.pos : t10.chartX - i10.pos,
            plotY: o10 ? s10.len - t10.chartX + s10.pos : t10.chartY - s10.pos
          }, e10, t10);
        }
        buildKDTree(t10) {
          this.buildingKdTree = true;
          let e10 = this, i10 = e10.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          delete e10.kdTree, rF(function() {
            e10.kdTree = function t11(i11, s10, o10) {
              let r10, a10;
              let n10 = i11?.length;
              if (n10) return r10 = e10.kdAxisArray[s10 % o10], i11.sort((t12, e11) => (t12[r10] || 0) - (e11[r10] || 0)), {
                point: i11[a10 = Math.floor(n10 / 2)],
                left: t11(i11.slice(0, a10), s10 + 1, o10),
                right: t11(i11.slice(a10 + 1), s10 + 1, o10)
              };
            }(e10.getValidPoints(void 0, !e10.directTouch), i10, i10), e10.buildingKdTree = false;
          }, e10.options.kdNow || t10?.type === "touchstart" ? 0 : 1);
        }
        searchKDTree(t10, e10, i10, s10, o10) {
          let r10 = this, [a10, n10] = this.kdAxisArray, h10 = e10 ? "distX" : "dist", l2 = (r10.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d2 = !!r10.isBubble, c2 = s10 || ((t11, e11, i11) => [(t11[i11] || 0) < (e11[i11] || 0) ? t11 : e11, false]), p2 = o10 || ((t11, e11) => t11 < e11);
          if (this.kdTree || this.buildingKdTree || this.buildKDTree(i10), this.kdTree) return function t11(e11, i11, s11, o11) {
            let l3 = i11.point, g2 = r10.kdAxisArray[s11 % o11], u2 = l3, f2 = false;
            !function(t12, e12) {
              let i12 = t12[a10], s12 = e12[a10], o12 = rM(i12) && rM(s12) ? i12 - s12 : null, r11 = t12[n10], h11 = e12[n10], l4 = rM(r11) && rM(h11) ? r11 - h11 : 0, c3 = d2 && e12.marker?.radius || 0;
              e12.dist = Math.sqrt((o12 && o12 * o12 || 0) + l4 * l4) - c3, e12.distX = rM(o12) ? Math.abs(o12) - c3 : Number.MAX_VALUE;
            }(e11, l3);
            let m2 = (e11[g2] || 0) - (l3[g2] || 0) + (d2 && l3.marker?.radius || 0), x2 = m2 < 0 ? "left" : "right", y2 = m2 < 0 ? "right" : "left";
            return i11[x2] && ([u2, f2] = c2(l3, t11(e11, i11[x2], s11 + 1, o11), h10)), i11[y2] && p2(Math.sqrt(m2 * m2), u2[h10], f2) && (u2 = c2(u2, t11(e11, i11[y2], s11 + 1, o11), h10)[0]), u2;
          }(t10, this.kdTree, l2, l2);
        }
        pointPlacementToXValue() {
          let {
            options: t10,
            xAxis: e10
          } = this, i10 = t10.pointPlacement;
          return "between" === i10 && (i10 = e10.reversed ? -0.5 : 0.5), rN(i10) ? i10 * (t10.pointRange || e10.pointRange) : 0;
        }
        isPointInside(t10) {
          let {
            chart: e10,
            xAxis: i10,
            yAxis: s10
          } = this, {
            plotX: o10 = -1,
            plotY: r10 = -1
          } = t10;
          return r10 >= 0 && r10 <= (s10 ? s10.len : e10.plotHeight) && o10 >= 0 && o10 <= (i10 ? i10.len : e10.plotWidth);
        }
        drawTracker() {
          let t10 = this, e10 = t10.options, i10 = e10.trackByArea, s10 = [].concat((i10 ? t10.areaPath : t10.graphPath) || []), o10 = t10.chart, r10 = o10.pointer, a10 = o10.renderer, n10 = o10.options.tooltip?.snap || 0, h10 = () => {
            e10.enableMouseTracking && o10.hoverSeries !== t10 && t10.onMouseOver();
          }, l2 = "rgba(192,192,192," + (rf ? 1e-4 : 2e-3) + ")", d2 = t10.tracker;
          d2 ? d2.attr({
            d: s10
          }) : t10.graph && (t10.tracker = d2 = a10.path(s10).attr({
            visibility: t10.visible ? "inherit" : "hidden",
            zIndex: 2
          }).addClass(i10 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t10.group), o10.styledMode || d2.attr({
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            stroke: l2,
            fill: i10 ? l2 : "none",
            "stroke-width": t10.graph.strokeWidth() + (i10 ? 0 : 2 * n10)
          }), [t10.tracker, t10.markerGroup, t10.dataLabelsGroup].forEach((t11) => {
            t11 && (t11.addClass("highcharts-tracker").on("mouseover", h10).on("mouseout", (t12) => {
              r10?.onTrackerMouseOut(t12);
            }), e10.cursor && !o10.styledMode && t11.css({
              cursor: e10.cursor
            }), t11.on("touchstart", h10));
          })), rO(this, "afterDrawTracker");
        }
        addPoint(t10, e10, i10, s10, o10) {
          let r10, a10;
          let n10 = this.options, {
            chart: h10,
            data: l2,
            dataTable: d2,
            xAxis: c2
          } = this, p2 = c2 && c2.hasNames && c2.names, g2 = n10.data, u2 = this.getColumn("x");
          e10 = rH(e10, true);
          let f2 = {
            series: this
          };
          this.pointClass.prototype.applyOptions.apply(f2, [t10]);
          let m2 = f2.x;
          if (a10 = u2.length, this.requireSorting && m2 < u2[a10 - 1]) for (r10 = true; a10 && u2[a10 - 1] > m2; ) a10--;
          d2.setRow(f2, a10, true, {
            addColumns: false
          }), p2 && f2.name && (p2[m2] = f2.name), g2?.splice(a10, 0, t10), (r10 || this.processedData) && (this.data.splice(a10, 0, null), this.processData()), "point" === n10.legendType && this.generatePoints(), i10 && (l2[0] && l2[0].remove ? l2[0].remove(false) : ([l2, g2, ...Object.values(d2.getColumns())].filter(rM).forEach((t11) => {
            t11.shift();
          }), d2.rowCount -= 1, rO(d2, "afterDeleteRows"))), false !== o10 && rO(this, "addPoint", {
            point: f2
          }), this.isDirty = true, this.isDirtyData = true, e10 && h10.redraw(s10);
        }
        removePoint(t10, e10, i10) {
          let s10 = this, {
            chart: o10,
            data: r10,
            points: a10,
            dataTable: n10
          } = s10, h10 = r10[t10], l2 = function() {
            [a10?.length === r10.length ? a10 : void 0, r10, s10.options.data, ...Object.values(n10.getColumns())].filter(rM).forEach((e11) => {
              e11.splice(t10, 1);
            }), n10.rowCount -= 1, rO(n10, "afterDeleteRows"), h10?.destroy(), s10.isDirty = true, s10.isDirtyData = true, e10 && o10.redraw();
          };
          rp(i10, o10), e10 = rH(e10, true), h10 ? h10.firePointEvent("remove", null, l2) : l2();
        }
        remove(t10, e10, i10, s10) {
          let o10 = this, r10 = o10.chart;
          function a10() {
            o10.destroy(s10), r10.isDirtyLegend = r10.isDirtyBox = true, r10.linkSeries(s10), rH(t10, true) && r10.redraw(e10);
          }
          false !== i10 ? rO(o10, "remove", null, a10) : a10();
        }
        update(t10, e10) {
          rO(this, "update", {
            options: t10 = rT(t10, this.userOptions)
          });
          let i10 = this, s10 = i10.chart, o10 = i10.userOptions, r10 = i10.initialType || i10.type, a10 = s10.options.plotOptions, n10 = rx[r10].prototype, h10 = i10.finishedAnimating && {
            animation: false
          }, l2 = {}, d2, c2, p2 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], g2 = t10.type || o10.type || s10.options.chart.type, u2 = !(this.hasDerivedData || g2 && g2 !== this.type || void 0 !== t10.keys || void 0 !== t10.pointStart || void 0 !== t10.pointInterval || void 0 !== t10.relativeXValue || t10.joinBy || t10.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some((t11) => i10.hasOptionChanged(t11)));
          g2 = g2 || r10, u2 ? (p2.push("data", "isDirtyData", "isDirtyCanvas", "points", "dataTable", "processedData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), false !== t10.visible && p2.push("area", "graph"), i10.parallelArrays.forEach(function(t11) {
            p2.push(t11 + "Data");
          }), t10.data && (t10.dataSorting && rP(i10.options.dataSorting, t10.dataSorting), this.setData(t10.data, false))) : this.dataTable.modified = this.dataTable, t10 = rR(o10, {
            index: void 0 === o10.index ? i10.index : o10.index,
            pointStart: a10?.series?.pointStart ?? o10.pointStart ?? i10.getColumn("x")[0]
          }, !u2 && {
            data: i10.options.data
          }, t10, h10), u2 && t10.data && (t10.data = i10.options.data), (p2 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p2)).forEach(function(t11) {
            p2[t11] = i10[t11], delete i10[t11];
          });
          let f2 = false;
          if (rx[g2]) {
            if (f2 = g2 !== i10.type, i10.remove(false, false, false, true), f2) {
              if (s10.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i10, rx[g2].prototype);
              else {
                let t11 = Object.hasOwnProperty.call(i10, "hcEvents") && i10.hcEvents;
                for (c2 in n10) i10[c2] = void 0;
                rP(i10, rx[g2].prototype), t11 ? i10.hcEvents = t11 : delete i10.hcEvents;
              }
            }
          } else rA(17, true, s10, {
            missingModuleFor: g2
          });
          if (p2.forEach(function(t11) {
            i10[t11] = p2[t11];
          }), i10.init(s10, t10), u2 && this.points) for (let t11 of (false === (d2 = i10.options).visible ? (l2.graphic = 1, l2.dataLabel = 1) : (this.hasMarkerChanged(d2, o10) && (l2.graphic = 1), i10.hasDataLabels?.() || (l2.dataLabel = 1)), this.points)) t11 && t11.series && (t11.resolveColor(), Object.keys(l2).length && t11.destroyElements(l2), false === d2.showInLegend && t11.legendItem && s10.legend.destroyItem(t11));
          i10.initialType = r10, s10.linkSeries(), s10.setSortedData(), f2 && i10.linkedSeries.length && (i10.isDirtyData = true), rO(this, "afterUpdate"), rH(e10, true) && s10.redraw(!!u2 && void 0);
        }
        setName(t10) {
          this.name = this.options.name = this.userOptions.name = t10, this.chart.isDirtyLegend = true;
        }
        hasOptionChanged(t10) {
          let e10 = this.chart, i10 = this.options[t10], s10 = e10.options.plotOptions, o10 = this.userOptions[t10], r10 = rH(s10?.[this.type]?.[t10], s10?.series?.[t10]);
          return o10 && !rM(r10) ? i10 !== o10 : i10 !== rH(r10, i10);
        }
        onMouseOver() {
          let t10 = this.chart, e10 = t10.hoverSeries, i10 = t10.pointer;
          i10?.setHoverChartIndex(), e10 && e10 !== this && e10.onMouseOut(), this.options.events.mouseOver && rO(this, "mouseOver"), this.setState("hover"), t10.hoverSeries = this;
        }
        onMouseOut() {
          let t10 = this.options, e10 = this.chart, i10 = e10.tooltip, s10 = e10.hoverPoint;
          e10.hoverSeries = null, s10 && s10.onMouseOut(), this && t10.events.mouseOut && rO(this, "mouseOut"), i10 && !this.stickyTracking && (!i10.shared || this.noSharedTooltip) && i10.hide(), e10.series.forEach(function(t11) {
            t11.setState("", true);
          });
        }
        setState(t10, e10) {
          let i10 = this, s10 = i10.options, o10 = i10.graph, r10 = s10.inactiveOtherPoints, a10 = s10.states, n10 = rH(a10[t10 || "normal"] && a10[t10 || "normal"].animation, i10.chart.options.chart.animation), h10 = s10.lineWidth, l2 = s10.opacity;
          if (t10 = t10 || "", i10.state !== t10 && ([i10.group, i10.markerGroup, i10.dataLabelsGroup].forEach(function(e11) {
            e11 && (i10.state && e11.removeClass("highcharts-series-" + i10.state), t10 && e11.addClass("highcharts-series-" + t10));
          }), i10.state = t10, !i10.chart.styledMode)) {
            if (a10[t10] && false === a10[t10].enabled) return;
            if (t10 && (h10 = a10[t10].lineWidth || h10 + (a10[t10].lineWidthPlus || 0), l2 = rH(a10[t10].opacity, l2)), o10 && !o10.dashstyle && rN(h10)) for (let t11 of [o10, ...this.zones.map((t12) => t12.graph)]) t11?.animate({
              "stroke-width": h10
            }, n10);
            r10 || [i10.group, i10.markerGroup, i10.dataLabelsGroup, i10.labelBySeries].forEach(function(t11) {
              t11 && t11.animate({
                opacity: l2
              }, n10);
            });
          }
          e10 && r10 && i10.points && i10.setAllPointsToState(t10 || void 0);
        }
        setAllPointsToState(t10) {
          this.points.forEach(function(e10) {
            e10.setState && e10.setState(t10);
          });
        }
        setVisible(t10, e10) {
          let i10 = this, s10 = i10.chart, o10 = s10.options.chart.ignoreHiddenSeries, r10 = i10.visible;
          i10.visible = t10 = i10.options.visible = i10.userOptions.visible = void 0 === t10 ? !r10 : t10;
          let a10 = t10 ? "show" : "hide";
          ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach((t11) => {
            i10[t11]?.[a10]();
          }), (s10.hoverSeries === i10 || s10.hoverPoint?.series === i10) && i10.onMouseOut(), i10.legendItem && s10.legend.colorizeItem(i10, t10), i10.isDirty = true, i10.options.stacking && s10.series.forEach((t11) => {
            t11.options.stacking && t11.visible && (t11.isDirty = true);
          }), i10.linkedSeries.forEach((e11) => {
            e11.setVisible(t10, false);
          }), o10 && (s10.isDirtyBox = true), rO(i10, a10), false !== e10 && s10.redraw();
        }
        show() {
          this.setVisible(true);
        }
        hide() {
          this.setVisible(false);
        }
        select(t10) {
          this.selected = t10 = this.options.selected = void 0 === t10 ? !this.selected : t10, this.checkbox && (this.checkbox.checked = t10), rO(this, t10 ? "select" : "unselect");
        }
        shouldShowTooltip(t10, e10, i10 = {}) {
          return i10.series = this, i10.visiblePlotOnly = true, this.chart.isInsidePlot(t10, e10, i10);
        }
        drawLegendSymbol(t10, e10) {
          rr[this.options.legendSymbol || "rectangle"]?.call(this, t10, e10);
        }
      }
      rG.defaultOptions = {
        lineWidth: 2,
        allowPointSelect: false,
        crisp: true,
        showCheckbox: false,
        animation: {
          duration: 1e3
        },
        enableMouseTracking: true,
        events: {},
        marker: {
          enabledThreshold: 2,
          lineColor: "#ffffff",
          lineWidth: 0,
          radius: 4,
          states: {
            normal: {
              animation: true
            },
            hover: {
              animation: {
                duration: 150
              },
              enabled: true,
              radiusPlus: 2,
              lineWidthPlus: 1
            },
            select: {
              fillColor: "#cccccc",
              lineColor: "#000000",
              lineWidth: 2
            }
          }
        },
        point: {
          events: {}
        },
        dataLabels: {
          animation: {},
          align: "center",
          borderWidth: 0,
          defer: true,
          formatter: function() {
            let {
              numberFormatter: t10
            } = this.series.chart;
            return "number" != typeof this.y ? "" : t10(this.y, -1);
          },
          padding: 5,
          style: {
            fontSize: "0.7em",
            fontWeight: "bold",
            color: "contrast",
            textOutline: "1px contrast"
          },
          verticalAlign: "bottom",
          x: 0,
          y: 0
        },
        cropThreshold: 300,
        opacity: 1,
        pointRange: 0,
        softThreshold: true,
        states: {
          normal: {
            animation: true
          },
          hover: {
            animation: {
              duration: 150
            },
            lineWidthPlus: 1,
            marker: {},
            halo: {
              size: 10,
              opacity: 0.25
            }
          },
          select: {
            animation: {
              duration: 0
            }
          },
          inactive: {
            animation: {
              duration: 150
            },
            opacity: 0.2
          }
        },
        stickyTracking: true,
        turboThreshold: 1e3,
        findNearestPointBy: "x"
      }, rG.types = rd.seriesTypes, rG.registerType = rd.registerSeriesType, rP(rG.prototype, {
        axisTypes: ["xAxis", "yAxis"],
        coll: "series",
        colorCounter: 0,
        directTouch: false,
        invertible: true,
        isCartesian: true,
        kdAxisArray: ["clientX", "plotY"],
        parallelArrays: ["x", "y"],
        pointClass: oF,
        requireSorting: true,
        sorted: true
      }), rd.series = rG;
      let rY = rG, {
        animObject: rj,
        setAnimation: rU
      } = tR, {
        registerEventOptions: r$
      } = i3, {
        composed: rV,
        marginNames: r_
      } = k, {
        distribute: rq
      } = ed, {
        format: rZ
      } = eo, {
        addEvent: rK,
        createElement: rJ,
        css: rQ,
        defined: r0,
        discardElement: r1,
        find: r2,
        fireEvent: r3,
        isNumber: r5,
        merge: r6,
        pick: r9,
        pushUnique: r4,
        relativeLength: r8,
        stableSort: r7,
        syncTimeout: at
      } = $;
      class ae {
        constructor(t10, e10) {
          this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t10, this.setOptions(e10), e10.enabled && (this.render(), r$(this, e10), rK(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          })), rK(this.chart, "render", () => {
            this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
          });
        }
        setOptions(t10) {
          let e10 = r9(t10.padding, 8);
          this.options = t10, this.chart.styledMode || (this.itemStyle = t10.itemStyle, this.itemHiddenStyle = r6(this.itemStyle, t10.itemHiddenStyle)), this.itemMarginTop = t10.itemMarginTop, this.itemMarginBottom = t10.itemMarginBottom, this.padding = e10, this.initialItemY = e10 - 5, this.symbolWidth = r9(t10.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t10.layout && !this.chart.inverted, this.baseline = void 0;
        }
        update(t10, e10) {
          let i10 = this.chart;
          this.setOptions(r6(true, this.options, t10)), "events" in this.options && r$(this, this.options), this.destroy(), i10.isDirtyLegend = i10.isDirtyBox = true, r9(e10, true) && i10.redraw(), r3(this, "afterUpdate", {
            redraw: e10
          });
        }
        colorizeItem(t10, e10) {
          let i10 = t10.color, {
            area: s10,
            group: o10,
            label: r10,
            line: a10,
            symbol: n10
          } = t10.legendItem || {};
          if ((t10 instanceof rY || t10 instanceof oF) && (t10.color = t10.options?.legendSymbolColor || i10), o10?.[e10 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
            let {
              itemHiddenStyle: i11 = {}
            } = this, o11 = i11.color, {
              fillColor: h10,
              fillOpacity: l2,
              lineColor: d2,
              marker: c2
            } = t10.options, p2 = (t11) => (!e10 && (t11.fill && (t11.fill = o11), t11.stroke && (t11.stroke = o11)), t11);
            r10?.css(r6(e10 ? this.itemStyle : i11)), a10?.attr(p2({
              stroke: d2 || t10.color
            })), n10 && n10.attr(p2(c2 && n10.isMarker ? t10.pointAttribs() : {
              fill: t10.color
            })), s10?.attr(p2({
              fill: h10 || t10.color,
              "fill-opacity": h10 ? 1 : l2 ?? 0.75
            }));
          }
          t10.color = i10, r3(this, "afterColorizeItem", {
            item: t10,
            visible: e10
          });
        }
        positionItems() {
          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
        }
        positionItem(t10) {
          let {
            group: e10,
            x: i10 = 0,
            y: s10 = 0
          } = t10.legendItem || {}, o10 = this.options, r10 = o10.symbolPadding, a10 = !o10.rtl, n10 = t10.checkbox;
          if (e10 && e10.element) {
            let o11 = {
              translateX: a10 ? i10 : this.legendWidth - i10 - 2 * r10 - 4,
              translateY: s10
            };
            e10[r0(e10.translateY) ? "animate" : "attr"](o11, void 0, () => {
              r3(this, "afterPositionItem", {
                item: t10
              });
            });
          }
          n10 && (n10.x = i10, n10.y = s10);
        }
        destroyItem(t10) {
          let e10 = t10.checkbox, i10 = t10.legendItem || {};
          for (let t11 of ["group", "label", "line", "symbol"]) i10[t11] && (i10[t11] = i10[t11].destroy());
          e10 && r1(e10), t10.legendItem = void 0;
        }
        destroy() {
          for (let t10 of this.getAllItems()) this.destroyItem(t10);
          for (let t10 of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t10] && (this[t10] = this[t10].destroy());
          this.display = null;
        }
        positionCheckboxes() {
          let t10;
          let e10 = this.group && this.group.alignAttr, i10 = this.clipHeight || this.legendHeight, s10 = this.titleHeight;
          e10 && (t10 = e10.translateY, this.allItems.forEach(function(o10) {
            let r10;
            let a10 = o10.checkbox;
            a10 && (r10 = t10 + s10 + a10.y + (this.scrollOffset || 0) + 3, rQ(a10, {
              left: e10.translateX + o10.checkboxOffset + a10.x - 20 + "px",
              top: r10 + "px",
              display: this.proximate || r10 > t10 - 6 && r10 < t10 + i10 - 6 ? "" : "none"
            }));
          }, this));
        }
        renderTitle() {
          let t10 = this.options, e10 = this.padding, i10 = t10.title, s10, o10 = 0;
          i10.text && (this.title || (this.title = this.chart.renderer.label(i10.text, e10 - 3, e10 - 4, void 0, void 0, void 0, t10.useHTML, void 0, "legend-title").attr({
            zIndex: 1
          }), this.chart.styledMode || this.title.css(i10.style), this.title.add(this.group)), i10.width || this.title.css({
            width: this.maxLegendWidth + "px"
          }), o10 = (s10 = this.title.getBBox()).height, this.offsetWidth = s10.width, this.contentGroup.attr({
            translateY: o10
          })), this.titleHeight = o10;
        }
        setText(t10) {
          let e10 = this.options;
          t10.legendItem.label.attr({
            text: e10.labelFormat ? rZ(e10.labelFormat, t10, this.chart) : e10.labelFormatter.call(t10)
          });
        }
        renderItem(t10) {
          let e10 = t10.legendItem = t10.legendItem || {}, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = "horizontal" === o10.layout, a10 = this.symbolWidth, n10 = o10.symbolPadding || 0, h10 = this.itemStyle, l2 = this.itemHiddenStyle, d2 = r10 ? r9(o10.itemDistance, 20) : 0, c2 = !o10.rtl, p2 = !t10.series, g2 = !p2 && t10.series.drawLegendSymbol ? t10.series : t10, u2 = g2.options, f2 = !!this.createCheckboxForItem && u2 && u2.showCheckbox, m2 = o10.useHTML, x2 = t10.options.className, y2 = e10.label, b2 = a10 + n10 + d2 + (f2 ? 20 : 0);
          !y2 && (e10.group = s10.g("legend-item").addClass("highcharts-" + g2.type + "-series highcharts-color-" + t10.colorIndex + (x2 ? " " + x2 : "") + (p2 ? " highcharts-series-" + t10.index : "")).attr({
            zIndex: 1
          }).add(this.scrollGroup), e10.label = y2 = s10.text("", c2 ? a10 + n10 : -n10, this.baseline || 0, m2), i10.styledMode || y2.css(r6(t10.visible ? h10 : l2)), y2.attr({
            align: c2 ? "left" : "right",
            zIndex: 2
          }).add(e10.group), !this.baseline && (this.fontMetrics = s10.fontMetrics(y2), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y2.attr("y", this.baseline), this.symbolHeight = r9(o10.symbolHeight, this.fontMetrics.f), o10.squareSymbol && (this.symbolWidth = r9(o10.symbolWidth, Math.max(this.symbolHeight, 16)), b2 = this.symbolWidth + n10 + d2 + (f2 ? 20 : 0), c2 && y2.attr("x", this.symbolWidth + n10))), g2.drawLegendSymbol(this, t10), this.setItemEvents && this.setItemEvents(t10, y2, m2)), f2 && !t10.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t10), this.colorizeItem(t10, t10.visible), (i10.styledMode || !h10.width) && y2.css({
            width: (o10.itemWidth || this.widthOption || i10.spacingBox.width) - b2 + "px"
          }), this.setText(t10);
          let v2 = y2.getBBox(), k2 = this.fontMetrics && this.fontMetrics.h || 0;
          t10.itemWidth = t10.checkboxOffset = o10.itemWidth || e10.labelWidth || v2.width + b2, this.maxItemWidth = Math.max(this.maxItemWidth, t10.itemWidth), this.totalItemWidth += t10.itemWidth, this.itemHeight = t10.itemHeight = Math.round(e10.labelHeight || (v2.height > 1.5 * k2 ? v2.height : k2));
        }
        layoutItem(t10) {
          let e10 = this.options, i10 = this.padding, s10 = "horizontal" === e10.layout, o10 = t10.itemHeight, r10 = this.itemMarginBottom, a10 = this.itemMarginTop, n10 = s10 ? r9(e10.itemDistance, 20) : 0, h10 = this.maxLegendWidth, l2 = e10.alignColumns && this.totalItemWidth > h10 ? this.maxItemWidth : t10.itemWidth, d2 = t10.legendItem || {};
          s10 && this.itemX - i10 + l2 > h10 && (this.itemX = i10, this.lastLineHeight && (this.itemY += a10 + this.lastLineHeight + r10), this.lastLineHeight = 0), this.lastItemY = a10 + this.itemY + r10, this.lastLineHeight = Math.max(o10, this.lastLineHeight), d2.x = this.itemX, d2.y = this.itemY, s10 ? this.itemX += l2 : (this.itemY += a10 + o10 + r10, this.lastLineHeight = o10), this.offsetWidth = this.widthOption || Math.max((s10 ? this.itemX - i10 - (t10.checkbox ? 0 : n10) : l2) + i10, this.offsetWidth);
        }
        getAllItems() {
          let t10 = [];
          return this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.options;
            e10 && r9(i10.showInLegend, !r0(i10.linkedTo) && void 0, true) && (t10 = t10.concat((e10.legendItem || {}).labels || ("point" === i10.legendType ? e10.data : e10)));
          }), r3(this, "afterGetAllItems", {
            allItems: t10
          }), t10;
        }
        getAlignment() {
          let t10 = this.options;
          return this.proximate ? t10.align.charAt(0) + "tv" : t10.floating ? "" : t10.align.charAt(0) + t10.verticalAlign.charAt(0) + t10.layout.charAt(0);
        }
        adjustMargins(t10, e10) {
          let i10 = this.chart, s10 = this.options, o10 = this.getAlignment();
          o10 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(r10, a10) {
            r10.test(o10) && !r0(t10[a10]) && (i10[r_[a10]] = Math.max(i10[r_[a10]], i10.legend[(a10 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][a10] * s10[a10 % 2 ? "x" : "y"] + r9(s10.margin, 12) + e10[a10] + (i10.titleOffset[a10] || 0)));
          });
        }
        proximatePositions() {
          let t10;
          let e10 = this.chart, i10 = [], s10 = "left" === this.options.align;
          for (let o10 of (this.allItems.forEach(function(t11) {
            let o11, r10, a10 = s10, n10, h10;
            t11.yAxis && (t11.xAxis.options.reversed && (a10 = !a10), t11.points && (o11 = r2(a10 ? t11.points : t11.points.slice(0).reverse(), function(t12) {
              return r5(t12.plotY);
            })), r10 = this.itemMarginTop + t11.legendItem.label.getBBox().height + this.itemMarginBottom, h10 = t11.yAxis.top - e10.plotTop, n10 = t11.visible ? (o11 ? o11.plotY : t11.yAxis.height) + (h10 - 0.3 * r10) : h10 + t11.yAxis.height, i10.push({
              target: n10,
              size: r10,
              item: t11
            }));
          }, this), rq(i10, e10.plotHeight))) t10 = o10.item.legendItem || {}, r5(o10.pos) && (t10.y = e10.plotTop - e10.spacing[0] + o10.pos);
        }
        render() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.options, s10 = this.padding, o10 = this.getAllItems(), r10, a10, n10, h10 = this.group, l2, d2 = this.box;
          this.itemX = s10, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = r8(i10.width, t10.spacingBox.width - s10), l2 = t10.spacingBox.width - 2 * s10 - i10.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l2 /= 2), this.maxLegendWidth = this.widthOption || l2, h10 || (this.group = h10 = e10.g("legend").addClass(i10.className || "").attr({
            zIndex: 7
          }).add(), this.contentGroup = e10.g().attr({
            zIndex: 1
          }).add(h10), this.scrollGroup = e10.g().add(this.contentGroup)), this.renderTitle(), r7(o10, (t11, e11) => (t11.options && t11.options.legendIndex || 0) - (e11.options && e11.options.legendIndex || 0)), i10.reversed && o10.reverse(), this.allItems = o10, this.display = r10 = !!o10.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o10.forEach(this.renderItem, this), o10.forEach(this.layoutItem, this), a10 = (this.widthOption || this.offsetWidth) + s10, n10 = this.lastItemY + this.lastLineHeight + this.titleHeight, n10 = this.handleOverflow(n10) + s10, d2 || (this.box = d2 = e10.rect().addClass("highcharts-legend-box").attr({
            r: i10.borderRadius
          }).add(h10)), t10.styledMode || d2.attr({
            stroke: i10.borderColor,
            "stroke-width": i10.borderWidth || 0,
            fill: i10.backgroundColor || "none"
          }).shadow(i10.shadow), a10 > 0 && n10 > 0 && d2[d2.placed ? "animate" : "attr"](d2.crisp.call({}, {
            x: 0,
            y: 0,
            width: a10,
            height: n10
          }, d2.strokeWidth())), h10[r10 ? "show" : "hide"](), t10.styledMode && "none" === h10.getStyle("display") && (a10 = n10 = 0), this.legendWidth = a10, this.legendHeight = n10, r10 && this.align(), this.proximate || this.positionItems(), r3(this, "afterRender");
        }
        align(t10 = this.chart.spacingBox) {
          let e10 = this.chart, i10 = this.options, s10 = t10.y;
          /(lth|ct|rth)/.test(this.getAlignment()) && e10.titleOffset[0] > 0 ? s10 += e10.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e10.titleOffset[2] > 0 && (s10 -= e10.titleOffset[2]), s10 !== t10.y && (t10 = r6(t10, {
            y: s10
          })), e10.hasRendered || (this.group.placed = false), this.group.align(r6(i10, {
            width: this.legendWidth,
            height: this.legendHeight,
            verticalAlign: this.proximate ? "top" : i10.verticalAlign
          }), true, t10);
        }
        handleOverflow(t10) {
          let e10 = this, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = o10.y, a10 = "top" === o10.verticalAlign, n10 = this.padding, h10 = o10.maxHeight, l2 = o10.navigation, d2 = r9(l2.animation, true), c2 = l2.arrowSize || 12, p2 = this.pages, g2 = this.allItems, u2 = function(t11) {
            "number" == typeof t11 ? k2.attr({
              height: t11
            }) : k2 && (e10.clipRect = k2.destroy(), e10.contentGroup.clip()), e10.contentGroup.div && (e10.contentGroup.div.style.clip = t11 ? "rect(" + n10 + "px,9999px," + (n10 + t11) + "px,0)" : "auto");
          }, f2 = function(t11) {
            return e10[t11] = s10.circle(0, 0, 1.3 * c2).translate(c2 / 2, c2 / 2).add(v2), i10.styledMode || e10[t11].attr("fill", "rgba(0,0,0,0.0001)"), e10[t11];
          }, m2, x2, y2, b2 = i10.spacingBox.height + (a10 ? -r10 : r10) - n10, v2 = this.nav, k2 = this.clipRect;
          return "horizontal" !== o10.layout || "middle" === o10.verticalAlign || o10.floating || (b2 /= 2), h10 && (b2 = Math.min(b2, h10)), p2.length = 0, t10 && b2 > 0 && t10 > b2 && false !== l2.enabled ? (this.clipHeight = m2 = Math.max(b2 - 20 - this.titleHeight - n10, 0), this.currentPage = r9(this.currentPage, 1), this.fullHeight = t10, g2.forEach((t11, e11) => {
            let i11 = (y2 = t11.legendItem || {}).y || 0, s11 = Math.round(y2.label.getBBox().height), o11 = p2.length;
            (!o11 || i11 - p2[o11 - 1] > m2 && (x2 || i11) !== p2[o11 - 1]) && (p2.push(x2 || i11), o11++), y2.pageIx = o11 - 1, x2 && ((g2[e11 - 1].legendItem || {}).pageIx = o11 - 1), e11 === g2.length - 1 && i11 + s11 - p2[o11 - 1] > m2 && i11 > p2[o11 - 1] && (p2.push(i11), y2.pageIx = o11), i11 !== x2 && (x2 = i11);
          }), k2 || (k2 = e10.clipRect = s10.clipRect(0, n10 - 2, 9999, 0), e10.contentGroup.clip(k2)), u2(m2), v2 || (this.nav = v2 = s10.g().attr({
            zIndex: 1
          }).add(this.group), this.up = s10.symbol("triangle", 0, 0, c2, c2).add(v2), f2("upTracker").on("click", function() {
            e10.scroll(-1, d2);
          }), this.pager = s10.text("", 15, 10).addClass("highcharts-legend-navigation"), !i10.styledMode && l2.style && this.pager.css(l2.style), this.pager.add(v2), this.down = s10.symbol("triangle-down", 0, 0, c2, c2).add(v2), f2("downTracker").on("click", function() {
            e10.scroll(1, d2);
          })), e10.scroll(0), t10 = b2) : v2 && (u2(), this.nav = v2.destroy(), this.scrollGroup.attr({
            translateY: 1
          }), this.clipHeight = 0), t10;
        }
        scroll(t10, e10) {
          let i10 = this.chart, s10 = this.pages, o10 = s10.length, r10 = this.clipHeight, a10 = this.options.navigation, n10 = this.pager, h10 = this.padding, l2 = this.currentPage + t10;
          l2 > o10 && (l2 = o10), l2 > 0 && (void 0 !== e10 && rU(e10, i10), this.nav.attr({
            translateX: h10,
            translateY: r10 + this.padding + 7 + this.titleHeight,
            visibility: "inherit"
          }), [this.up, this.upTracker].forEach(function(t11) {
            t11.attr({
              class: 1 === l2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }), n10.attr({
            text: l2 + "/" + o10
          }), [this.down, this.downTracker].forEach(function(t11) {
            t11.attr({
              x: 18 + this.pager.getBBox().width,
              class: l2 === o10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }, this), i10.styledMode || (this.up.attr({
            fill: 1 === l2 ? a10.inactiveColor : a10.activeColor
          }), this.upTracker.css({
            cursor: 1 === l2 ? "default" : "pointer"
          }), this.down.attr({
            fill: l2 === o10 ? a10.inactiveColor : a10.activeColor
          }), this.downTracker.css({
            cursor: l2 === o10 ? "default" : "pointer"
          })), this.scrollOffset = -s10[l2 - 1] + this.initialItemY, this.scrollGroup.animate({
            translateY: this.scrollOffset
          }), this.currentPage = l2, this.positionCheckboxes(), at(() => {
            r3(this, "afterScroll", {
              currentPage: l2
            });
          }, rj(r9(e10, i10.renderer.globalAnimation, true)).duration));
        }
        setItemEvents(t10, e10, i10) {
          let s10 = this, o10 = t10.legendItem || {}, r10 = s10.chart.renderer.boxWrapper, a10 = t10 instanceof oF, n10 = t10 instanceof rY, h10 = "highcharts-legend-" + (a10 ? "point" : "series") + "-active", l2 = s10.chart.styledMode, d2 = i10 ? [e10, o10.symbol] : [o10.group], c2 = (e11) => {
            s10.allItems.forEach((i11) => {
              t10 !== i11 && [i11].concat(i11.linkedSeries || []).forEach((t11) => {
                t11.setState(e11, !a10);
              });
            });
          };
          for (let i11 of d2) i11 && i11.on("mouseover", function() {
            t10.visible && c2("inactive"), t10.setState("hover"), t10.visible && r10.addClass(h10), l2 || e10.css(s10.options.itemHoverStyle);
          }).on("mouseout", function() {
            s10.chart.styledMode || e10.css(r6(t10.visible ? s10.itemStyle : s10.itemHiddenStyle)), c2(""), r10.removeClass(h10), t10.setState();
          }).on("click", function(e11) {
            let i12 = function() {
              t10.setVisible && t10.setVisible(), c2(t10.visible ? "inactive" : "");
            };
            r10.removeClass(h10), r3(s10, "itemClick", {
              browserEvent: e11,
              legendItem: t10
            }, i12), a10 ? t10.firePointEvent("legendItemClick", {
              browserEvent: e11
            }) : n10 && r3(t10, "legendItemClick", {
              browserEvent: e11
            });
          });
        }
        createCheckboxForItem(t10) {
          t10.checkbox = rJ("input", {
            type: "checkbox",
            className: "highcharts-legend-checkbox",
            checked: t10.selected,
            defaultChecked: t10.selected
          }, this.options.itemCheckboxStyle, this.chart.container), rK(t10.checkbox, "click", function(e10) {
            let i10 = e10.target;
            r3(t10.series || t10, "checkboxClick", {
              checked: i10.checked,
              item: t10
            }, function() {
              t10.select();
            });
          });
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          r4(rV, "Core.Legend") && rK(e10, "beforeMargins", function() {
            this.legend = new t10(this, this.options.legend);
          });
        };
      }(ae || (ae = {}));
      let ai = ae, {
        animate: as,
        animObject: ao,
        setAnimation: ar
      } = tR, {
        defaultOptions: aa
      } = tm, {
        numberFormat: an
      } = eo, {
        registerEventOptions: ah
      } = i3, {
        charts: al,
        doc: ad,
        marginNames: ac,
        svg: ap,
        win: ag
      } = k, {
        seriesTypes: au
      } = rd, {
        addEvent: af,
        attr: am,
        createElement: ax,
        css: ay,
        defined: ab,
        diffObjects: av,
        discardElement: ak,
        erase: aw,
        error: aM,
        extend: aS,
        find: aT,
        fireEvent: aC,
        getAlignFactor: aA,
        getStyle: aP,
        isArray: aL,
        isNumber: aO,
        isObject: aE,
        isString: aI,
        merge: aD,
        objectEach: aB,
        pick: aN,
        pInt: az,
        relativeLength: aR,
        removeEvent: aW,
        splat: aH,
        syncTimeout: aX,
        uniqueKey: aF
      } = $;
      class aG {
        static chart(t10, e10, i10) {
          return new aG(t10, e10, i10);
        }
        constructor(t10, e10, i10) {
          this.sharedClips = {};
          let s10 = [...arguments];
          (aI(t10) || t10.nodeName) && (this.renderTo = s10.shift()), this.init(s10[0], s10[1]);
        }
        setZoomOptions() {
          let t10 = this.options.chart, e10 = t10.zooming;
          this.zooming = __spreadProps(__spreadValues({}, e10), {
            type: aN(t10.zoomType, e10.type),
            key: aN(t10.zoomKey, e10.key),
            pinchType: aN(t10.pinchType, e10.pinchType),
            singleTouch: aN(t10.zoomBySingleTouch, e10.singleTouch, false),
            resetButton: aD(e10.resetButton, t10.resetZoomButton)
          });
        }
        init(t10, e10) {
          aC(this, "init", {
            args: arguments
          }, function() {
            let i10 = aD(aa, t10), s10 = i10.chart, o10 = this.renderTo || s10.renderTo;
            this.userOptions = aS({}, t10), (this.renderTo = aI(o10) ? ad.getElementById(o10) : o10) || aM(13, true, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e10, this.isResizing = 0, this.options = i10, this.axes = [], this.series = [], this.locale = i10.lang.locale ?? this.renderTo.closest("[lang]")?.lang, this.time = new td(aS(i10.time || {}, {
              locale: this.locale
            })), i10.time = this.time.options, this.numberFormatter = (s10.numberFormatter || an).bind(this), this.styledMode = s10.styledMode, this.hasCartesianSeries = s10.showAxes, this.index = al.length, al.push(this), k.chartCount++, ah(this, s10), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), aC(this, "afterInit"), this.firstRender();
          });
        }
        initSeries(t10) {
          let e10 = this.options.chart, i10 = t10.type || e10.type, s10 = au[i10];
          s10 || aM(17, true, this, {
            missingModuleFor: i10
          });
          let o10 = new s10();
          return "function" == typeof o10.init && o10.init(this, t10), o10;
        }
        setSortedData() {
          this.getSeriesOrderByLinks().forEach(function(t10) {
            t10.points || t10.data || !t10.enabledDataSorting || t10.setData(t10.options.data, false);
          });
        }
        getSeriesOrderByLinks() {
          return this.series.concat().sort(function(t10, e10) {
            return t10.linkedSeries.length || e10.linkedSeries.length ? e10.linkedSeries.length - t10.linkedSeries.length : 0;
          });
        }
        orderItems(t10, e10 = 0) {
          let i10 = this[t10], s10 = this.options[t10] = aH(this.options[t10]).slice(), o10 = this.userOptions[t10] = this.userOptions[t10] ? aH(this.userOptions[t10]).slice() : [];
          if (this.hasRendered && (s10.splice(e10), o10.splice(e10)), i10) for (let t11 = e10, r10 = i10.length; t11 < r10; ++t11) {
            let e11 = i10[t11];
            e11 && (e11.index = t11, e11 instanceof rY && (e11.name = e11.getName()), e11.options.isInternal || (s10[t11] = e11.options, o10[t11] = e11.userOptions));
          }
        }
        isInsidePlot(t10, e10, i10 = {}) {
          let {
            inverted: s10,
            plotBox: o10,
            plotLeft: r10,
            plotTop: a10,
            scrollablePlotBox: n10
          } = this, {
            scrollLeft: h10 = 0,
            scrollTop: l2 = 0
          } = i10.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, d2 = i10.series, c2 = i10.visiblePlotOnly && n10 || o10, p2 = i10.inverted ? e10 : t10, g2 = i10.inverted ? t10 : e10, u2 = {
            x: p2,
            y: g2,
            isInsidePlot: true,
            options: i10
          };
          if (!i10.ignoreX) {
            let t11 = d2 && (s10 && !this.polar ? d2.yAxis : d2.xAxis) || {
              pos: r10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + p2 : r10 + p2;
            e11 >= Math.max(h10 + r10, t11.pos) && e11 <= Math.min(h10 + r10 + c2.width, t11.pos + t11.len) || (u2.isInsidePlot = false);
          }
          if (!i10.ignoreY && u2.isInsidePlot) {
            let t11 = !s10 && i10.axis && !i10.axis.isXAxis && i10.axis || d2 && (s10 ? d2.xAxis : d2.yAxis) || {
              pos: a10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + g2 : a10 + g2;
            e11 >= Math.max(l2 + a10, t11.pos) && e11 <= Math.min(l2 + a10 + c2.height, t11.pos + t11.len) || (u2.isInsidePlot = false);
          }
          return aC(this, "afterIsInsidePlot", u2), u2.isInsidePlot;
        }
        redraw(t10) {
          aC(this, "beforeRedraw");
          let e10 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i10 = this.series, s10 = this.pointer, o10 = this.legend, r10 = this.userOptions.legend, a10 = this.renderer, n10 = a10.isHidden(), h10 = [], l2, d2, c2, p2 = this.isDirtyBox, g2 = this.isDirtyLegend, u2;
          for (a10.rootFontSize = a10.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(false), ar(!!this.hasRendered && t10, this), n10 && this.temporaryDisplay(), this.layOutTitles(false), c2 = i10.length; c2--; ) if (((u2 = i10[c2]).options.stacking || u2.options.centerInCategory) && (d2 = true, u2.isDirty)) {
            l2 = true;
            break;
          }
          if (l2) for (c2 = i10.length; c2--; ) (u2 = i10[c2]).options.stacking && (u2.isDirty = true);
          i10.forEach(function(t11) {
            t11.isDirty && ("point" === t11.options.legendType ? ("function" == typeof t11.updateTotals && t11.updateTotals(), g2 = true) : r10 && (r10.labelFormatter || r10.labelFormat) && (g2 = true)), t11.isDirtyData && aC(t11, "updatedData");
          }), g2 && o10 && o10.options.enabled && (o10.render(), this.isDirtyLegend = false), d2 && this.getStacks(), e10.forEach(function(t11) {
            t11.updateNames(), t11.setScale();
          }), this.getMargins(), e10.forEach(function(t11) {
            t11.isDirty && (p2 = true);
          }), e10.forEach(function(t11) {
            let e11 = t11.min + "," + t11.max;
            t11.extKey !== e11 && (t11.extKey = e11, h10.push(function() {
              aC(t11, "afterSetExtremes", aS(t11.eventArgs, t11.getExtremes())), delete t11.eventArgs;
            })), (p2 || d2) && t11.redraw();
          }), p2 && this.drawChartBox(), aC(this, "predraw"), i10.forEach(function(t11) {
            (p2 || t11.isDirty) && t11.visible && t11.redraw(), t11.isDirtyData = false;
          }), s10 && s10.reset(true), a10.draw(), aC(this, "redraw"), aC(this, "render"), n10 && this.temporaryDisplay(true), h10.forEach(function(t11) {
            t11.call();
          });
        }
        get(t10) {
          let e10 = this.series;
          function i10(e11) {
            return e11.id === t10 || e11.options && e11.options.id === t10;
          }
          let s10 = aT(this.axes, i10) || aT(this.series, i10);
          for (let t11 = 0; !s10 && t11 < e10.length; t11++) s10 = aT(e10[t11].points || [], i10);
          return s10;
        }
        createAxes() {
          let t10 = this.userOptions;
          for (let e10 of (aC(this, "createAxes"), ["xAxis", "yAxis"])) for (let i10 of t10[e10] = aH(t10[e10] || {})) new sR(this, i10, e10);
          aC(this, "afterCreateAxes");
        }
        getSelectedPoints() {
          return this.series.reduce((t10, e10) => (e10.getPointsCollection().forEach((e11) => {
            aN(e11.selectedStaging, e11.selected) && t10.push(e11);
          }), t10), []);
        }
        getSelectedSeries() {
          return this.series.filter((t10) => t10.selected);
        }
        setTitle(t10, e10, i10) {
          this.applyDescription("title", t10), this.applyDescription("subtitle", e10), this.applyDescription("caption", void 0), this.layOutTitles(i10);
        }
        applyDescription(t10, e10) {
          let i10 = this, s10 = this.options[t10] = aD(this.options[t10], e10), o10 = this[t10];
          o10 && e10 && (this[t10] = o10 = o10.destroy()), s10 && !o10 && ((o10 = this.renderer.text(s10.text, 0, 0, s10.useHTML).attr({
            align: s10.align,
            class: "highcharts-" + t10,
            zIndex: s10.zIndex || 4
          }).css({
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          }).add()).update = function(e11, s11) {
            i10.applyDescription(t10, e11), i10.layOutTitles(s11);
          }, this.styledMode || o10.css(aS("title" === t10 ? {
            fontSize: this.options.isStock ? "1em" : "1.2em"
          } : {}, s10.style)), o10.textPxLength = o10.getBBox().width, o10.css({
            whiteSpace: s10.style?.whiteSpace
          }), this[t10] = o10);
        }
        layOutTitles(t10 = true) {
          let e10 = [0, 0, 0], {
            options: i10,
            renderer: s10,
            spacingBox: o10
          } = this;
          ["title", "subtitle", "caption"].forEach((t11) => {
            let i11 = this[t11], r11 = this.options[t11], a10 = aD(o10), n10 = i11?.textPxLength || 0;
            if (i11 && r11) {
              aC(this, "layOutTitle", {
                alignTo: a10,
                key: t11,
                textPxLength: n10
              });
              let o11 = s10.fontMetrics(i11), h10 = o11.b, l2 = o11.h, d2 = r11.verticalAlign || "top", c2 = "top" === d2, p2 = c2 && r11.minScale || 1, g2 = "title" === t11 ? c2 ? -3 : 0 : c2 ? e10[0] + 2 : 0, u2 = Math.min(a10.width / n10, 1), f2 = Math.max(p2, u2), m2 = aD({
                y: "bottom" === d2 ? h10 : g2 + h10
              }, {
                align: "title" === t11 ? u2 < p2 ? "left" : "center" : this.title?.alignValue
              }, r11), x2 = r11.width || (u2 > p2 ? this.chartWidth : a10.width) / f2;
              i11.alignValue !== m2.align && (i11.placed = false);
              let y2 = Math.round(i11.css({
                width: `${x2}px`
              }).getBBox(r11.useHTML).height);
              if (m2.height = y2, i11.align(m2, false, a10).attr({
                align: m2.align,
                scaleX: f2,
                scaleY: f2,
                "transform-origin": `${a10.x + n10 * f2 * aA(m2.align)} ${l2}`
              }), !r11.floating) {
                let t12 = y2 * (y2 < 1.2 * l2 ? 1 : f2);
                "top" === d2 ? e10[0] = Math.ceil(e10[0] + t12) : "bottom" === d2 && (e10[2] = Math.ceil(e10[2] + t12));
              }
            }
          }, this), e10[0] && "top" === (i10.title?.verticalAlign || "top") && (e10[0] += i10.title?.margin || 0), e10[2] && i10.caption?.verticalAlign === "bottom" && (e10[2] += i10.caption?.margin || 0);
          let r10 = !this.titleOffset || this.titleOffset.join(",") !== e10.join(",");
          this.titleOffset = e10, aC(this, "afterLayOutTitles"), !this.isDirtyBox && r10 && (this.isDirtyBox = this.isDirtyLegend = r10, this.hasRendered && t10 && this.isDirtyBox && this.redraw());
        }
        getContainerBox() {
          let t10 = [].map.call(this.renderTo.children, (t11) => {
            if (t11 !== this.container) {
              let e11 = t11.style.display;
              return t11.style.display = "none", [t11, e11];
            }
          }), e10 = {
            width: aP(this.renderTo, "width", true) || 0,
            height: aP(this.renderTo, "height", true) || 0
          };
          return t10.filter(Boolean).forEach(([t11, e11]) => {
            t11.style.display = e11;
          }), e10;
        }
        getChartSize() {
          let t10 = this.options.chart, e10 = t10.width, i10 = t10.height, s10 = this.getContainerBox(), o10 = s10.height <= 1 || !this.renderTo.parentElement?.style.height && "100%" === this.renderTo.style.height;
          this.chartWidth = Math.max(0, e10 || s10.width || 600), this.chartHeight = Math.max(0, aR(i10, this.chartWidth) || (o10 ? 400 : s10.height)), this.containerBox = s10;
        }
        temporaryDisplay(t10) {
          let e10 = this.renderTo, i10;
          if (t10) for (; e10 && e10.style; ) e10.hcOrigStyle && (ay(e10, e10.hcOrigStyle), delete e10.hcOrigStyle), e10.hcOrigDetached && (ad.body.removeChild(e10), e10.hcOrigDetached = false), e10 = e10.parentNode;
          else for (; e10 && e10.style && (ad.body.contains(e10) || e10.parentNode || (e10.hcOrigDetached = true, ad.body.appendChild(e10)), ("none" === aP(e10, "display", false) || e10.hcOricDetached) && (e10.hcOrigStyle = {
            display: e10.style.display,
            height: e10.style.height,
            overflow: e10.style.overflow
          }, i10 = {
            display: "block",
            overflow: "hidden"
          }, e10 !== this.renderTo && (i10.height = 0), ay(e10, i10), e10.offsetWidth || e10.style.setProperty("display", "block", "important")), (e10 = e10.parentNode) !== ad.body); ) ;
        }
        setClassName(t10) {
          this.container.className = "highcharts-container " + (t10 || "");
        }
        getContainer() {
          let t10;
          let e10 = this.options, i10 = e10.chart, s10 = "data-highcharts-chart", o10 = aF(), r10 = this.renderTo, a10 = az(am(r10, s10));
          aO(a10) && al[a10] && al[a10].hasRendered && al[a10].destroy(), am(r10, s10, this.index), r10.innerHTML = tK.emptyHTML, i10.skipClone || r10.offsetWidth || this.temporaryDisplay(), this.getChartSize();
          let n10 = this.chartHeight, h10 = this.chartWidth;
          ay(r10, {
            overflow: "hidden"
          }), this.styledMode || (t10 = aS({
            position: "relative",
            overflow: "hidden",
            width: h10 + "px",
            height: n10 + "px",
            textAlign: "left",
            lineHeight: "normal",
            zIndex: 0,
            "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
            userSelect: "none",
            "touch-action": "manipulation",
            outline: "none",
            padding: "0px"
          }, i10.style || {}));
          let l2 = ax("div", {
            id: o10
          }, t10, r10);
          this.container = l2, this.getChartSize(), h10 === this.chartWidth || (h10 = this.chartWidth, this.styledMode || ay(l2, {
            width: aN(i10.style?.width, h10 + "px")
          })), this.containerBox = this.getContainerBox(), this._cursor = l2.style.cursor;
          let d2 = i10.renderer || !ap ? er.getRendererType(i10.renderer) : iR;
          if (this.renderer = new d2(l2, h10, n10, void 0, i10.forExport, e10.exporting && e10.exporting.allowHTML, this.styledMode), ar(void 0, this), this.setClassName(i10.className), this.styledMode) for (let t11 in e10.defs) this.renderer.definition(e10.defs[t11]);
          else this.renderer.setStyle(i10.style);
          this.renderer.chartIndex = this.index, aC(this, "afterGetContainer");
        }
        getMargins(t10) {
          let {
            spacing: e10,
            margin: i10,
            titleOffset: s10
          } = this;
          this.resetMargins(), s10[0] && !ab(i10[0]) && (this.plotTop = Math.max(this.plotTop, s10[0] + e10[0])), s10[2] && !ab(i10[2]) && (this.marginBottom = Math.max(this.marginBottom, s10[2] + e10[2])), this.legend && this.legend.display && this.legend.adjustMargins(i10, e10), aC(this, "getMargins"), t10 || this.getAxisMargins();
        }
        getAxisMargins() {
          let t10 = this, e10 = t10.axisOffset = [0, 0, 0, 0], i10 = t10.colorAxis, s10 = t10.margin, o10 = function(t11) {
            t11.forEach(function(t12) {
              t12.visible && t12.getOffset();
            });
          };
          t10.hasCartesianSeries ? o10(t10.axes) : i10 && i10.length && o10(i10), ac.forEach(function(i11, o11) {
            ab(s10[o11]) || (t10[i11] += e10[o11]);
          }), t10.setChartSize();
        }
        getOptions() {
          return av(this.userOptions, aa);
        }
        reflow(t10) {
          let e10 = this, i10 = e10.containerBox, s10 = e10.getContainerBox();
          delete e10.pointer?.chartPosition, !e10.isPrinting && !e10.isResizing && i10 && s10.width && ((s10.width !== i10.width || s10.height !== i10.height) && ($.clearTimeout(e10.reflowTimeout), e10.reflowTimeout = aX(function() {
            e10.container && e10.setSize(void 0, void 0, false);
          }, t10 ? 100 : 0)), e10.containerBox = s10);
        }
        setReflow() {
          let t10 = this, e10 = (e11) => {
            t10.options?.chart.reflow && t10.hasLoaded && t10.reflow(e11);
          };
          if ("function" == typeof ResizeObserver) new ResizeObserver(e10).observe(t10.renderTo);
          else {
            let t11 = af(ag, "resize", e10);
            af(this, "destroy", t11);
          }
        }
        setSize(t10, e10, i10) {
          let s10 = this, o10 = s10.renderer;
          s10.isResizing += 1, ar(i10, s10);
          let r10 = o10.globalAnimation;
          s10.oldChartHeight = s10.chartHeight, s10.oldChartWidth = s10.chartWidth, void 0 !== t10 && (s10.options.chart.width = t10), void 0 !== e10 && (s10.options.chart.height = e10), s10.getChartSize();
          let {
            chartWidth: a10,
            chartHeight: n10,
            scrollablePixelsX: h10 = 0,
            scrollablePixelsY: l2 = 0
          } = s10;
          (s10.isDirtyBox || a10 !== s10.oldChartWidth || n10 !== s10.oldChartHeight) && (s10.styledMode || (r10 ? as : ay)(s10.container, {
            width: `${a10 + h10}px`,
            height: `${n10 + l2}px`
          }, r10), s10.setChartSize(true), o10.setSize(a10, n10, r10), s10.axes.forEach(function(t11) {
            t11.isDirty = true, t11.setScale();
          }), s10.isDirtyLegend = true, s10.isDirtyBox = true, s10.layOutTitles(), s10.getMargins(), s10.redraw(r10), s10.oldChartHeight = void 0, aC(s10, "resize"), setTimeout(() => {
            s10 && aC(s10, "endResize");
          }, ao(r10).duration)), s10.isResizing -= 1;
        }
        setChartSize(t10) {
          let e10, i10, s10, o10;
          let {
            chartHeight: r10,
            chartWidth: a10,
            inverted: n10,
            spacing: h10,
            renderer: l2
          } = this, d2 = this.clipOffset, c2 = Math[n10 ? "floor" : "round"];
          this.plotLeft = e10 = Math.round(this.plotLeft), this.plotTop = i10 = Math.round(this.plotTop), this.plotWidth = s10 = Math.max(0, Math.round(a10 - e10 - this.marginRight)), this.plotHeight = o10 = Math.max(0, Math.round(r10 - i10 - this.marginBottom)), this.plotSizeX = n10 ? o10 : s10, this.plotSizeY = n10 ? s10 : o10, this.spacingBox = l2.spacingBox = {
            x: h10[3],
            y: h10[0],
            width: a10 - h10[3] - h10[1],
            height: r10 - h10[0] - h10[2]
          }, this.plotBox = l2.plotBox = {
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }, d2 && (this.clipBox = {
            x: c2(d2[3]),
            y: c2(d2[0]),
            width: c2(this.plotSizeX - d2[1] - d2[3]),
            height: c2(this.plotSizeY - d2[0] - d2[2])
          }), t10 || (this.axes.forEach(function(t11) {
            t11.setAxisSize(), t11.setAxisTranslation();
          }), l2.alignElements()), aC(this, "afterSetChartSize", {
            skipAxes: t10
          });
        }
        resetMargins() {
          aC(this, "resetMargins");
          let t10 = this, e10 = t10.options.chart, i10 = e10.plotBorderWidth || 0, s10 = i10 / 2;
          ["margin", "spacing"].forEach(function(i11) {
            let s11 = e10[i11], o10 = aE(s11) ? s11 : [s11, s11, s11, s11];
            ["Top", "Right", "Bottom", "Left"].forEach(function(s12, r10) {
              t10[i11][r10] = aN(e10[i11 + s12], o10[r10]);
            });
          }), ac.forEach(function(e11, i11) {
            t10[e11] = aN(t10.margin[i11], t10.spacing[i11]);
          }), t10.axisOffset = [0, 0, 0, 0], t10.clipOffset = [s10, s10, s10, s10], t10.plotBorderWidth = i10;
        }
        drawChartBox() {
          let t10 = this.options.chart, e10 = this.renderer, i10 = this.chartWidth, s10 = this.chartHeight, o10 = this.styledMode, r10 = this.plotBGImage, a10 = t10.backgroundColor, n10 = t10.plotBackgroundColor, h10 = t10.plotBackgroundImage, l2 = this.plotLeft, d2 = this.plotTop, c2 = this.plotWidth, p2 = this.plotHeight, g2 = this.plotBox, u2 = this.clipRect, f2 = this.clipBox, m2 = this.chartBackground, x2 = this.plotBackground, y2 = this.plotBorder, b2, v2, k2, w2 = "animate";
          m2 || (this.chartBackground = m2 = e10.rect().addClass("highcharts-background").add(), w2 = "attr"), o10 ? b2 = v2 = m2.strokeWidth() : (v2 = (b2 = t10.borderWidth || 0) + (t10.shadow ? 8 : 0), k2 = {
            fill: a10 || "none"
          }, (b2 || m2["stroke-width"]) && (k2.stroke = t10.borderColor, k2["stroke-width"] = b2), m2.attr(k2).shadow(t10.shadow)), m2[w2]({
            x: v2 / 2,
            y: v2 / 2,
            width: i10 - v2 - b2 % 2,
            height: s10 - v2 - b2 % 2,
            r: t10.borderRadius
          }), w2 = "animate", x2 || (w2 = "attr", this.plotBackground = x2 = e10.rect().addClass("highcharts-plot-background").add()), x2[w2](g2), !o10 && (x2.attr({
            fill: n10 || "none"
          }).shadow(t10.plotShadow), h10 && (r10 ? (h10 !== r10.attr("href") && r10.attr("href", h10), r10.animate(g2)) : this.plotBGImage = e10.image(h10, l2, d2, c2, p2).add())), u2 ? u2.animate({
            width: f2.width,
            height: f2.height
          }) : this.clipRect = e10.clipRect(f2), w2 = "animate", y2 || (w2 = "attr", this.plotBorder = y2 = e10.rect().addClass("highcharts-plot-border").attr({
            zIndex: 1
          }).add()), o10 || y2.attr({
            stroke: t10.plotBorderColor,
            "stroke-width": t10.plotBorderWidth || 0,
            fill: "none"
          }), y2[w2](y2.crisp({
            x: l2,
            y: d2,
            width: c2,
            height: p2
          }, -y2.strokeWidth())), this.isDirtyBox = false, aC(this, "afterDrawChartBox");
        }
        propFromSeries() {
          let t10, e10, i10;
          let s10 = this, o10 = s10.options.chart, r10 = s10.options.series;
          ["inverted", "angular", "polar"].forEach(function(a10) {
            for (e10 = au[o10.type], i10 = o10[a10] || e10 && e10.prototype[a10], t10 = r10 && r10.length; !i10 && t10--; ) (e10 = au[r10[t10].type]) && e10.prototype[a10] && (i10 = true);
            s10[a10] = i10;
          });
        }
        linkSeries(t10) {
          let e10 = this, i10 = e10.series;
          i10.forEach(function(t11) {
            t11.linkedSeries.length = 0;
          }), i10.forEach(function(t11) {
            let {
              linkedTo: i11
            } = t11.options;
            if (aI(i11)) {
              let s10;
              (s10 = ":previous" === i11 ? e10.series[t11.index - 1] : e10.get(i11)) && s10.linkedParent !== t11 && (s10.linkedSeries.push(t11), t11.linkedParent = s10, s10.enabledDataSorting && t11.setDataSortingOptions(), t11.visible = aN(t11.options.visible, s10.options.visible, t11.visible));
            }
          }), aC(this, "afterLinkSeries", {
            isUpdating: t10
          });
        }
        renderSeries() {
          this.series.forEach(function(t10) {
            t10.translate(), t10.render();
          });
        }
        render() {
          let t10 = this.axes, e10 = this.colorAxis, i10 = this.renderer, s10 = this.options.chart.axisLayoutRuns || 2, o10 = (t11) => {
            t11.forEach((t12) => {
              t12.visible && t12.render();
            });
          }, r10 = 0, a10 = true, n10, h10 = 0;
          for (let e11 of (this.setTitle(), aC(this, "beforeMargins"), this.getStacks?.(), this.getMargins(true), this.setChartSize(), t10)) {
            let {
              options: t11
            } = e11, {
              labels: i11
            } = t11;
            if (this.hasCartesianSeries && e11.horiz && e11.visible && i11.enabled && e11.series.length && "colorAxis" !== e11.coll && !this.polar) {
              r10 = t11.tickLength, e11.createGroups();
              let s11 = new sa(e11, 0, "", true), o11 = s11.createLabel("x", i11);
              if (s11.destroy(), o11 && aN(i11.reserveSpace, !aO(t11.crossing)) && (r10 = o11.getBBox().height + i11.distance + Math.max(t11.offset || 0, 0)), r10) {
                o11?.destroy();
                break;
              }
            }
          }
          for (this.plotHeight = Math.max(this.plotHeight - r10, 0); (a10 || n10 || s10 > 1) && h10 < s10; ) {
            let e11 = this.plotWidth, i11 = this.plotHeight;
            for (let e12 of t10) 0 === h10 ? e12.setScale() : (e12.horiz && a10 || !e12.horiz && n10) && e12.setTickInterval(true);
            0 === h10 ? this.getAxisMargins() : this.getMargins(), a10 = e11 / this.plotWidth > (h10 ? 1 : 1.1), n10 = i11 / this.plotHeight > (h10 ? 1 : 1.05), h10++;
          }
          this.drawChartBox(), this.hasCartesianSeries ? o10(t10) : e10 && e10.length && o10(e10), this.seriesGroup || (this.seriesGroup = i10.g("series-group").attr({
            zIndex: 3
          }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = true;
        }
        addCredits(t10) {
          let e10 = this, i10 = aD(true, this.options.credits, t10);
          i10.enabled && !this.credits && (this.credits = this.renderer.text(i10.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
            i10.href && (ag.location.href = i10.href);
          }).attr({
            align: i10.position.align,
            zIndex: 8
          }), e10.styledMode || this.credits.css(i10.style), this.credits.add().align(i10.position), this.credits.update = function(t11) {
            e10.credits = e10.credits.destroy(), e10.addCredits(t11);
          });
        }
        destroy() {
          let t10;
          let e10 = this, i10 = e10.axes, s10 = e10.series, o10 = e10.container, r10 = o10 && o10.parentNode;
          for (aC(e10, "destroy"), e10.renderer.forExport ? aw(al, e10) : al[e10.index] = void 0, k.chartCount--, e10.renderTo.removeAttribute("data-highcharts-chart"), aW(e10), t10 = i10.length; t10--; ) i10[t10] = i10[t10].destroy();
          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t10 = s10.length; t10--; ) s10[t10] = s10[t10].destroy();
          ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(t11) {
            let i11 = e10[t11];
            i11 && i11.destroy && (e10[t11] = i11.destroy());
          }), o10 && (o10.innerHTML = tK.emptyHTML, aW(o10), r10 && ak(o10)), aB(e10, function(t11, i11) {
            delete e10[i11];
          });
        }
        firstRender() {
          let t10 = this, e10 = t10.options;
          t10.getContainer(), t10.resetMargins(), t10.setChartSize(), t10.propFromSeries(), t10.createAxes();
          let i10 = aL(e10.series) ? e10.series : [];
          e10.series = [], i10.forEach(function(e11) {
            t10.initSeries(e11);
          }), t10.linkSeries(), t10.setSortedData(), aC(t10, "beforeRender"), t10.render(), t10.pointer?.getChartPosition(), t10.renderer.imgCount || t10.hasLoaded || t10.onload(), t10.temporaryDisplay(true);
        }
        onload() {
          this.callbacks.concat([this.callback]).forEach(function(t10) {
            t10 && void 0 !== this.index && t10.apply(this, [this]);
          }, this), aC(this, "load"), aC(this, "render"), ab(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = true;
        }
        warnIfA11yModuleNotLoaded() {
          let {
            options: t10,
            title: e10
          } = this;
          !t10 || this.accessibility || (this.renderer.boxWrapper.attr({
            role: "img",
            "aria-label": (e10 && e10.element.textContent || "").replace(/</g, "&lt;")
          }), t10.accessibility && false === t10.accessibility.enabled || aM('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this));
        }
        addSeries(t10, e10, i10) {
          let s10;
          let o10 = this;
          return t10 && (e10 = aN(e10, true), aC(o10, "addSeries", {
            options: t10
          }, function() {
            s10 = o10.initSeries(t10), o10.isDirtyLegend = true, o10.linkSeries(), s10.enabledDataSorting && s10.setData(t10.data, false), aC(o10, "afterAddSeries", {
              series: s10
            }), e10 && o10.redraw(i10);
          })), s10;
        }
        addAxis(t10, e10, i10, s10) {
          return this.createAxis(e10 ? "xAxis" : "yAxis", {
            axis: t10,
            redraw: i10,
            animation: s10
          });
        }
        addColorAxis(t10, e10, i10) {
          return this.createAxis("colorAxis", {
            axis: t10,
            redraw: e10,
            animation: i10
          });
        }
        createAxis(t10, e10) {
          let i10 = new sR(this, e10.axis, t10);
          return aN(e10.redraw, true) && this.redraw(e10.animation), i10;
        }
        showLoading(t10) {
          let e10 = this, i10 = e10.options, s10 = i10.loading, o10 = function() {
            r10 && ay(r10, {
              left: e10.plotLeft + "px",
              top: e10.plotTop + "px",
              width: e10.plotWidth + "px",
              height: e10.plotHeight + "px"
            });
          }, r10 = e10.loadingDiv, a10 = e10.loadingSpan;
          r10 || (e10.loadingDiv = r10 = ax("div", {
            className: "highcharts-loading highcharts-loading-hidden"
          }, null, e10.container)), a10 || (e10.loadingSpan = a10 = ax("span", {
            className: "highcharts-loading-inner"
          }, null, r10), af(e10, "redraw", o10)), r10.className = "highcharts-loading", tK.setElementHTML(a10, aN(t10, i10.lang.loading, "")), e10.styledMode || (ay(r10, aS(s10.style, {
            zIndex: 10
          })), ay(a10, s10.labelStyle), e10.loadingShown || (ay(r10, {
            opacity: 0,
            display: ""
          }), as(r10, {
            opacity: s10.style.opacity || 0.5
          }, {
            duration: s10.showDuration || 0
          }))), e10.loadingShown = true, o10();
        }
        hideLoading() {
          let t10 = this.options, e10 = this.loadingDiv;
          e10 && (e10.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || as(e10, {
            opacity: 0
          }, {
            duration: t10.loading.hideDuration || 100,
            complete: function() {
              ay(e10, {
                display: "none"
              });
            }
          })), this.loadingShown = false;
        }
        update(t10, e10, i10, s10) {
          let o10, r10, a10;
          let n10 = this, h10 = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }, l2 = t10.isResponsiveOptions, d2 = [];
          aC(n10, "update", {
            options: t10
          }), l2 || n10.setResponsive(false, true), t10 = av(t10, n10.options), n10.userOptions = aD(n10.userOptions, t10);
          let c2 = t10.chart;
          c2 && (aD(true, n10.options.chart, c2), this.setZoomOptions(), "className" in c2 && n10.setClassName(c2.className), ("inverted" in c2 || "polar" in c2 || "type" in c2) && (n10.propFromSeries(), o10 = true), "alignTicks" in c2 && (o10 = true), "events" in c2 && ah(this, c2), aB(c2, function(t11, e11) {
            -1 !== n10.propsRequireUpdateSeries.indexOf("chart." + e11) && (r10 = true), -1 !== n10.propsRequireDirtyBox.indexOf(e11) && (n10.isDirtyBox = true), -1 === n10.propsRequireReflow.indexOf(e11) || (n10.isDirtyBox = true, l2 || (a10 = true));
          }), !n10.styledMode && c2.style && n10.renderer.setStyle(n10.options.chart.style || {})), !n10.styledMode && t10.colors && (this.options.colors = t10.colors), aB(t10, function(e11, i11) {
            n10[i11] && "function" == typeof n10[i11].update ? n10[i11].update(e11, false) : "function" == typeof n10[h10[i11]] ? n10[h10[i11]](e11) : "colors" !== i11 && -1 === n10.collectionsWithUpdate.indexOf(i11) && aD(true, n10.options[i11], t10[i11]), "chart" !== i11 && -1 !== n10.propsRequireUpdateSeries.indexOf(i11) && (r10 = true);
          }), this.collectionsWithUpdate.forEach(function(e11) {
            t10[e11] && (aH(t10[e11]).forEach(function(t11, s11) {
              let o11;
              let r11 = ab(t11.id);
              r11 && (o11 = n10.get(t11.id)), !o11 && n10[e11] && (o11 = n10[e11][aN(t11.index, s11)]) && (r11 && ab(o11.options.id) || o11.options.isInternal) && (o11 = void 0), o11 && o11.coll === e11 && (o11.update(t11, false), i10 && (o11.touched = true)), !o11 && i10 && n10.collectionsWithInit[e11] && (n10.collectionsWithInit[e11][0].apply(n10, [t11].concat(n10.collectionsWithInit[e11][1] || []).concat([false])).touched = true);
            }), i10 && n10[e11].forEach(function(t11) {
              t11.touched || t11.options.isInternal ? delete t11.touched : d2.push(t11);
            }));
          }), d2.forEach(function(t11) {
            t11.chart && t11.remove && t11.remove(false);
          }), o10 && n10.axes.forEach(function(t11) {
            t11.update({}, false);
          }), r10 && n10.getSeriesOrderByLinks().forEach(function(t11) {
            t11.chart && t11.update({}, false);
          }, this);
          let p2 = c2 && c2.width, g2 = c2 && (aI(c2.height) ? aR(c2.height, p2 || n10.chartWidth) : c2.height);
          a10 || aO(p2) && p2 !== n10.chartWidth || aO(g2) && g2 !== n10.chartHeight ? n10.setSize(p2, g2, s10) : aN(e10, true) && n10.redraw(s10), aC(n10, "afterUpdate", {
            options: t10,
            redraw: e10,
            animation: s10
          });
        }
        setSubtitle(t10, e10) {
          this.applyDescription("subtitle", t10), this.layOutTitles(e10);
        }
        setCaption(t10, e10) {
          this.applyDescription("caption", t10), this.layOutTitles(e10);
        }
        showResetZoom() {
          let t10 = this, e10 = aa.lang, i10 = t10.zooming.resetButton, s10 = i10.theme, o10 = "chart" === i10.relativeTo || "spacingBox" === i10.relativeTo ? null : "plotBox";
          function r10() {
            t10.zoomOut();
          }
          aC(this, "beforeShowResetZoom", null, function() {
            t10.resetZoomButton = t10.renderer.button(e10.resetZoom, null, null, r10, s10).attr({
              align: i10.position.align,
              title: e10.resetZoomTitle
            }).addClass("highcharts-reset-zoom").add().align(i10.position, false, o10);
          }), aC(this, "afterShowResetZoom");
        }
        zoomOut() {
          aC(this, "selection", {
            resetSelection: true
          }, () => this.transform({
            reset: true,
            trigger: "zoom"
          }));
        }
        pan(t10, e10) {
          let i10 = this, s10 = "object" == typeof e10 ? e10 : {
            enabled: e10,
            type: "x"
          }, o10 = s10.type, r10 = o10 && i10[{
            x: "xAxis",
            xy: "axes",
            y: "yAxis"
          }[o10]].filter((t11) => t11.options.panningEnabled && !t11.options.isInternal), a10 = i10.options.chart;
          a10?.panning && (a10.panning = s10), aC(this, "pan", {
            originalEvent: t10
          }, () => {
            i10.transform({
              axes: r10,
              event: t10,
              to: {
                x: t10.chartX - (i10.mouseDownX || 0),
                y: t10.chartY - (i10.mouseDownY || 0)
              },
              trigger: "pan"
            }), ay(i10.container, {
              cursor: "move"
            });
          });
        }
        transform(t10) {
          let {
            axes: e10 = this.axes,
            event: i10,
            from: s10 = {},
            reset: o10,
            selection: r10,
            to: a10 = {},
            trigger: n10
          } = t10, {
            inverted: h10,
            time: l2
          } = this, d2 = false, c2, p2;
          for (let t11 of (this.hoverPoints?.forEach((t12) => t12.setState()), e10)) {
            let {
              horiz: e11,
              len: g2,
              minPointOffset: u2 = 0,
              options: f2,
              reversed: m2
            } = t11, x2 = e11 ? "width" : "height", y2 = e11 ? "x" : "y", b2 = aN(a10[x2], t11.len), v2 = aN(s10[x2], t11.len), k2 = 10 > Math.abs(b2) ? 1 : b2 / v2, w2 = (s10[y2] || 0) + v2 / 2 - t11.pos, M2 = w2 - ((a10[y2] ?? t11.pos) + b2 / 2 - t11.pos) / k2, S2 = m2 && !h10 || !m2 && h10 ? -1 : 1;
            if (!o10 && (w2 < 0 || w2 > t11.len)) continue;
            let T2 = t11.toValue(M2, true) + (r10 || t11.isOrdinal ? 0 : u2 * S2), C2 = t11.toValue(M2 + g2 / k2, true) - (r10 || t11.isOrdinal ? 0 : u2 * S2 || 0), A2 = t11.allExtremes;
            if (T2 > C2 && ([T2, C2] = [C2, T2]), 1 === k2 && !o10 && "yAxis" === t11.coll && !A2) {
              for (let e12 of t11.series) {
                let t12 = e12.getExtremes(e12.getProcessedData(true).modified.getColumn("y") || [], true);
                A2 ?? (A2 = {
                  dataMin: Number.MAX_VALUE,
                  dataMax: -Number.MAX_VALUE
                }), aO(t12.dataMin) && aO(t12.dataMax) && (A2.dataMin = Math.min(t12.dataMin, A2.dataMin), A2.dataMax = Math.max(t12.dataMax, A2.dataMax));
              }
              t11.allExtremes = A2;
            }
            let {
              dataMin: P2,
              dataMax: L2,
              min: O2,
              max: E2
            } = aS(t11.getExtremes(), A2 || {}), I2 = l2.parse(f2.min), D2 = l2.parse(f2.max), B2 = P2 ?? I2, N2 = L2 ?? D2, z2 = C2 - T2, R2 = t11.categories ? 0 : Math.min(z2, N2 - B2), W2 = B2 - R2 * (ab(I2) ? 0 : f2.minPadding), H2 = N2 + R2 * (ab(D2) ? 0 : f2.maxPadding), X2 = t11.allowZoomOutside || 1 === k2 || "zoom" !== n10 && k2 > 1, F2 = Math.min(I2 ?? W2, W2, X2 ? O2 : W2), G2 = Math.max(D2 ?? H2, H2, X2 ? E2 : H2);
            (!t11.isOrdinal || t11.options.overscroll || 1 !== k2 || o10) && (T2 < F2 && (T2 = F2, k2 >= 1 && (C2 = T2 + z2)), C2 > G2 && (C2 = G2, k2 >= 1 && (T2 = C2 - z2)), (o10 || t11.series.length && (T2 !== O2 || C2 !== E2) && T2 >= F2 && C2 <= G2) && (r10 ? r10[t11.coll].push({
              axis: t11,
              min: T2,
              max: C2
            }) : (t11.isPanning = "zoom" !== n10, t11.isPanning && (p2 = true), t11.setExtremes(o10 ? void 0 : T2, o10 ? void 0 : C2, false, false, {
              move: M2,
              trigger: n10,
              scale: k2
            }), !o10 && (T2 > F2 || C2 < G2) && "mousewheel" !== n10 && (c2 = true)), d2 = true), i10 && (this[e11 ? "mouseDownX" : "mouseDownY"] = i10[e11 ? "chartX" : "chartY"]));
          }
          return d2 && (r10 ? aC(this, "selection", r10, () => {
            delete t10.selection, t10.trigger = "zoom", this.transform(t10);
          }) : (!c2 || p2 || this.resetZoomButton ? !c2 && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw("zoom" === n10 && (this.options.chart.animation ?? this.pointCount < 100)))), d2;
        }
      }
      aS(aG.prototype, {
        callbacks: [],
        collectionsWithInit: {
          xAxis: [aG.prototype.addAxis, [true]],
          yAxis: [aG.prototype.addAxis, [false]],
          series: [aG.prototype.addSeries]
        },
        collectionsWithUpdate: ["xAxis", "yAxis", "series"],
        propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],
        propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],
        propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]
      });
      let {
        stop: aY
      } = tR, {
        composed: aj
      } = k, {
        addEvent: aU,
        createElement: a$,
        css: aV,
        defined: a_,
        erase: aq,
        merge: aZ,
        pushUnique: aK
      } = $;
      function aJ() {
        let t10 = this.scrollablePlotArea;
        (this.scrollablePixelsX || this.scrollablePixelsY) && !t10 && (this.scrollablePlotArea = t10 = new a0(this)), t10?.applyFixed();
      }
      function aQ() {
        this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = true);
      }
      class a0 {
        static compose(t10, e10, i10) {
          aK(aj, this.compose) && (aU(t10, "afterInit", aQ), aU(e10, "afterSetChartSize", (t11) => this.afterSetSize(t11.target, t11)), aU(e10, "render", aJ), aU(i10, "show", aQ));
        }
        static afterSetSize(t10, e10) {
          let i10, s10, o10;
          let {
            minWidth: r10,
            minHeight: a10
          } = t10.options.chart.scrollablePlotArea || {}, {
            clipBox: n10,
            plotBox: h10,
            inverted: l2,
            renderer: d2
          } = t10;
          if (!d2.forExport && (r10 ? (t10.scrollablePixelsX = i10 = Math.max(0, r10 - t10.chartWidth), i10 && (t10.scrollablePlotBox = aZ(t10.plotBox), h10.width = t10.plotWidth += i10, n10[l2 ? "height" : "width"] += i10, o10 = true)) : a10 && (t10.scrollablePixelsY = s10 = Math.max(0, a10 - t10.chartHeight), a_(s10) && (t10.scrollablePlotBox = aZ(t10.plotBox), h10.height = t10.plotHeight += s10, n10[l2 ? "width" : "height"] += s10, o10 = false)), a_(o10) && !e10.skipAxes)) for (let e11 of t10.axes) (e11.horiz === o10 || t10.hasParallelCoordinates && "yAxis" === e11.coll) && (e11.setAxisSize(), e11.setAxisTranslation());
        }
        constructor(t10) {
          let e10;
          let i10 = t10.options.chart, s10 = er.getRendererType(), o10 = i10.scrollablePlotArea || {}, r10 = this.moveFixedElements.bind(this), a10 = {
            WebkitOverflowScrolling: "touch",
            overflowX: "hidden",
            overflowY: "hidden"
          };
          t10.scrollablePixelsX && (a10.overflowX = "auto"), t10.scrollablePixelsY && (a10.overflowY = "auto"), this.chart = t10;
          let n10 = this.parentDiv = a$("div", {
            className: "highcharts-scrolling-parent"
          }, {
            position: "relative"
          }, t10.renderTo), h10 = this.scrollingContainer = a$("div", {
            className: "highcharts-scrolling"
          }, a10, n10), l2 = this.innerContainer = a$("div", {
            className: "highcharts-inner-container"
          }, void 0, h10), d2 = this.fixedDiv = a$("div", {
            className: "highcharts-fixed"
          }, {
            position: "absolute",
            overflow: "hidden",
            pointerEvents: "none",
            zIndex: (i10.style?.zIndex || 0) + 2,
            top: 0
          }, void 0, true), c2 = this.fixedRenderer = new s10(d2, t10.chartWidth, t10.chartHeight, i10.style);
          this.mask = c2.path().attr({
            fill: i10.backgroundColor || "#fff",
            "fill-opacity": o10.opacity ?? 0.85,
            zIndex: -1
          }).addClass("highcharts-scrollable-mask").add(), h10.parentNode.insertBefore(d2, h10), aV(t10.renderTo, {
            overflow: "visible"
          }), aU(t10, "afterShowResetZoom", r10), aU(t10, "afterApplyDrilldown", r10), aU(t10, "afterLayOutTitles", r10), aU(h10, "scroll", () => {
            let {
              pointer: i11,
              hoverPoint: s11
            } = t10;
            i11 && (delete i11.chartPosition, s11 && (e10 = s11), i11.runPointActions(void 0, e10, true));
          }), l2.appendChild(t10.container);
        }
        applyFixed() {
          let {
            chart: t10,
            fixedRenderer: e10,
            isDirty: i10,
            scrollingContainer: s10
          } = this, {
            axisOffset: o10,
            chartWidth: r10,
            chartHeight: a10,
            container: n10,
            plotHeight: h10,
            plotLeft: l2,
            plotTop: d2,
            plotWidth: c2,
            scrollablePixelsX: p2 = 0,
            scrollablePixelsY: g2 = 0
          } = t10, {
            scrollPositionX: u2 = 0,
            scrollPositionY: f2 = 0
          } = t10.options.chart.scrollablePlotArea || {}, m2 = r10 + p2, x2 = a10 + g2;
          e10.setSize(r10, a10), (i10 ?? true) && (this.isDirty = false, this.moveFixedElements()), aY(t10.container), aV(n10, {
            width: `${m2}px`,
            height: `${x2}px`
          }), t10.renderer.boxWrapper.attr({
            width: m2,
            height: x2,
            viewBox: [0, 0, m2, x2].join(" ")
          }), t10.chartBackground?.attr({
            width: m2,
            height: x2
          }), aV(s10, {
            width: `${r10}px`,
            height: `${a10}px`
          }), a_(i10) || (s10.scrollLeft = p2 * u2, s10.scrollTop = g2 * f2);
          let y2 = d2 - o10[0] - 1, b2 = l2 - o10[3] - 1, v2 = d2 + h10 + o10[2] + 1, k2 = l2 + c2 + o10[1] + 1, w2 = l2 + c2 - p2, M2 = d2 + h10 - g2, S2 = [["M", 0, 0]];
          p2 ? S2 = [["M", 0, y2], ["L", l2 - 1, y2], ["L", l2 - 1, v2], ["L", 0, v2], ["Z"], ["M", w2, y2], ["L", r10, y2], ["L", r10, v2], ["L", w2, v2], ["Z"]] : g2 && (S2 = [["M", b2, 0], ["L", b2, d2 - 1], ["L", k2, d2 - 1], ["L", k2, 0], ["Z"], ["M", b2, M2], ["L", b2, a10], ["L", k2, a10], ["L", k2, M2], ["Z"]]), "adjustHeight" !== t10.redrawTrigger && this.mask.attr({
            d: S2
          });
        }
        moveFixedElements() {
          let t10;
          let {
            container: e10,
            inverted: i10,
            scrollablePixelsX: s10,
            scrollablePixelsY: o10
          } = this.chart, r10 = this.fixedRenderer, a10 = a0.fixedSelectors;
          if (s10 && !i10 ? t10 = ".highcharts-yaxis" : s10 && i10 ? t10 = ".highcharts-xaxis" : o10 && !i10 ? t10 = ".highcharts-xaxis" : o10 && i10 && (t10 = ".highcharts-yaxis"), t10 && !(this.chart.hasParallelCoordinates && ".highcharts-yaxis" === t10)) for (let e11 of [`${t10}:not(.highcharts-radial-axis)`, `${t10}-labels:not(.highcharts-radial-axis-labels)`]) aK(a10, e11);
          else for (let t11 of [".highcharts-xaxis", ".highcharts-yaxis"]) for (let e11 of [`${t11}:not(.highcharts-radial-axis)`, `${t11}-labels:not(.highcharts-radial-axis-labels)`]) aq(a10, e11);
          for (let t11 of a10) [].forEach.call(e10.querySelectorAll(t11), (t12) => {
            (t12.namespaceURI === r10.SVG_NS ? r10.box : r10.box.parentNode).appendChild(t12), t12.style.pointerEvents = "auto";
          });
        }
      }
      a0.fixedSelectors = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-drillup-button", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-range-selector-group", ".highcharts-reset-zoom", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];
      let {
        format: a1
      } = eo, {
        series: a2
      } = rd, {
        destroyObjectProperties: a3,
        fireEvent: a5,
        getAlignFactor: a6,
        isNumber: a9,
        pick: a4
      } = $, a8 = class {
        constructor(t10, e10, i10, s10, o10) {
          let r10 = t10.chart.inverted, a10 = t10.reversed;
          this.axis = t10;
          let n10 = this.isNegative = !!i10 != !!a10;
          this.options = e10 = e10 || {}, this.x = s10, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = false, this.stack = o10, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
            align: e10.align || (r10 ? n10 ? "left" : "right" : "center"),
            verticalAlign: e10.verticalAlign || (r10 ? "middle" : n10 ? "bottom" : "top"),
            y: e10.y,
            x: e10.x
          }, this.textAlign = e10.textAlign || (r10 ? n10 ? "right" : "left" : "center");
        }
        destroy() {
          a3(this, this.axis);
        }
        render(t10) {
          let e10 = this.axis.chart, i10 = this.options, s10 = i10.format, o10 = s10 ? a1(s10, this, e10) : i10.formatter.call(this);
          if (this.label) this.label.attr({
            text: o10,
            visibility: "hidden"
          });
          else {
            this.label = e10.renderer.label(o10, null, void 0, i10.shape, void 0, void 0, i10.useHTML, false, "stack-labels");
            let s11 = {
              r: i10.borderRadius || 0,
              text: o10,
              padding: a4(i10.padding, 5),
              visibility: "hidden"
            };
            e10.styledMode || (s11.fill = i10.backgroundColor, s11.stroke = i10.borderColor, s11["stroke-width"] = i10.borderWidth, this.label.css(i10.style || {})), this.label.attr(s11), this.label.added || this.label.add(t10);
          }
          this.label.labelrank = e10.plotSizeY, a5(this, "afterRender");
        }
        setOffset(t10, e10, i10, s10, o10, r10) {
          let {
            alignOptions: a10,
            axis: n10,
            label: h10,
            options: l2,
            textAlign: d2
          } = this, c2 = n10.chart, p2 = this.getStackBox({
            xOffset: t10,
            width: e10,
            boxBottom: i10,
            boxTop: s10,
            defaultX: o10,
            xAxis: r10
          }), {
            verticalAlign: g2
          } = a10;
          if (h10 && p2) {
            let t11 = h10.getBBox(void 0, 0), e11 = h10.padding, i11 = "justify" === a4(l2.overflow, "justify"), s11;
            a10.x = l2.x || 0, a10.y = l2.y || 0;
            let {
              x: o11,
              y: r11
            } = this.adjustStackPosition({
              labelBox: t11,
              verticalAlign: g2,
              textAlign: d2
            });
            p2.x -= o11, p2.y -= r11, h10.align(a10, false, p2), (s11 = c2.isInsidePlot(h10.alignAttr.x + a10.x + o11, h10.alignAttr.y + a10.y + r11)) || (i11 = false), i11 && a2.prototype.justifyDataLabel.call(n10, h10, a10, h10.alignAttr, t11, p2), h10.attr({
              x: h10.alignAttr.x,
              y: h10.alignAttr.y,
              rotation: l2.rotation,
              rotationOriginX: t11.width * a6(l2.textAlign || "center"),
              rotationOriginY: t11.height / 2
            }), a4(!i11 && l2.crop, true) && (s11 = a9(h10.x) && a9(h10.y) && c2.isInsidePlot(h10.x - e11 + (h10.width || 0), h10.y) && c2.isInsidePlot(h10.x + e11, h10.y)), h10[s11 ? "show" : "hide"]();
          }
          a5(this, "afterSetOffset", {
            xOffset: t10,
            width: e10
          });
        }
        adjustStackPosition({
          labelBox: t10,
          verticalAlign: e10,
          textAlign: i10
        }) {
          return {
            x: t10.width / 2 + t10.width / 2 * (2 * a6(i10) - 1),
            y: t10.height / 2 * 2 * (1 - a6(e10))
          };
        }
        getStackBox(t10) {
          let e10 = this.axis, i10 = e10.chart, {
            boxTop: s10,
            defaultX: o10,
            xOffset: r10,
            width: a10,
            boxBottom: n10
          } = t10, h10 = e10.stacking.usePercentage ? 100 : a4(s10, this.total, 0), l2 = e10.toPixels(h10), d2 = t10.xAxis || i10.xAxis[0], c2 = a4(o10, d2.translate(this.x)) + r10, p2 = Math.abs(l2 - e10.toPixels(n10 || a9(e10.min) && e10.logarithmic && e10.logarithmic.lin2log(e10.min) || 0)), g2 = i10.inverted, u2 = this.isNegative;
          return g2 ? {
            x: (u2 ? l2 : l2 - p2) - i10.plotLeft,
            y: d2.height - c2 - a10 + d2.top - i10.plotTop,
            width: p2,
            height: a10
          } : {
            x: c2 + d2.transB - i10.plotLeft,
            y: (u2 ? l2 - p2 : l2) - i10.plotTop,
            width: a10,
            height: p2
          };
        }
      }, {
        getDeferredAnimation: a7
      } = tR, {
        series: {
          prototype: nt
        }
      } = rd, {
        addEvent: ne,
        correctFloat: ni,
        defined: ns,
        destroyObjectProperties: no,
        fireEvent: nr,
        isNumber: na,
        objectEach: nn,
        pick: nh
      } = $;
      function nl() {
        let t10 = this.inverted;
        this.axes.forEach((t11) => {
          t11.stacking && t11.stacking.stacks && t11.hasVisibleSeries && (t11.stacking.oldStacks = t11.stacking.stacks);
        }), this.series.forEach((e10) => {
          let i10 = e10.xAxis && e10.xAxis.options || {};
          e10.options.stacking && e10.reserveSpace() && (e10.stackKey = [e10.type, nh(e10.options.stack, ""), t10 ? i10.top : i10.left, t10 ? i10.height : i10.width].join(","));
        });
      }
      function nd() {
        let t10 = this.stacking;
        if (t10) {
          let e10 = t10.stacks;
          nn(e10, (t11, i10) => {
            no(t11), delete e10[i10];
          }), t10.stackTotalGroup?.destroy();
        }
      }
      function nc() {
        this.stacking || (this.stacking = new nx(this));
      }
      function np(t10, e10, i10, s10) {
        return !ns(t10) || t10.x !== e10 || s10 && t10.stackKey !== s10 ? t10 = {
          x: e10,
          index: 0,
          key: s10,
          stackKey: s10
        } : t10.index++, t10.key = [i10, e10, t10.index].join(","), t10;
      }
      function ng() {
        let t10;
        let e10 = this, i10 = e10.yAxis, s10 = e10.stackKey || "", o10 = i10.stacking.stacks, r10 = e10.getColumn("x", true), a10 = e10.options.stacking, n10 = e10[a10 + "Stacker"];
        n10 && [s10, "-" + s10].forEach((i11) => {
          let s11 = r10.length, a11, h10, l2;
          for (; s11--; ) a11 = r10[s11], t10 = e10.getStackIndicator(t10, a11, e10.index, i11), h10 = o10[i11]?.[a11], (l2 = h10?.points[t10.key || ""]) && n10.call(e10, l2, h10, s11);
        });
      }
      function nu(t10, e10, i10) {
        let s10 = e10.total ? 100 / e10.total : 0;
        t10[0] = ni(t10[0] * s10), t10[1] = ni(t10[1] * s10), this.stackedYData[i10] = t10[1];
      }
      function nf(t10) {
        (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? nt.setStackedPoints.call(this, t10, "group") : t10.stacking.resetStacks());
      }
      function nm(t10, e10) {
        let i10, s10, o10, r10, a10, n10, h10;
        let l2 = e10 || this.options.stacking;
        if (!l2 || !this.reserveSpace() || ({
          group: "xAxis"
        }[l2] || "yAxis") !== t10.coll) return;
        let d2 = this.getColumn("x", true), c2 = this.getColumn(this.pointValKey || "y", true), p2 = [], g2 = c2.length, u2 = this.options, f2 = u2.threshold || 0, m2 = u2.startFromThreshold ? f2 : 0, x2 = u2.stack, y2 = e10 ? `${this.type},${l2}` : this.stackKey || "", b2 = "-" + y2, v2 = this.negStacks, k2 = t10.stacking, w2 = k2.stacks, M2 = k2.oldStacks;
        for (k2.stacksTouched += 1, h10 = 0; h10 < g2; h10++) {
          let e11 = d2[h10] || 0, g3 = c2[h10], u3 = na(g3) && g3 || 0;
          n10 = (i10 = this.getStackIndicator(i10, e11, this.index)).key || "", w2[a10 = (s10 = v2 && u3 < (m2 ? 0 : f2)) ? b2 : y2] || (w2[a10] = {}), w2[a10][e11] || (M2[a10]?.[e11] ? (w2[a10][e11] = M2[a10][e11], w2[a10][e11].total = null) : w2[a10][e11] = new a8(t10, t10.options.stackLabels, !!s10, e11, x2)), o10 = w2[a10][e11], null !== g3 ? (o10.points[n10] = o10.points[this.index] = [nh(o10.cumulative, m2)], ns(o10.cumulative) || (o10.base = n10), o10.touched = k2.stacksTouched, i10.index > 0 && false === this.singleStacks && (o10.points[n10][0] = o10.points[this.index + "," + e11 + ",0"][0])) : (delete o10.points[n10], delete o10.points[this.index]);
          let S2 = o10.total || 0;
          "percent" === l2 ? (r10 = s10 ? y2 : b2, S2 = v2 && w2[r10]?.[e11] ? (r10 = w2[r10][e11]).total = Math.max(r10.total || 0, S2) + Math.abs(u3) : ni(S2 + Math.abs(u3))) : "group" === l2 ? na(g3) && S2++ : S2 = ni(S2 + u3), "group" === l2 ? o10.cumulative = (S2 || 1) - 1 : o10.cumulative = ni(nh(o10.cumulative, m2) + u3), o10.total = S2, null !== g3 && (o10.points[n10].push(o10.cumulative), p2[h10] = o10.cumulative, o10.hasValidPoints = true);
        }
        "percent" === l2 && (k2.usePercentage = true), "group" !== l2 && (this.stackedYData = p2), k2.oldStacks = {};
      }
      class nx {
        constructor(t10) {
          this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t10;
        }
        buildStacks() {
          let t10, e10;
          let i10 = this.axis, s10 = i10.series, o10 = "xAxis" === i10.coll, r10 = i10.options.reversedStacks, a10 = s10.length;
          for (this.resetStacks(), this.usePercentage = false, e10 = a10; e10--; ) t10 = s10[r10 ? e10 : a10 - e10 - 1], o10 && t10.setGroupedPoints(i10), t10.setStackedPoints(i10);
          if (!o10) for (e10 = 0; e10 < a10; e10++) s10[e10].modifyStacks();
          nr(i10, "afterBuildStacks");
        }
        cleanStacks() {
          this.oldStacks && (this.stacks = this.oldStacks, nn(this.stacks, (t10) => {
            nn(t10, (t11) => {
              t11.cumulative = t11.total;
            });
          }));
        }
        resetStacks() {
          nn(this.stacks, (t10) => {
            nn(t10, (e10, i10) => {
              na(e10.touched) && e10.touched < this.stacksTouched ? (e10.destroy(), delete t10[i10]) : (e10.total = null, e10.cumulative = null);
            });
          });
        }
        renderStackTotals() {
          let t10 = this.axis, e10 = t10.chart, i10 = e10.renderer, s10 = this.stacks, o10 = a7(e10, t10.options.stackLabels?.animation || false), r10 = this.stackTotalGroup = this.stackTotalGroup || i10.g("stack-labels").attr({
            zIndex: 6,
            opacity: 0
          }).add();
          r10.translate(e10.plotLeft, e10.plotTop), nn(s10, (t11) => {
            nn(t11, (t12) => {
              t12.render(r10);
            });
          }), r10.animate({
            opacity: 1
          }, o10);
        }
      }
      (p || (p = {})).compose = function(t10, e10, i10) {
        let s10 = e10.prototype, o10 = i10.prototype;
        s10.getStacks || (ne(t10, "init", nc), ne(t10, "destroy", nd), s10.getStacks = nl, o10.getStackIndicator = np, o10.modifyStacks = ng, o10.percentStacker = nu, o10.setGroupedPoints = nf, o10.setStackedPoints = nm);
      };
      let ny = p, {
        defined: nb,
        merge: nv,
        isObject: nk
      } = $;
      class nw extends rY {
        drawGraph() {
          let t10 = this.options, e10 = (this.gappedPath || this.getGraphPath).call(this), i10 = this.chart.styledMode;
          [this, ...this.zones].forEach((s10, o10) => {
            let r10, a10 = s10.graph, n10 = a10 ? "animate" : "attr", h10 = s10.dashStyle || t10.dashStyle;
            a10 ? (a10.endX = this.preventGraphAnimation ? null : e10.xMap, a10.animate({
              d: e10
            })) : e10.length && (s10.graph = a10 = this.chart.renderer.path(e10).addClass("highcharts-graph" + (o10 ? ` highcharts-zone-graph-${o10 - 1} ` : " ") + (o10 && s10.className || "")).attr({
              zIndex: 1
            }).add(this.group)), a10 && !i10 && (r10 = {
              stroke: !o10 && t10.lineColor || s10.color || this.color || "#cccccc",
              "stroke-width": t10.lineWidth || 0,
              fill: this.fillGraph && this.color || "none"
            }, h10 ? r10.dashstyle = h10 : "square" !== t10.linecap && (r10["stroke-linecap"] = r10["stroke-linejoin"] = "round"), a10[n10](r10).shadow(t10.shadow && nv({
              filterUnits: "userSpaceOnUse"
            }, nk(t10.shadow) ? t10.shadow : {}))), a10 && (a10.startX = e10.xMap, a10.isArea = e10.isArea);
          });
        }
        getGraphPath(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = [], a10 = [], n10, h10 = o10.step, l2 = (t10 = t10 || s10.points).reversed;
          return l2 && t10.reverse(), (h10 = {
            right: 1,
            center: 2
          }[h10] || h10 && 3) && l2 && (h10 = 4 - h10), (t10 = this.getValidPoints(t10, false, !(o10.connectNulls && !e10 && !i10))).forEach(function(l3, d2) {
            let c2;
            let p2 = l3.plotX, g2 = l3.plotY, u2 = t10[d2 - 1], f2 = l3.isNull || "number" != typeof g2;
            (l3.leftCliff || u2 && u2.rightCliff) && !i10 && (n10 = true), f2 && !nb(e10) && d2 > 0 ? n10 = !o10.connectNulls : f2 && !e10 ? n10 = true : (0 === d2 || n10 ? c2 = [["M", l3.plotX, l3.plotY]] : s10.getPointSpline ? c2 = [s10.getPointSpline(t10, l3, d2)] : h10 ? (c2 = 1 === h10 ? [["L", u2.plotX, g2]] : 2 === h10 ? [["L", (u2.plotX + p2) / 2, u2.plotY], ["L", (u2.plotX + p2) / 2, g2]] : [["L", p2, u2.plotY]]).push(["L", p2, g2]) : c2 = [["L", p2, g2]], a10.push(l3.x), h10 && (a10.push(l3.x), 2 === h10 && a10.push(l3.x)), r10.push.apply(r10, c2), n10 = false);
          }), r10.xMap = a10, s10.graphPath = r10, r10;
        }
      }
      nw.defaultOptions = nv(rY.defaultOptions, {
        legendSymbol: "lineMarker"
      }), rd.registerSeriesType("line", nw);
      let {
        seriesTypes: {
          line: nM
        }
      } = rd, {
        extend: nS,
        merge: nT,
        objectEach: nC,
        pick: nA
      } = $;
      class nP extends nM {
        drawGraph() {
          this.areaPath = [], super.drawGraph.apply(this);
          let {
            areaPath: t10,
            options: e10
          } = this;
          [this, ...this.zones].forEach((i10, s10) => {
            let o10 = {}, r10 = i10.fillColor || e10.fillColor, a10 = i10.area, n10 = a10 ? "animate" : "attr";
            a10 ? (a10.endX = this.preventGraphAnimation ? null : t10.xMap, a10.animate({
              d: t10
            })) : (o10.zIndex = 0, (a10 = i10.area = this.chart.renderer.path(t10).addClass("highcharts-area" + (s10 ? ` highcharts-zone-area-${s10 - 1} ` : " ") + (s10 && i10.className || "")).add(this.group)).isArea = true), this.chart.styledMode || (o10.fill = r10 || i10.color || this.color, o10["fill-opacity"] = r10 ? 1 : e10.fillOpacity ?? 0.75, a10.css({
              pointerEvents: this.stickyTracking ? "none" : "auto"
            })), a10[n10](o10), a10.startX = t10.xMap, a10.shiftUnit = e10.step ? 2 : 1;
          });
        }
        getGraphPath(t10) {
          let e10, i10, s10;
          let o10 = nM.prototype.getGraphPath, r10 = this.options, a10 = r10.stacking, n10 = this.yAxis, h10 = [], l2 = [], d2 = this.index, c2 = n10.stacking.stacks[this.stackKey], p2 = r10.threshold, g2 = Math.round(n10.getThreshold(r10.threshold)), u2 = nA(r10.connectNulls, "percent" === a10), f2 = function(i11, s11, o11) {
            let r11 = t10[i11], u3 = a10 && c2[r11.x].points[d2], f3 = r11[o11 + "Null"] || 0, m3 = r11[o11 + "Cliff"] || 0, x3, y3, b3 = true;
            m3 || f3 ? (x3 = (f3 ? u3[0] : u3[1]) + m3, y3 = u3[0] + m3, b3 = !!f3) : !a10 && t10[s11] && t10[s11].isNull && (x3 = y3 = p2), void 0 !== x3 && (l2.push({
              plotX: e10,
              plotY: null === x3 ? g2 : n10.getThreshold(x3),
              isNull: b3,
              isCliff: true
            }), h10.push({
              plotX: e10,
              plotY: null === y3 ? g2 : n10.getThreshold(y3),
              doCurve: false
            }));
          };
          t10 = t10 || this.points, a10 && (t10 = this.getStackPoints(t10));
          for (let o11 = 0, r11 = t10.length; o11 < r11; ++o11) a10 || (t10[o11].leftCliff = t10[o11].rightCliff = t10[o11].leftNull = t10[o11].rightNull = void 0), i10 = t10[o11].isNull, e10 = nA(t10[o11].rectPlotX, t10[o11].plotX), s10 = a10 ? nA(t10[o11].yBottom, g2) : g2, i10 && !u2 || (u2 || f2(o11, o11 - 1, "left"), i10 && !a10 && u2 || (l2.push(t10[o11]), h10.push({
            x: o11,
            plotX: e10,
            plotY: s10
          })), u2 || f2(o11, o11 + 1, "right"));
          let m2 = o10.call(this, l2, true, true);
          h10.reversed = true;
          let x2 = o10.call(this, h10, true, true), y2 = x2[0];
          y2 && "M" === y2[0] && (x2[0] = ["L", y2[1], y2[2]]);
          let b2 = m2.concat(x2);
          b2.length && b2.push(["Z"]);
          let v2 = o10.call(this, l2, false, u2);
          return this.chart.series.length > 1 && a10 && l2.some((t11) => t11.isCliff) && (b2.hasStackedCliffs = v2.hasStackedCliffs = true), b2.xMap = m2.xMap, this.areaPath = b2, v2;
        }
        getStackPoints(t10) {
          let e10 = this, i10 = [], s10 = [], o10 = this.xAxis, r10 = this.yAxis, a10 = r10.stacking.stacks[this.stackKey], n10 = {}, h10 = r10.series, l2 = h10.length, d2 = r10.options.reversedStacks ? 1 : -1, c2 = h10.indexOf(e10);
          if (t10 = t10 || this.points, this.options.stacking) {
            for (let e11 = 0; e11 < t10.length; e11++) t10[e11].leftNull = t10[e11].rightNull = void 0, n10[t10[e11].x] = t10[e11];
            nC(a10, function(t11, e11) {
              null !== t11.total && s10.push(e11);
            }), s10.sort(function(t11, e11) {
              return t11 - e11;
            });
            let p2 = h10.map((t11) => t11.visible);
            s10.forEach(function(t11, g2) {
              let u2 = 0, f2, m2;
              if (n10[t11] && !n10[t11].isNull) i10.push(n10[t11]), [-1, 1].forEach(function(i11) {
                let o11 = 1 === i11 ? "rightNull" : "leftNull", r11 = a10[s10[g2 + i11]], u3 = 0;
                if (r11) {
                  let i12 = c2;
                  for (; i12 >= 0 && i12 < l2; ) {
                    let s11 = h10[i12].index;
                    !(f2 = r11.points[s11]) && (s11 === e10.index ? n10[t11][o11] = true : p2[i12] && (m2 = a10[t11].points[s11]) && (u3 -= m2[1] - m2[0])), i12 += d2;
                  }
                }
                n10[t11][1 === i11 ? "rightCliff" : "leftCliff"] = u3;
              });
              else {
                let e11 = c2;
                for (; e11 >= 0 && e11 < l2; ) {
                  let i11 = h10[e11].index;
                  if (f2 = a10[t11].points[i11]) {
                    u2 = f2[1];
                    break;
                  }
                  e11 += d2;
                }
                u2 = nA(u2, 0), u2 = r10.translate(u2, 0, 1, 0, 1), i10.push({
                  isNull: true,
                  plotX: o10.translate(t11, 0, 0, 0, 1),
                  x: t11,
                  plotY: u2,
                  yBottom: u2
                });
              }
            });
          }
          return i10;
        }
      }
      nP.defaultOptions = nT(nM.defaultOptions, {
        threshold: 0,
        legendSymbol: "areaMarker"
      }), nS(nP.prototype, {
        singleStacks: false
      }), rd.registerSeriesType("area", nP);
      let {
        line: nL
      } = rd.seriesTypes, {
        merge: nO,
        pick: nE
      } = $;
      class nI extends nL {
        getPointSpline(t10, e10, i10) {
          let s10, o10, r10, a10;
          let n10 = e10.plotX || 0, h10 = e10.plotY || 0, l2 = t10[i10 - 1], d2 = t10[i10 + 1];
          function c2(t11) {
            return t11 && !t11.isNull && false !== t11.doCurve && !e10.isCliff;
          }
          if (c2(l2) && c2(d2)) {
            let t11 = l2.plotX || 0, i11 = l2.plotY || 0, c3 = d2.plotX || 0, p3 = d2.plotY || 0, g2 = 0;
            s10 = (1.5 * n10 + t11) / 2.5, o10 = (1.5 * h10 + i11) / 2.5, r10 = (1.5 * n10 + c3) / 2.5, a10 = (1.5 * h10 + p3) / 2.5, r10 !== s10 && (g2 = (a10 - o10) * (r10 - n10) / (r10 - s10) + h10 - a10), o10 += g2, a10 += g2, o10 > i11 && o10 > h10 ? (o10 = Math.max(i11, h10), a10 = 2 * h10 - o10) : o10 < i11 && o10 < h10 && (o10 = Math.min(i11, h10), a10 = 2 * h10 - o10), a10 > p3 && a10 > h10 ? (a10 = Math.max(p3, h10), o10 = 2 * h10 - a10) : a10 < p3 && a10 < h10 && (a10 = Math.min(p3, h10), o10 = 2 * h10 - a10), e10.rightContX = r10, e10.rightContY = a10, e10.controlPoints = {
              low: [s10, o10],
              high: [r10, a10]
            };
          }
          let p2 = ["C", nE(l2.rightContX, l2.plotX, 0), nE(l2.rightContY, l2.plotY, 0), nE(s10, n10, 0), nE(o10, h10, 0), n10, h10];
          return l2.rightContX = l2.rightContY = void 0, p2;
        }
      }
      nI.defaultOptions = nO(nL.defaultOptions), rd.registerSeriesType("spline", nI);
      let nD = nI, {
        area: nB,
        area: {
          prototype: nN
        }
      } = rd.seriesTypes, {
        extend: nz,
        merge: nR
      } = $;
      class nW extends nD {
      }
      nW.defaultOptions = nR(nD.defaultOptions, nB.defaultOptions), nz(nW.prototype, {
        getGraphPath: nN.getGraphPath,
        getStackPoints: nN.getStackPoints,
        drawGraph: nN.drawGraph
      }), rd.registerSeriesType("areaspline", nW);
      let {
        animObject: nH
      } = tR, {
        parse: nX
      } = tk, {
        noop: nF
      } = k, {
        clamp: nG,
        crisp: nY,
        defined: nj,
        extend: nU,
        fireEvent: n$,
        isArray: nV,
        isNumber: n_,
        merge: nq,
        pick: nZ,
        objectEach: nK
      } = $;
      class nJ extends rY {
        animate(t10) {
          let e10, i10;
          let s10 = this, o10 = this.yAxis, r10 = o10.pos, a10 = o10.reversed, n10 = s10.options, {
            clipOffset: h10,
            inverted: l2
          } = this.chart, d2 = {}, c2 = l2 ? "translateX" : "translateY";
          t10 && h10 ? (d2.scaleY = 1e-3, i10 = nG(o10.toPixels(n10.threshold || 0), r10, r10 + o10.len), l2 ? (i10 += a10 ? -Math.floor(h10[0]) : Math.ceil(h10[2]), d2.translateX = i10 - o10.len) : (i10 += a10 ? Math.ceil(h10[0]) : -Math.floor(h10[2]), d2.translateY = i10), s10.clipBox && s10.setClip(), s10.group.attr(d2)) : (e10 = Number(s10.group.attr(c2)), s10.group.animate({
            scaleY: 1
          }, nU(nH(s10.options.animation), {
            step: function(t11, i11) {
              s10.group && (d2[c2] = e10 + i11.pos * (r10 - e10), s10.group.attr(d2));
            }
          })));
        }
        init(t10, e10) {
          super.init.apply(this, arguments);
          let i10 = this;
          (t10 = i10.chart).hasRendered && t10.series.forEach(function(t11) {
            t11.type === i10.type && (t11.isDirty = true);
          });
        }
        getColumnMetrics() {
          let t10 = this, e10 = t10.options, i10 = t10.xAxis, s10 = t10.yAxis, o10 = i10.options.reversedStacks, r10 = i10.reversed && !o10 || !i10.reversed && o10, a10 = {}, n10, h10 = 0;
          false === e10.grouping ? h10 = 1 : t10.chart.series.forEach(function(e11) {
            let i11;
            let o11 = e11.yAxis, r11 = e11.options;
            e11.type === t10.type && e11.reserveSpace() && s10.len === o11.len && s10.pos === o11.pos && (r11.stacking && "group" !== r11.stacking ? (void 0 === a10[n10 = e11.stackKey] && (a10[n10] = h10++), i11 = a10[n10]) : false !== r11.grouping && (i11 = h10++), e11.columnIndex = i11);
          });
          let l2 = Math.min(Math.abs(i10.transA) * (!i10.brokenAxis?.hasBreaks && i10.ordinal?.slope || e10.pointRange || i10.closestPointRange || i10.tickInterval || 1), i10.len), d2 = l2 * e10.groupPadding, c2 = (l2 - 2 * d2) / (h10 || 1), p2 = Math.min(e10.maxPointWidth || i10.len, nZ(e10.pointWidth, c2 * (1 - 2 * e10.pointPadding))), g2 = (t10.columnIndex || 0) + (r10 ? 1 : 0);
          return t10.columnMetrics = {
            width: p2,
            offset: (c2 - p2) / 2 + (d2 + g2 * c2 - l2 / 2) * (r10 ? -1 : 1),
            paddedWidth: c2,
            columnCount: h10
          }, t10.columnMetrics;
        }
        crispCol(t10, e10, i10, s10) {
          let o10 = this.borderWidth, r10 = this.chart.inverted;
          return s10 = nY(e10 + s10, o10, r10) - (e10 = nY(e10, o10, r10)), this.options.crisp && (i10 = nY(t10 + i10, o10) - (t10 = nY(t10, o10))), {
            x: t10,
            y: e10,
            width: i10,
            height: s10
          };
        }
        adjustForMissingColumns(t10, e10, i10, s10) {
          if (!i10.isNull && s10.columnCount > 1) {
            let o10 = this.xAxis.series.filter((t11) => t11.visible).map((t11) => t11.index), r10 = 0, a10 = 0;
            nK(this.xAxis.stacking?.stacks, (t11) => {
              let e11 = "number" == typeof i10.x ? t11[i10.x.toString()]?.points : void 0, s11 = e11?.[this.index], n11 = {};
              if (e11 && nV(s11)) {
                let t12 = this.index, i11 = Object.keys(e11).filter((t13) => !t13.match(",") && e11[t13] && e11[t13].length > 1).map(parseFloat).filter((t13) => -1 !== o10.indexOf(t13)).filter((e12) => {
                  let i12 = this.chart.series[e12].options, s12 = i12.stacking && i12.stack;
                  if (nj(s12)) {
                    if (n_(n11[s12])) return t12 === e12 && (t12 = n11[s12]), false;
                    n11[s12] = e12;
                  }
                  return true;
                }).sort((t13, e12) => e12 - t13);
                r10 = i11.indexOf(t12), a10 = i11.length;
              }
            }), r10 = this.xAxis.reversed ? a10 - 1 - r10 : r10;
            let n10 = (a10 - 1) * s10.paddedWidth + e10;
            t10 = (i10.plotX || 0) + n10 / 2 - e10 - r10 * s10.paddedWidth;
          }
          return t10;
        }
        translate() {
          let t10 = this, e10 = t10.chart, i10 = t10.options, s10 = t10.dense = t10.closestPointRange * t10.xAxis.transA < 2, o10 = t10.borderWidth = nZ(i10.borderWidth, s10 ? 0 : 1), r10 = t10.xAxis, a10 = t10.yAxis, n10 = i10.threshold, h10 = nZ(i10.minPointLength, 5), l2 = t10.getColumnMetrics(), d2 = l2.width, c2 = t10.pointXOffset = l2.offset, p2 = t10.dataMin, g2 = t10.dataMax, u2 = t10.translatedThreshold = a10.getThreshold(n10), f2 = t10.barW = Math.max(d2, 1 + 2 * o10);
          i10.pointPadding && i10.crisp && (f2 = Math.ceil(f2)), rY.prototype.translate.apply(t10), t10.points.forEach(function(s11) {
            let o11 = nZ(s11.yBottom, u2), m2 = 999 + Math.abs(o11), x2 = s11.plotX || 0, y2 = nG(s11.plotY, -m2, a10.len + m2), b2, v2 = Math.min(y2, o11), k2 = Math.max(y2, o11) - v2, w2 = d2, M2 = x2 + c2, S2 = f2;
            h10 && Math.abs(k2) < h10 && (k2 = h10, b2 = !a10.reversed && !s11.negative || a10.reversed && s11.negative, n_(n10) && n_(g2) && s11.y === n10 && g2 <= n10 && (a10.min || 0) < n10 && (p2 !== g2 || (a10.max || 0) <= n10) && (b2 = !b2, s11.negative = !s11.negative), v2 = Math.abs(v2 - u2) > h10 ? o11 - h10 : u2 - (b2 ? h10 : 0)), nj(s11.options.pointWidth) && (M2 -= Math.round(((w2 = S2 = Math.ceil(s11.options.pointWidth)) - d2) / 2)), i10.centerInCategory && (M2 = t10.adjustForMissingColumns(M2, w2, s11, l2)), s11.barX = M2, s11.pointWidth = w2, s11.tooltipPos = e10.inverted ? [nG(a10.len + a10.pos - e10.plotLeft - y2, a10.pos - e10.plotLeft, a10.len + a10.pos - e10.plotLeft), r10.len + r10.pos - e10.plotTop - M2 - S2 / 2, k2] : [r10.left - e10.plotLeft + M2 + S2 / 2, nG(y2 + a10.pos - e10.plotTop, a10.pos - e10.plotTop, a10.len + a10.pos - e10.plotTop), k2], s11.shapeType = t10.pointClass.prototype.shapeType || "roundedRect", s11.shapeArgs = t10.crispCol(M2, s11.isNull ? u2 : v2, S2, s11.isNull ? 0 : k2);
          }), n$(this, "afterColumnTranslate");
        }
        drawGraph() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = this.pointAttrToOptions || {}, o10 = s10.stroke || "borderColor", r10 = s10["stroke-width"] || "borderWidth", a10, n10, h10, l2 = t10 && t10.color || this.color, d2 = t10 && t10[o10] || i10[o10] || l2, c2 = t10 && t10.options.dashStyle || i10.dashStyle, p2 = t10 && t10[r10] || i10[r10] || this[r10] || 0, g2 = nZ(t10 && t10.opacity, i10.opacity, 1);
          t10 && this.zones.length && (n10 = t10.getZone(), l2 = t10.options.color || n10 && (n10.color || t10.nonZonedColor) || this.color, n10 && (d2 = n10.borderColor || d2, c2 = n10.dashStyle || c2, p2 = n10.borderWidth || p2)), e10 && t10 && (h10 = (a10 = nq(i10.states[e10], t10.options.states && t10.options.states[e10] || {})).brightness, l2 = a10.color || void 0 !== h10 && nX(l2).brighten(a10.brightness).get() || l2, d2 = a10[o10] || d2, p2 = a10[r10] || p2, c2 = a10.dashStyle || c2, g2 = nZ(a10.opacity, g2));
          let u2 = {
            fill: l2,
            stroke: d2,
            "stroke-width": p2,
            opacity: g2
          };
          return c2 && (u2.dashstyle = c2), u2;
        }
        drawPoints(t10 = this.points) {
          let e10;
          let i10 = this, s10 = this.chart, o10 = i10.options, r10 = s10.renderer, a10 = o10.animationLimit || 250;
          t10.forEach(function(t11) {
            let n10 = t11.plotY, h10 = t11.graphic, l2 = !!h10, d2 = h10 && s10.pointCount < a10 ? "animate" : "attr";
            n_(n10) && null !== t11.y ? (e10 = t11.shapeArgs, h10 && t11.hasNewShapeType() && (h10 = h10.destroy()), i10.enabledDataSorting && (t11.startXPos = i10.xAxis.reversed ? -(e10 && e10.width || 0) : i10.xAxis.width), !h10 && (t11.graphic = h10 = r10[t11.shapeType](e10).add(t11.group || i10.group), h10 && i10.enabledDataSorting && s10.hasRendered && s10.pointCount < a10 && (h10.attr({
              x: t11.startXPos
            }), l2 = true, d2 = "animate")), h10 && l2 && h10[d2](nq(e10)), s10.styledMode || h10[d2](i10.pointAttribs(t11, t11.selected && "select")).shadow(false !== t11.allowShadow && o10.shadow), h10 && (h10.addClass(t11.getClassName(), true), h10.attr({
              visibility: t11.visible ? "inherit" : "hidden"
            }))) : h10 && (t11.graphic = h10.destroy());
          });
        }
        drawTracker(t10 = this.points) {
          let e10;
          let i10 = this, s10 = i10.chart, o10 = s10.pointer, r10 = function(t11) {
            o10?.normalize(t11);
            let e11 = o10?.getPointFromEvent(t11), r11 = !s10.scrollablePlotArea || s10.isInsidePlot(t11.chartX - s10.plotLeft, t11.chartY - s10.plotTop, {
              visiblePlotOnly: true
            });
            o10 && e11 && i10.options.enableMouseTracking && r11 && (o10.isDirectTouch = true, e11.onMouseOver(t11));
          };
          t10.forEach(function(t11) {
            e10 = nV(t11.dataLabels) ? t11.dataLabels : t11.dataLabel ? [t11.dataLabel] : [], t11.graphic && (t11.graphic.element.point = t11), e10.forEach(function(e11) {
              (e11.div || e11.element).point = t11;
            });
          }), i10._hasTracking || (i10.trackerGroups.forEach(function(t11) {
            i10[t11] && (i10[t11].addClass("highcharts-tracker").on("mouseover", r10).on("mouseout", function(t12) {
              o10?.onTrackerMouseOut(t12);
            }).on("touchstart", r10), !s10.styledMode && i10.options.cursor && i10[t11].css({
              cursor: i10.options.cursor
            }));
          }), i10._hasTracking = true), n$(this, "afterDrawTracker");
        }
        remove() {
          let t10 = this, e10 = t10.chart;
          e10.hasRendered && e10.series.forEach(function(e11) {
            e11.type === t10.type && (e11.isDirty = true);
          }), rY.prototype.remove.apply(t10, arguments);
        }
      }
      nJ.defaultOptions = nq(rY.defaultOptions, {
        borderRadius: 3,
        centerInCategory: false,
        groupPadding: 0.2,
        marker: null,
        pointPadding: 0.1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: false,
            brightness: 0.1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: true,
        stickyTracking: false,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      }), nU(nJ.prototype, {
        directTouch: true,
        getSymbol: nF,
        negStacks: true,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), rd.registerSeriesType("column", nJ);
      let nQ = nJ, {
        getDeferredAnimation: n0
      } = tR, {
        format: n1
      } = eo, {
        defined: n2,
        extend: n3,
        fireEvent: n5,
        getAlignFactor: n6,
        isArray: n9,
        isString: n4,
        merge: n8,
        objectEach: n7,
        pick: ht,
        pInt: he,
        splat: hi
      } = $;
      !function(t10) {
        function e10() {
          return h10(this).some((t11) => t11?.enabled);
        }
        function i10(t11, e11, i11, s11, o11) {
          let {
            chart: r11,
            enabledDataSorting: a11
          } = this, n11 = this.isCartesian && r11.inverted, h11 = t11.plotX, l3 = t11.plotY, d2 = i11.rotation || 0, c2 = n2(h11) && n2(l3) && r11.isInsidePlot(h11, Math.round(l3), {
            inverted: n11,
            paneCoordinates: true,
            series: this
          }), p2 = 0 === d2 && "justify" === ht(i11.overflow, a11 ? "none" : "justify"), g2 = this.visible && false !== t11.visible && n2(h11) && (t11.series.forceDL || a11 && !p2 || c2 || ht(i11.inside, !!this.options.stacking) && s11 && r11.isInsidePlot(h11, n11 ? s11.x + 1 : s11.y + s11.height - 1, {
            inverted: n11,
            paneCoordinates: true,
            series: this
          })), u2 = t11.pos();
          if (g2 && u2) {
            var f2;
            let h12 = e11.getBBox(), l4 = e11.getBBox(void 0, 0);
            if (s11 = n3({
              x: u2[0],
              y: Math.round(u2[1]),
              width: 0,
              height: 0
            }, s11 || {}), "plotEdges" === i11.alignTo && this.isCartesian && (s11[n11 ? "x" : "y"] = 0, s11[n11 ? "width" : "height"] = this.yAxis?.len || 0), n3(i11, {
              width: h12.width,
              height: h12.height
            }), f2 = s11, a11 && this.xAxis && !p2 && this.setDataLabelStartPos(t11, e11, o11, c2, f2), e11.align(n8(i11, {
              width: l4.width,
              height: l4.height
            }), false, s11, false), e11.alignAttr.x += n6(i11.align) * (l4.width - h12.width), e11.alignAttr.y += n6(i11.verticalAlign) * (l4.height - h12.height), e11[e11.placed ? "animate" : "attr"]({
              "text-align": e11.alignAttr["text-align"] || "center",
              x: e11.alignAttr.x + (h12.width - l4.width) / 2,
              y: e11.alignAttr.y + (h12.height - l4.height) / 2,
              rotationOriginX: (e11.width || 0) / 2,
              rotationOriginY: (e11.height || 0) / 2
            }), p2 && s11.height >= 0) this.justifyDataLabel(e11, i11, e11.alignAttr, h12, s11, o11);
            else if (ht(i11.crop, true)) {
              let {
                x: t12,
                y: i12
              } = e11.alignAttr;
              g2 = r11.isInsidePlot(t12, i12, {
                paneCoordinates: true,
                series: this
              }) && r11.isInsidePlot(t12 + h12.width - 1, i12 + h12.height - 1, {
                paneCoordinates: true,
                series: this
              });
            }
            i11.shape && !d2 && e11[o11 ? "attr" : "animate"]({
              anchorX: u2[0],
              anchorY: u2[1]
            });
          }
          o11 && a11 && (e11.placed = false), g2 || a11 && !p2 ? (e11.show(), e11.placed = true) : (e11.hide(), e11.placed = false);
        }
        function s10() {
          return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
        }
        function o10(t11) {
          let e11 = this.hasRendered || 0, i11 = this.initDataLabelsGroup().attr({
            opacity: +e11
          });
          return !e11 && i11 && (this.visible && i11.show(), this.options.animation ? i11.animate({
            opacity: 1
          }, t11) : i11.attr({
            opacity: 1
          })), i11;
        }
        function r10(t11) {
          let e11;
          t11 = t11 || this.points;
          let i11 = this, s11 = i11.chart, o11 = i11.options, r11 = s11.renderer, {
            backgroundColor: a11,
            plotBackgroundColor: l3
          } = s11.options.chart, d2 = r11.getContrast(n4(l3) && l3 || n4(a11) && a11 || "#000000"), c2 = h10(i11), {
            animation: p2,
            defer: g2
          } = c2[0], u2 = g2 ? n0(s11, p2, i11) : {
            defer: 0,
            duration: 0
          };
          n5(this, "drawDataLabels"), i11.hasDataLabels?.() && (e11 = this.initDataLabels(u2), t11.forEach((t12) => {
            let a12 = t12.dataLabels || [];
            hi(n10(c2, t12.dlOptions || t12.options?.dataLabels)).forEach((n11, h12) => {
              let l4 = n11.enabled && (t12.visible || t12.dataLabelOnHidden) && (!t12.isNull || t12.dataLabelOnNull) && function(t13, e12) {
                let i12 = e12.filter;
                if (i12) {
                  let e13 = i12.operator, s12 = t13[i12.property], o12 = i12.value;
                  return ">" === e13 && s12 > o12 || "<" === e13 && s12 < o12 || ">=" === e13 && s12 >= o12 || "<=" === e13 && s12 <= o12 || "==" === e13 && s12 == o12 || "===" === e13 && s12 === o12 || "!=" === e13 && s12 != o12 || "!==" === e13 && s12 !== o12;
                }
                return true;
              }(t12, n11), {
                backgroundColor: c3,
                borderColor: p3,
                distance: g3,
                style: u3 = {}
              } = n11, f2, m2, x2, y2 = {}, b2 = a12[h12], v2 = !b2, k2;
              l4 && (m2 = n2(f2 = ht(n11[t12.formatPrefix + "Format"], n11.format)) ? n1(f2, t12, s11) : (n11[t12.formatPrefix + "Formatter"] || n11.formatter).call(t12, n11), x2 = n11.rotation, !s11.styledMode && (u3.color = ht(n11.color, u3.color, n4(i11.color) ? i11.color : void 0, "#000000"), "contrast" === u3.color ? ("none" !== c3 && (k2 = c3), t12.contrastColor = r11.getContrast("auto" !== k2 && k2 || t12.color || i11.color), u3.color = k2 || !n2(g3) && n11.inside || 0 > he(g3 || 0) || o11.stacking ? t12.contrastColor : d2) : delete t12.contrastColor, o11.cursor && (u3.cursor = o11.cursor)), y2 = {
                r: n11.borderRadius || 0,
                rotation: x2,
                padding: n11.padding,
                zIndex: 1
              }, s11.styledMode || (y2.fill = "auto" === c3 ? t12.color : c3, y2.stroke = "auto" === p3 ? t12.color : p3, y2["stroke-width"] = n11.borderWidth), n7(y2, (t13, e12) => {
                void 0 === t13 && delete y2[e12];
              })), !b2 || l4 && n2(m2) && !!b2.div == !!n11.useHTML && (b2.rotation && n11.rotation || b2.rotation === n11.rotation) || (b2 = void 0, v2 = true), l4 && n2(m2) && (b2 ? y2.text = m2 : (b2 = r11.label(m2, 0, 0, n11.shape, void 0, void 0, n11.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + t12.colorIndex + " " + (n11.className || "") + (n11.useHTML ? " highcharts-tracker" : "")), b2 && (b2.options = n11, b2.attr(y2), s11.styledMode ? u3.width && b2.css({
                width: u3.width,
                textOverflow: u3.textOverflow,
                whiteSpace: u3.whiteSpace
              }) : b2.css(u3).shadow(n11.shadow), n5(b2, "beforeAddingDataLabel", {
                labelOptions: n11,
                point: t12
              }), b2.added || b2.add(e11), i11.alignDataLabel(t12, b2, n11, void 0, v2), b2.isActive = true, a12[h12] && a12[h12] !== b2 && a12[h12].destroy(), a12[h12] = b2));
            });
            let h11 = a12.length;
            for (; h11--; ) a12[h11] && a12[h11].isActive ? a12[h11].isActive = false : (a12[h11]?.destroy(), a12.splice(h11, 1));
            t12.dataLabel = a12[0], t12.dataLabels = a12;
          })), n5(this, "afterDrawDataLabels");
        }
        function a10(t11, e11, i11, s11, o11, r11) {
          let a11 = this.chart, n11 = e11.align, h11 = e11.verticalAlign, l3 = t11.box ? 0 : t11.padding || 0, d2 = a11.inverted ? this.yAxis : this.xAxis, c2 = d2 ? d2.left - a11.plotLeft : 0, p2 = a11.inverted ? this.xAxis : this.yAxis, g2 = p2 ? p2.top - a11.plotTop : 0, {
            x: u2 = 0,
            y: f2 = 0
          } = e11, m2, x2;
          return (m2 = (i11.x || 0) + l3 + c2) < 0 && ("right" === n11 && u2 >= 0 ? (e11.align = "left", e11.inside = true) : u2 -= m2, x2 = true), (m2 = (i11.x || 0) + s11.width - l3 + c2) > a11.plotWidth && ("left" === n11 && u2 <= 0 ? (e11.align = "right", e11.inside = true) : u2 += a11.plotWidth - m2, x2 = true), (m2 = i11.y + l3 + g2) < 0 && ("bottom" === h11 && f2 >= 0 ? (e11.verticalAlign = "top", e11.inside = true) : f2 -= m2, x2 = true), (m2 = (i11.y || 0) + s11.height - l3 + g2) > a11.plotHeight && ("top" === h11 && f2 <= 0 ? (e11.verticalAlign = "bottom", e11.inside = true) : f2 += a11.plotHeight - m2, x2 = true), x2 && (e11.x = u2, e11.y = f2, t11.placed = !r11, t11.align(e11, void 0, o11)), x2;
        }
        function n10(t11, e11) {
          let i11 = [], s11;
          if (n9(t11) && !n9(e11)) i11 = t11.map(function(t12) {
            return n8(t12, e11);
          });
          else if (n9(e11) && !n9(t11)) i11 = e11.map(function(e12) {
            return n8(t11, e12);
          });
          else if (n9(t11) || n9(e11)) {
            if (n9(t11) && n9(e11)) for (s11 = Math.max(t11.length, e11.length); s11--; ) i11[s11] = n8(t11[s11], e11[s11]);
          } else i11 = n8(t11, e11);
          return i11;
        }
        function h10(t11) {
          let e11 = t11.chart.options.plotOptions;
          return hi(n10(n10(e11?.series?.dataLabels, e11?.[t11.type]?.dataLabels), t11.options.dataLabels));
        }
        function l2(t11, e11, i11, s11, o11) {
          let r11 = this.chart, a11 = r11.inverted, n11 = this.xAxis, h11 = n11.reversed, l3 = ((a11 ? e11.height : e11.width) || 0) / 2, d2 = t11.pointWidth, c2 = d2 ? d2 / 2 : 0;
          e11.startXPos = a11 ? o11.x : h11 ? -l3 - c2 : n11.width - l3 + c2, e11.startYPos = a11 ? h11 ? this.yAxis.height - l3 + c2 : -l3 - c2 : o11.y, s11 ? "hidden" === e11.visibility && (e11.show(), e11.attr({
            opacity: 0
          }).animate({
            opacity: 1
          })) : e11.attr({
            opacity: 1
          }).animate({
            opacity: 0
          }, void 0, e11.hide), r11.hasRendered && (i11 && e11.attr({
            x: e11.startXPos,
            y: e11.startYPos
          }), e11.placed = true);
        }
        t10.compose = function(t11) {
          let n11 = t11.prototype;
          n11.initDataLabels || (n11.initDataLabels = o10, n11.initDataLabelsGroup = s10, n11.alignDataLabel = i10, n11.drawDataLabels = r10, n11.justifyDataLabel = a10, n11.setDataLabelStartPos = l2, n11.hasDataLabels = e10);
        };
      }(g || (g = {}));
      let hs = g, {
        composed: ho
      } = k, {
        series: hr
      } = rd, {
        merge: ha,
        pick: hn,
        pushUnique: hh
      } = $;
      !function(t10) {
        function e10(t11, e11, i10, s10, o10) {
          let r10 = this.chart.inverted, a10 = t11.series, n10 = (a10.xAxis ? a10.xAxis.len : this.chart.plotSizeX) || 0, h10 = (a10.yAxis ? a10.yAxis.len : this.chart.plotSizeY) || 0, l2 = t11.dlBox || t11.shapeArgs, d2 = hn(t11.below, t11.plotY > hn(this.translatedThreshold, h10)), c2 = hn(i10.inside, !!this.options.stacking);
          if (l2) {
            if (s10 = ha(l2), !("allow" === i10.overflow && false === i10.crop)) {
              s10.y < 0 && (s10.height += s10.y, s10.y = 0);
              let t12 = s10.y + s10.height - h10;
              t12 > 0 && t12 < s10.height - 1 && (s10.height -= t12);
            }
            r10 && (s10 = {
              x: h10 - s10.y - s10.height,
              y: n10 - s10.x - s10.width,
              width: s10.height,
              height: s10.width
            }), c2 || (r10 ? (s10.x += d2 ? 0 : s10.width, s10.width = 0) : (s10.y += d2 ? s10.height : 0, s10.height = 0));
          }
          i10.align = hn(i10.align, !r10 || c2 ? "center" : d2 ? "right" : "left"), i10.verticalAlign = hn(i10.verticalAlign, r10 || c2 ? "middle" : d2 ? "top" : "bottom"), hr.prototype.alignDataLabel.call(this, t11, e11, i10, s10, o10), i10.inside && t11.contrastColor && e11.css({
            color: t11.contrastColor
          });
        }
        t10.compose = function(t11) {
          hs.compose(hr), hh(ho, "ColumnDataLabel") && (t11.prototype.alignDataLabel = e10);
        };
      }(u || (u = {}));
      let hl = u, {
        extend: hd,
        merge: hc
      } = $;
      class hp extends nQ {
      }
      hp.defaultOptions = hc(nQ.defaultOptions, {}), hd(hp.prototype, {
        inverted: true
      }), rd.registerSeriesType("bar", hp);
      let {
        column: hg,
        line: hu
      } = rd.seriesTypes, {
        addEvent: hf,
        extend: hm,
        merge: hx
      } = $;
      class hy extends hu {
        applyJitter() {
          let t10 = this, e10 = this.options.jitter, i10 = this.points.length;
          e10 && this.points.forEach(function(s10, o10) {
            ["x", "y"].forEach(function(r10, a10) {
              if (e10[r10] && !s10.isNull) {
                let n10 = `plot${r10.toUpperCase()}`, h10 = t10[`${r10}Axis`], l2 = e10[r10] * h10.transA;
                if (h10 && !h10.logarithmic) {
                  let t11 = Math.max(0, (s10[n10] || 0) - l2), e11 = Math.min(h10.len, (s10[n10] || 0) + l2);
                  s10[n10] = t11 + (e11 - t11) * function(t12) {
                    let e12 = 1e4 * Math.sin(t12);
                    return e12 - Math.floor(e12);
                  }(o10 + a10 * i10), "x" === r10 && (s10.clientX = s10.plotX);
                }
              }
            });
          });
        }
        drawGraph() {
          this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
        }
      }
      hy.defaultOptions = hx(hu.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: true
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      }), hm(hy.prototype, {
        drawTracker: hg.prototype.drawTracker,
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]
      }), hf(hy, "afterTranslate", function() {
        this.applyJitter();
      }), rd.registerSeriesType("scatter", hy);
      let {
        deg2rad: hb
      } = k, {
        fireEvent: hv,
        isNumber: hk,
        pick: hw,
        relativeLength: hM
      } = $;
      !function(t10) {
        t10.getCenter = function() {
          let t11 = this.options, e10 = this.chart, i10 = 2 * (t11.slicedOffset || 0), s10 = e10.plotWidth - 2 * i10, o10 = e10.plotHeight - 2 * i10, r10 = t11.center, a10 = Math.min(s10, o10), n10 = t11.thickness, h10, l2 = t11.size, d2 = t11.innerSize || 0, c2, p2;
          "string" == typeof l2 && (l2 = parseFloat(l2)), "string" == typeof d2 && (d2 = parseFloat(d2));
          let g2 = [hw(r10?.[0], "50%"), hw(r10?.[1], "50%"), hw(l2 && l2 < 0 ? void 0 : t11.size, "100%"), hw(d2 && d2 < 0 ? void 0 : t11.innerSize || 0, "0%")];
          for (!e10.angular || this instanceof rY || (g2[3] = 0), c2 = 0; c2 < 4; ++c2) p2 = g2[c2], h10 = c2 < 2 || 2 === c2 && /%$/.test(p2), g2[c2] = hM(p2, [s10, o10, a10, g2[2]][c2]) + (h10 ? i10 : 0);
          return g2[3] > g2[2] && (g2[3] = g2[2]), hk(n10) && 2 * n10 < g2[2] && n10 > 0 && (g2[3] = g2[2] - 2 * n10), hv(this, "afterGetCenter", {
            positions: g2
          }), g2;
        }, t10.getStartAndEndRadians = function(t11, e10) {
          let i10 = hk(t11) ? t11 : 0, s10 = hk(e10) && e10 > i10 && e10 - i10 < 360 ? e10 : i10 + 360;
          return {
            start: hb * (i10 + -90),
            end: hb * (s10 + -90)
          };
        };
      }(f || (f = {}));
      let hS = f, {
        setAnimation: hT
      } = tR, {
        addEvent: hC,
        defined: hA,
        extend: hP,
        isNumber: hL,
        pick: hO,
        relativeLength: hE
      } = $;
      class hI extends oF {
        getConnectorPath(t10) {
          let e10 = t10.dataLabelPosition, i10 = t10.options || {}, s10 = i10.connectorShape, o10 = this.connectorShapes[s10] || s10;
          return e10 && o10.call(this, __spreadProps(__spreadValues({}, e10.computed), {
            alignment: e10.alignment
          }), e10.connectorPosition, i10) || [];
        }
        getTranslate() {
          return this.sliced && this.slicedTranslation || {
            translateX: 0,
            translateY: 0
          };
        }
        haloPath(t10) {
          let e10 = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e10.x, e10.y, e10.r + t10, e10.r + t10, {
            innerR: e10.r - 1,
            start: e10.start,
            end: e10.end,
            borderRadius: e10.borderRadius
          });
        }
        constructor(t10, e10, i10) {
          super(t10, e10, i10), this.half = 0, this.name ?? (this.name = "Slice");
          let s10 = (t11) => {
            this.slice("select" === t11.type);
          };
          hC(this, "select", s10), hC(this, "unselect", s10);
        }
        isValid() {
          return hL(this.y) && this.y >= 0;
        }
        setVisible(t10, e10 = true) {
          t10 !== this.visible && this.update({
            visible: t10 ?? !this.visible
          }, e10, void 0, false);
        }
        slice(t10, e10, i10) {
          let s10 = this.series;
          hT(i10, s10.chart), e10 = hO(e10, true), this.sliced = this.options.sliced = t10 = hA(t10) ? t10 : !this.sliced, s10.options.data[s10.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
        }
      }
      hP(hI.prototype, {
        connectorShapes: {
          fixedOffset: function(t10, e10, i10) {
            let s10 = e10.breakAt, o10 = e10.touchingSliceAt, r10 = i10.softConnector ? ["C", t10.x + ("left" === t10.alignment ? -5 : 5), t10.y, 2 * s10.x - o10.x, 2 * s10.y - o10.y, s10.x, s10.y] : ["L", s10.x, s10.y];
            return [["M", t10.x, t10.y], r10, ["L", o10.x, o10.y]];
          },
          straight: function(t10, e10) {
            let i10 = e10.touchingSliceAt;
            return [["M", t10.x, t10.y], ["L", i10.x, i10.y]];
          },
          crookedLine: function(t10, e10, i10) {
            let {
              angle: s10 = this.angle || 0,
              breakAt: o10,
              touchingSliceAt: r10
            } = e10, {
              series: a10
            } = this, [n10, h10, l2] = a10.center, d2 = l2 / 2, {
              plotLeft: c2,
              plotWidth: p2
            } = a10.chart, g2 = "left" === t10.alignment, {
              x: u2,
              y: f2
            } = t10, m2 = o10.x;
            if (i10.crookDistance) {
              let t11 = hE(i10.crookDistance, 1);
              m2 = g2 ? n10 + d2 + (p2 + c2 - n10 - d2) * (1 - t11) : c2 + (n10 - d2) * t11;
            } else m2 = n10 + (h10 - f2) * Math.tan(s10 - Math.PI / 2);
            let x2 = [["M", u2, f2]];
            return (g2 ? m2 <= u2 && m2 >= o10.x : m2 >= u2 && m2 <= o10.x) && x2.push(["L", m2, f2]), x2.push(["L", o10.x, o10.y], ["L", r10.x, r10.y]), x2;
          }
        }
      });
      let {
        getStartAndEndRadians: hD
      } = hS, {
        noop: hB
      } = k, {
        clamp: hN,
        extend: hz,
        fireEvent: hR,
        merge: hW,
        pick: hH
      } = $;
      class hX extends rY {
        animate(t10) {
          let e10 = this, i10 = e10.points, s10 = e10.startAngleRad;
          t10 || i10.forEach(function(t11) {
            let i11 = t11.graphic, o10 = t11.shapeArgs;
            i11 && o10 && (i11.attr({
              r: hH(t11.startR, e10.center && e10.center[3] / 2),
              start: s10,
              end: s10
            }), i11.animate({
              r: o10.r,
              start: o10.start,
              end: o10.end
            }, e10.options.animation));
          });
        }
        drawEmpty() {
          let t10, e10;
          let i10 = this.startAngleRad, s10 = this.endAngleRad, o10 = this.options;
          0 === this.total && this.center ? (t10 = this.center[0], e10 = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t10, e10, this.center[1] / 2, 0, i10, s10).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
            d: e6.arc(t10, e10, this.center[2] / 2, 0, {
              start: i10,
              end: s10,
              innerR: this.center[3] / 2
            })
          }), this.chart.styledMode || this.graph.attr({
            "stroke-width": o10.borderWidth,
            fill: o10.fillColor || "none",
            stroke: o10.color || "#cccccc"
          })) : this.graph && (this.graph = this.graph.destroy());
        }
        drawPoints() {
          let t10 = this.chart.renderer;
          this.points.forEach(function(e10) {
            e10.graphic && e10.hasNewShapeType() && (e10.graphic = e10.graphic.destroy()), e10.graphic || (e10.graphic = t10[e10.shapeType](e10.shapeArgs).add(e10.series.group), e10.delayedRendering = true);
          });
        }
        generatePoints() {
          super.generatePoints(), this.updateTotals();
        }
        getX(t10, e10, i10, s10) {
          let o10 = this.center, r10 = this.radii ? this.radii[i10.index] || 0 : o10[2] / 2, a10 = s10.dataLabelPosition, n10 = a10?.distance || 0, h10 = Math.asin(hN((t10 - o10[1]) / (r10 + n10), -1, 1));
          return o10[0] + Math.cos(h10) * (r10 + n10) * (e10 ? -1 : 1) + (n10 > 0 ? (e10 ? -1 : 1) * (s10.padding || 0) : 0);
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        redrawPoints() {
          let t10, e10, i10, s10;
          let o10 = this, r10 = o10.chart;
          this.drawEmpty(), o10.group && !r10.styledMode && o10.group.shadow(o10.options.shadow), o10.points.forEach(function(a10) {
            let n10 = {};
            e10 = a10.graphic, !a10.isNull && e10 ? (s10 = a10.shapeArgs, t10 = a10.getTranslate(), r10.styledMode || (i10 = o10.pointAttribs(a10, a10.selected && "select")), a10.delayedRendering ? (e10.setRadialReference(o10.center).attr(s10).attr(t10), r10.styledMode || e10.attr(i10).attr({
              "stroke-linejoin": "round"
            }), a10.delayedRendering = false) : (e10.setRadialReference(o10.center), r10.styledMode || hW(true, n10, i10), hW(true, n10, s10, t10), e10.animate(n10)), e10.attr({
              visibility: a10.visible ? "inherit" : "hidden"
            }), e10.addClass(a10.getClassName(), true)) : e10 && (a10.graphic = e10.destroy());
          });
        }
        sortByAngle(t10, e10) {
          t10.sort(function(t11, i10) {
            return void 0 !== t11.angle && (i10.angle - t11.angle) * e10;
          });
        }
        translate(t10) {
          hR(this, "translate"), this.generatePoints();
          let e10 = this.options, i10 = e10.slicedOffset, s10 = hD(e10.startAngle, e10.endAngle), o10 = this.startAngleRad = s10.start, r10 = (this.endAngleRad = s10.end) - o10, a10 = this.points, n10 = e10.ignoreHiddenPoint, h10 = a10.length, l2, d2, c2, p2, g2, u2, f2, m2 = 0;
          for (t10 || (this.center = t10 = this.getCenter()), u2 = 0; u2 < h10; u2++) {
            f2 = a10[u2], l2 = o10 + m2 * r10, f2.isValid() && (!n10 || f2.visible) && (m2 += f2.percentage / 100), d2 = o10 + m2 * r10;
            let e11 = {
              x: t10[0],
              y: t10[1],
              r: t10[2] / 2,
              innerR: t10[3] / 2,
              start: Math.round(1e3 * l2) / 1e3,
              end: Math.round(1e3 * d2) / 1e3
            };
            f2.shapeType = "arc", f2.shapeArgs = e11, (c2 = (d2 + l2) / 2) > 1.5 * Math.PI ? c2 -= 2 * Math.PI : c2 < -Math.PI / 2 && (c2 += 2 * Math.PI), f2.slicedTranslation = {
              translateX: Math.round(Math.cos(c2) * i10),
              translateY: Math.round(Math.sin(c2) * i10)
            }, p2 = Math.cos(c2) * t10[2] / 2, g2 = Math.sin(c2) * t10[2] / 2, f2.tooltipPos = [t10[0] + 0.7 * p2, t10[1] + 0.7 * g2], f2.half = c2 < -Math.PI / 2 || c2 > Math.PI / 2 ? 1 : 0, f2.angle = c2;
          }
          hR(this, "afterTranslate");
        }
        updateTotals() {
          let t10 = this.points, e10 = t10.length, i10 = this.options.ignoreHiddenPoint, s10, o10, r10 = 0;
          for (s10 = 0; s10 < e10; s10++) (o10 = t10[s10]).isValid() && (!i10 || o10.visible) && (r10 += o10.y);
          for (s10 = 0, this.total = r10; s10 < e10; s10++) (o10 = t10[s10]).percentage = r10 > 0 && (o10.visible || !i10) ? o10.y / r10 * 100 : 0, o10.total = r10;
        }
      }
      hX.defaultOptions = hW(rY.defaultOptions, {
        borderRadius: 3,
        center: [null, null],
        clip: false,
        colorByPoint: true,
        dataLabels: {
          connectorPadding: 5,
          connectorShape: "crookedLine",
          crookDistance: void 0,
          distance: 30,
          enabled: true,
          formatter: function() {
            return this.isNull ? void 0 : this.name;
          },
          softConnector: true,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: true,
        inactiveOtherPoints: true,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: false,
        slicedOffset: 10,
        stickyTracking: false,
        tooltip: {
          followPointer: true
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: 0.1
          }
        }
      }), hz(hX.prototype, {
        axisTypes: [],
        directTouch: true,
        drawGraph: void 0,
        drawTracker: nQ.prototype.drawTracker,
        getCenter: hS.getCenter,
        getSymbol: hB,
        invertible: false,
        isCartesian: false,
        noSharedTooltip: true,
        pointAttribs: nQ.prototype.pointAttribs,
        pointClass: hI,
        requireSorting: false,
        searchPoint: hB,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), rd.registerSeriesType("pie", hX);
      let {
        composed: hF,
        noop: hG
      } = k, {
        distribute: hY
      } = ed, {
        series: hj
      } = rd, {
        arrayMax: hU,
        clamp: h$,
        defined: hV,
        pick: h_,
        pushUnique: hq,
        relativeLength: hZ
      } = $;
      !function(t10) {
        let e10 = {
          radialDistributionY: function(t11, e11) {
            return (e11.dataLabelPosition?.top || 0) + t11.distributeBox.pos;
          },
          radialDistributionX: function(t11, e11, i11, s11, o11) {
            let r11 = o11.dataLabelPosition;
            return t11.getX(i11 < (r11?.top || 0) + 2 || i11 > (r11?.bottom || 0) - 2 ? s11 : i11, e11.half, e11, o11);
          },
          justify: function(t11, e11, i11, s11) {
            return s11[0] + (t11.half ? -1 : 1) * (i11 + (e11.dataLabelPosition?.distance || 0));
          },
          alignToPlotEdges: function(t11, e11, i11, s11) {
            let o11 = t11.getBBox().width;
            return e11 ? o11 + s11 : i11 - o11 - s11;
          },
          alignToConnectors: function(t11, e11, i11, s11) {
            let o11 = 0, r11;
            return t11.forEach(function(t12) {
              (r11 = t12.dataLabel.getBBox().width) > o11 && (o11 = r11);
            }), e11 ? o11 + s11 : i11 - o11 - s11;
          }
        };
        function i10(t11, e11) {
          let i11 = Math.PI / 2, {
            start: s11 = 0,
            end: o11 = 0
          } = t11.shapeArgs || {}, r11 = t11.angle || 0;
          e11 > 0 && s11 < i11 && o11 > i11 && r11 > i11 / 2 && r11 < 1.5 * i11 && (r11 = r11 <= i11 ? Math.max(i11 / 2, (s11 + i11) / 2) : Math.min(1.5 * i11, (i11 + o11) / 2));
          let {
            center: a10,
            options: n10
          } = this, h10 = a10[2] / 2, l2 = Math.cos(r11), d2 = Math.sin(r11), c2 = a10[0] + l2 * h10, p2 = a10[1] + d2 * h10, g2 = Math.min((n10.slicedOffset || 0) + (n10.borderWidth || 0), e11 / 5);
          return {
            natural: {
              x: c2 + l2 * e11,
              y: p2 + d2 * e11
            },
            computed: {},
            alignment: e11 < 0 ? "center" : t11.half ? "right" : "left",
            connectorPosition: {
              angle: r11,
              breakAt: {
                x: c2 + l2 * g2,
                y: p2 + d2 * g2
              },
              touchingSliceAt: {
                x: c2,
                y: p2
              }
            },
            distance: e11
          };
        }
        function s10() {
          let t11 = this, e11 = t11.points, i11 = t11.chart, s11 = i11.plotWidth, o11 = i11.plotHeight, r11 = i11.plotLeft, a10 = Math.round(i11.chartWidth / 3), n10 = t11.center, h10 = n10[2] / 2, l2 = n10[1], d2 = [[], []], c2 = [0, 0, 0, 0], p2 = t11.dataLabelPositioners, g2, u2, f2, m2 = 0;
          t11.visible && t11.hasDataLabels?.() && (e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((t13) => {
              t13.shortened && (t13.attr({
                width: "auto"
              }).css({
                width: "auto",
                textOverflow: "clip"
              }), t13.shortened = false);
            });
          }), hj.prototype.drawDataLabels.apply(t11), e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((e12, i12) => {
              let s12 = n10[2] / 2, o12 = e12.options, r12 = hZ(o12?.distance || 0, s12);
              0 === i12 && d2[t12.half].push(t12), !hV(o12?.style?.width) && e12.getBBox().width > a10 && (e12.css({
                width: Math.round(0.7 * a10) + "px"
              }), e12.shortened = true), e12.dataLabelPosition = this.getDataLabelPosition(t12, r12), m2 = Math.max(m2, r12);
            });
          }), d2.forEach((e12, a11) => {
            let d3 = e12.length, g3 = [], x2, y2, b2 = 0, v2;
            d3 && (t11.sortByAngle(e12, a11 - 0.5), m2 > 0 && (x2 = Math.max(0, l2 - h10 - m2), y2 = Math.min(l2 + h10 + m2, i11.plotHeight), e12.forEach((t12) => {
              (t12.dataLabels || []).forEach((e13) => {
                let s12 = e13.dataLabelPosition;
                s12 && s12.distance > 0 && (s12.top = Math.max(0, l2 - h10 - s12.distance), s12.bottom = Math.min(l2 + h10 + s12.distance, i11.plotHeight), b2 = e13.getBBox().height || 21, e13.lineHeight = i11.renderer.fontMetrics(e13.text || e13).h + 2 * e13.padding, t12.distributeBox = {
                  target: (e13.dataLabelPosition?.natural.y || 0) - s12.top + e13.lineHeight / 2,
                  size: b2,
                  rank: t12.y
                }, g3.push(t12.distributeBox));
              });
            }), hY(g3, v2 = y2 + b2 - x2, v2 / 5)), e12.forEach((i12) => {
              (i12.dataLabels || []).forEach((l3) => {
                let d4 = l3.options || {}, m3 = i12.distributeBox, x3 = l3.dataLabelPosition, y3 = x3?.natural.y || 0, b3 = d4.connectorPadding || 0, v3 = l3.lineHeight || 21, k2 = (v3 - l3.getBBox().height) / 2, w2 = 0, M2 = y3, S2 = "inherit";
                if (x3) {
                  if (g3 && hV(m3) && x3.distance > 0 && (void 0 === m3.pos ? S2 = "hidden" : (f2 = m3.size, M2 = p2.radialDistributionY(i12, l3))), d4.justify) w2 = p2.justify(i12, l3, h10, n10);
                  else switch (d4.alignTo) {
                    case "connectors":
                      w2 = p2.alignToConnectors(e12, a11, s11, r11);
                      break;
                    case "plotEdges":
                      w2 = p2.alignToPlotEdges(l3, a11, s11, r11);
                      break;
                    default:
                      w2 = p2.radialDistributionX(t11, i12, M2 - k2, y3, l3);
                  }
                  if (x3.attribs = {
                    visibility: S2,
                    align: x3.alignment
                  }, x3.posAttribs = {
                    x: w2 + (d4.x || 0) + ({
                      left: b3,
                      right: -b3
                    }[x3.alignment] || 0),
                    y: M2 + (d4.y || 0) - v3 / 2
                  }, x3.computed.x = w2, x3.computed.y = M2 - k2, h_(d4.crop, true)) {
                    let t12;
                    w2 - (u2 = l3.getBBox().width) < b3 && 1 === a11 ? (t12 = Math.round(u2 - w2 + b3), c2[3] = Math.max(t12, c2[3])) : w2 + u2 > s11 - b3 && 0 === a11 && (t12 = Math.round(w2 + u2 - s11 + b3), c2[1] = Math.max(t12, c2[1])), M2 - f2 / 2 < 0 ? c2[0] = Math.max(Math.round(-M2 + f2 / 2), c2[0]) : M2 + f2 / 2 > o11 && (c2[2] = Math.max(Math.round(M2 + f2 / 2 - o11), c2[2])), x3.sideOverflow = t12;
                  }
                }
              });
            }));
          }), (0 === hU(c2) || this.verifyDataLabelOverflow(c2)) && (this.placeDataLabels(), this.points.forEach((e12) => {
            (e12.dataLabels || []).forEach((s12) => {
              let {
                connectorColor: o12,
                connectorWidth: r12 = 1
              } = s12.options || {}, a11 = s12.dataLabelPosition;
              if (r12) {
                let n11;
                g2 = s12.connector, a11 && a11.distance > 0 ? (n11 = !g2, g2 || (s12.connector = g2 = i11.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e12.colorIndex + (e12.className ? " " + e12.className : "")).add(t11.dataLabelsGroup)), i11.styledMode || g2.attr({
                  "stroke-width": r12,
                  stroke: o12 || e12.color || "#666666"
                }), g2[n11 ? "attr" : "animate"]({
                  d: e12.getConnectorPath(s12)
                }), g2.attr({
                  visibility: a11.attribs?.visibility
                })) : g2 && (s12.connector = g2.destroy());
              }
            });
          })));
        }
        function o10() {
          this.points.forEach((t11) => {
            (t11.dataLabels || []).forEach((t12) => {
              let e11 = t12.dataLabelPosition;
              e11 ? (e11.sideOverflow && (t12.css({
                width: Math.max(t12.getBBox().width - e11.sideOverflow, 0) + "px",
                textOverflow: (t12.options?.style || {}).textOverflow || "ellipsis"
              }), t12.shortened = true), t12.attr(e11.attribs), t12[t12.moved ? "animate" : "attr"](e11.posAttribs), t12.moved = true) : t12 && t12.attr({
                y: -9999
              });
            }), delete t11.distributeBox;
          }, this);
        }
        function r10(t11) {
          let e11 = this.center, i11 = this.options, s11 = i11.center, o11 = i11.minSize || 80, r11 = o11, a10 = null !== i11.size;
          return !a10 && (null !== s11[0] ? r11 = Math.max(e11[2] - Math.max(t11[1], t11[3]), o11) : (r11 = Math.max(e11[2] - t11[1] - t11[3], o11), e11[0] += (t11[3] - t11[1]) / 2), null !== s11[1] ? r11 = h$(r11, o11, e11[2] - Math.max(t11[0], t11[2])) : (r11 = h$(r11, o11, e11[2] - t11[0] - t11[2]), e11[1] += (t11[0] - t11[2]) / 2), r11 < e11[2] ? (e11[2] = r11, e11[3] = Math.min(i11.thickness ? Math.max(0, r11 - 2 * i11.thickness) : Math.max(0, hZ(i11.innerSize || 0, r11)), r11), this.translate(e11), this.drawDataLabels && this.drawDataLabels()) : a10 = true), a10;
        }
        t10.compose = function(t11) {
          if (hs.compose(hj), hq(hF, "PieDataLabel")) {
            let a10 = t11.prototype;
            a10.dataLabelPositioners = e10, a10.alignDataLabel = hG, a10.drawDataLabels = s10, a10.getDataLabelPosition = i10, a10.placeDataLabels = o10, a10.verifyDataLabelOverflow = r10;
          }
        };
      }(m || (m = {}));
      let hK = m;
      !function(t10) {
        t10.getCenterOfPoints = function(t11) {
          let e10 = t11.reduce((t12, e11) => (t12.x += e11.x, t12.y += e11.y, t12), {
            x: 0,
            y: 0
          });
          return {
            x: e10.x / t11.length,
            y: e10.y / t11.length
          };
        }, t10.getDistanceBetweenPoints = function(t11, e10) {
          return Math.sqrt(Math.pow(e10.x - t11.x, 2) + Math.pow(e10.y - t11.y, 2));
        }, t10.getAngleBetweenPoints = function(t11, e10) {
          return Math.atan2(e10.x - t11.x, e10.y - t11.y);
        }, t10.pointInPolygon = function({
          x: t11,
          y: e10
        }, i10) {
          let s10 = i10.length, o10, r10, a10 = false;
          for (o10 = 0, r10 = s10 - 1; o10 < s10; r10 = o10++) {
            let [s11, n10] = i10[o10], [h10, l2] = i10[r10];
            n10 > e10 != l2 > e10 && t11 < (h10 - s11) * (e10 - n10) / (l2 - n10) + s11 && (a10 = !a10);
          }
          return a10;
        };
      }(x || (x = {}));
      let {
        pointInPolygon: hJ
      } = x, {
        addEvent: hQ,
        fireEvent: h0,
        objectEach: h1,
        pick: h2
      } = $;
      function h3(t10) {
        let e10 = t10.length, i10 = (t11, e11) => !(e11.x >= t11.x + t11.width || e11.x + e11.width <= t11.x || e11.y >= t11.y + t11.height || e11.y + e11.height <= t11.y), s10 = (t11, e11) => {
          for (let i11 of t11) if (hJ({
            x: i11[0],
            y: i11[1]
          }, e11)) return true;
          return false;
        }, o10, r10, a10, n10, h10, l2 = false;
        for (let i11 = 0; i11 < e10; i11++) (o10 = t10[i11]) && (o10.oldOpacity = o10.opacity, o10.newOpacity = 1, o10.absoluteBox = function(t11) {
          if (t11 && (!t11.alignAttr || t11.placed)) {
            let e11 = t11.box ? 0 : t11.padding || 0, i12 = t11.alignAttr || {
              x: t11.attr("x"),
              y: t11.attr("y")
            }, s11 = t11.getBBox();
            return t11.width = s11.width, t11.height = s11.height, {
              x: i12.x + (t11.parentGroup?.translateX || 0) + e11,
              y: i12.y + (t11.parentGroup?.translateY || 0) + e11,
              width: (t11.width || 0) - 2 * e11,
              height: (t11.height || 0) - 2 * e11,
              polygon: s11?.polygon
            };
          }
        }(o10));
        t10.sort((t11, e11) => (e11.labelrank || 0) - (t11.labelrank || 0));
        for (let o11 = 0; o11 < e10; ++o11) {
          n10 = (r10 = t10[o11]) && r10.absoluteBox;
          let l3 = n10?.polygon;
          for (let d2 = o11 + 1; d2 < e10; ++d2) {
            h10 = (a10 = t10[d2]) && a10.absoluteBox;
            let e11 = false;
            if (n10 && h10 && r10 !== a10 && 0 !== r10.newOpacity && 0 !== a10.newOpacity && "hidden" !== r10.visibility && "hidden" !== a10.visibility) {
              let t11 = h10.polygon;
              if (l3 && t11 && l3 !== t11 ? s10(l3, t11) && (e11 = true) : i10(n10, h10) && (e11 = true), e11) {
                let t12 = r10.labelrank < a10.labelrank ? r10 : a10, e12 = t12.text;
                t12.newOpacity = 0, e12?.element.querySelector("textPath") && e12.hide();
              }
            }
          }
        }
        for (let e11 of t10) h5(e11, this) && (l2 = true);
        l2 && h0(this, "afterHideAllOverlappingLabels");
      }
      function h5(t10, e10) {
        let i10, s10, o10 = false;
        return t10 && (s10 = t10.newOpacity, t10.oldOpacity !== s10 && (t10.hasClass("highcharts-data-label") ? (t10[s10 ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), i10 = function() {
          e10.styledMode || t10.css({
            pointerEvents: s10 ? "auto" : "none"
          });
        }, o10 = true, t10[t10.isOld ? "animate" : "attr"]({
          opacity: s10
        }, void 0, i10), h0(e10, "afterHideOverlappingLabel")) : t10.attr({
          opacity: s10
        })), t10.isOld = true), o10;
      }
      function h6() {
        let t10 = this, e10 = [];
        for (let i10 of t10.labelCollectors || []) e10 = e10.concat(i10());
        for (let i10 of t10.yAxis || []) i10.stacking && i10.options.stackLabels && !i10.options.stackLabels.allowOverlap && h1(i10.stacking.stacks, (t11) => {
          h1(t11, (t12) => {
            t12.label && e10.push(t12.label);
          });
        });
        for (let i10 of t10.series || []) if (i10.visible && i10.hasDataLabels?.()) {
          let s10 = (i11) => {
            for (let s11 of i11) s11.visible && (s11.dataLabels || []).forEach((i12) => {
              let o10 = i12.options || {};
              i12.labelrank = h2(o10.labelrank, s11.labelrank, s11.shapeArgs?.height), o10.allowOverlap ?? Number(o10.distance) > 0 ? (i12.oldOpacity = i12.opacity, i12.newOpacity = 1, h5(i12, t10)) : e10.push(i12);
            });
          };
          s10(i10.nodes || []), s10(i10.points);
        }
        this.hideOverlappingLabels(e10);
      }
      let h9 = {
        compose: function(t10) {
          let e10 = t10.prototype;
          e10.hideOverlappingLabels || (e10.hideOverlappingLabels = h3, hQ(t10, "render", h6));
        }
      }, {
        defaultOptions: h4
      } = tm, {
        noop: h8
      } = k, {
        addEvent: h7,
        extend: lt,
        isObject: le,
        merge: li,
        relativeLength: ls
      } = $, lo = {
        radius: 0,
        scope: "stack",
        where: void 0
      }, lr = h8, la = h8;
      function ln(t10, e10, i10, s10, o10 = {}) {
        let r10 = lr(t10, e10, i10, s10, o10), {
          innerR: a10 = 0,
          r: n10 = i10,
          start: h10 = 0,
          end: l2 = 0
        } = o10;
        if (o10.open || !o10.borderRadius) return r10;
        let d2 = l2 - h10, c2 = Math.sin(d2 / 2), p2 = Math.max(Math.min(ls(o10.borderRadius || 0, n10 - a10), (n10 - a10) / 2, n10 * c2 / (1 + c2)), 0), g2 = Math.min(p2, d2 / Math.PI * 2 * a10), u2 = r10.length - 1;
        for (; u2--; ) !function(t11, e11, i11) {
          let s11, o11, r11;
          let a11 = t11[e11], n11 = t11[e11 + 1];
          if ("Z" === n11[0] && (n11 = t11[0]), ("M" === a11[0] || "L" === a11[0]) && "A" === n11[0] ? (s11 = a11, o11 = n11, r11 = true) : "A" === a11[0] && ("M" === n11[0] || "L" === n11[0]) && (s11 = n11, o11 = a11), s11 && o11 && o11.params) {
            let a12 = o11[1], n12 = o11[5], h11 = o11.params, {
              start: l3,
              end: d3,
              cx: c3,
              cy: p3
            } = h11, g3 = n12 ? a12 - i11 : a12 + i11, u3 = g3 ? Math.asin(i11 / g3) : 0, f2 = n12 ? u3 : -u3, m2 = Math.cos(u3) * g3;
            r11 ? (h11.start = l3 + f2, s11[1] = c3 + m2 * Math.cos(l3), s11[2] = p3 + m2 * Math.sin(l3), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c3 + a12 * Math.cos(h11.start), p3 + a12 * Math.sin(h11.start)])) : (h11.end = d3 - f2, o11[6] = c3 + a12 * Math.cos(h11.end), o11[7] = p3 + a12 * Math.sin(h11.end), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c3 + m2 * Math.cos(d3), p3 + m2 * Math.sin(d3)])), o11[4] = Math.abs(h11.end - h11.start) < Math.PI ? 0 : 1;
          }
        }(r10, u2, u2 > 1 ? g2 : p2);
        return r10;
      }
      function lh() {
        if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
          let {
            options: t10,
            yAxis: e10
          } = this, i10 = "percent" === t10.stacking, s10 = h4.plotOptions?.[this.type]?.borderRadius, o10 = ll(t10.borderRadius, le(s10) ? s10 : {}), r10 = e10.options.reversed;
          for (let s11 of this.points) {
            let {
              shapeArgs: a10
            } = s11;
            if ("roundedRect" === s11.shapeType && a10) {
              let {
                width: n10 = 0,
                height: h10 = 0,
                y: l2 = 0
              } = a10, d2 = l2, c2 = h10;
              if ("stack" === o10.scope && s11.stackTotal) {
                let o11 = e10.translate(i10 ? 100 : s11.stackTotal, false, true, false, true), r11 = e10.translate(t10.threshold || 0, false, true, false, true), a11 = this.crispCol(0, Math.min(o11, r11), 0, Math.abs(o11 - r11));
                d2 = a11.y, c2 = a11.height;
              }
              let p2 = (s11.negative ? -1 : 1) * (r10 ? -1 : 1) == -1, g2 = o10.where;
              !g2 && this.is("waterfall") && Math.abs((s11.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (g2 = "all"), g2 || (g2 = "end");
              let u2 = Math.min(ls(o10.radius, n10), n10 / 2, "all" === g2 ? h10 / 2 : 1 / 0) || 0;
              "end" === g2 && (p2 && (d2 -= u2), c2 += u2), lt(a10, {
                brBoxHeight: c2,
                brBoxY: d2,
                r: u2
              });
            }
          }
        }
      }
      function ll(t10, e10) {
        return le(t10) || (t10 = {
          radius: t10 || 0
        }), li(lo, e10, t10);
      }
      function ld() {
        let t10 = ll(this.options.borderRadius);
        for (let e10 of this.points) {
          let i10 = e10.shapeArgs;
          i10 && (i10.borderRadius = ls(t10.radius, (i10.r || 0) - (i10.innerR || 0)));
        }
      }
      function lc(t10, e10, i10, s10, o10 = {}) {
        let r10 = la(t10, e10, i10, s10, o10), {
          r: a10 = 0,
          brBoxHeight: n10 = s10,
          brBoxY: h10 = e10
        } = o10, l2 = e10 - h10, d2 = h10 + n10 - (e10 + s10), c2 = l2 - a10 > -0.1 ? 0 : a10, p2 = d2 - a10 > -0.1 ? 0 : a10, g2 = Math.max(c2 && l2, 0), u2 = Math.max(p2 && d2, 0), f2 = [t10 + c2, e10], m2 = [t10 + i10 - c2, e10], x2 = [t10 + i10, e10 + c2], y2 = [t10 + i10, e10 + s10 - p2], b2 = [t10 + i10 - p2, e10 + s10], v2 = [t10 + p2, e10 + s10], k2 = [t10, e10 + s10 - p2], w2 = [t10, e10 + c2], M2 = (t11, e11) => Math.sqrt(Math.pow(t11, 2) - Math.pow(e11, 2));
        if (g2) {
          let t11 = M2(c2, c2 - g2);
          f2[0] -= t11, m2[0] += t11, x2[1] = w2[1] = e10 + c2 - g2;
        }
        if (s10 < c2 - g2) {
          let o11 = M2(c2, c2 - g2 - s10);
          x2[0] = y2[0] = t10 + i10 - c2 + o11, b2[0] = Math.min(x2[0], b2[0]), v2[0] = Math.max(y2[0], v2[0]), k2[0] = w2[0] = t10 + c2 - o11, x2[1] = w2[1] = e10 + s10;
        }
        if (u2) {
          let t11 = M2(p2, p2 - u2);
          b2[0] += t11, v2[0] -= t11, y2[1] = k2[1] = e10 + s10 - p2 + u2;
        }
        if (s10 < p2 - u2) {
          let o11 = M2(p2, p2 - u2 - s10);
          x2[0] = y2[0] = t10 + i10 - p2 + o11, m2[0] = Math.min(x2[0], m2[0]), f2[0] = Math.max(y2[0], f2[0]), k2[0] = w2[0] = t10 + p2 - o11, y2[1] = k2[1] = e10;
        }
        return r10.length = 0, r10.push(["M", ...f2], ["L", ...m2], ["A", c2, c2, 0, 0, 1, ...x2], ["L", ...y2], ["A", p2, p2, 0, 0, 1, ...b2], ["L", ...v2], ["A", p2, p2, 0, 0, 1, ...k2], ["L", ...w2], ["A", c2, c2, 0, 0, 1, ...f2], ["Z"]), r10;
      }
      let {
        diffObjects: lp,
        extend: lg,
        find: lu,
        merge: lf,
        pick: lm,
        uniqueKey: lx
      } = $;
      !function(t10) {
        function e10(t11, e11) {
          let i11 = t11.condition;
          (i11.callback || function() {
            return this.chartWidth <= lm(i11.maxWidth, Number.MAX_VALUE) && this.chartHeight <= lm(i11.maxHeight, Number.MAX_VALUE) && this.chartWidth >= lm(i11.minWidth, 0) && this.chartHeight >= lm(i11.minHeight, 0);
          }).call(this) && e11.push(t11._id);
        }
        function i10(t11, e11) {
          let i11 = this.options.responsive, s10 = this.currentResponsive, o10 = [], r10;
          !e11 && i11 && i11.rules && i11.rules.forEach((t12) => {
            void 0 === t12._id && (t12._id = lx()), this.matchResponsiveRule(t12, o10);
          }, this);
          let a10 = lf(...o10.map((t12) => lu((i11 || {}).rules || [], (e12) => e12._id === t12)).map((t12) => t12 && t12.chartOptions));
          a10.isResponsiveOptions = true, o10 = o10.toString() || void 0;
          let n10 = s10 && s10.ruleIds;
          o10 === n10 || (s10 && (this.currentResponsive = void 0, this.updatingResponsive = true, this.update(s10.undoOptions, t11, true), this.updatingResponsive = false), o10 ? ((r10 = lp(a10, this.options, true, this.collectionsWithUpdate)).isResponsiveOptions = true, this.currentResponsive = {
            ruleIds: o10,
            mergedOptions: a10,
            undoOptions: r10
          }, this.updatingResponsive || this.update(a10, t11, true)) : this.currentResponsive = void 0);
        }
        t10.compose = function(t11) {
          let s10 = t11.prototype;
          return s10.matchResponsiveRule || lg(s10, {
            matchResponsiveRule: e10,
            setResponsive: i10
          }), t11;
        };
      }(y || (y = {}));
      let ly = y;
      k.AST = tK, k.Axis = sR, k.Chart = aG, k.Color = tk, k.DataLabel = hs, k.DataTableCore = re, k.Fx = tC, k.HTMLElement = iZ, k.Legend = ai, k.LegendSymbol = rr, k.OverlappingDataLabels = k.OverlappingDataLabels || h9, k.PlotLineOrBand = s4, k.Point = oF, k.Pointer = o9, k.RendererRegistry = er, k.Series = rY, k.SeriesRegistry = rd, k.StackItem = a8, k.SVGElement = ej, k.SVGRenderer = iR, k.Templating = eo, k.Tick = sa, k.Time = td, k.Tooltip = ok, k.animate = tR.animate, k.animObject = tR.animObject, k.chart = aG.chart, k.color = tk.parse, k.dateFormat = eo.dateFormat, k.defaultOptions = tm.defaultOptions, k.distribute = ed.distribute, k.format = eo.format, k.getDeferredAnimation = tR.getDeferredAnimation, k.getOptions = tm.getOptions, k.numberFormat = eo.numberFormat, k.seriesType = rd.seriesType, k.setAnimation = tR.setAnimation, k.setOptions = tm.setOptions, k.stop = tR.stop, k.time = tm.defaultTime, k.timers = tC.timers, {
        compose: function(t10, e10, i10) {
          let s10 = t10.types.pie;
          if (!e10.symbolCustomAttribs.includes("borderRadius")) {
            let o10 = i10.prototype.symbols;
            h7(t10, "afterColumnTranslate", lh, {
              order: 9
            }), h7(s10, "afterTranslate", ld), e10.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), lr = o10.arc, la = o10.roundedRect, o10.arc = ln, o10.roundedRect = lc;
          }
        },
        optionsToObject: ll
      }.compose(k.Series, k.SVGElement, k.SVGRenderer), hl.compose(k.Series.types.column), hs.compose(k.Series), sG.compose(k.Axis), iZ.compose(k.SVGRenderer), ai.compose(k.Chart), s$.compose(k.Axis), h9.compose(k.Chart), hK.compose(k.Series.types.pie), s4.compose(k.Chart, k.Axis), o9.compose(k.Chart), ly.compose(k.Chart), a0.compose(k.Axis, k.Chart, k.Series), ny.compose(k.Axis, k.Chart, k.Series), ok.compose(k.Pointer), $.extend(k, $);
      let lb = k;
      return v.default;
    })());
  }
});

// node_modules/highcharts/highmaps.js
var require_highmaps = __commonJS({
  "node_modules/highcharts/highmaps.js"(exports, module) {
    !/**
    * Highcharts JS v12.1.2 (2024-12-21)
    * @module highcharts/highcharts
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? (t._Highcharts = e(), module.exports = t._Highcharts) : "function" == typeof define && define.amd ? define("highcharts/highcharts", [], e) : "object" == typeof exports ? (t._Highcharts = e(), exports.highcharts = t._Highcharts) : (t.Highcharts && t.Highcharts.error(16, true), t.Highcharts = e());
    }("undefined" == typeof window ? exports : window, () => (() => {
      "use strict";
      let t, e, i;
      var s, o, r, a, n, l, h, d, c, p, u, g, m, f, x, y, b, v, M, w, k, S, T = {};
      T.d = (t10, e10) => {
        for (var i10 in e10) T.o(e10, i10) && !T.o(t10, i10) && Object.defineProperty(t10, i10, {
          enumerable: true,
          get: e10[i10]
        });
      }, T.o = (t10, e10) => Object.prototype.hasOwnProperty.call(t10, e10);
      var C = {};
      T.d(C, {
        default: () => p8
      }), function(t10) {
        t10.SVG_NS = "http://www.w3.org/2000/svg", t10.product = "Highcharts", t10.version = "12.1.2", t10.win = "undefined" != typeof window ? window : {}, t10.doc = t10.win.document, t10.svg = t10.doc && t10.doc.createElementNS && !!t10.doc.createElementNS(t10.SVG_NS, "svg").createSVGRect, t10.pageLang = t10.doc?.documentElement?.closest("[lang]")?.lang, t10.userAgent = t10.win.navigator && t10.win.navigator.userAgent || "", t10.isChrome = t10.win.chrome, t10.isFirefox = -1 !== t10.userAgent.indexOf("Firefox"), t10.isMS = /(edge|msie|trident)/i.test(t10.userAgent) && !t10.win.opera, t10.isSafari = !t10.isChrome && -1 !== t10.userAgent.indexOf("Safari"), t10.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(t10.userAgent), t10.isWebKit = -1 !== t10.userAgent.indexOf("AppleWebKit"), t10.deg2rad = 2 * Math.PI / 360, t10.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], t10.noop = function() {
        }, t10.supportsPassiveEvents = function() {
          let e10 = false;
          if (!t10.isMS) {
            let i10 = Object.defineProperty({}, "passive", {
              get: function() {
                e10 = true;
              }
            });
            t10.win.addEventListener && t10.win.removeEventListener && (t10.win.addEventListener("testPassive", t10.noop, i10), t10.win.removeEventListener("testPassive", t10.noop, i10));
          }
          return e10;
        }(), t10.charts = [], t10.composed = [], t10.dateFormats = {}, t10.seriesTypes = {}, t10.symbolSizes = {}, t10.chartCount = 0;
      }(s || (s = {}));
      let A = s, {
        charts: P,
        doc: L,
        win: O
      } = A;
      function E(t10, e10, i10, s10) {
        let o10 = e10 ? "Highcharts error" : "Highcharts warning";
        32 === t10 && (t10 = `${o10}: Deprecated member`);
        let r10 = W(t10), a10 = r10 ? `${o10} #${t10}: www.highcharts.com/errors/${t10}/` : t10.toString();
        if (void 0 !== s10) {
          let t11 = "";
          r10 && (a10 += "?"), $(s10, function(e11, i11) {
            t11 += `
 - ${i11}: ${e11}`, r10 && (a10 += encodeURI(i11) + "=" + encodeURI(e11));
          }), a10 += t11;
        }
        q(A, "displayError", {
          chart: i10,
          code: t10,
          message: a10,
          params: s10
        }, function() {
          if (e10) throw Error(a10);
          O.console && -1 === E.messages.indexOf(a10) && console.warn(a10);
        }), E.messages.push(a10);
      }
      function I(t10, e10) {
        return parseInt(t10, e10 || 10);
      }
      function D(t10) {
        return "string" == typeof t10;
      }
      function B(t10) {
        let e10 = Object.prototype.toString.call(t10);
        return "[object Array]" === e10 || "[object Array Iterator]" === e10;
      }
      function z(t10, e10) {
        return !!t10 && "object" == typeof t10 && (!e10 || !B(t10));
      }
      function N(t10) {
        return z(t10) && "number" == typeof t10.nodeType;
      }
      function R(t10) {
        let e10 = t10 && t10.constructor;
        return !!(z(t10, true) && !N(t10) && e10 && e10.name && "Object" !== e10.name);
      }
      function W(t10) {
        return "number" == typeof t10 && !isNaN(t10) && t10 < 1 / 0 && t10 > -1 / 0;
      }
      function j(t10) {
        return null != t10;
      }
      function X(t10, e10, i10) {
        let s10;
        let o10 = D(e10) && !j(i10), r10 = (e11, i11) => {
          j(e11) ? t10.setAttribute(i11, e11) : o10 ? (s10 = t10.getAttribute(i11)) || "class" !== i11 || (s10 = t10.getAttribute(i11 + "Name")) : t10.removeAttribute(i11);
        };
        return D(e10) ? r10(i10, e10) : $(e10, r10), s10;
      }
      function G(t10) {
        return B(t10) ? t10 : [t10];
      }
      function F(t10, e10) {
        let i10;
        for (i10 in t10 || (t10 = {}), e10) t10[i10] = e10[i10];
        return t10;
      }
      function H() {
        let t10 = arguments, e10 = t10.length;
        for (let i10 = 0; i10 < e10; i10++) {
          let e11 = t10[i10];
          if (null != e11) return e11;
        }
      }
      function Y(t10, e10) {
        F(t10.style, e10);
      }
      function V(t10) {
        return Math.pow(10, Math.floor(Math.log(t10) / Math.LN10));
      }
      function U(t10, e10) {
        return t10 > 1e14 ? t10 : parseFloat(t10.toPrecision(e10 || 14));
      }
      (E || (E = {})).messages = [], Math.easeInOutSine = function(t10) {
        return -0.5 * (Math.cos(Math.PI * t10) - 1);
      };
      let Z = Array.prototype.find ? function(t10, e10) {
        return t10.find(e10);
      } : function(t10, e10) {
        let i10;
        let s10 = t10.length;
        for (i10 = 0; i10 < s10; i10++) if (e10(t10[i10], i10)) return t10[i10];
      };
      function $(t10, e10, i10) {
        for (let s10 in t10) Object.hasOwnProperty.call(t10, s10) && e10.call(i10 || t10[s10], t10[s10], s10, t10);
      }
      function _(t10, e10, i10) {
        function s10(e11, i11) {
          let s11 = t10.removeEventListener;
          s11 && s11.call(t10, e11, i11, false);
        }
        function o10(i11) {
          let o11, r11;
          t10.nodeName && (e10 ? (o11 = {})[e10] = true : o11 = i11, $(o11, function(t11, e11) {
            if (i11[e11]) for (r11 = i11[e11].length; r11--; ) s10(e11, i11[e11][r11].fn);
          }));
        }
        let r10 = "function" == typeof t10 && t10.prototype || t10;
        if (Object.hasOwnProperty.call(r10, "hcEvents")) {
          let t11 = r10.hcEvents;
          if (e10) {
            let r11 = t11[e10] || [];
            i10 ? (t11[e10] = r11.filter(function(t12) {
              return i10 !== t12.fn;
            }), s10(e10, i10)) : (o10(t11), t11[e10] = []);
          } else o10(t11), delete r10.hcEvents;
        }
      }
      function q(t10, e10, i10, s10) {
        if (i10 = i10 || {}, L.createEvent && (t10.dispatchEvent || t10.fireEvent && t10 !== A)) {
          let s11 = L.createEvent("Events");
          s11.initEvent(e10, true, true), i10 = F(s11, i10), t10.dispatchEvent ? t10.dispatchEvent(i10) : t10.fireEvent(e10, i10);
        } else if (t10.hcEvents) {
          i10.target || F(i10, {
            preventDefault: function() {
              i10.defaultPrevented = true;
            },
            target: t10,
            type: e10
          });
          let s11 = [], o10 = t10, r10 = false;
          for (; o10.hcEvents; ) Object.hasOwnProperty.call(o10, "hcEvents") && o10.hcEvents[e10] && (s11.length && (r10 = true), s11.unshift.apply(s11, o10.hcEvents[e10])), o10 = Object.getPrototypeOf(o10);
          r10 && s11.sort((t11, e11) => t11.order - e11.order), s11.forEach((e11) => {
            false === e11.fn.call(t10, i10) && i10.preventDefault();
          });
        }
        s10 && !i10.defaultPrevented && s10.call(t10, i10);
      }
      let K = function() {
        let e10 = Math.random().toString(36).substring(2, 9) + "-", i10 = 0;
        return function() {
          return "highcharts-" + (t ? "" : e10) + i10++;
        };
      }();
      O.jQuery && (O.jQuery.fn.highcharts = function() {
        let t10 = [].slice.call(arguments);
        if (this[0]) return t10[0] ? (new A[D(t10[0]) ? t10.shift() : "Chart"](this[0], t10[0], t10[1]), this) : P[X(this[0], "data-highcharts-chart")];
      });
      let J = {
        addEvent: function(t10, e10, i10, s10 = {}) {
          let o10 = "function" == typeof t10 && t10.prototype || t10;
          Object.hasOwnProperty.call(o10, "hcEvents") || (o10.hcEvents = {});
          let r10 = o10.hcEvents;
          A.Point && t10 instanceof A.Point && t10.series && t10.series.chart && (t10.series.chart.runTrackerClick = true);
          let a10 = t10.addEventListener;
          a10 && a10.call(t10, e10, i10, !!A.supportsPassiveEvents && {
            passive: void 0 === s10.passive ? -1 !== e10.indexOf("touch") : s10.passive,
            capture: false
          }), r10[e10] || (r10[e10] = []);
          let n10 = {
            fn: i10,
            order: "number" == typeof s10.order ? s10.order : 1 / 0
          };
          return r10[e10].push(n10), r10[e10].sort((t11, e11) => t11.order - e11.order), function() {
            _(t10, e10, i10);
          };
        },
        arrayMax: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] > i10 && (i10 = t10[e10]);
          return i10;
        },
        arrayMin: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] < i10 && (i10 = t10[e10]);
          return i10;
        },
        attr: X,
        clamp: function(t10, e10, i10) {
          return t10 > e10 ? t10 < i10 ? t10 : i10 : e10;
        },
        clearTimeout: function(t10) {
          j(t10) && clearTimeout(t10);
        },
        correctFloat: U,
        createElement: function(t10, e10, i10, s10, o10) {
          let r10 = L.createElement(t10);
          return e10 && F(r10, e10), o10 && Y(r10, {
            padding: "0",
            border: "none",
            margin: "0"
          }), i10 && Y(r10, i10), s10 && s10.appendChild(r10), r10;
        },
        crisp: function(t10, e10 = 0, i10) {
          let s10 = e10 % 2 / 2, o10 = i10 ? -1 : 1;
          return (Math.round(t10 * o10 - s10) + s10) * o10;
        },
        css: Y,
        defined: j,
        destroyObjectProperties: function(t10, e10, i10) {
          $(t10, function(s10, o10) {
            s10 !== e10 && s10?.destroy && s10.destroy(), (s10?.destroy || !i10) && delete t10[o10];
          });
        },
        diffObjects: function(t10, e10, i10, s10) {
          let o10 = {};
          return !function t11(e11, o11, r10, a10) {
            let n10 = i10 ? o11 : e11;
            $(e11, function(i11, l10) {
              if (!a10 && s10 && s10.indexOf(l10) > -1 && o11[l10]) {
                i11 = G(i11), r10[l10] = [];
                for (let e12 = 0; e12 < Math.max(i11.length, o11[l10].length); e12++) o11[l10][e12] && (void 0 === i11[e12] ? r10[l10][e12] = o11[l10][e12] : (r10[l10][e12] = {}, t11(i11[e12], o11[l10][e12], r10[l10][e12], a10 + 1)));
              } else z(i11, true) && !i11.nodeType ? (r10[l10] = B(i11) ? [] : {}, t11(i11, o11[l10] || {}, r10[l10], a10 + 1), 0 !== Object.keys(r10[l10]).length || "colorAxis" === l10 && 0 === a10 || delete r10[l10]) : (e11[l10] !== o11[l10] || l10 in e11 && !(l10 in o11)) && "__proto__" !== l10 && "constructor" !== l10 && (r10[l10] = n10[l10]);
            });
          }(t10, e10, o10, 0), o10;
        },
        discardElement: function(t10) {
          t10 && t10.parentElement && t10.parentElement.removeChild(t10);
        },
        erase: function(t10, e10) {
          let i10 = t10.length;
          for (; i10--; ) if (t10[i10] === e10) {
            t10.splice(i10, 1);
            break;
          }
        },
        error: E,
        extend: F,
        extendClass: function(t10, e10) {
          let i10 = function() {
          };
          return i10.prototype = new t10(), F(i10.prototype, e10), i10;
        },
        find: Z,
        fireEvent: q,
        getAlignFactor: (t10 = "") => ({
          center: 0.5,
          right: 1,
          middle: 0.5,
          bottom: 1
        })[t10] || 0,
        getClosestDistance: function(t10, e10) {
          let i10, s10, o10, r10;
          let a10 = !e10;
          return t10.forEach((t11) => {
            if (t11.length > 1) for (r10 = s10 = t11.length - 1; r10 > 0; r10--) (o10 = t11[r10] - t11[r10 - 1]) < 0 && !a10 ? (e10?.(), e10 = void 0) : o10 && (void 0 === i10 || o10 < i10) && (i10 = o10);
          }), i10;
        },
        getMagnitude: V,
        getNestedProperty: function(t10, e10) {
          let i10 = t10.split(".");
          for (; i10.length && j(e10); ) {
            let t11 = i10.shift();
            if (void 0 === t11 || "__proto__" === t11) return;
            if ("this" === t11) {
              let t12;
              return z(e10) && (t12 = e10["@this"]), t12 ?? e10;
            }
            let s10 = e10[t11.replace(/[\\'"]/g, "")];
            if (!j(s10) || "function" == typeof s10 || "number" == typeof s10.nodeType || s10 === O) return;
            e10 = s10;
          }
          return e10;
        },
        getStyle: function t10(e10, i10, s10) {
          let o10;
          if ("width" === i10) {
            let i11 = Math.min(e10.offsetWidth, e10.scrollWidth), s11 = e10.getBoundingClientRect && e10.getBoundingClientRect().width;
            return s11 < i11 && s11 >= i11 - 1 && (i11 = Math.floor(s11)), Math.max(0, i11 - (t10(e10, "padding-left", true) || 0) - (t10(e10, "padding-right", true) || 0));
          }
          if ("height" === i10) return Math.max(0, Math.min(e10.offsetHeight, e10.scrollHeight) - (t10(e10, "padding-top", true) || 0) - (t10(e10, "padding-bottom", true) || 0));
          let r10 = O.getComputedStyle(e10, void 0);
          return r10 && (o10 = r10.getPropertyValue(i10), H(s10, "opacity" !== i10) && (o10 = I(o10))), o10;
        },
        insertItem: function(t10, e10) {
          let i10;
          let s10 = t10.options.index, o10 = e10.length;
          for (i10 = t10.options.isInternal ? o10 : 0; i10 < o10 + 1; i10++) if (!e10[i10] || W(s10) && s10 < H(e10[i10].options.index, e10[i10]._i) || e10[i10].options.isInternal) {
            e10.splice(i10, 0, t10);
            break;
          }
          return i10;
        },
        isArray: B,
        isClass: R,
        isDOMElement: N,
        isFunction: function(t10) {
          return "function" == typeof t10;
        },
        isNumber: W,
        isObject: z,
        isString: D,
        merge: function(t10, ...e10) {
          let i10, s10 = [t10, ...e10], o10 = {}, r10 = function(t11, e11) {
            return "object" != typeof t11 && (t11 = {}), $(e11, function(i11, s11) {
              "__proto__" !== s11 && "constructor" !== s11 && (!z(i11, true) || R(i11) || N(i11) ? t11[s11] = e11[s11] : t11[s11] = r10(t11[s11] || {}, i11));
            }), t11;
          };
          true === t10 && (o10 = s10[1], s10 = Array.prototype.slice.call(s10, 2));
          let a10 = s10.length;
          for (i10 = 0; i10 < a10; i10++) o10 = r10(o10, s10[i10]);
          return o10;
        },
        normalizeTickInterval: function(t10, e10, i10, s10, o10) {
          let r10, a10 = t10;
          i10 = H(i10, V(t10));
          let n10 = t10 / i10;
          for (!e10 && (e10 = o10 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === s10 && (1 === i10 ? e10 = e10.filter(function(t11) {
            return t11 % 1 == 0;
          }) : i10 <= 0.1 && (e10 = [1 / i10]))), r10 = 0; r10 < e10.length && (a10 = e10[r10], (!o10 || !(a10 * i10 >= t10)) && (o10 || !(n10 <= (e10[r10] + (e10[r10 + 1] || e10[r10])) / 2))); r10++) ;
          return U(a10 * i10, -Math.round(Math.log(1e-3) / Math.LN10));
        },
        objectEach: $,
        offset: function(t10) {
          let e10 = L.documentElement, i10 = t10.parentElement || t10.parentNode ? t10.getBoundingClientRect() : {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          };
          return {
            top: i10.top + (O.pageYOffset || e10.scrollTop) - (e10.clientTop || 0),
            left: i10.left + (O.pageXOffset || e10.scrollLeft) - (e10.clientLeft || 0),
            width: i10.width,
            height: i10.height
          };
        },
        pad: function(t10, e10, i10) {
          return Array((e10 || 2) + 1 - String(t10).replace("-", "").length).join(i10 || "0") + t10;
        },
        pick: H,
        pInt: I,
        pushUnique: function(t10, e10) {
          return 0 > t10.indexOf(e10) && !!t10.push(e10);
        },
        relativeLength: function(t10, e10, i10) {
          return /%$/.test(t10) ? e10 * parseFloat(t10) / 100 + (i10 || 0) : parseFloat(t10);
        },
        removeEvent: _,
        replaceNested: function(t10, ...e10) {
          let i10, s10;
          do
            for (s10 of (i10 = t10, e10)) t10 = t10.replace(s10[0], s10[1]);
          while (t10 !== i10);
          return t10;
        },
        splat: G,
        stableSort: function(t10, e10) {
          let i10, s10;
          let o10 = t10.length;
          for (s10 = 0; s10 < o10; s10++) t10[s10].safeI = s10;
          for (t10.sort(function(t11, s11) {
            return 0 === (i10 = e10(t11, s11)) ? t11.safeI - s11.safeI : i10;
          }), s10 = 0; s10 < o10; s10++) delete t10[s10].safeI;
        },
        syncTimeout: function(t10, e10, i10) {
          return e10 > 0 ? setTimeout(t10, e10, i10) : (t10.call(0, i10), -1);
        },
        timeUnits: {
          millisecond: 1,
          second: 1e3,
          minute: 6e4,
          hour: 36e5,
          day: 864e5,
          week: 6048e5,
          month: 24192e5,
          year: 314496e5
        },
        ucfirst: function(t10) {
          return D(t10) ? t10.substring(0, 1).toUpperCase() + t10.substring(1) : String(t10);
        },
        uniqueKey: K,
        useSerialIds: function(e10) {
          return t = H(e10, t);
        },
        wrap: function(t10, e10, i10) {
          let s10 = t10[e10];
          t10[e10] = function() {
            let t11 = arguments, e11 = this;
            return i10.apply(this, [function() {
              return s10.apply(e11, arguments.length ? arguments : t11);
            }].concat([].slice.call(arguments)));
          };
        }
      }, {
        pageLang: Q,
        win: tt
      } = A, {
        defined: te,
        error: ti,
        extend: ts,
        isNumber: to,
        isObject: tr,
        isString: ta,
        merge: tn,
        objectEach: tl,
        pad: th,
        splat: td,
        timeUnits: tc,
        ucfirst: tp
      } = J, tu = A.isSafari && tt.Intl && !tt.Intl.DateTimeFormat.prototype.formatRange, tg = (t10) => void 0 === t10.main, tm = (t10) => ["D", "L", "M", "X", "J", "V", "S"].indexOf(t10), tf = class {
        constructor(t10) {
          this.options = {
            timezone: "UTC"
          }, this.variableTimezone = false, this.Date = tt.Date, this.update(t10);
        }
        update(t10 = {}) {
          this.dTLCache = {}, this.options = t10 = tn(true, this.options, t10);
          let {
            timezoneOffset: e10,
            useUTC: i10
          } = t10;
          this.Date = t10.Date || tt.Date || Date;
          let s10 = t10.timezone;
          te(i10) && (s10 = i10 ? "UTC" : void 0), e10 && e10 % 60 == 0 && (s10 = "Etc/GMT" + (e10 > 0 ? "+" : "") + e10 / 60), this.variableTimezone = "UTC" !== s10 && s10?.indexOf("Etc/GMT") !== 0, this.timezone = s10, ["months", "shortMonths", "weekdays", "shortWeekdays"].forEach((t11) => {
            let e11 = /months/i.test(t11), i11 = /short/.test(t11), s11 = {
              timeZone: "UTC"
            };
            s11[e11 ? "month" : "weekday"] = i11 ? "short" : "long", this[t11] = (e11 ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map((t12) => this.dateFormat(s11, (e11 ? 31 : 1) * 24 * 36e5 * t12));
          });
        }
        toParts(t10) {
          let [e10, i10, s10, o10, r10, a10, n10] = this.dateTimeFormat({
            weekday: "narrow",
            day: "numeric",
            month: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
          }, t10, "es").split(/(?:, |\/|:)/g);
          return [o10, +s10 - 1, i10, r10, a10, n10, Math.floor(Number(t10) || 0) % 1e3, tm(e10)].map(Number);
        }
        dateTimeFormat(t10, e10, i10 = this.options.locale || Q) {
          let s10 = JSON.stringify(t10) + i10;
          ta(t10) && (t10 = this.str2dtf(t10));
          let o10 = this.dTLCache[s10];
          if (!o10) {
            t10.timeZone ?? (t10.timeZone = this.timezone);
            try {
              o10 = new Intl.DateTimeFormat(i10, t10);
            } catch (e11) {
              /Invalid time zone/i.test(e11.message) ? (ti(34), t10.timeZone = "UTC", o10 = new Intl.DateTimeFormat(i10, t10)) : ti(e11.message, false);
            }
          }
          return this.dTLCache[s10] = o10, o10?.format(e10) || "";
        }
        str2dtf(t10, e10 = {}) {
          let i10 = {
            L: {
              fractionalSecondDigits: 3
            },
            S: {
              second: "2-digit"
            },
            M: {
              minute: "numeric"
            },
            H: {
              hour: "2-digit"
            },
            k: {
              hour: "numeric"
            },
            E: {
              weekday: "narrow"
            },
            a: {
              weekday: "short"
            },
            A: {
              weekday: "long"
            },
            d: {
              day: "2-digit"
            },
            e: {
              day: "numeric"
            },
            b: {
              month: "short"
            },
            B: {
              month: "long"
            },
            m: {
              month: "2-digit"
            },
            o: {
              month: "numeric"
            },
            y: {
              year: "2-digit"
            },
            Y: {
              year: "numeric"
            }
          };
          return Object.keys(i10).forEach((s10) => {
            -1 !== t10.indexOf(s10) && ts(e10, i10[s10]);
          }), e10;
        }
        makeTime(t10, e10, i10 = 1, s10 = 0, o10, r10, a10) {
          let n10 = this.Date.UTC(t10, e10, i10, s10, o10 || 0, r10 || 0, a10 || 0);
          if ("UTC" !== this.timezone) {
            let t11 = this.getTimezoneOffset(n10);
            if (n10 += t11, -1 !== [2, 3, 8, 9, 10, 11].indexOf(e10) && (s10 < 5 || s10 > 20)) {
              let e11 = this.getTimezoneOffset(n10);
              t11 !== e11 ? n10 += e11 - t11 : t11 - 36e5 !== this.getTimezoneOffset(n10 - 36e5) || tu || (n10 -= 36e5);
            }
          }
          return n10;
        }
        parse(t10) {
          if (!ta(t10)) return t10 ?? void 0;
          let e10 = (t10 = t10.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t10), i10 = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(t10);
          e10 || i10 || (t10 += "Z");
          let s10 = Date.parse(t10);
          if (to(s10)) return s10 + (!e10 || i10 ? this.getTimezoneOffset(s10) : 0);
        }
        getTimezoneOffset(t10) {
          if ("UTC" !== this.timezone) {
            let [e10, i10, s10, o10, r10 = 0] = this.dateTimeFormat({
              timeZoneName: "shortOffset"
            }, t10, "en").split(/(GMT|:)/).map(Number), a10 = -(36e5 * (s10 + r10 / 60));
            if (to(a10)) return a10;
          }
          return 0;
        }
        dateFormat(t10, e10, i10) {
          let s10 = A.defaultOptions?.lang;
          if (!te(e10) || isNaN(e10)) return s10?.invalidDate || "";
          if (ta(t10 = t10 ?? "%Y-%m-%d %H:%M:%S")) {
            let i11;
            let s11 = /%\[([a-zA-Z]+)\]/g;
            for (; i11 = s11.exec(t10); ) t10 = t10.replace(i11[0], this.dateTimeFormat(i11[1], e10));
          }
          if (ta(t10) && -1 !== t10.indexOf("%")) {
            let i11 = this, [o10, r10, a10, n10, l10, h10, d10, c10] = this.toParts(e10), p4 = s10?.weekdays || this.weekdays, u2 = s10?.shortWeekdays || this.shortWeekdays, g2 = s10?.months || this.months, m2 = s10?.shortMonths || this.shortMonths;
            tl(ts({
              a: u2 ? u2[c10] : p4[c10].substr(0, 3),
              A: p4[c10],
              d: th(a10),
              e: th(a10, 2, " "),
              w: c10,
              b: m2[r10],
              B: g2[r10],
              m: th(r10 + 1),
              o: r10 + 1,
              y: o10.toString().substr(2, 2),
              Y: o10,
              H: th(n10),
              k: n10,
              I: th(n10 % 12 || 12),
              l: n10 % 12 || 12,
              M: th(l10),
              p: n10 < 12 ? "AM" : "PM",
              P: n10 < 12 ? "am" : "pm",
              S: th(h10),
              L: th(d10, 3)
            }, A.dateFormats), function(s11, o11) {
              if (ta(t10)) for (; -1 !== t10.indexOf("%" + o11); ) t10 = t10.replace("%" + o11, "function" == typeof s11 ? s11.call(i11, e10) : s11);
            });
          } else if (tr(t10)) {
            let i11 = (this.getTimezoneOffset(e10) || 0) / 36e5, s11 = this.timezone || "Etc/GMT" + (i11 >= 0 ? "+" : "") + i11, {
              prefix: o10 = "",
              suffix: r10 = ""
            } = t10;
            t10 = o10 + this.dateTimeFormat(ts({
              timeZone: s11
            }, t10), e10) + r10;
          }
          return i10 ? tp(t10) : t10;
        }
        resolveDTLFormat(t10) {
          return tr(t10, true) ? tr(t10, true) && tg(t10) ? {
            main: t10
          } : t10 : {
            main: (t10 = td(t10))[0],
            from: t10[1],
            to: t10[2]
          };
        }
        getTimeTicks(t10, e10, i10, s10) {
          let o10 = this, r10 = [], a10 = {}, {
            count: n10 = 1,
            unitRange: l10
          } = t10, [h10, d10, c10, p4, u2, g2] = o10.toParts(e10), m2 = (e10 || 0) % 1e3, f2;
          if (s10 ?? (s10 = 1), te(e10)) {
            if (m2 = l10 >= tc.second ? 0 : n10 * Math.floor(m2 / n10), l10 >= tc.second && (g2 = l10 >= tc.minute ? 0 : n10 * Math.floor(g2 / n10)), l10 >= tc.minute && (u2 = l10 >= tc.hour ? 0 : n10 * Math.floor(u2 / n10)), l10 >= tc.hour && (p4 = l10 >= tc.day ? 0 : n10 * Math.floor(p4 / n10)), l10 >= tc.day && (c10 = l10 >= tc.month ? 1 : Math.max(1, n10 * Math.floor(c10 / n10))), l10 >= tc.month && (d10 = l10 >= tc.year ? 0 : n10 * Math.floor(d10 / n10)), l10 >= tc.year && (h10 -= h10 % n10), l10 === tc.week) {
              n10 && (e10 = o10.makeTime(h10, d10, c10, p4, u2, g2, m2));
              let t12 = tm(this.dateTimeFormat({
                timeZone: this.timezone,
                weekday: "narrow"
              }, e10, "es"));
              c10 += -t12 + s10 + (t12 < s10 ? -7 : 0);
            }
            e10 = o10.makeTime(h10, d10, c10, p4, u2, g2, m2), o10.variableTimezone && te(i10) && (f2 = i10 - e10 > 4 * tc.month || o10.getTimezoneOffset(e10) !== o10.getTimezoneOffset(i10));
            let t11 = e10, x2 = 1;
            for (; t11 < i10; ) r10.push(t11), l10 === tc.year ? t11 = o10.makeTime(h10 + x2 * n10, 0) : l10 === tc.month ? t11 = o10.makeTime(h10, d10 + x2 * n10) : f2 && (l10 === tc.day || l10 === tc.week) ? t11 = o10.makeTime(h10, d10, c10 + x2 * n10 * (l10 === tc.day ? 1 : 7)) : f2 && l10 === tc.hour && n10 > 1 ? t11 = o10.makeTime(h10, d10, c10, p4 + x2 * n10) : t11 += l10 * n10, x2++;
            r10.push(t11), l10 <= tc.hour && r10.length < 1e4 && r10.forEach((t12) => {
              t12 % 18e5 == 0 && "000000000" === o10.dateFormat("%H%M%S%L", t12) && (a10[t12] = "day");
            });
          }
          return r10.info = ts(t10, {
            higherRanks: a10,
            totalRange: l10 * n10
          }), r10;
        }
        getDateFormat(t10, e10, i10, s10) {
          let o10 = this.dateFormat("%m-%d %H:%M:%S.%L", e10), r10 = "01-01 00:00:00.000", a10 = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          }, n10 = "millisecond", l10 = n10;
          for (n10 in tc) {
            if (t10 === tc.week && +this.dateFormat("%w", e10) === i10 && o10.substr(6) === r10.substr(6)) {
              n10 = "week";
              break;
            }
            if (tc[n10] > t10) {
              n10 = l10;
              break;
            }
            if (a10[n10] && o10.substr(a10[n10]) !== r10.substr(a10[n10])) break;
            "week" !== n10 && (l10 = n10);
          }
          return this.resolveDTLFormat(s10[n10]).main;
        }
      }, {
        isTouchDevice: tx
      } = A, {
        fireEvent: ty,
        merge: tb
      } = J, tv = {
        colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"],
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          locale: void 0,
          loading: "Loading...",
          months: void 0,
          shortMonths: void 0,
          weekdays: void 0,
          numericSymbols: ["k", "M", "G", "T", "P", "E"],
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1"
        },
        global: {
          buttonTheme: {
            fill: "#f7f7f7",
            padding: 8,
            r: 2,
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontSize: "0.8em",
              fontWeight: "normal"
            },
            states: {
              hover: {
                fill: "#e6e6e6"
              },
              select: {
                fill: "#e6e9ff",
                style: {
                  color: "#000000",
                  fontWeight: "bold"
                }
              },
              disabled: {
                style: {
                  color: "#cccccc"
                }
              }
            }
          }
        },
        time: {
          Date: void 0,
          timezone: "UTC",
          timezoneOffset: 0,
          useUTC: void 0
        },
        chart: {
          alignThresholds: false,
          panning: {
            enabled: false,
            type: "x"
          },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: {
            theme: {},
            position: {}
          },
          reflow: true,
          type: "line",
          zooming: {
            singleTouch: false,
            resetButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            }
          },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        },
        title: {
          style: {
            color: "#333333",
            fontWeight: "bold"
          },
          text: "Chart title",
          margin: 15,
          minScale: 0.67
        },
        subtitle: {
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: ""
        },
        caption: {
          margin: 15,
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        legend: {
          enabled: true,
          align: "center",
          alignColumns: true,
          className: "highcharts-no-tooltip",
          events: {},
          layout: "horizontal",
          itemMarginBottom: 2,
          itemMarginTop: 2,
          labelFormatter: function() {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            style: {
              fontSize: "0.8em"
            },
            activeColor: "#0022ff",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "0.8em",
            textDecoration: "none",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#666666",
            textDecoration: "line-through"
          },
          shadow: false,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: true,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontSize: "0.8em",
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: 0.5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: true,
          animation: {
            duration: 300,
            easing: (t10) => Math.sqrt(1 - Math.pow(t10 - 1, 2))
          },
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%[AebHMSL]",
            second: "%[AebHMS]",
            minute: "%[AebHM]",
            hour: "%[AebHM]",
            day: "%[AebY]",
            week: "Week from %[AebY]",
            month: "%[BY]",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: false,
          snap: tx ? 25 : 10,
          headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: "#ffffff",
          borderWidth: void 0,
          shadow: true,
          stickOnContact: false,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "0.8em"
          },
          useHTML: false
        },
        credits: {
          enabled: true,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "0.6em"
          },
          text: "Highcharts.com"
        }
      }, tM = new tf(tv.time), tw = {
        defaultOptions: tv,
        defaultTime: tM,
        getOptions: function() {
          return tv;
        },
        setOptions: function(t10) {
          return ty(A, "setOptions", {
            options: t10
          }), tb(true, tv, t10), t10.time && tM.update(tv.time), t10.lang && "locale" in t10.lang && tM.update({
            locale: t10.lang.locale
          }), tv;
        }
      }, {
        isNumber: tk,
        merge: tS,
        pInt: tT,
        defined: tC
      } = J;
      class tA {
        static parse(t10) {
          return t10 ? new tA(t10) : tA.None;
        }
        constructor(t10) {
          let e10, i10, s10, o10;
          this.rgba = [NaN, NaN, NaN, NaN], this.input = t10;
          let r10 = A.Color;
          if (r10 && r10 !== tA) return new r10(t10);
          if ("object" == typeof t10 && void 0 !== t10.stops) this.stops = t10.stops.map((t11) => new tA(t11[1]));
          else if ("string" == typeof t10) for (this.input = t10 = tA.names[t10.toLowerCase()] || t10, s10 = tA.parsers.length; s10-- && !i10; ) (e10 = (o10 = tA.parsers[s10]).regex.exec(t10)) && (i10 = o10.parse(e10));
          i10 && (this.rgba = i10);
        }
        get(t10) {
          let e10 = this.input, i10 = this.rgba;
          if ("object" == typeof e10 && void 0 !== this.stops) {
            let i11 = tS(e10);
            return i11.stops = [].slice.call(i11.stops), this.stops.forEach((e11, s10) => {
              i11.stops[s10] = [i11.stops[s10][0], e11.get(t10)];
            }), i11;
          }
          return i10 && tk(i10[0]) ? "rgb" !== t10 && (t10 || 1 !== i10[3]) ? "a" === t10 ? `${i10[3]}` : "rgba(" + i10.join(",") + ")" : "rgb(" + i10[0] + "," + i10[1] + "," + i10[2] + ")" : e10;
        }
        brighten(t10) {
          let e10 = this.rgba;
          if (this.stops) this.stops.forEach(function(e11) {
            e11.brighten(t10);
          });
          else if (tk(t10) && 0 !== t10) for (let i10 = 0; i10 < 3; i10++) e10[i10] += tT(255 * t10), e10[i10] < 0 && (e10[i10] = 0), e10[i10] > 255 && (e10[i10] = 255);
          return this;
        }
        setOpacity(t10) {
          return this.rgba[3] = t10, this;
        }
        tweenTo(t10, e10) {
          let i10 = this.rgba, s10 = t10.rgba;
          if (!tk(i10[0]) || !tk(s10[0])) return t10.input || "none";
          let o10 = 1 !== s10[3] || 1 !== i10[3], r10 = (t11, s11) => t11 + (i10[s11] - t11) * (1 - e10), a10 = s10.slice(0, 3).map(r10).map(Math.round);
          return o10 && a10.push(r10(s10[3], 3)), (o10 ? "rgba(" : "rgb(") + a10.join(",") + ")";
        }
      }
      tA.names = {
        white: "#ffffff",
        black: "#000000"
      }, tA.parsers = [{
        regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
        parse: function(t10) {
          return [tT(t10[1]), tT(t10[2]), tT(t10[3]), parseFloat(t10[4], 10)];
        }
      }, {
        regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
        parse: function(t10) {
          return [tT(t10[1]), tT(t10[2]), tT(t10[3]), 1];
        }
      }, {
        regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
        parse: function(t10) {
          return [tT(t10[1] + t10[1], 16), tT(t10[2] + t10[2], 16), tT(t10[3] + t10[3], 16), tC(t10[4]) ? tT(t10[4] + t10[4], 16) / 255 : 1];
        }
      }, {
        regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
        parse: function(t10) {
          return [tT(t10[1], 16), tT(t10[2], 16), tT(t10[3], 16), tC(t10[4]) ? tT(t10[4], 16) / 255 : 1];
        }
      }], tA.None = new tA("");
      let {
        parse: tP
      } = tA, {
        win: tL
      } = A, {
        isNumber: tO,
        objectEach: tE
      } = J;
      class tI {
        constructor(t10, e10, i10) {
          this.pos = NaN, this.options = e10, this.elem = t10, this.prop = i10;
        }
        dSetter() {
          let t10 = this.paths, e10 = t10 && t10[0], i10 = t10 && t10[1], s10 = this.now || 0, o10 = [];
          if (1 !== s10 && e10 && i10) {
            if (e10.length === i10.length && s10 < 1) for (let t11 = 0; t11 < i10.length; t11++) {
              let r10 = e10[t11], a10 = i10[t11], n10 = [];
              for (let t12 = 0; t12 < a10.length; t12++) {
                let e11 = r10[t12], i11 = a10[t12];
                tO(e11) && tO(i11) && !("A" === a10[0] && (4 === t12 || 5 === t12)) ? n10[t12] = e11 + s10 * (i11 - e11) : n10[t12] = i11;
              }
              o10.push(n10);
            }
            else o10 = i10;
          } else o10 = this.toD || [];
          this.elem.attr("d", o10, void 0, true);
        }
        update() {
          let t10 = this.elem, e10 = this.prop, i10 = this.now, s10 = this.options.step;
          this[e10 + "Setter"] ? this[e10 + "Setter"]() : t10.attr ? t10.element && t10.attr(e10, i10, null, true) : t10.style[e10] = i10 + this.unit, s10 && s10.call(t10, i10, this);
        }
        run(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = function(t11) {
            return !r10.stopped && s10.step(t11);
          }, a10 = tL.requestAnimationFrame || function(t11) {
            setTimeout(t11, 13);
          }, n10 = function() {
            for (let t11 = 0; t11 < tI.timers.length; t11++) tI.timers[t11]() || tI.timers.splice(t11--, 1);
            tI.timers.length && a10(n10);
          };
          t10 !== e10 || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = t10, this.end = e10, this.unit = i10, this.now = this.start, this.pos = 0, r10.elem = this.elem, r10.prop = this.prop, r10() && 1 === tI.timers.push(r10) && a10(n10)) : (delete o10.curAnim[this.prop], o10.complete && 0 === Object.keys(o10.curAnim).length && o10.complete.call(this.elem));
        }
        step(t10) {
          let e10, i10;
          let s10 = +/* @__PURE__ */ new Date(), o10 = this.options, r10 = this.elem, a10 = o10.complete, n10 = o10.duration, l10 = o10.curAnim;
          return r10.attr && !r10.element ? e10 = false : t10 || s10 >= n10 + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l10[this.prop] = true, i10 = true, tE(l10, function(t11) {
            true !== t11 && (i10 = false);
          }), i10 && a10 && a10.call(r10), e10 = false) : (this.pos = o10.easing((s10 - this.startTime) / n10), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e10 = true), e10;
        }
        initPath(t10, e10, i10) {
          let s10 = t10.startX, o10 = t10.endX, r10 = i10.slice(), a10 = t10.isArea, n10 = a10 ? 2 : 1, l10 = e10 && i10.length > e10.length && i10.hasStackedCliffs, h10, d10, c10, p4, u2 = e10 && e10.slice();
          if (!u2 || l10) return [r10, r10];
          function g2(t11, e11) {
            for (; t11.length < d10; ) {
              let i11 = t11[0], s11 = e11[d10 - t11.length];
              if (s11 && "M" === i11[0] && ("C" === s11[0] ? t11[0] = ["C", i11[1], i11[2], i11[1], i11[2], i11[1], i11[2]] : t11[0] = ["L", i11[1], i11[2]]), t11.unshift(i11), a10) {
                let e12 = t11.pop();
                t11.push(t11[t11.length - 1], e12);
              }
            }
          }
          function m2(t11) {
            for (; t11.length < d10; ) {
              let e11 = t11[Math.floor(t11.length / n10) - 1].slice();
              if ("C" === e11[0] && (e11[1] = e11[5], e11[2] = e11[6]), a10) {
                let i11 = t11[Math.floor(t11.length / n10)].slice();
                t11.splice(t11.length / 2, 0, e11, i11);
              } else t11.push(e11);
            }
          }
          if (s10 && o10 && o10.length) {
            for (c10 = 0; c10 < s10.length; c10++) {
              if (s10[c10] === o10[0]) {
                h10 = c10;
                break;
              }
              if (s10[0] === o10[o10.length - s10.length + c10]) {
                h10 = c10, p4 = true;
                break;
              }
              if (s10[s10.length - 1] === o10[o10.length - s10.length + c10]) {
                h10 = s10.length - c10;
                break;
              }
            }
            void 0 === h10 && (u2 = []);
          }
          return u2.length && tO(h10) && (d10 = r10.length + h10 * n10, p4 ? (g2(u2, r10), m2(r10)) : (g2(r10, u2), m2(u2))), [u2, r10];
        }
        fillSetter() {
          tI.prototype.strokeSetter.apply(this, arguments);
        }
        strokeSetter() {
          this.elem.attr(this.prop, tP(this.start).tweenTo(tP(this.end), this.pos), void 0, true);
        }
      }
      tI.timers = [];
      let {
        defined: tD,
        getStyle: tB,
        isArray: tz,
        isNumber: tN,
        isObject: tR,
        merge: tW,
        objectEach: tj,
        pick: tX
      } = J;
      function tG(t10) {
        return tR(t10) ? tW({
          duration: 500,
          defer: 0
        }, t10) : {
          duration: t10 ? 500 : 0,
          defer: 0
        };
      }
      function tF(t10, e10) {
        let i10 = tI.timers.length;
        for (; i10--; ) tI.timers[i10].elem !== t10 || e10 && e10 !== tI.timers[i10].prop || (tI.timers[i10].stopped = true);
      }
      let tH = {
        animate: function(t10, e10, i10) {
          let s10, o10 = "", r10, a10, n10;
          tR(i10) || (n10 = arguments, i10 = {
            duration: n10[2],
            easing: n10[3],
            complete: n10[4]
          }), tN(i10.duration) || (i10.duration = 400), i10.easing = "function" == typeof i10.easing ? i10.easing : Math[i10.easing] || Math.easeInOutSine, i10.curAnim = tW(e10), tj(e10, function(n11, l10) {
            tF(t10, l10), a10 = new tI(t10, i10, l10), r10 = void 0, "d" === l10 && tz(e10.d) ? (a10.paths = a10.initPath(t10, t10.pathArray, e10.d), a10.toD = e10.d, s10 = 0, r10 = 1) : t10.attr ? s10 = t10.attr(l10) : (s10 = parseFloat(tB(t10, l10)) || 0, "opacity" !== l10 && (o10 = "px")), r10 || (r10 = n11), "string" == typeof r10 && r10.match("px") && (r10 = r10.replace(/px/g, "")), a10.run(s10, r10, o10);
          });
        },
        animObject: tG,
        getDeferredAnimation: function(t10, e10, i10) {
          let s10 = tG(e10), o10 = i10 ? [i10] : t10.series, r10 = 0, a10 = 0;
          return o10.forEach((t11) => {
            let i11 = tG(t11.options.animation);
            r10 = tR(e10) && tD(e10.defer) ? s10.defer : Math.max(r10, i11.duration + i11.defer), a10 = Math.min(s10.duration, i11.duration);
          }), t10.renderer.forExport && (r10 = 0), {
            defer: Math.max(0, r10 - a10),
            duration: Math.min(r10, a10)
          };
        },
        setAnimation: function(t10, e10) {
          e10.renderer.globalAnimation = tX(t10, e10.options.chart.animation, true);
        },
        stop: tF
      }, {
        SVG_NS: tY,
        win: tV
      } = A, {
        attr: tU,
        createElement: tZ,
        css: t$,
        error: t_,
        isFunction: tq,
        isString: tK,
        objectEach: tJ,
        splat: tQ
      } = J, {
        trustedTypes: t0
      } = tV, t1 = t0 && tq(t0.createPolicy) && t0.createPolicy("highcharts", {
        createHTML: (t10) => t10
      }), t2 = t1 ? t1.createHTML("") : "";
      class t3 {
        static filterUserAttributes(t10) {
          return tJ(t10, (e10, i10) => {
            let s10 = true;
            -1 === t3.allowedAttributes.indexOf(i10) && (s10 = false), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i10) && (s10 = tK(e10) && t3.allowedReferences.some((t11) => 0 === e10.indexOf(t11))), s10 || (t_(33, false, void 0, {
              "Invalid attribute in config": `${i10}`
            }), delete t10[i10]), tK(e10) && t10[i10] && (t10[i10] = e10.replace(/</g, "&lt;"));
          }), t10;
        }
        static parseStyle(t10) {
          return t10.split(";").reduce((t11, e10) => {
            let i10 = e10.split(":").map((t12) => t12.trim()), s10 = i10.shift();
            return s10 && i10.length && (t11[s10.replace(/-([a-z])/g, (t12) => t12[1].toUpperCase())] = i10.join(":")), t11;
          }, {});
        }
        static setElementHTML(t10, e10) {
          t10.innerHTML = t3.emptyHTML, e10 && new t3(e10).addToDOM(t10);
        }
        constructor(t10) {
          this.nodes = "string" == typeof t10 ? this.parseMarkup(t10) : t10;
        }
        addToDOM(t10) {
          return function t11(e10, i10) {
            let s10;
            return tQ(e10).forEach(function(e11) {
              let o10;
              let r10 = e11.tagName, a10 = e11.textContent ? A.doc.createTextNode(e11.textContent) : void 0, n10 = t3.bypassHTMLFiltering;
              if (r10) {
                if ("#text" === r10) o10 = a10;
                else if (-1 !== t3.allowedTags.indexOf(r10) || n10) {
                  let s11 = "svg" === r10 ? tY : i10.namespaceURI || tY, l10 = A.doc.createElementNS(s11, r10), h10 = e11.attributes || {};
                  tJ(e11, function(t12, e12) {
                    "tagName" !== e12 && "attributes" !== e12 && "children" !== e12 && "style" !== e12 && "textContent" !== e12 && (h10[e12] = t12);
                  }), tU(l10, n10 ? h10 : t3.filterUserAttributes(h10)), e11.style && t$(l10, e11.style), a10 && l10.appendChild(a10), t11(e11.children || [], l10), o10 = l10;
                } else t_(33, false, void 0, {
                  "Invalid tagName in config": r10
                });
              }
              o10 && i10.appendChild(o10), s10 = o10;
            }), s10;
          }(this.nodes, t10);
        }
        parseMarkup(t10) {
          let e10;
          let i10 = [];
          t10 = t10.trim().replace(/ style=(["'])/g, " data-style=$1");
          try {
            e10 = new DOMParser().parseFromString(t1 ? t1.createHTML(t10) : t10, "text/html");
          } catch (t11) {
          }
          if (!e10) {
            let i11 = tZ("div");
            i11.innerHTML = t10, e10 = {
              body: i11
            };
          }
          let s10 = (t11, e11) => {
            let i11 = t11.nodeName.toLowerCase(), o10 = {
              tagName: i11
            };
            "#text" === i11 && (o10.textContent = t11.textContent || "");
            let r10 = t11.attributes;
            if (r10) {
              let t12 = {};
              [].forEach.call(r10, (e12) => {
                "data-style" === e12.name ? o10.style = t3.parseStyle(e12.value) : t12[e12.name] = e12.value;
              }), o10.attributes = t12;
            }
            if (t11.childNodes.length) {
              let e12 = [];
              [].forEach.call(t11.childNodes, (t12) => {
                s10(t12, e12);
              }), e12.length && (o10.children = e12);
            }
            e11.push(o10);
          };
          return [].forEach.call(e10.body.childNodes, (t11) => s10(t11, i10)), i10;
        }
      }
      t3.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "in2", "markerHeight", "markerWidth", "offset", "opacity", "operator", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "radius", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], t3.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], t3.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feComposite", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMorphology", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], t3.emptyHTML = t2, t3.bypassHTMLFiltering = false;
      let {
        defaultOptions: t6,
        defaultTime: t5
      } = tw, {
        pageLang: t9
      } = A, {
        extend: t8,
        getNestedProperty: t4,
        isArray: t7,
        isNumber: et,
        isObject: ee,
        isString: ei,
        pick: es,
        ucfirst: eo
      } = J, er = {
        add: (t10, e10) => t10 + e10,
        divide: (t10, e10) => 0 !== e10 ? t10 / e10 : "",
        eq: (t10, e10) => t10 == e10,
        each: function(t10) {
          let e10 = arguments[arguments.length - 1];
          return !!t7(t10) && t10.map((i10, s10) => el(e10.body, t8(ee(i10) ? i10 : {
            "@this": i10
          }, {
            "@index": s10,
            "@first": 0 === s10,
            "@last": s10 === t10.length - 1
          }))).join("");
        },
        ge: (t10, e10) => t10 >= e10,
        gt: (t10, e10) => t10 > e10,
        if: (t10) => !!t10,
        le: (t10, e10) => t10 <= e10,
        lt: (t10, e10) => t10 < e10,
        multiply: (t10, e10) => t10 * e10,
        ne: (t10, e10) => t10 != e10,
        subtract: (t10, e10) => t10 - e10,
        ucfirst: eo,
        unless: (t10) => !t10
      }, ea = {}, en = (t10) => /^["'].+["']$/.test(t10);
      function el(t10 = "", e10, i10) {
        let s10 = /\{([\p{L}\d:\.,;\-\/<>\[\]%_@+"'’= #\(\)]+)\}/gu, o10 = /\(([\p{L}\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/gu, r10 = [], a10 = /f$/, n10 = /\.(\d)/, l10 = i10?.options.lang || t6.lang, h10 = i10 && i10.time || t5, d10 = i10 && i10.numberFormatter || eh, c10 = (t11 = "") => {
          let i11;
          return "true" === t11 || "false" !== t11 && ((i11 = Number(t11)).toString() === t11 ? i11 : en(t11) ? t11.slice(1, -1) : t4(t11, e10));
        }, p4, u2, g2 = 0, m2;
        for (; null !== (p4 = s10.exec(t10)); ) {
          let i11 = p4, s11 = o10.exec(p4[1]);
          s11 && (p4 = s11, m2 = true), u2 && u2.isBlock || (u2 = {
            ctx: e10,
            expression: p4[1],
            find: p4[0],
            isBlock: "#" === p4[1].charAt(0),
            start: p4.index,
            startInner: p4.index + p4[0].length,
            length: p4[0].length
          });
          let a11 = (u2.isBlock ? i11 : p4)[1].split(" ")[0].replace("#", "");
          er[a11] && (u2.isBlock && a11 === u2.fn && g2++, u2.fn || (u2.fn = a11));
          let n11 = "else" === p4[1];
          if (u2.isBlock && u2.fn && (p4[1] === `/${u2.fn}` || n11)) {
            if (g2) !n11 && g2--;
            else {
              let e11 = u2.startInner, i12 = t10.substr(e11, p4.index - e11);
              void 0 === u2.body ? (u2.body = i12, u2.startInner = p4.index + p4[0].length) : u2.elseBody = i12, u2.find += i12 + p4[0], n11 || (r10.push(u2), u2 = void 0);
            }
          } else u2.isBlock || r10.push(u2);
          if (s11 && !u2?.isBlock) break;
        }
        return r10.forEach((s11) => {
          let r11, p7;
          let {
            body: u3,
            elseBody: g3,
            expression: m3,
            fn: f2
          } = s11;
          if (f2) {
            let t11 = [s11], o11 = [], a11 = m3.length, n11 = 0, l11;
            for (p7 = 0; p7 <= a11; p7++) {
              let t12 = m3.charAt(p7);
              l11 || '"' !== t12 && "'" !== t12 ? l11 === t12 && (l11 = "") : l11 = t12, l11 || " " !== t12 && p7 !== a11 || (o11.push(m3.substr(n11, p7 - n11)), n11 = p7 + 1);
            }
            for (p7 = er[f2].length; p7--; ) t11.unshift(c10(o11[p7 + 1]));
            r11 = er[f2].apply(e10, t11), s11.isBlock && "boolean" == typeof r11 && (r11 = el(r11 ? u3 : g3, e10, i10));
          } else {
            let t11 = en(m3) ? [m3] : m3.split(":");
            if (r11 = c10(t11.shift() || ""), t11.length && "number" == typeof r11) {
              let e11 = t11.join(":");
              if (a10.test(e11)) {
                let t12 = parseInt((e11.match(n10) || ["", "-1"])[1], 10);
                null !== r11 && (r11 = d10(r11, t12, l10.decimalPoint, e11.indexOf(",") > -1 ? l10.thousandsSep : ""));
              } else r11 = h10.dateFormat(e11, r11);
            }
            o10.lastIndex = 0, o10.test(s11.find) && ei(r11) && (r11 = `"${r11}"`);
          }
          t10 = t10.replace(s11.find, es(r11, ""));
        }), m2 ? el(t10, e10, i10) : t10;
      }
      function eh(t10, e10, i10, s10) {
        e10 = +e10;
        let o10, r10, [a10, n10] = (t10 = +t10 || 0).toString().split("e").map(Number), l10 = this?.options?.lang || t6.lang, h10 = (t10.toString().split(".")[1] || "").split("e")[0].length, d10 = e10, c10 = {};
        i10 ?? (i10 = l10.decimalPoint), s10 ?? (s10 = l10.thousandsSep), -1 === e10 ? e10 = Math.min(h10, 20) : et(e10) ? e10 && n10 < 0 && ((r10 = e10 + n10) >= 0 ? (a10 = +a10.toExponential(r10).split("e")[0], e10 = r10) : (a10 = Math.floor(a10), t10 = e10 < 20 ? +(a10 * Math.pow(10, n10)).toFixed(e10) : 0, n10 = 0)) : e10 = 2, n10 && (e10 ?? (e10 = 2), t10 = a10), et(e10) && e10 >= 0 && (c10.minimumFractionDigits = e10, c10.maximumFractionDigits = e10), "" === s10 && (c10.useGrouping = false);
        let p4 = s10 || i10, u2 = p4 ? "en" : this?.locale || l10.locale || t9, g2 = JSON.stringify(c10) + u2;
        return o10 = (ea[g2] ?? (ea[g2] = new Intl.NumberFormat(u2, c10))).format(t10), p4 && (o10 = o10.replace(/([,\.])/g, "_$1").replace(/_\,/g, s10 ?? ",").replace("_.", i10 ?? ".")), (e10 || 0 != +o10) && (!(n10 < 0) || d10) || (o10 = "0"), n10 && 0 != +o10 && (o10 += "e" + (n10 < 0 ? "" : "+") + n10), o10;
      }
      let ed = {
        dateFormat: function(t10, e10, i10) {
          return t5.dateFormat(t10, e10, i10);
        },
        format: el,
        helpers: er,
        numberFormat: eh
      };
      !function(t10) {
        let e10;
        t10.rendererTypes = {}, t10.getRendererType = function(i10 = e10) {
          return t10.rendererTypes[i10] || t10.rendererTypes[e10];
        }, t10.registerRendererType = function(i10, s10, o10) {
          t10.rendererTypes[i10] = s10, (!e10 || o10) && (e10 = i10, A.Renderer = s10);
        };
      }(o || (o = {}));
      let ec = o, {
        clamp: ep,
        pick: eu,
        pushUnique: eg,
        stableSort: em
      } = J;
      (r || (r = {})).distribute = function t10(e10, i10, s10) {
        let o10 = e10, r10 = o10.reducedLen || i10, a10 = (t11, e11) => t11.target - e11.target, n10 = [], l10 = e10.length, h10 = [], d10 = n10.push, c10, p4, u2, g2 = true, m2, f2, x2 = 0, y2;
        for (c10 = l10; c10--; ) x2 += e10[c10].size;
        if (x2 > r10) {
          for (em(e10, (t11, e11) => (e11.rank || 0) - (t11.rank || 0)), u2 = (y2 = e10[0].rank === e10[e10.length - 1].rank) ? l10 / 2 : -1, p4 = y2 ? u2 : l10 - 1; u2 && x2 > r10; ) m2 = e10[c10 = Math.floor(p4)], eg(h10, c10) && (x2 -= m2.size), p4 += u2, y2 && p4 >= e10.length && (u2 /= 2, p4 = u2);
          h10.sort((t11, e11) => e11 - t11).forEach((t11) => d10.apply(n10, e10.splice(t11, 1)));
        }
        for (em(e10, a10), e10 = e10.map((t11) => ({
          size: t11.size,
          targets: [t11.target],
          align: eu(t11.align, 0.5)
        })); g2; ) {
          for (c10 = e10.length; c10--; ) m2 = e10[c10], f2 = (Math.min.apply(0, m2.targets) + Math.max.apply(0, m2.targets)) / 2, m2.pos = ep(f2 - m2.size * m2.align, 0, i10 - m2.size);
          for (c10 = e10.length, g2 = false; c10--; ) c10 > 0 && e10[c10 - 1].pos + e10[c10 - 1].size > e10[c10].pos && (e10[c10 - 1].size += e10[c10].size, e10[c10 - 1].targets = e10[c10 - 1].targets.concat(e10[c10].targets), e10[c10 - 1].align = 0.5, e10[c10 - 1].pos + e10[c10 - 1].size > i10 && (e10[c10 - 1].pos = i10 - e10[c10 - 1].size), e10.splice(c10, 1), g2 = true);
        }
        return d10.apply(o10, n10), c10 = 0, e10.some((e11) => {
          let r11 = 0;
          return (e11.targets || []).some(() => (o10[c10].pos = e11.pos + r11, void 0 !== s10 && Math.abs(o10[c10].pos - o10[c10].target) > s10) ? (o10.slice(0, c10 + 1).forEach((t11) => delete t11.pos), o10.reducedLen = (o10.reducedLen || i10) - 0.1 * i10, o10.reducedLen > 0.1 * i10 && t10(o10, i10, s10), true) : (r11 += o10[c10].size, c10++, false));
        }), em(o10, a10), o10;
      };
      let ef = r, {
        animate: ex,
        animObject: ey,
        stop: eb
      } = tH, {
        deg2rad: ev,
        doc: eM,
        svg: ew,
        SVG_NS: ek,
        win: eS,
        isFirefox: eT
      } = A, {
        addEvent: eC,
        attr: eA,
        createElement: eP,
        crisp: eL,
        css: eO,
        defined: eE,
        erase: eI,
        extend: eD,
        fireEvent: eB,
        getAlignFactor: ez,
        isArray: eN,
        isFunction: eR,
        isNumber: eW,
        isObject: ej,
        isString: eX,
        merge: eG,
        objectEach: eF,
        pick: eH,
        pInt: eY,
        pushUnique: eV,
        replaceNested: eU,
        syncTimeout: eZ,
        uniqueKey: e$
      } = J;
      class e_ {
        _defaultGetter(t10) {
          let e10 = eH(this[t10 + "Value"], this[t10], this.element ? this.element.getAttribute(t10) : null, 0);
          return /^-?[\d\.]+$/.test(e10) && (e10 = parseFloat(e10)), e10;
        }
        _defaultSetter(t10, e10, i10) {
          i10.setAttribute(e10, t10);
        }
        add(t10) {
          let e10;
          let i10 = this.renderer, s10 = this.element;
          return t10 && (this.parentGroup = t10), void 0 !== this.textStr && "text" === this.element.nodeName && i10.buildText(this), this.added = true, (!t10 || t10.handleZ || this.zIndex) && (e10 = this.zIndexSetter()), e10 || (t10 ? t10.element : i10.box).appendChild(s10), this.onAdd && this.onAdd(), this;
        }
        addClass(t10, e10) {
          let i10 = e10 ? "" : this.attr("class") || "";
          return (t10 = (t10 || "").split(/ /g).reduce(function(t11, e11) {
            return -1 === i10.indexOf(e11) && t11.push(e11), t11;
          }, i10 ? [i10] : []).join(" ")) !== i10 && this.attr("class", t10), this;
        }
        afterSetters() {
          this.doTransform && (this.updateTransform(), this.doTransform = false);
        }
        align(t10, e10, i10, s10 = true) {
          let o10 = this.renderer, r10 = o10.alignedObjects, a10 = !!t10;
          t10 ? (this.alignOptions = t10, this.alignByTranslate = e10, this.alignTo = i10) : (t10 = this.alignOptions || {}, e10 = this.alignByTranslate, i10 = this.alignTo);
          let n10 = !i10 || eX(i10) ? i10 || "renderer" : void 0;
          n10 && (a10 && eV(r10, this), i10 = void 0);
          let l10 = eH(i10, o10[n10], o10), h10 = (l10.x || 0) + (t10.x || 0) + ((l10.width || 0) - (t10.width || 0)) * ez(t10.align), d10 = (l10.y || 0) + (t10.y || 0) + ((l10.height || 0) - (t10.height || 0)) * ez(t10.verticalAlign), c10 = {
            "text-align": t10?.align
          };
          return c10[e10 ? "translateX" : "x"] = Math.round(h10), c10[e10 ? "translateY" : "y"] = Math.round(d10), s10 && (this[this.placed ? "animate" : "attr"](c10), this.placed = true), this.alignAttr = c10, this;
        }
        alignSetter(t10) {
          let e10 = {
            left: "start",
            center: "middle",
            right: "end"
          };
          e10[t10] && (this.alignValue = t10, this.element.setAttribute("text-anchor", e10[t10]));
        }
        animate(t10, e10, i10) {
          let s10 = ey(eH(e10, this.renderer.globalAnimation, true)), o10 = s10.defer;
          return eM.hidden && (s10.duration = 0), 0 !== s10.duration ? (i10 && (s10.complete = i10), eZ(() => {
            this.element && ex(this, t10, s10);
          }, o10)) : (this.attr(t10, void 0, i10 || s10.complete), eF(t10, function(t11, e11) {
            s10.step && s10.step.call(this, t11, {
              prop: e11,
              pos: 1,
              elem: this
            });
          }, this)), this;
        }
        applyTextOutline(t10) {
          let e10 = this.element;
          -1 !== t10.indexOf("contrast") && (t10 = t10.replace(/contrast/g, this.renderer.getContrast(e10.style.fill)));
          let i10 = t10.split(" "), s10 = i10[i10.length - 1], o10 = i10[0];
          if (o10 && "none" !== o10 && A.svg) {
            this.fakeTS = true, o10 = o10.replace(/(^[\d\.]+)(.*?)$/g, function(t12, e11, i12) {
              return 2 * Number(e11) + i12;
            }), this.removeTextOutline();
            let t11 = eM.createElementNS(ek, "tspan");
            eA(t11, {
              class: "highcharts-text-outline",
              fill: s10,
              stroke: s10,
              "stroke-width": o10,
              "stroke-linejoin": "round"
            });
            let i11 = e10.querySelector("textPath") || e10;
            [].forEach.call(i11.childNodes, (e11) => {
              let i12 = e11.cloneNode(true);
              i12.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((t12) => i12.removeAttribute(t12)), t11.appendChild(i12);
            });
            let r10 = 0;
            [].forEach.call(i11.querySelectorAll("text tspan"), (t12) => {
              r10 += Number(t12.getAttribute("dy"));
            });
            let a10 = eM.createElementNS(ek, "tspan");
            a10.textContent = "​", eA(a10, {
              x: Number(e10.getAttribute("x")),
              dy: -r10
            }), t11.appendChild(a10), i11.insertBefore(t11, i11.firstChild);
          }
        }
        attr(t10, e10, i10, s10) {
          let {
            element: o10
          } = this, r10 = e_.symbolCustomAttribs, a10, n10, l10 = this, h10;
          return "string" == typeof t10 && void 0 !== e10 && (a10 = t10, (t10 = {})[a10] = e10), "string" == typeof t10 ? l10 = (this[t10 + "Getter"] || this._defaultGetter).call(this, t10, o10) : (eF(t10, function(e11, i11) {
            h10 = false, s10 || eb(this, i11), this.symbolName && -1 !== r10.indexOf(i11) && (n10 || (this.symbolAttr(t10), n10 = true), h10 = true), this.rotation && ("x" === i11 || "y" === i11) && (this.doTransform = true), h10 || (this[i11 + "Setter"] || this._defaultSetter).call(this, e11, i11, o10);
          }, this), this.afterSetters()), i10 && i10.call(this), l10;
        }
        clip(t10) {
          if (t10 && !t10.clipPath) {
            let e10 = e$() + "-", i10 = this.renderer.createElement("clipPath").attr({
              id: e10
            }).add(this.renderer.defs);
            eD(t10, {
              clipPath: i10,
              id: e10,
              count: 0
            }), t10.add(i10);
          }
          return this.attr("clip-path", t10 ? `url(${this.renderer.url}#${t10.id})` : "none");
        }
        crisp(t10, e10) {
          e10 = Math.round(e10 || t10.strokeWidth || 0);
          let i10 = t10.x || this.x || 0, s10 = t10.y || this.y || 0, o10 = (t10.width || this.width || 0) + i10, r10 = (t10.height || this.height || 0) + s10, a10 = eL(i10, e10), n10 = eL(s10, e10);
          return eD(t10, {
            x: a10,
            y: n10,
            width: eL(o10, e10) - a10,
            height: eL(r10, e10) - n10
          }), eE(t10.strokeWidth) && (t10.strokeWidth = e10), t10;
        }
        complexColor(t10, e10, i10) {
          let s10 = this.renderer, o10, r10, a10, n10, l10, h10, d10, c10, p4, u2, g2 = [], m2;
          eB(this.renderer, "complexColor", {
            args: arguments
          }, function() {
            if (t10.radialGradient ? r10 = "radialGradient" : t10.linearGradient && (r10 = "linearGradient"), r10) {
              if (a10 = t10[r10], l10 = s10.gradients, h10 = t10.stops, p4 = i10.radialReference, eN(a10) && (t10[r10] = a10 = {
                x1: a10[0],
                y1: a10[1],
                x2: a10[2],
                y2: a10[3],
                gradientUnits: "userSpaceOnUse"
              }), "radialGradient" === r10 && p4 && !eE(a10.gradientUnits) && (n10 = a10, a10 = eG(a10, s10.getRadialAttr(p4, n10), {
                gradientUnits: "userSpaceOnUse"
              })), eF(a10, function(t11, e11) {
                "id" !== e11 && g2.push(e11, t11);
              }), eF(h10, function(t11) {
                g2.push(t11);
              }), l10[g2 = g2.join(",")]) u2 = l10[g2].attr("id");
              else {
                a10.id = u2 = e$();
                let t11 = l10[g2] = s10.createElement(r10).attr(a10).add(s10.defs);
                t11.radAttr = n10, t11.stops = [], h10.forEach(function(e11) {
                  0 === e11[1].indexOf("rgba") ? (d10 = (o10 = tA.parse(e11[1])).get("rgb"), c10 = o10.get("a")) : (d10 = e11[1], c10 = 1);
                  let i11 = s10.createElement("stop").attr({
                    offset: e11[0],
                    "stop-color": d10,
                    "stop-opacity": c10
                  }).add(t11);
                  t11.stops.push(i11);
                });
              }
              m2 = "url(" + s10.url + "#" + u2 + ")", i10.setAttribute(e10, m2), i10.gradient = g2, t10.toString = function() {
                return m2;
              };
            }
          });
        }
        css(t10) {
          let e10 = this.styles, i10 = {}, s10 = this.element, o10, r10 = !e10;
          if (e10 && eF(t10, function(t11, s11) {
            e10 && e10[s11] !== t11 && (i10[s11] = t11, r10 = true);
          }), r10) {
            e10 && (t10 = eD(e10, i10)), null === t10.width || "auto" === t10.width ? delete this.textWidth : "text" === s10.nodeName.toLowerCase() && t10.width && (o10 = this.textWidth = eY(t10.width)), eD(this.styles, t10), o10 && !ew && this.renderer.forExport && delete t10.width;
            let r11 = eT && t10.fontSize || null;
            r11 && (eW(r11) || /^\d+$/.test(r11)) && (t10.fontSize += "px");
            let a10 = eG(t10);
            s10.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "whiteSpace", "width"].forEach((t11) => a10 && delete a10[t11]), a10.color && (a10.fill = a10.color)), eO(s10, a10);
          }
          return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t10.textOutline && this.applyTextOutline(t10.textOutline)), this;
        }
        dashstyleSetter(t10) {
          let e10, i10 = this["stroke-width"];
          if ("inherit" === i10 && (i10 = 1), t10 = t10 && t10.toLowerCase()) {
            let s10 = t10.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            for (e10 = s10.length; e10--; ) s10[e10] = "" + eY(s10[e10]) * eH(i10, NaN);
            t10 = s10.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t10);
          }
        }
        destroy() {
          let t10 = this, e10 = t10.element || {}, i10 = t10.renderer, s10 = e10.ownerSVGElement, o10 = "SPAN" === e10.nodeName && t10.parentGroup || void 0, r10, a10;
          if (e10.onclick = e10.onmouseout = e10.onmouseover = e10.onmousemove = e10.point = null, eb(t10), t10.clipPath && s10) {
            let e11 = t10.clipPath;
            [].forEach.call(s10.querySelectorAll("[clip-path],[CLIP-PATH]"), function(t11) {
              t11.getAttribute("clip-path").indexOf(e11.element.id) > -1 && t11.removeAttribute("clip-path");
            }), t10.clipPath = e11.destroy();
          }
          if (t10.connector = t10.connector?.destroy(), t10.stops) {
            for (a10 = 0; a10 < t10.stops.length; a10++) t10.stops[a10].destroy();
            t10.stops.length = 0, t10.stops = void 0;
          }
          for (t10.safeRemoveChild(e10); o10 && o10.div && 0 === o10.div.childNodes.length; ) r10 = o10.parentGroup, t10.safeRemoveChild(o10.div), delete o10.div, o10 = r10;
          t10.alignOptions && eI(i10.alignedObjects, t10), eF(t10, function(e11, i11) {
            t10[i11] && t10[i11].parentGroup === t10 && t10[i11].destroy && t10[i11].destroy(), delete t10[i11];
          });
        }
        dSetter(t10, e10, i10) {
          eN(t10) && ("string" == typeof t10[0] && (t10 = this.renderer.pathToSegments(t10)), this.pathArray = t10, t10 = t10.reduce((t11, e11, i11) => e11 && e11.join ? (i11 ? t11 + " " : "") + e11.join(" ") : (e11 || "").toString(), "")), /(NaN| {2}|^$)/.test(t10) && (t10 = "M 0 0"), this[e10] !== t10 && (i10.setAttribute(e10, t10), this[e10] = t10);
        }
        fillSetter(t10, e10, i10) {
          "string" == typeof t10 ? i10.setAttribute(e10, t10) : t10 && this.complexColor(t10, e10, i10);
        }
        hrefSetter(t10, e10, i10) {
          i10.setAttributeNS("http://www.w3.org/1999/xlink", e10, t10);
        }
        getBBox(t10, e10) {
          let i10, s10, o10, r10;
          let {
            alignValue: a10,
            element: n10,
            renderer: l10,
            styles: h10,
            textStr: d10
          } = this, {
            cache: c10,
            cacheKeys: p4
          } = l10, u2 = n10.namespaceURI === this.SVG_NS, g2 = eH(e10, this.rotation, 0), m2 = l10.styledMode ? n10 && e_.prototype.getStyle.call(n10, "font-size") : h10.fontSize;
          if (eE(d10) && (-1 === (r10 = d10.toString()).indexOf("<") && (r10 = r10.replace(/\d/g, "0")), r10 += ["", l10.rootFontSize, m2, g2, this.textWidth, a10, h10.lineClamp, h10.textOverflow, h10.fontWeight].join(",")), r10 && !t10 && (i10 = c10[r10]), !i10 || i10.polygon) {
            if (u2 || l10.forExport) {
              try {
                o10 = this.fakeTS && function(t12) {
                  let e11 = n10.querySelector(".highcharts-text-outline");
                  e11 && eO(e11, {
                    display: t12
                  });
                }, eR(o10) && o10("none"), i10 = n10.getBBox ? eD({}, n10.getBBox()) : {
                  width: n10.offsetWidth,
                  height: n10.offsetHeight,
                  x: 0,
                  y: 0
                }, eR(o10) && o10("");
              } catch (t12) {
              }
              (!i10 || i10.width < 0) && (i10 = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              });
            } else i10 = this.htmlGetBBox();
            s10 = i10.height, u2 && (i10.height = s10 = {
              "11px,17": 14,
              "13px,20": 16
            }[`${m2 || ""},${Math.round(s10)}`] || s10), g2 && (i10 = this.getRotatedBox(i10, g2));
            let t11 = {
              bBox: i10
            };
            eB(this, "afterGetBBox", t11), i10 = t11.bBox;
          }
          if (r10 && ("" === d10 || i10.height > 0)) {
            for (; p4.length > 250; ) delete c10[p4.shift()];
            c10[r10] || p4.push(r10), c10[r10] = i10;
          }
          return i10;
        }
        getRotatedBox(t10, e10) {
          let {
            x: i10,
            y: s10,
            width: o10,
            height: r10
          } = t10, {
            alignValue: a10,
            translateY: n10,
            rotationOriginX: l10 = 0,
            rotationOriginY: h10 = 0
          } = this, d10 = ez(a10), c10 = Number(this.element.getAttribute("y") || 0) - (n10 ? 0 : s10), p4 = e10 * ev, u2 = (e10 - 90) * ev, g2 = Math.cos(p4), m2 = Math.sin(p4), f2 = o10 * g2, x2 = o10 * m2, y2 = Math.cos(u2), b2 = Math.sin(u2), [[v2, M2], [w2, k2]] = [l10, h10].map((t11) => [t11 - t11 * g2, t11 * m2]), S2 = i10 + d10 * (o10 - f2) + v2 + k2 + c10 * y2, T2 = S2 + f2, C2 = T2 - r10 * y2, A2 = C2 - f2, P2 = s10 + c10 - d10 * x2 - M2 + w2 + c10 * b2, L2 = P2 + x2, O2 = L2 - r10 * b2, E2 = O2 - x2, I2 = Math.min(S2, T2, C2, A2), D2 = Math.min(P2, L2, O2, E2), B2 = Math.max(S2, T2, C2, A2) - I2, z2 = Math.max(P2, L2, O2, E2) - D2;
          return {
            x: I2,
            y: D2,
            width: B2,
            height: z2,
            polygon: [[S2, P2], [T2, L2], [C2, O2], [A2, E2]]
          };
        }
        getStyle(t10) {
          return eS.getComputedStyle(this.element || this, "").getPropertyValue(t10);
        }
        hasClass(t10) {
          return -1 !== ("" + this.attr("class")).split(" ").indexOf(t10);
        }
        hide() {
          return this.attr({
            visibility: "hidden"
          });
        }
        htmlGetBBox() {
          return {
            height: 0,
            width: 0,
            x: 0,
            y: 0
          };
        }
        constructor(t10, e10) {
          this.onEvents = {}, this.opacity = 1, this.SVG_NS = ek, this.element = "span" === e10 || "body" === e10 ? eP(e10) : eM.createElementNS(this.SVG_NS, e10), this.renderer = t10, this.styles = {}, eB(this, "afterInit");
        }
        on(t10, e10) {
          let {
            onEvents: i10
          } = this;
          return i10[t10] && i10[t10](), i10[t10] = eC(this.element, t10, e10), this;
        }
        opacitySetter(t10, e10, i10) {
          let s10 = Number(Number(t10).toFixed(3));
          this.opacity = s10, i10.setAttribute(e10, s10);
        }
        reAlign() {
          this.alignOptions?.width && "left" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = false, this.align());
        }
        removeClass(t10) {
          return this.attr("class", ("" + this.attr("class")).replace(eX(t10) ? RegExp(`(^| )${t10}( |$)`) : t10, " ").replace(/ +/g, " ").trim());
        }
        removeTextOutline() {
          let t10 = this.element.querySelector("tspan.highcharts-text-outline");
          t10 && this.safeRemoveChild(t10);
        }
        safeRemoveChild(t10) {
          let e10 = t10.parentNode;
          e10 && e10.removeChild(t10);
        }
        setRadialReference(t10) {
          let e10 = this.element.gradient && this.renderer.gradients[this.element.gradient];
          return this.element.radialReference = t10, e10 && e10.radAttr && e10.animate(this.renderer.getRadialAttr(t10, e10.radAttr)), this;
        }
        shadow(t10) {
          let {
            renderer: e10
          } = this, i10 = eG(this.parentGroup?.rotation === 90 ? {
            offsetX: -1,
            offsetY: -1
          } : {}, ej(t10) ? t10 : {}), s10 = e10.shadowDefinition(i10);
          return this.attr({
            filter: t10 ? `url(${e10.url}#${s10})` : "none"
          });
        }
        show(t10 = true) {
          return this.attr({
            visibility: t10 ? "inherit" : "visible"
          });
        }
        "stroke-widthSetter"(t10, e10, i10) {
          this[e10] = t10, i10.setAttribute(e10, t10);
        }
        strokeWidth() {
          if (!this.renderer.styledMode) return this["stroke-width"] || 0;
          let t10 = this.getStyle("stroke-width"), e10 = 0, i10;
          return /px$/.test(t10) ? e10 = eY(t10) : "" !== t10 && (eA(i10 = eM.createElementNS(ek, "rect"), {
            width: t10,
            "stroke-width": 0
          }), this.element.parentNode.appendChild(i10), e10 = i10.getBBox().width, i10.parentNode.removeChild(i10)), e10;
        }
        symbolAttr(t10) {
          let e10 = this;
          e_.symbolCustomAttribs.forEach(function(i10) {
            e10[i10] = eH(t10[i10], e10[i10]);
          }), e10.attr({
            d: e10.renderer.symbols[e10.symbolName](e10.x, e10.y, e10.width, e10.height, e10)
          });
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.textPxLength, this.textStr = t10, this.added && this.renderer.buildText(this), this.reAlign());
        }
        titleSetter(t10) {
          let e10 = this.element, i10 = e10.getElementsByTagName("title")[0] || eM.createElementNS(this.SVG_NS, "title");
          e10.insertBefore ? e10.insertBefore(i10, e10.firstChild) : e10.appendChild(i10), i10.textContent = eU(eH(t10, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        }
        toFront() {
          let t10 = this.element;
          return t10.parentNode.appendChild(t10), this;
        }
        translate(t10, e10) {
          return this.attr({
            translateX: t10,
            translateY: e10
          });
        }
        updateTransform(t10 = "transform") {
          let {
            element: e10,
            matrix: i10,
            rotation: s10 = 0,
            rotationOriginX: o10,
            rotationOriginY: r10,
            scaleX: a10,
            scaleY: n10,
            translateX: l10 = 0,
            translateY: h10 = 0
          } = this, d10 = ["translate(" + l10 + "," + h10 + ")"];
          eE(i10) && d10.push("matrix(" + i10.join(",") + ")"), s10 && (d10.push("rotate(" + s10 + " " + eH(o10, e10.getAttribute("x"), 0) + " " + eH(r10, e10.getAttribute("y") || 0) + ")"), this.text?.element.tagName === "SPAN" && this.text.attr({
            rotation: s10,
            rotationOriginX: (o10 || 0) - this.padding,
            rotationOriginY: (r10 || 0) - this.padding
          })), (eE(a10) || eE(n10)) && d10.push("scale(" + eH(a10, 1) + " " + eH(n10, 1) + ")"), d10.length && !(this.text || this).textPath && e10.setAttribute(t10, d10.join(" "));
        }
        visibilitySetter(t10, e10, i10) {
          "inherit" === t10 ? i10.removeAttribute(e10) : this[e10] !== t10 && i10.setAttribute(e10, t10), this[e10] = t10;
        }
        xGetter(t10) {
          return "circle" === this.element.nodeName && ("x" === t10 ? t10 = "cx" : "y" === t10 && (t10 = "cy")), this._defaultGetter(t10);
        }
        zIndexSetter(t10, e10) {
          let i10 = this.renderer, s10 = this.parentGroup, o10 = (s10 || i10).element || i10.box, r10 = this.element, a10 = o10 === i10.box, n10, l10, h10, d10 = false, c10, p4 = this.added, u2;
          if (eE(t10) ? (r10.setAttribute("data-z-index", t10), t10 = +t10, this[e10] === t10 && (p4 = false)) : eE(this[e10]) && r10.removeAttribute("data-z-index"), this[e10] = t10, p4) {
            for ((t10 = this.zIndex) && s10 && (s10.handleZ = true), u2 = (n10 = o10.childNodes).length - 1; u2 >= 0 && !d10; u2--) c10 = !eE(h10 = (l10 = n10[u2]).getAttribute("data-z-index")), l10 !== r10 && (t10 < 0 && c10 && !a10 && !u2 ? (o10.insertBefore(r10, n10[u2]), d10 = true) : (eY(h10) <= t10 || c10 && (!eE(t10) || t10 >= 0)) && (o10.insertBefore(r10, n10[u2 + 1]), d10 = true));
            d10 || (o10.insertBefore(r10, n10[a10 ? 3 : 0]), d10 = true);
          }
          return d10;
        }
      }
      e_.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], e_.prototype.strokeSetter = e_.prototype.fillSetter, e_.prototype.yGetter = e_.prototype.xGetter, e_.prototype.matrixSetter = e_.prototype.rotationOriginXSetter = e_.prototype.rotationOriginYSetter = e_.prototype.rotationSetter = e_.prototype.scaleXSetter = e_.prototype.scaleYSetter = e_.prototype.translateXSetter = e_.prototype.translateYSetter = e_.prototype.verticalAlignSetter = function(t10, e10) {
        this[e10] = t10, this.doTransform = true;
      };
      let eq = e_, {
        defined: eK,
        extend: eJ,
        getAlignFactor: eQ,
        isNumber: e0,
        merge: e1,
        pick: e2,
        removeEvent: e3
      } = J;
      class e6 extends eq {
        constructor(t10, e10, i10, s10, o10, r10, a10, n10, l10, h10) {
          let d10;
          super(t10, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = false, this.textStr = e10, this.x = i10, this.y = s10, this.anchorX = r10, this.anchorY = a10, this.baseline = l10, this.className = h10, this.addClass("button" === h10 ? "highcharts-no-tooltip" : "highcharts-label"), h10 && this.addClass("highcharts-" + h10), this.text = t10.text(void 0, 0, 0, n10).attr({
            zIndex: 1
          }), "string" == typeof o10 && ((d10 = /^url\((.*?)\)$/.test(o10)) || this.renderer.symbols[o10]) && (this.symbolKey = o10), this.bBox = e6.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t10.styledMode || d10, this.deferredAttr = {}, this.alignFactor = 0;
        }
        alignSetter(t10) {
          let e10 = eQ(t10);
          this.textAlign = t10, e10 !== this.alignFactor && (this.alignFactor = e10, this.bBox && e0(this.xSetting) && this.attr({
            x: this.xSetting
          }));
        }
        anchorXSetter(t10, e10) {
          this.anchorX = t10, this.boxAttr(e10, Math.round(t10) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(t10, e10) {
          this.anchorY = t10, this.boxAttr(e10, t10 - this.ySetting);
        }
        boxAttr(t10, e10) {
          this.box ? this.box.attr(t10, e10) : this.deferredAttr[t10] = e10;
        }
        css(t10) {
          if (t10) {
            let e10 = {};
            t10 = e1(t10), e6.textProps.forEach((i10) => {
              void 0 !== t10[i10] && (e10[i10] = t10[i10], delete t10[i10]);
            }), this.text.css(e10), "fontSize" in e10 || "fontWeight" in e10 ? this.updateTextPadding() : ("width" in e10 || "textOverflow" in e10) && this.updateBoxSize();
          }
          return eq.prototype.css.call(this, t10);
        }
        destroy() {
          e3(this.element, "mouseenter"), e3(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), eq.prototype.destroy.call(this);
        }
        fillSetter(t10, e10) {
          t10 && (this.needsBox = true), this.fill = t10, this.boxAttr(e10, t10);
        }
        getBBox(t10, e10) {
          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
          let {
            padding: i10,
            height: s10 = 0,
            translateX: o10 = 0,
            translateY: r10 = 0,
            width: a10 = 0
          } = this, n10 = e2(this.paddingLeft, i10), l10 = e10 ?? (this.rotation || 0), h10 = {
            width: a10,
            height: s10,
            x: o10 + this.bBox.x - n10,
            y: r10 + this.bBox.y - i10 + this.baselineOffset
          };
          return l10 && (h10 = this.getRotatedBox(h10, l10)), h10;
        }
        getCrispAdjust() {
          return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        }
        heightSetter(t10) {
          this.heightSetting = t10, this.doUpdate = true;
        }
        afterSetters() {
          super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = false);
        }
        onAdd() {
          this.text.add(this), this.attr({
            text: e2(this.textStr, ""),
            x: this.x || 0,
            y: this.y || 0
          }), this.box && eK(this.anchorX) && this.attr({
            anchorX: this.anchorX,
            anchorY: this.anchorY
          });
        }
        paddingSetter(t10, e10) {
          e0(t10) ? t10 !== this[e10] && (this[e10] = t10, this.updateTextPadding()) : this[e10] = void 0;
        }
        rSetter(t10, e10) {
          this.boxAttr(e10, t10);
        }
        strokeSetter(t10, e10) {
          this.stroke = t10, this.boxAttr(e10, t10);
        }
        "stroke-widthSetter"(t10, e10) {
          t10 && (this.needsBox = true), this["stroke-width"] = t10, this.boxAttr(e10, t10);
        }
        "text-alignSetter"(t10) {
          this.textAlign = this["text-align"] = t10, this.updateTextPadding();
        }
        textSetter(t10) {
          void 0 !== t10 && this.text.attr({
            text: t10
          }), this.updateTextPadding(), this.reAlign();
        }
        updateBoxSize() {
          let t10;
          let e10 = this.text, i10 = {}, s10 = this.padding, o10 = this.bBox = (!e0(this.widthSetting) || !e0(this.heightSetting) || this.textAlign) && eK(e10.textStr) ? e10.getBBox(void 0, 0) : e6.emptyBBox;
          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o10.height || 0) + 2 * s10;
          let r10 = this.renderer.fontMetrics(e10);
          if (this.baselineOffset = s10 + Math.min((this.text.firstLineMetrics || r10).b, o10.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r10.h) / 2), this.needsBox && !e10.textPath) {
            if (!this.box) {
              let t11 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
              t11.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t11.add(this);
            }
            t10 = this.getCrispAdjust(), i10.x = t10, i10.y = (this.baseline ? -this.baselineOffset : 0) + t10, i10.width = Math.round(this.width), i10.height = Math.round(this.height), this.box.attr(eJ(i10, this.deferredAttr)), this.deferredAttr = {};
          }
        }
        updateTextPadding() {
          let t10 = this.text, e10 = t10.styles.textAlign || this.textAlign;
          if (!t10.textPath) {
            this.updateBoxSize();
            let i10 = this.baseline ? 0 : this.baselineOffset, s10 = (this.paddingLeft ?? this.padding) + eQ(e10) * (this.widthSetting ?? this.bBox.width);
            (s10 !== t10.x || i10 !== t10.y) && (t10.attr({
              align: e10,
              x: s10
            }), void 0 !== i10 && t10.attr("y", i10)), t10.x = s10, t10.y = i10;
          }
        }
        widthSetter(t10) {
          this.widthSetting = e0(t10) ? t10 : void 0, this.doUpdate = true;
        }
        getPaddedWidth() {
          let t10 = this.padding, e10 = e2(this.paddingLeft, t10), i10 = e2(this.paddingRight, t10);
          return (this.widthSetting || this.bBox.width || 0) + e10 + i10;
        }
        xSetter(t10) {
          this.x = t10, this.alignFactor && (t10 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true), this.xSetting = Math.round(t10), this.attr("translateX", this.xSetting);
        }
        ySetter(t10) {
          this.ySetting = this.y = Math.round(t10), this.attr("translateY", this.ySetting);
        }
      }
      e6.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }, e6.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineClamp", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"];
      let {
        defined: e5,
        isNumber: e9,
        pick: e8
      } = J;
      function e4(t10, e10, i10, s10, o10) {
        let r10 = [];
        if (o10) {
          let a10 = o10.start || 0, n10 = e8(o10.r, i10), l10 = e8(o10.r, s10 || i10), h10 = 2e-4 / (o10.borderRadius ? 1 : Math.max(n10, 1)), d10 = Math.abs((o10.end || 0) - a10 - 2 * Math.PI) < h10, c10 = (o10.end || 0) - (d10 ? h10 : 0), p4 = o10.innerR, u2 = e8(o10.open, d10), g2 = Math.cos(a10), m2 = Math.sin(a10), f2 = Math.cos(c10), x2 = Math.sin(c10), y2 = e8(o10.longArc, c10 - a10 - Math.PI < h10 ? 0 : 1), b2 = ["A", n10, l10, 0, y2, e8(o10.clockwise, 1), t10 + n10 * f2, e10 + l10 * x2];
          b2.params = {
            start: a10,
            end: c10,
            cx: t10,
            cy: e10
          }, r10.push(["M", t10 + n10 * g2, e10 + l10 * m2], b2), e5(p4) && ((b2 = ["A", p4, p4, 0, y2, e5(o10.clockwise) ? 1 - o10.clockwise : 0, t10 + p4 * g2, e10 + p4 * m2]).params = {
            start: c10,
            end: a10,
            cx: t10,
            cy: e10
          }, r10.push(u2 ? ["M", t10 + p4 * f2, e10 + p4 * x2] : ["L", t10 + p4 * f2, e10 + p4 * x2], b2)), u2 || r10.push(["Z"]);
        }
        return r10;
      }
      function e7(t10, e10, i10, s10, o10) {
        return o10 && o10.r ? it(t10, e10, i10, s10, o10) : [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
      }
      function it(t10, e10, i10, s10, o10) {
        let r10 = o10?.r || 0;
        return [["M", t10 + r10, e10], ["L", t10 + i10 - r10, e10], ["A", r10, r10, 0, 0, 1, t10 + i10, e10 + r10], ["L", t10 + i10, e10 + s10 - r10], ["A", r10, r10, 0, 0, 1, t10 + i10 - r10, e10 + s10], ["L", t10 + r10, e10 + s10], ["A", r10, r10, 0, 0, 1, t10, e10 + s10 - r10], ["L", t10, e10 + r10], ["A", r10, r10, 0, 0, 1, t10 + r10, e10], ["Z"]];
      }
      let ie = {
        arc: e4,
        callout: function(t10, e10, i10, s10, o10) {
          let r10 = Math.min(o10 && o10.r || 0, i10, s10), a10 = r10 + 6, n10 = o10 && o10.anchorX, l10 = o10 && o10.anchorY || 0, h10 = it(t10, e10, i10, s10, {
            r: r10
          });
          if (!e9(n10) || n10 < i10 && n10 > 0 && l10 < s10 && l10 > 0) return h10;
          if (t10 + n10 > i10 - a10) {
            if (l10 > e10 + a10 && l10 < e10 + s10 - a10) h10.splice(3, 1, ["L", t10 + i10, l10 - 6], ["L", t10 + i10 + 6, l10], ["L", t10 + i10, l10 + 6], ["L", t10 + i10, e10 + s10 - r10]);
            else if (n10 < i10) {
              let o11 = l10 < e10 + a10, d10 = o11 ? e10 : e10 + s10;
              h10.splice(o11 ? 2 : 5, 0, ["L", n10, l10], ["L", t10 + i10 - r10, d10]);
            } else h10.splice(3, 1, ["L", t10 + i10, s10 / 2], ["L", n10, l10], ["L", t10 + i10, s10 / 2], ["L", t10 + i10, e10 + s10 - r10]);
          } else if (t10 + n10 < a10) {
            if (l10 > e10 + a10 && l10 < e10 + s10 - a10) h10.splice(7, 1, ["L", t10, l10 + 6], ["L", t10 - 6, l10], ["L", t10, l10 - 6], ["L", t10, e10 + r10]);
            else if (n10 > 0) {
              let i11 = l10 < e10 + a10, o11 = i11 ? e10 : e10 + s10;
              h10.splice(i11 ? 1 : 6, 0, ["L", n10, l10], ["L", t10 + r10, o11]);
            } else h10.splice(7, 1, ["L", t10, s10 / 2], ["L", n10, l10], ["L", t10, s10 / 2], ["L", t10, e10 + r10]);
          } else l10 > s10 && n10 < i10 - a10 ? h10.splice(5, 1, ["L", n10 + 6, e10 + s10], ["L", n10, e10 + s10 + 6], ["L", n10 - 6, e10 + s10], ["L", t10 + r10, e10 + s10]) : l10 < 0 && n10 > a10 && h10.splice(1, 1, ["L", n10 - 6, e10], ["L", n10, e10 - 6], ["L", n10 + 6, e10], ["L", i10 - r10, e10]);
          return h10;
        },
        circle: function(t10, e10, i10, s10) {
          return e4(t10 + i10 / 2, e10 + s10 / 2, i10 / 2, s10 / 2, {
            start: 0.5 * Math.PI,
            end: 2.5 * Math.PI,
            open: false
          });
        },
        diamond: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10 / 2], ["L", t10 + i10 / 2, e10 + s10], ["L", t10, e10 + s10 / 2], ["Z"]];
        },
        rect: e7,
        roundedRect: it,
        square: e7,
        triangle: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
        },
        "triangle-down": function(t10, e10, i10, s10) {
          return [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10 / 2, e10 + s10], ["Z"]];
        }
      }, {
        doc: ii,
        SVG_NS: is,
        win: io
      } = A, {
        attr: ir,
        extend: ia,
        fireEvent: il,
        isString: ih,
        objectEach: id,
        pick: ic
      } = J, ip = (t10, e10) => t10.substring(0, e10) + "…", iu = class {
        constructor(t10) {
          let e10 = t10.styles;
          this.renderer = t10.renderer, this.svgElement = t10, this.width = t10.textWidth, this.textLineHeight = e10 && e10.lineHeight, this.textOutline = e10 && e10.textOutline, this.ellipsis = !!(e10 && "ellipsis" === e10.textOverflow), this.lineClamp = e10?.lineClamp, this.noWrap = !!(e10 && "nowrap" === e10.whiteSpace);
        }
        buildSVG() {
          let t10 = this.svgElement, e10 = t10.element, i10 = t10.renderer, s10 = ic(t10.textStr, "").toString(), o10 = -1 !== s10.indexOf("<"), r10 = e10.childNodes, a10 = !t10.added && i10.box, n10 = [s10, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, t10.getStyle("font-size"), t10.styles.lineClamp, this.width].join(",");
          if (n10 !== t10.textCache) {
            t10.textCache = n10, delete t10.actualWidth;
            for (let t11 = r10.length; t11--; ) e10.removeChild(r10[t11]);
            if (o10 || this.ellipsis || this.width || t10.textPath || -1 !== s10.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(s10))) {
              if ("" !== s10) {
                a10 && a10.appendChild(e10);
                let i11 = new t3(s10);
                this.modifyTree(i11.nodes), i11.addToDOM(e10), this.modifyDOM(), this.ellipsis && -1 !== (e10.textContent || "").indexOf("…") && t10.attr("title", this.unescapeEntities(t10.textStr || "", ["&lt;", "&gt;"])), a10 && a10.removeChild(e10);
              }
            } else e10.appendChild(ii.createTextNode(this.unescapeEntities(s10)));
            ih(this.textOutline) && t10.applyTextOutline && t10.applyTextOutline(this.textOutline);
          }
        }
        modifyDOM() {
          let t10;
          let e10 = this.svgElement, i10 = ir(e10.element, "x");
          for (e10.firstLineMetrics = void 0; t10 = e10.element.firstChild; ) if (/^[\s\u200B]*$/.test(t10.textContent || " ")) e10.element.removeChild(t10);
          else break;
          [].forEach.call(e10.element.querySelectorAll("tspan.highcharts-br"), (t11, s11) => {
            t11.nextSibling && t11.previousSibling && (0 === s11 && 1 === t11.previousSibling.nodeType && (e10.firstLineMetrics = e10.renderer.fontMetrics(t11.previousSibling)), ir(t11, {
              dy: this.getLineHeight(t11.nextSibling),
              x: i10
            }));
          });
          let s10 = this.width || 0;
          if (!s10) return;
          let o10 = (t11, o11) => {
            let r11 = t11.textContent || "", a10 = r11.replace(/([^\^])-/g, "$1- ").split(" "), n10 = !this.noWrap && (a10.length > 1 || e10.element.childNodes.length > 1), l10 = this.getLineHeight(o11), h10 = Math.max(0, s10 - 0.8 * l10), d10 = 0, c10 = e10.actualWidth;
            if (n10) {
              let r12 = [], n11 = [];
              for (; o11.firstChild && o11.firstChild !== t11; ) n11.push(o11.firstChild), o11.removeChild(o11.firstChild);
              for (; a10.length; ) if (a10.length && !this.noWrap && d10 > 0 && (r12.push(t11.textContent || ""), t11.textContent = a10.join(" ").replace(/- /g, "-")), this.truncate(t11, void 0, a10, 0 === d10 && c10 || 0, s10, h10, (t12, e11) => a10.slice(0, e11).join(" ").replace(/- /g, "-")), c10 = e10.actualWidth, d10++, this.lineClamp && d10 >= this.lineClamp) {
                a10.length && (this.truncate(t11, t11.textContent || "", void 0, 0, s10, h10, ip), t11.textContent = t11.textContent?.replace("…", "") + "…");
                break;
              }
              n11.forEach((e11) => {
                o11.insertBefore(e11, t11);
              }), r12.forEach((e11) => {
                o11.insertBefore(ii.createTextNode(e11), t11);
                let s11 = ii.createElementNS(is, "tspan");
                s11.textContent = "​", ir(s11, {
                  dy: l10,
                  x: i10
                }), o11.insertBefore(s11, t11);
              });
            } else this.ellipsis && r11 && this.truncate(t11, r11, void 0, 0, s10, h10, ip);
          }, r10 = (t11) => {
            [].slice.call(t11.childNodes).forEach((i11) => {
              i11.nodeType === io.Node.TEXT_NODE ? o10(i11, t11) : (-1 !== i11.className.baseVal.indexOf("highcharts-br") && (e10.actualWidth = 0), r10(i11));
            });
          };
          r10(e10.element);
        }
        getLineHeight(t10) {
          let e10 = t10.nodeType === io.Node.TEXT_NODE ? t10.parentElement : t10;
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e10 || this.svgElement.element).h;
        }
        modifyTree(t10) {
          let e10 = (i10, s10) => {
            let {
              attributes: o10 = {},
              children: r10,
              style: a10 = {},
              tagName: n10
            } = i10, l10 = this.renderer.styledMode;
            if ("b" === n10 || "strong" === n10 ? l10 ? o10.class = "highcharts-strong" : a10.fontWeight = "bold" : ("i" === n10 || "em" === n10) && (l10 ? o10.class = "highcharts-emphasized" : a10.fontStyle = "italic"), a10 && a10.color && (a10.fill = a10.color), "br" === n10) {
              o10.class = "highcharts-br", i10.textContent = "​";
              let e11 = t10[s10 + 1];
              e11 && e11.textContent && (e11.textContent = e11.textContent.replace(/^ +/gm, ""));
            } else "a" === n10 && r10 && r10.some((t11) => "#text" === t11.tagName) && (i10.children = [{
              children: r10,
              tagName: "tspan"
            }]);
            "#text" !== n10 && "a" !== n10 && (i10.tagName = "tspan"), ia(i10, {
              attributes: o10,
              style: a10
            }), r10 && r10.filter((t11) => "#text" !== t11.tagName).forEach(e10);
          };
          t10.forEach(e10), il(this.svgElement, "afterModifyTree", {
            nodes: t10
          });
        }
        truncate(t10, e10, i10, s10, o10, r10, a10) {
          let n10, l10;
          let h10 = this.svgElement, {
            rotation: d10
          } = h10, c10 = [], p4 = i10 && !s10 ? 1 : 0, u2 = (e10 || i10 || "").length, g2 = u2;
          i10 || (o10 = r10);
          let m2 = function(e11, o11) {
            let r11 = o11 || e11, a11 = t10.parentNode;
            if (a11 && void 0 === c10[r11] && a11.getSubStringLength) try {
              c10[r11] = s10 + a11.getSubStringLength(0, i10 ? r11 + 1 : r11);
            } catch (t11) {
            }
            return c10[r11];
          };
          if (h10.rotation = 0, s10 + (l10 = m2(t10.textContent.length)) > o10) {
            for (; p4 <= u2; ) g2 = Math.ceil((p4 + u2) / 2), i10 && (n10 = a10(i10, g2)), l10 = m2(g2, n10 && n10.length - 1), p4 === u2 ? p4 = u2 + 1 : l10 > o10 ? u2 = g2 - 1 : p4 = g2;
            0 === u2 ? t10.textContent = "" : e10 && u2 === e10.length - 1 || (t10.textContent = n10 || a10(e10 || i10, g2)), this.ellipsis && l10 > o10 && this.truncate(t10, t10.textContent || "", void 0, 0, o10, r10, ip);
          }
          i10 && i10.splice(0, g2), h10.actualWidth = l10, h10.rotation = d10;
        }
        unescapeEntities(t10, e10) {
          return id(this.renderer.escapes, function(i10, s10) {
            e10 && -1 !== e10.indexOf(i10) || (t10 = t10.toString().replace(RegExp(i10, "g"), s10));
          }), t10;
        }
      }, {
        defaultOptions: ig
      } = tw, {
        charts: im,
        deg2rad: ix,
        doc: iy,
        isFirefox: ib,
        isMS: iv,
        isWebKit: iM,
        noop: iw,
        SVG_NS: ik,
        symbolSizes: iS,
        win: iT
      } = A, {
        addEvent: iC,
        attr: iA,
        createElement: iP,
        crisp: iL,
        css: iO,
        defined: iE,
        destroyObjectProperties: iI,
        extend: iD,
        isArray: iB,
        isNumber: iz,
        isObject: iN,
        isString: iR,
        merge: iW,
        pick: ij,
        pInt: iX,
        replaceNested: iG,
        uniqueKey: iF
      } = J;
      class iH {
        constructor(t10, e10, i10, s10, o10, r10, a10) {
          let n10, l10;
          let h10 = this.createElement("svg").attr({
            version: "1.1",
            class: "highcharts-root"
          }), d10 = h10.element;
          a10 || h10.css(this.getStyle(s10 || {})), t10.appendChild(d10), iA(t10, "dir", "ltr"), -1 === t10.innerHTML.indexOf("xmlns") && iA(d10, "xmlns", this.SVG_NS), this.box = d10, this.boxWrapper = h10, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(iy.createTextNode("Created with Highcharts 12.1.2")), this.defs = this.createElement("defs").add(), this.allowHTML = r10, this.forExport = o10, this.styledMode = a10, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = h10.getStyle("font-size"), this.setSize(e10, i10, false), ib && t10.getBoundingClientRect && ((n10 = function() {
            iO(t10, {
              left: 0,
              top: 0
            }), l10 = t10.getBoundingClientRect(), iO(t10, {
              left: Math.ceil(l10.left) - l10.left + "px",
              top: Math.ceil(l10.top) - l10.top + "px"
            });
          })(), this.unSubPixelFix = iC(iT, "resize", n10));
        }
        definition(t10) {
          return new t3([t10]).addToDOM(this.defs.element);
        }
        getReferenceURL() {
          if ((ib || iM) && iy.getElementsByTagName("base").length) {
            if (!iE(e)) {
              let t10 = iF(), i10 = new t3([{
                tagName: "svg",
                attributes: {
                  width: 8,
                  height: 8
                },
                children: [{
                  tagName: "defs",
                  children: [{
                    tagName: "clipPath",
                    attributes: {
                      id: t10
                    },
                    children: [{
                      tagName: "rect",
                      attributes: {
                        width: 4,
                        height: 4
                      }
                    }]
                  }]
                }, {
                  tagName: "rect",
                  attributes: {
                    id: "hitme",
                    width: 8,
                    height: 8,
                    "clip-path": `url(#${t10})`,
                    fill: "rgba(0,0,0,0.001)"
                  }
                }]
              }]).addToDOM(iy.body);
              iO(i10, {
                position: "fixed",
                top: 0,
                left: 0,
                zIndex: 9e5
              });
              let s10 = iy.elementFromPoint(6, 6);
              e = "hitme" === (s10 && s10.id), iy.body.removeChild(i10);
            }
            if (e) return iG(iT.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
          }
          return "";
        }
        getStyle(t10) {
          return this.style = iD({
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
            fontSize: "1rem"
          }, t10), this.style;
        }
        setStyle(t10) {
          this.boxWrapper.css(this.getStyle(t10));
        }
        isHidden() {
          return !this.boxWrapper.getBBox().width;
        }
        destroy() {
          let t10 = this.defs;
          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), iI(this.gradients || {}), this.gradients = null, this.defs = t10.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
        }
        createElement(t10) {
          return new this.Element(this, t10);
        }
        getRadialAttr(t10, e10) {
          return {
            cx: t10[0] - t10[2] / 2 + (e10.cx || 0) * t10[2],
            cy: t10[1] - t10[2] / 2 + (e10.cy || 0) * t10[2],
            r: (e10.r || 0) * t10[2]
          };
        }
        shadowDefinition(t10) {
          let e10 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t10).map((e11) => `${e11}-${t10[e11]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i10 = iW({
            color: "#000000",
            offsetX: 1,
            offsetY: 1,
            opacity: 0.15,
            width: 5
          }, t10);
          return this.defs.element.querySelector(`#${e10}`) || this.definition({
            tagName: "filter",
            attributes: {
              id: e10,
              filterUnits: i10.filterUnits
            },
            children: this.getShadowFilterContent(i10)
          }), e10;
        }
        getShadowFilterContent(t10) {
          return [{
            tagName: "feDropShadow",
            attributes: {
              dx: t10.offsetX,
              dy: t10.offsetY,
              "flood-color": t10.color,
              "flood-opacity": Math.min(5 * t10.opacity, 1),
              stdDeviation: t10.width / 2
            }
          }];
        }
        buildText(t10) {
          new iu(t10).buildSVG();
        }
        getContrast(t10) {
          let e10 = tA.parse(t10).rgba.map((t11) => {
            let e11 = t11 / 255;
            return e11 <= 0.03928 ? e11 / 12.92 : Math.pow((e11 + 0.055) / 1.055, 2.4);
          }), i10 = 0.2126 * e10[0] + 0.7152 * e10[1] + 0.0722 * e10[2];
          return 1.05 / (i10 + 0.05) > (i10 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
        }
        button(t10, e10, i10, s10, o10 = {}, r10, a10, n10, l10, h10) {
          let d10 = this.label(t10, e10, i10, l10, void 0, void 0, h10, void 0, "button"), c10 = this.styledMode, p4 = arguments, u2 = 0;
          o10 = iW(ig.global.buttonTheme, o10), c10 && (delete o10.fill, delete o10.stroke, delete o10["stroke-width"]);
          let g2 = o10.states || {}, m2 = o10.style || {};
          delete o10.states, delete o10.style;
          let f2 = [t3.filterUserAttributes(o10)], x2 = [m2];
          return c10 || ["hover", "select", "disabled"].forEach((t11, e11) => {
            f2.push(iW(f2[0], t3.filterUserAttributes(p4[e11 + 5] || g2[t11] || {}))), x2.push(f2[e11 + 1].style), delete f2[e11 + 1].style;
          }), iC(d10.element, iv ? "mouseover" : "mouseenter", function() {
            3 !== u2 && d10.setState(1);
          }), iC(d10.element, iv ? "mouseout" : "mouseleave", function() {
            3 !== u2 && d10.setState(u2);
          }), d10.setState = (t11 = 0) => {
            if (1 !== t11 && (d10.state = u2 = t11), d10.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t11]), !c10) {
              d10.attr(f2[t11]);
              let e11 = x2[t11];
              iN(e11) && d10.css(e11);
            }
          }, d10.attr(f2[0]), !c10 && (d10.css(iD({
            cursor: "default"
          }, m2)), h10 && d10.text.css({
            pointerEvents: "none"
          })), d10.on("touchstart", (t11) => t11.stopPropagation()).on("click", function(t11) {
            3 !== u2 && s10.call(d10, t11);
          });
        }
        crispLine(t10, e10) {
          let [i10, s10] = t10;
          return iE(i10[1]) && i10[1] === s10[1] && (i10[1] = s10[1] = iL(i10[1], e10)), iE(i10[2]) && i10[2] === s10[2] && (i10[2] = s10[2] = iL(i10[2], e10)), t10;
        }
        path(t10) {
          let e10 = this.styledMode ? {} : {
            fill: "none"
          };
          return iB(t10) ? e10.d = t10 : iN(t10) && iD(e10, t10), this.createElement("path").attr(e10);
        }
        circle(t10, e10, i10) {
          let s10 = iN(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: i10
          }, o10 = this.createElement("circle");
          return o10.xSetter = o10.ySetter = function(t11, e11, i11) {
            i11.setAttribute("c" + e11, t11);
          }, o10.attr(s10);
        }
        arc(t10, e10, i10, s10, o10, r10) {
          let a10;
          iN(t10) ? (e10 = (a10 = t10).y, i10 = a10.r, s10 = a10.innerR, o10 = a10.start, r10 = a10.end, t10 = a10.x) : a10 = {
            innerR: s10,
            start: o10,
            end: r10
          };
          let n10 = this.symbol("arc", t10, e10, i10, i10, a10);
          return n10.r = i10, n10;
        }
        rect(t10, e10, i10, s10, o10, r10) {
          let a10 = iN(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: o10,
            width: Math.max(i10 || 0, 0),
            height: Math.max(s10 || 0, 0)
          }, n10 = this.createElement("rect");
          return this.styledMode || (void 0 !== r10 && (a10["stroke-width"] = r10, iD(a10, n10.crisp(a10))), a10.fill = "none"), n10.rSetter = function(t11, e11, i11) {
            n10.r = t11, iA(i11, {
              rx: t11,
              ry: t11
            });
          }, n10.rGetter = function() {
            return n10.r || 0;
          }, n10.attr(a10);
        }
        roundedRect(t10) {
          return this.symbol("roundedRect").attr(t10);
        }
        setSize(t10, e10, i10) {
          this.width = t10, this.height = e10, this.boxWrapper.animate({
            width: t10,
            height: e10
          }, {
            step: function() {
              this.attr({
                viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
              });
            },
            duration: ij(i10, true) ? void 0 : 0
          }), this.alignElements();
        }
        g(t10) {
          let e10 = this.createElement("g");
          return t10 ? e10.attr({
            class: "highcharts-" + t10
          }) : e10;
        }
        image(t10, e10, i10, s10, o10, r10) {
          let a10 = {
            preserveAspectRatio: "none"
          };
          iz(e10) && (a10.x = e10), iz(i10) && (a10.y = i10), iz(s10) && (a10.width = s10), iz(o10) && (a10.height = o10);
          let n10 = this.createElement("image").attr(a10), l10 = function(e11) {
            n10.attr({
              href: t10
            }), r10.call(n10, e11);
          };
          if (r10) {
            n10.attr({
              href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
            });
            let e11 = new iT.Image();
            iC(e11, "load", l10), e11.src = t10, e11.complete && l10({});
          } else n10.attr({
            href: t10
          });
          return n10;
        }
        symbol(t10, e10, i10, s10, o10, r10) {
          let a10, n10, l10, h10;
          let d10 = this, c10 = /^url\((.*?)\)$/, p4 = c10.test(t10), u2 = !p4 && (this.symbols[t10] ? t10 : "circle"), g2 = u2 && this.symbols[u2];
          if (g2) "number" == typeof e10 && (n10 = g2.call(this.symbols, e10 || 0, i10 || 0, s10 || 0, o10 || 0, r10)), a10 = this.path(n10), d10.styledMode || a10.attr("fill", "none"), iD(a10, {
            symbolName: u2 || void 0,
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }), r10 && iD(a10, r10);
          else if (p4) {
            l10 = t10.match(c10)[1];
            let s11 = a10 = this.image(l10);
            s11.imgwidth = ij(r10 && r10.width, iS[l10] && iS[l10].width), s11.imgheight = ij(r10 && r10.height, iS[l10] && iS[l10].height), h10 = (t11) => t11.attr({
              width: t11.width,
              height: t11.height
            }), ["width", "height"].forEach((t11) => {
              s11[`${t11}Setter`] = function(t12, e11) {
                this[e11] = t12;
                let {
                  alignByTranslate: i11,
                  element: s12,
                  width: o11,
                  height: a11,
                  imgwidth: n11,
                  imgheight: l11
                } = this, h11 = "width" === e11 ? n11 : l11, d11 = 1;
                r10 && "within" === r10.backgroundSize && o11 && a11 && n11 && l11 ? (d11 = Math.min(o11 / n11, a11 / l11), iA(s12, {
                  width: Math.round(n11 * d11),
                  height: Math.round(l11 * d11)
                })) : s12 && h11 && s12.setAttribute(e11, h11), !i11 && n11 && l11 && this.translate(((o11 || 0) - n11 * d11) / 2, ((a11 || 0) - l11 * d11) / 2);
              };
            }), iE(e10) && s11.attr({
              x: e10,
              y: i10
            }), s11.isImg = true, s11.symbolUrl = t10, iE(s11.imgwidth) && iE(s11.imgheight) ? h10(s11) : (s11.attr({
              width: 0,
              height: 0
            }), iP("img", {
              onload: function() {
                let t11 = im[d10.chartIndex];
                0 === this.width && (iO(this, {
                  position: "absolute",
                  top: "-999em"
                }), iy.body.appendChild(this)), iS[l10] = {
                  width: this.width,
                  height: this.height
                }, s11.imgwidth = this.width, s11.imgheight = this.height, s11.element && h10(s11), this.parentNode && this.parentNode.removeChild(this), d10.imgCount--, d10.imgCount || !t11 || t11.hasLoaded || t11.onload();
              },
              src: l10
            }), this.imgCount++);
          }
          return a10;
        }
        clipRect(t10, e10, i10, s10) {
          return this.rect(t10, e10, i10, s10, 0);
        }
        text(t10, e10, i10, s10) {
          let o10 = {};
          if (s10 && (this.allowHTML || !this.forExport)) return this.html(t10, e10, i10);
          o10.x = Math.round(e10 || 0), i10 && (o10.y = Math.round(i10)), iE(t10) && (o10.text = t10);
          let r10 = this.createElement("text").attr(o10);
          return s10 && (!this.forExport || this.allowHTML) || (r10.xSetter = function(t11, e11, i11) {
            let s11 = i11.getElementsByTagName("tspan"), o11 = i11.getAttribute(e11);
            for (let i12 = 0, r11; i12 < s11.length; i12++) (r11 = s11[i12]).getAttribute(e11) === o11 && r11.setAttribute(e11, t11);
            i11.setAttribute(e11, t11);
          }), r10;
        }
        fontMetrics(t10) {
          let e10 = iX(eq.prototype.getStyle.call(t10, "font-size") || 0), i10 = e10 < 24 ? e10 + 3 : Math.round(1.2 * e10), s10 = Math.round(0.8 * i10);
          return {
            h: i10,
            b: s10,
            f: e10
          };
        }
        rotCorr(t10, e10, i10) {
          let s10 = t10;
          return e10 && i10 && (s10 = Math.max(s10 * Math.cos(e10 * ix), 4)), {
            x: -t10 / 3 * Math.sin(e10 * ix),
            y: s10
          };
        }
        pathToSegments(t10) {
          let e10 = [], i10 = [], s10 = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          };
          for (let o10 = 0; o10 < t10.length; o10++) iR(i10[0]) && iz(t10[o10]) && i10.length === s10[i10[0].toUpperCase()] && t10.splice(o10, 0, i10[0].replace("M", "L").replace("m", "l")), "string" == typeof t10[o10] && (i10.length && e10.push(i10.slice(0)), i10.length = 0), i10.push(t10[o10]);
          return e10.push(i10.slice(0)), e10;
        }
        label(t10, e10, i10, s10, o10, r10, a10, n10, l10) {
          return new e6(this, t10, e10, i10, s10, o10, r10, a10, n10, l10);
        }
        alignElements() {
          this.alignedObjects.forEach((t10) => t10.align());
        }
      }
      iD(iH.prototype, {
        Element: eq,
        SVG_NS: ik,
        escapes: {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "'": "&#39;",
          '"': "&quot;"
        },
        symbols: ie,
        draw: iw
      }), ec.registerRendererType("svg", iH, true);
      let {
        composed: iY
      } = A, {
        attr: iV,
        css: iU,
        createElement: iZ,
        defined: i$,
        extend: i_,
        getAlignFactor: iq,
        isNumber: iK,
        pInt: iJ,
        pushUnique: iQ
      } = J;
      function i0(t10, e10, i10) {
        let s10 = this.div?.style || i10.style;
        eq.prototype[`${e10}Setter`].call(this, t10, e10, i10), s10 && (s10[e10] = t10);
      }
      let i1 = (t10, e10) => {
        if (!t10.div) {
          let i10 = iV(t10.element, "class"), s10 = t10.css, o10 = iZ("div", i10 ? {
            className: i10
          } : void 0, __spreadProps(__spreadValues({
            position: "absolute",
            left: `${t10.translateX || 0}px`,
            top: `${t10.translateY || 0}px`
          }, t10.styles), {
            display: t10.display,
            opacity: t10.opacity,
            visibility: t10.visibility
          }), t10.parentGroup?.div || e10);
          t10.classSetter = (t11, e11, i11) => {
            i11.setAttribute("class", t11), o10.className = t11;
          }, t10.translateXSetter = t10.translateYSetter = (e11, i11) => {
            t10[i11] = e11, o10.style["translateX" === i11 ? "left" : "top"] = `${e11}px`, t10.doTransform = true;
          }, t10.opacitySetter = t10.visibilitySetter = i0, t10.css = (e11) => (s10.call(t10, e11), e11.cursor && (o10.style.cursor = e11.cursor), e11.pointerEvents && (o10.style.pointerEvents = e11.pointerEvents), t10), t10.on = function() {
            return eq.prototype.on.apply({
              element: o10,
              onEvents: t10.onEvents
            }, arguments), t10;
          }, t10.div = o10;
        }
        return t10.div;
      };
      class i2 extends eq {
        static compose(t10) {
          iQ(iY, this.compose) && (t10.prototype.html = function(t11, e10, i10) {
            return new i2(this, "span").attr({
              text: t11,
              x: Math.round(e10),
              y: Math.round(i10)
            });
          });
        }
        constructor(t10, e10) {
          super(t10, e10), this.css(__spreadValues({
            position: "absolute"
          }, t10.styledMode ? {} : {
            fontFamily: t10.style.fontFamily,
            fontSize: t10.style.fontSize
          }));
        }
        getSpanCorrection(t10, e10, i10) {
          this.xCorr = -t10 * i10, this.yCorr = -e10;
        }
        css(t10) {
          let e10;
          let {
            element: i10
          } = this, s10 = "SPAN" === i10.tagName && t10 && "width" in t10, o10 = s10 && t10.width;
          return s10 && (delete t10.width, this.textWidth = iJ(o10) || void 0, e10 = true), t10?.textOverflow === "ellipsis" && (t10.overflow = "hidden"), t10?.lineClamp && (t10.display = "-webkit-box", t10.WebkitLineClamp = t10.lineClamp, t10.WebkitBoxOrient = "vertical", t10.overflow = "hidden"), iK(Number(t10?.fontSize)) && (t10.fontSize = t10.fontSize + "px"), i_(this.styles, t10), iU(i10, t10), e10 && this.updateTransform(), this;
        }
        htmlGetBBox() {
          let {
            element: t10
          } = this;
          return {
            x: t10.offsetLeft,
            y: t10.offsetTop,
            width: t10.offsetWidth,
            height: t10.offsetHeight
          };
        }
        updateTransform() {
          if (!this.added) {
            this.alignOnAdd = true;
            return;
          }
          let {
            element: t10,
            renderer: e10,
            rotation: i10,
            rotationOriginX: s10,
            rotationOriginY: o10,
            scaleX: r10,
            scaleY: a10,
            styles: n10,
            textAlign: l10 = "left",
            textWidth: h10,
            translateX: d10 = 0,
            translateY: c10 = 0,
            x: p4 = 0,
            y: u2 = 0
          } = this, {
            display: g2 = "block",
            whiteSpace: m2
          } = n10;
          if (iU(t10, {
            marginLeft: `${d10}px`,
            marginTop: `${c10}px`
          }), "SPAN" === t10.tagName) {
            let n11;
            let d11 = [i10, l10, t10.innerHTML, h10, this.textAlign].join(","), c11 = -(this.parentGroup?.padding * 1) || 0;
            if (h10 !== this.oldTextWidth) {
              let e11 = this.textPxLength ? this.textPxLength : (iU(t10, {
                width: "",
                whiteSpace: m2 || "nowrap"
              }), t10.offsetWidth), s11 = h10 || 0;
              (s11 > this.oldTextWidth || e11 > s11) && (/[ \-]/.test(t10.textContent || t10.innerText) || "ellipsis" === t10.style.textOverflow) && (iU(t10, {
                width: e11 > s11 || i10 || r10 ? h10 + "px" : "auto",
                display: g2,
                whiteSpace: m2 || "normal"
              }), this.oldTextWidth = h10);
            }
            d11 !== this.cTT && (n11 = e10.fontMetrics(t10).b, i$(i10) && (i10 !== (this.oldRotation || 0) || l10 !== this.oldAlign) && this.setSpanRotation(i10, c11, c11), this.getSpanCorrection(!i$(i10) && !this.textWidth && this.textPxLength || t10.offsetWidth, n11, iq(l10)));
            let {
              xCorr: f2 = 0,
              yCorr: x2 = 0
            } = this, y2 = {
              left: `${p4 + f2}px`,
              top: `${u2 + x2}px`,
              textAlign: l10,
              transformOrigin: `${(s10 ?? p4) - f2 - p4 - c11}px ${(o10 ?? u2) - x2 - u2 - c11}px`
            };
            (r10 || a10) && (y2.transform = `scale(${r10 ?? 1},${a10 ?? 1})`), iU(t10, y2), this.cTT = d11, this.oldRotation = i10, this.oldAlign = l10;
          }
        }
        setSpanRotation(t10, e10, i10) {
          iU(this.element, {
            transform: `rotate(${t10}deg)`,
            transformOrigin: `${e10}% ${i10}px`
          });
        }
        add(t10) {
          let e10;
          let i10 = this.renderer.box.parentNode, s10 = [];
          if (this.parentGroup = t10, t10 && !(e10 = t10.div)) {
            let o10 = t10;
            for (; o10; ) s10.push(o10), o10 = o10.parentGroup;
            for (let t11 of s10.reverse()) e10 = i1(t11, i10);
          }
          return (e10 || i10).appendChild(this.element), this.added = true, this.alignOnAdd && this.updateTransform(), this;
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t3.setElementHTML(this.element, t10 ?? ""), this.textStr = t10, this.doTransform = true);
        }
        alignSetter(t10) {
          this.alignValue = this.textAlign = t10, this.doTransform = true;
        }
        xSetter(t10, e10) {
          this[e10] = t10, this.doTransform = true;
        }
      }
      let i3 = i2.prototype;
      i3.visibilitySetter = i3.opacitySetter = i0, i3.ySetter = i3.rotationSetter = i3.rotationOriginXSetter = i3.rotationOriginYSetter = i3.xSetter, function(t10) {
        t10.xAxis = {
          alignTicks: true,
          allowDecimals: void 0,
          panningEnabled: true,
          zIndex: 2,
          zoomEnabled: true,
          dateTimeLabelFormats: {
            millisecond: {
              main: "%[HMSL]",
              range: false
            },
            second: {
              main: "%[HMS]",
              range: false
            },
            minute: {
              main: "%[HM]",
              range: false
            },
            hour: {
              main: "%[HM]",
              range: false
            },
            day: {
              main: "%[eb]"
            },
            week: {
              main: "%[eb]"
            },
            month: {
              main: "%[bY]"
            },
            year: {
              main: "%Y"
            }
          },
          endOnTick: false,
          gridLineDashStyle: "Solid",
          gridZIndex: 1,
          labels: {
            autoRotationLimit: 80,
            distance: 15,
            enabled: true,
            indentation: 10,
            overflow: "justify",
            reserveSpace: void 0,
            rotation: void 0,
            staggerLines: 0,
            step: 0,
            useHTML: false,
            zIndex: 7,
            style: {
              color: "#333333",
              cursor: "default",
              fontSize: "0.8em",
              textOverflow: "ellipsis"
            }
          },
          maxPadding: 0.01,
          minorGridLineDashStyle: "Solid",
          minorTickLength: 2,
          minorTickPosition: "outside",
          minorTicksPerMajor: 5,
          minPadding: 0.01,
          offset: void 0,
          reversed: void 0,
          reversedStacks: false,
          showEmpty: true,
          showFirstLabel: true,
          showLastLabel: true,
          startOfWeek: 1,
          startOnTick: false,
          tickLength: 10,
          tickPixelInterval: 100,
          tickmarkPlacement: "between",
          tickPosition: "outside",
          title: {
            align: "middle",
            useHTML: false,
            x: 0,
            y: 0,
            style: {
              color: "#666666",
              fontSize: "0.8em"
            }
          },
          visible: true,
          minorGridLineColor: "#f2f2f2",
          minorGridLineWidth: 1,
          minorTickColor: "#999999",
          lineColor: "#333333",
          lineWidth: 1,
          gridLineColor: "#e6e6e6",
          gridLineWidth: void 0,
          tickColor: "#333333"
        }, t10.yAxis = {
          reversedStacks: true,
          endOnTick: true,
          maxPadding: 0.05,
          minPadding: 0.05,
          tickPixelInterval: 72,
          showLastLabel: true,
          labels: {
            x: void 0
          },
          startOnTick: true,
          title: {
            text: "Values"
          },
          stackLabels: {
            animation: {},
            allowOverlap: false,
            enabled: false,
            crop: true,
            overflow: "justify",
            formatter: function() {
              let {
                numberFormatter: t11
              } = this.axis.chart;
              return t11(this.total || 0, -1);
            },
            style: {
              color: "#000000",
              fontSize: "0.7em",
              fontWeight: "bold",
              textOutline: "1px contrast"
            }
          },
          gridLineWidth: 1,
          lineWidth: 0
        };
      }(a || (a = {}));
      let i6 = a, {
        addEvent: i5,
        isFunction: i9,
        objectEach: i8,
        removeEvent: i4
      } = J;
      (n || (n = {})).registerEventOptions = function(t10, e10) {
        t10.eventOptions = t10.eventOptions || {}, i8(e10.events, function(e11, i10) {
          t10.eventOptions[i10] !== e11 && (t10.eventOptions[i10] && (i4(t10, i10, t10.eventOptions[i10]), delete t10.eventOptions[i10]), i9(e11) && (t10.eventOptions[i10] = e11, i5(t10, i10, e11, {
            order: 0
          })));
        });
      };
      let i7 = n, {
        deg2rad: st
      } = A, {
        clamp: se,
        correctFloat: si,
        defined: ss,
        destroyObjectProperties: so,
        extend: sr,
        fireEvent: sa,
        getAlignFactor: sn,
        isNumber: sl,
        merge: sh,
        objectEach: sd,
        pick: sc
      } = J, sp = class {
        constructor(t10, e10, i10, s10, o10) {
          this.isNew = true, this.isNewLabel = true, this.axis = t10, this.pos = e10, this.type = i10 || "", this.parameters = o10 || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, sa(this, "init"), i10 || s10 || this.addLabel();
        }
        addLabel() {
          let t10 = this, e10 = t10.axis, i10 = e10.options, s10 = e10.chart, o10 = e10.categories, r10 = e10.logarithmic, a10 = e10.names, n10 = t10.pos, l10 = sc(t10.options && t10.options.labels, i10.labels), h10 = e10.tickPositions, d10 = n10 === h10[0], c10 = n10 === h10[h10.length - 1], p4 = (!l10.step || 1 === l10.step) && 1 === e10.tickInterval, u2 = h10.info, g2 = t10.label, m2, f2, x2, y2 = this.parameters.category || (o10 ? sc(o10[n10], a10[n10], n10) : n10);
          r10 && sl(y2) && (y2 = si(r10.lin2log(y2))), e10.dateTime && (u2 ? m2 = (f2 = s10.time.resolveDTLFormat(i10.dateTimeLabelFormats[!i10.grid && u2.higherRanks[n10] || u2.unitName])).main : sl(y2) && (m2 = e10.dateTime.getXDateFormat(y2, i10.dateTimeLabelFormats || {}))), t10.isFirst = d10, t10.isLast = c10;
          let b2 = {
            axis: e10,
            chart: s10,
            dateTimeLabelFormat: m2,
            isFirst: d10,
            isLast: c10,
            pos: n10,
            tick: t10,
            tickPositionInfo: u2,
            value: y2
          };
          sa(this, "labelFormat", b2);
          let v2 = (t11) => l10.formatter ? l10.formatter.call(t11, t11) : l10.format ? (t11.text = e10.defaultLabelFormatter.call(t11), ed.format(l10.format, t11, s10)) : e10.defaultLabelFormatter.call(t11), M2 = v2.call(b2, b2), w2 = f2 && f2.list;
          w2 ? t10.shortenLabel = function() {
            for (x2 = 0; x2 < w2.length; x2++) if (sr(b2, {
              dateTimeLabelFormat: w2[x2]
            }), g2.attr({
              text: v2.call(b2, b2)
            }), g2.getBBox().width < e10.getSlotWidth(t10) - 2 * (l10.padding || 0)) return;
            g2.attr({
              text: ""
            });
          } : t10.shortenLabel = void 0, p4 && e10._addedPlotLB && t10.moveLabel(M2, l10), ss(g2) || t10.movedLabel ? g2 && g2.textStr !== M2 && !p4 && (!g2.textWidth || l10.style.width || g2.styles.width || g2.css({
            width: null
          }), g2.attr({
            text: M2
          }), g2.textPxLength = g2.getBBox().width) : (t10.label = g2 = t10.createLabel(M2, l10), t10.rotation = 0);
        }
        createLabel(t10, e10, i10) {
          let s10 = this.axis, {
            renderer: o10,
            styledMode: r10
          } = s10.chart, a10 = ss(t10) && e10.enabled ? o10.text(t10, i10?.x, i10?.y, e10.useHTML).add(s10.labelGroup) : void 0;
          if (a10) {
            let t11 = e10.style.whiteSpace || "normal";
            r10 || a10.css(sh(e10.style, {
              whiteSpace: "nowrap"
            })), a10.textPxLength = a10.getBBox().width, r10 || a10.css({
              whiteSpace: t11
            });
          }
          return a10;
        }
        destroy() {
          so(this, this.axis);
        }
        getPosition(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart, a10 = s10 && r10.oldChartHeight || r10.chartHeight, n10 = {
            x: t10 ? si(o10.translate(e10 + i10, void 0, void 0, s10) + o10.transB) : o10.left + o10.offset + (o10.opposite ? (s10 && r10.oldChartWidth || r10.chartWidth) - o10.right - o10.left : 0),
            y: t10 ? a10 - o10.bottom + o10.offset - (o10.opposite ? o10.height : 0) : si(a10 - o10.translate(e10 + i10, void 0, void 0, s10) - o10.transB)
          };
          return n10.y = se(n10.y, -1e9, 1e9), sa(this, "afterGetPosition", {
            pos: n10
          }), n10;
        }
        getLabelPosition(t10, e10, i10, s10, o10, r10, a10, n10) {
          let l10, h10;
          let d10 = this.axis, c10 = d10.transA, p4 = d10.isLinked && d10.linkedParent ? d10.linkedParent.reversed : d10.reversed, u2 = d10.staggerLines, g2 = d10.tickRotCorr || {
            x: 0,
            y: 0
          }, m2 = s10 || d10.reserveSpaceDefault ? 0 : -d10.labelOffset * ("center" === d10.labelAlign ? 0.5 : 1), f2 = o10.distance, x2 = {};
          return l10 = 0 === d10.side ? i10.rotation ? -f2 : -i10.getBBox().height : 2 === d10.side ? g2.y + f2 : Math.cos(i10.rotation * st) * (g2.y - i10.getBBox(false, 0).height / 2), ss(o10.y) && (l10 = 0 === d10.side && d10.horiz ? o10.y + l10 : o10.y), t10 = t10 + sc(o10.x, [0, 1, 0, -1][d10.side] * f2) + m2 + g2.x - (r10 && s10 ? r10 * c10 * (p4 ? -1 : 1) : 0), e10 = e10 + l10 - (r10 && !s10 ? r10 * c10 * (p4 ? 1 : -1) : 0), u2 && (h10 = a10 / (n10 || 1) % u2, d10.opposite && (h10 = u2 - h10 - 1), e10 += h10 * (d10.labelOffset / u2)), x2.x = t10, x2.y = Math.round(e10), sa(this, "afterGetLabelPosition", {
            pos: x2,
            tickmarkOffset: r10,
            index: a10
          }), x2;
        }
        getLabelSize() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        }
        getMarkPath(t10, e10, i10, s10, o10 = false, r10) {
          return r10.crispLine([["M", t10, e10], ["L", t10 + (o10 ? 0 : -i10), e10 + (o10 ? i10 : 0)]], s10);
        }
        handleOverflow(t10) {
          let e10 = this.axis, i10 = e10.options.labels, s10 = t10.x, o10 = e10.chart.chartWidth, r10 = e10.chart.spacing, a10 = sc(e10.labelLeft, Math.min(e10.pos, r10[3])), n10 = sc(e10.labelRight, Math.max(e10.isRadial ? 0 : e10.pos + e10.len, o10 - r10[1])), l10 = this.label, h10 = this.rotation, d10 = sn(e10.labelAlign || l10.attr("align")), c10 = l10.getBBox().width, p4 = e10.getSlotWidth(this), u2 = p4, g2 = 1, m2, f2, x2;
          h10 || "justify" !== i10.overflow ? h10 < 0 && s10 - d10 * c10 < a10 ? x2 = Math.round(s10 / Math.cos(h10 * st) - a10) : h10 > 0 && s10 + d10 * c10 > n10 && (x2 = Math.round((o10 - s10) / Math.cos(h10 * st))) : (m2 = s10 - d10 * c10, f2 = s10 + (1 - d10) * c10, m2 < a10 ? u2 = t10.x + u2 * (1 - d10) - a10 : f2 > n10 && (u2 = n10 - t10.x + u2 * d10, g2 = -1), (u2 = Math.min(p4, u2)) < p4 && "center" === e10.labelAlign && (t10.x += g2 * (p4 - u2 - d10 * (p4 - Math.min(c10, u2)))), (c10 > u2 || e10.autoRotation && (l10.styles || {}).width) && (x2 = u2)), x2 && l10 && (this.shortenLabel ? this.shortenLabel() : l10.css(sr({}, {
            width: Math.floor(x2) + "px",
            lineClamp: e10.isRadial ? 0 : 1
          })));
        }
        moveLabel(t10, e10) {
          let i10 = this, s10 = i10.label, o10 = i10.axis, r10 = false, a10;
          s10 && s10.textStr === t10 ? (i10.movedLabel = s10, r10 = true, delete i10.label) : sd(o10.ticks, function(e11) {
            r10 || e11.isNew || e11 === i10 || !e11.label || e11.label.textStr !== t10 || (i10.movedLabel = e11.label, r10 = true, e11.labelPos = i10.movedLabel.xy, delete e11.label);
          }), !r10 && (i10.labelPos || s10) && (a10 = i10.labelPos || s10.xy, i10.movedLabel = i10.createLabel(t10, e10, a10), i10.movedLabel && i10.movedLabel.attr({
            opacity: 0
          }));
        }
        render(t10, e10, i10) {
          let s10 = this.axis, o10 = s10.horiz, r10 = this.pos, a10 = sc(this.tickmarkOffset, s10.tickmarkOffset), n10 = this.getPosition(o10, r10, a10, e10), l10 = n10.x, h10 = n10.y, d10 = s10.pos, c10 = d10 + s10.len, p4 = o10 ? l10 : h10;
          !s10.chart.polar && this.isNew && (si(p4) < d10 || p4 > c10) && (i10 = 0);
          let u2 = sc(i10, this.label && this.label.newOpacity, 1);
          i10 = sc(i10, 1), this.isActive = true, this.renderGridLine(e10, i10), this.renderMark(n10, i10), this.renderLabel(n10, e10, u2, t10), this.isNew = false, sa(this, "afterRender");
        }
        renderGridLine(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = {}, r10 = this.pos, a10 = this.type, n10 = sc(this.tickmarkOffset, i10.tickmarkOffset), l10 = i10.chart.renderer, h10 = this.gridLine, d10, c10 = s10.gridLineWidth, p4 = s10.gridLineColor, u2 = s10.gridLineDashStyle;
          "minor" === this.type && (c10 = s10.minorGridLineWidth, p4 = s10.minorGridLineColor, u2 = s10.minorGridLineDashStyle), h10 || (i10.chart.styledMode || (o10.stroke = p4, o10["stroke-width"] = c10 || 0, o10.dashstyle = u2), a10 || (o10.zIndex = 1), t10 && (e10 = 0), this.gridLine = h10 = l10.path().attr(o10).addClass("highcharts-" + (a10 ? a10 + "-" : "") + "grid-line").add(i10.gridGroup)), h10 && (d10 = i10.getPlotLinePath({
            value: r10 + n10,
            lineWidth: h10.strokeWidth(),
            force: "pass",
            old: t10,
            acrossPanes: false
          })) && h10[t10 || this.isNew ? "attr" : "animate"]({
            d: d10,
            opacity: e10
          });
        }
        renderMark(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = i10.chart.renderer, r10 = this.type, a10 = i10.tickSize(r10 ? r10 + "Tick" : "tick"), n10 = t10.x, l10 = t10.y, h10 = sc(s10["minor" !== r10 ? "tickWidth" : "minorTickWidth"], !r10 && i10.isXAxis ? 1 : 0), d10 = s10["minor" !== r10 ? "tickColor" : "minorTickColor"], c10 = this.mark, p4 = !c10;
          a10 && (i10.opposite && (a10[0] = -a10[0]), c10 || (this.mark = c10 = o10.path().addClass("highcharts-" + (r10 ? r10 + "-" : "") + "tick").add(i10.axisGroup), i10.chart.styledMode || c10.attr({
            stroke: d10,
            "stroke-width": h10
          })), c10[p4 ? "attr" : "animate"]({
            d: this.getMarkPath(n10, l10, a10[0], c10.strokeWidth(), i10.horiz, o10),
            opacity: e10
          }));
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.horiz, a10 = o10.options, n10 = this.label, l10 = a10.labels, h10 = l10.step, d10 = sc(this.tickmarkOffset, o10.tickmarkOffset), c10 = t10.x, p4 = t10.y, u2 = true;
          n10 && sl(c10) && (n10.xy = t10 = this.getLabelPosition(c10, p4, n10, r10, l10, d10, s10, h10), (!this.isFirst || this.isLast || a10.showFirstLabel) && (!this.isLast || this.isFirst || a10.showLastLabel) ? !r10 || l10.step || l10.rotation || e10 || 0 === i10 || this.handleOverflow(t10) : u2 = false, h10 && s10 % h10 && (u2 = false), u2 && sl(t10.y) ? (t10.opacity = i10, n10[this.isNewLabel ? "attr" : "animate"](t10).show(true), this.isNewLabel = false) : (n10.hide(), this.isNewLabel = true));
        }
        replaceMovedLabel() {
          let t10 = this.label, e10 = this.axis;
          t10 && !this.isNew && (t10.animate({
            opacity: 0
          }, void 0, t10.destroy), delete this.label), e10.isDirty = true, this.label = this.movedLabel, delete this.movedLabel;
        }
      }, {
        animObject: su
      } = tH, {
        xAxis: sg,
        yAxis: sm
      } = i6, {
        defaultOptions: sf
      } = tw, {
        registerEventOptions: sx
      } = i7, {
        deg2rad: sy
      } = A, {
        arrayMax: sb,
        arrayMin: sv,
        clamp: sM,
        correctFloat: sw,
        defined: sk,
        destroyObjectProperties: sS,
        erase: sT,
        error: sC,
        extend: sA,
        fireEvent: sP,
        getClosestDistance: sL,
        insertItem: sO,
        isArray: sE,
        isNumber: sI,
        isString: sD,
        merge: sB,
        normalizeTickInterval: sz,
        objectEach: sN,
        pick: sR,
        relativeLength: sW,
        removeEvent: sj,
        splat: sX,
        syncTimeout: sG
      } = J, sF = (t10, e10) => sz(e10, void 0, void 0, sR(t10.options.allowDecimals, e10 < 0.5 || void 0 !== t10.tickAmount), !!t10.tickAmount);
      sA(sf, {
        xAxis: sg,
        yAxis: sB(sg, sm)
      });
      class sH {
        constructor(t10, e10, i10) {
          this.init(t10, e10, i10);
        }
        init(t10, e10, i10 = this.coll) {
          let s10 = "xAxis" === i10, o10 = this.isZAxis || (t10.inverted ? !s10 : s10);
          this.chart = t10, this.horiz = o10, this.isXAxis = s10, this.coll = i10, sP(this, "init", {
            userOptions: e10
          }), this.opposite = sR(e10.opposite, this.opposite), this.side = sR(e10.side, this.side, o10 ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e10);
          let r10 = this.options, a10 = r10.labels;
          this.type ?? (this.type = r10.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r10.uniqueNames ?? true), sP(this, "afterSetType"), this.userOptions = e10, this.minPixelPadding = 0, this.reversed = sR(r10.reversed, this.reversed), this.visible = r10.visible, this.zoomEnabled = r10.zoomEnabled, this.hasNames = "category" === this.type || true === r10.categories, this.categories = sE(r10.categories) && r10.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = sk(r10.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r10.minRange || r10.maxZoom, this.range = r10.range, this.offset = r10.offset || 0, this.max = void 0, this.min = void 0;
          let n10 = sR(r10.crosshair, sX(t10.options.tooltip.crosshairs)[s10 ? 0 : 1]);
          this.crosshair = true === n10 ? {} : n10, -1 === t10.axes.indexOf(this) && (s10 ? t10.axes.splice(t10.xAxis.length, 0, this) : t10.axes.push(this), sO(this, t10[this.coll])), t10.orderItems(this.coll), this.series = this.series || [], t10.inverted && !this.isZAxis && s10 && !sk(this.reversed) && (this.reversed = true), this.labelRotation = sI(a10.rotation) ? a10.rotation : void 0, sx(this, r10), sP(this, "afterInit");
        }
        setOptions(t10) {
          let e10 = this.horiz ? {
            labels: {
              autoRotation: [-45],
              padding: 3
            },
            margin: 15
          } : {
            labels: {
              padding: 1
            },
            title: {
              rotation: 90 * this.side
            }
          };
          this.options = sB(e10, sf[this.coll], t10), sP(this, "afterSetOptions", {
            userOptions: t10
          });
        }
        defaultLabelFormatter() {
          let t10 = this.axis, {
            numberFormatter: e10
          } = this.chart, i10 = sI(this.value) ? this.value : NaN, s10 = t10.chart.time, o10 = t10.categories, r10 = this.dateTimeLabelFormat, a10 = sf.lang, n10 = a10.numericSymbols, l10 = a10.numericSymbolMagnitude || 1e3, h10 = t10.logarithmic ? Math.abs(i10) : t10.tickInterval, d10 = n10 && n10.length, c10, p4;
          if (o10) p4 = `${this.value}`;
          else if (r10) p4 = s10.dateFormat(r10, i10, true);
          else if (d10 && n10 && h10 >= 1e3) for (; d10-- && void 0 === p4; ) h10 >= (c10 = Math.pow(l10, d10 + 1)) && 10 * i10 % c10 == 0 && null !== n10[d10] && 0 !== i10 && (p4 = e10(i10 / c10, -1) + n10[d10]);
          return void 0 === p4 && (p4 = Math.abs(i10) >= 1e4 ? e10(i10, -1) : e10(i10, -1, void 0, "")), p4;
        }
        getSeriesExtremes() {
          let t10;
          let e10 = this;
          sP(this, "getSeriesExtremes", null, function() {
            e10.hasVisibleSeries = false, e10.dataMin = e10.dataMax = e10.threshold = void 0, e10.softThreshold = !e10.isXAxis, e10.series.forEach((i10) => {
              if (i10.reserveSpace()) {
                let s10 = i10.options, o10, r10 = s10.threshold, a10, n10;
                if (e10.hasVisibleSeries = true, e10.positiveValuesOnly && 0 >= (r10 || 0) && (r10 = void 0), e10.isXAxis) (o10 = i10.getColumn("x")).length && (o10 = e10.logarithmic ? o10.filter((t11) => t11 > 0) : o10, a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max, sI(a10) || a10 instanceof Date || (o10 = o10.filter(sI), a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max), o10.length && (e10.dataMin = Math.min(sR(e10.dataMin, a10), a10), e10.dataMax = Math.max(sR(e10.dataMax, n10), n10)));
                else {
                  let t11 = i10.applyExtremes();
                  sI(t11.dataMin) && (a10 = t11.dataMin, e10.dataMin = Math.min(sR(e10.dataMin, a10), a10)), sI(t11.dataMax) && (n10 = t11.dataMax, e10.dataMax = Math.max(sR(e10.dataMax, n10), n10)), sk(r10) && (e10.threshold = r10), (!s10.softThreshold || e10.positiveValuesOnly) && (e10.softThreshold = false);
                }
              }
            });
          }), sP(this, "afterGetSeriesExtremes");
        }
        translate(t10, e10, i10, s10, o10, r10) {
          let a10 = this.linkedParent || this, n10 = s10 && a10.old ? a10.old.min : a10.min;
          if (!sI(n10)) return NaN;
          let l10 = a10.minPixelPadding, h10 = (a10.isOrdinal || a10.brokenAxis?.hasBreaks || a10.logarithmic && o10) && a10.lin2val, d10 = 1, c10 = 0, p4 = s10 && a10.old ? a10.old.transA : a10.transA, u2 = 0;
          return p4 || (p4 = a10.transA), i10 && (d10 *= -1, c10 = a10.len), a10.reversed && (d10 *= -1, c10 -= d10 * (a10.sector || a10.len)), e10 ? (u2 = (t10 = t10 * d10 + c10 - l10) / p4 + n10, h10 && (u2 = a10.lin2val(u2))) : (h10 && (t10 = a10.val2lin(t10)), u2 = d10 * (t10 - n10) * p4 + c10 + d10 * l10 + (sI(r10) ? p4 * r10 : 0), a10.isRadial || (u2 = sw(u2))), u2;
        }
        toPixels(t10, e10) {
          return this.translate(this.chart?.time.parse(t10) ?? NaN, false, !this.horiz, void 0, true) + (e10 ? 0 : this.pos);
        }
        toValue(t10, e10) {
          return this.translate(t10 - (e10 ? 0 : this.pos), true, !this.horiz, void 0, true);
        }
        getPlotLinePath(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.left, o10 = e10.top, r10 = t10.old, a10 = t10.value, n10 = t10.lineWidth, l10 = r10 && i10.oldChartHeight || i10.chartHeight, h10 = r10 && i10.oldChartWidth || i10.chartWidth, d10 = e10.transB, c10 = t10.translatedValue, p4 = t10.force, u2, g2, m2, f2, x2;
          function y2(t11, e11, i11) {
            return "pass" !== p4 && (t11 < e11 || t11 > i11) && (p4 ? t11 = sM(t11, e11, i11) : x2 = true), t11;
          }
          let b2 = {
            value: a10,
            lineWidth: n10,
            old: r10,
            force: p4,
            acrossPanes: t10.acrossPanes,
            translatedValue: c10
          };
          return sP(this, "getPlotLinePath", b2, function(t11) {
            u2 = m2 = (c10 = sM(c10 = sR(c10, e10.translate(a10, void 0, void 0, r10)), -1e9, 1e9)) + d10, g2 = f2 = l10 - c10 - d10, sI(c10) ? e10.horiz ? (g2 = o10, f2 = l10 - e10.bottom + (e10.options.isInternal ? 0 : i10.scrollablePixelsY || 0), u2 = m2 = y2(u2, s10, s10 + e10.width)) : (u2 = s10, m2 = h10 - e10.right + (i10.scrollablePixelsX || 0), g2 = f2 = y2(g2, o10, o10 + e10.height)) : (x2 = true, p4 = false), t11.path = x2 && !p4 ? void 0 : i10.renderer.crispLine([["M", u2, g2], ["L", m2, f2]], n10 || 1);
          }), b2.path;
        }
        getLinearTickPositions(t10, e10, i10) {
          let s10, o10, r10;
          let a10 = sw(Math.floor(e10 / t10) * t10), n10 = sw(Math.ceil(i10 / t10) * t10), l10 = [];
          if (sw(a10 + t10) === a10 && (r10 = 20), this.single) return [e10];
          for (s10 = a10; s10 <= n10 && (l10.push(s10), (s10 = sw(s10 + t10, r10)) !== o10); ) o10 = s10;
          return l10;
        }
        getMinorTickInterval() {
          let {
            minorTicks: t10,
            minorTickInterval: e10
          } = this.options;
          return true === t10 ? sR(e10, "auto") : false !== t10 ? e10 : void 0;
        }
        getMinorTickPositions() {
          let t10 = this.options, e10 = this.tickPositions, i10 = this.minorTickInterval, s10 = this.pointRangePadding || 0, o10 = (this.min || 0) - s10, r10 = (this.max || 0) + s10, a10 = this.brokenAxis?.hasBreaks ? this.brokenAxis.unitLength : r10 - o10, n10 = [], l10;
          if (a10 && a10 / i10 < this.len / 3) {
            let s11 = this.logarithmic;
            if (s11) this.paddedTicks.forEach(function(t11, e11, o11) {
              e11 && n10.push.apply(n10, s11.getLogTickPositions(i10, o11[e11 - 1], o11[e11], true));
            });
            else if (this.dateTime && "auto" === this.getMinorTickInterval()) n10 = n10.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i10), o10, r10, t10.startOfWeek));
            else for (l10 = o10 + (e10[0] - o10) % i10; l10 <= r10 && l10 !== n10[0]; l10 += i10) n10.push(l10);
          }
          return 0 !== n10.length && this.trimTicks(n10), n10;
        }
        adjustForMinRange() {
          let t10 = this.options, e10 = this.logarithmic, i10 = this.chart.time, {
            max: s10,
            min: o10,
            minRange: r10
          } = this, a10, n10, l10, h10;
          this.isXAxis && void 0 === r10 && !e10 && (r10 = sk(t10.min) || sk(t10.max) || sk(t10.floor) || sk(t10.ceiling) ? null : Math.min(5 * (sL(this.series.map((t11) => {
            let e11 = t11.getColumn("x");
            return t11.xIncrement ? e11.slice(0, 2) : e11;
          })) || 0), this.dataMax - this.dataMin)), sI(s10) && sI(o10) && sI(r10) && s10 - o10 < r10 && (n10 = this.dataMax - this.dataMin >= r10, a10 = (r10 - s10 + o10) / 2, l10 = [o10 - a10, i10.parse(t10.min) ?? o10 - a10], n10 && (l10[2] = e10 ? e10.log2lin(this.dataMin) : this.dataMin), h10 = [(o10 = sb(l10)) + r10, i10.parse(t10.max) ?? o10 + r10], n10 && (h10[2] = e10 ? e10.log2lin(this.dataMax) : this.dataMax), (s10 = sv(h10)) - o10 < r10 && (l10[0] = s10 - r10, l10[1] = i10.parse(t10.min) ?? s10 - r10, o10 = sb(l10))), this.minRange = r10, this.min = o10, this.max = s10;
        }
        getClosest() {
          let t10, e10;
          if (this.categories) e10 = 1;
          else {
            let i10 = [];
            this.series.forEach(function(t11) {
              let s10 = t11.closestPointRange, o10 = t11.getColumn("x");
              1 === o10.length ? i10.push(o10[0]) : t11.sorted && sk(s10) && t11.reserveSpace() && (e10 = sk(e10) ? Math.min(e10, s10) : s10);
            }), i10.length && (i10.sort((t11, e11) => t11 - e11), t10 = sL([i10]));
          }
          return t10 && e10 ? Math.min(t10, e10) : t10 || e10;
        }
        nameToX(t10) {
          let e10 = sE(this.options.categories), i10 = e10 ? this.categories : this.names, s10 = t10.options.x, o10;
          return t10.series.requireSorting = false, sk(s10) || (s10 = this.uniqueNames && i10 ? e10 ? i10.indexOf(t10.name) : sR(i10.keys[t10.name], -1) : t10.series.autoIncrement()), -1 === s10 ? !e10 && i10 && (o10 = i10.length) : sI(s10) && (o10 = s10), void 0 !== o10 ? (this.names[o10] = t10.name, this.names.keys[t10.name] = o10) : t10.x && (o10 = t10.x), o10;
        }
        updateNames() {
          let t10 = this, e10 = this.names;
          e10.length > 0 && (Object.keys(e10.keys).forEach(function(t11) {
            delete e10.keys[t11];
          }), e10.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e11) => {
            e11.xIncrement = null, (!e11.points || e11.isDirtyData) && (t10.max = Math.max(t10.max || 0, e11.dataTable.rowCount - 1), e11.processData(), e11.generatePoints());
            let i10 = e11.getColumn("x").slice();
            e11.data.forEach((e12, s10) => {
              let o10 = i10[s10];
              e12?.options && void 0 !== e12.name && void 0 !== (o10 = t10.nameToX(e12)) && o10 !== e12.x && (i10[s10] = e12.x = o10);
            }), e11.dataTable.setColumn("x", i10);
          }));
        }
        setAxisTranslation() {
          let t10 = this, e10 = t10.max - t10.min, i10 = t10.linkedParent, s10 = !!t10.categories, o10 = t10.isXAxis, r10 = t10.axisPointRange || 0, a10, n10 = 0, l10 = 0, h10, d10 = t10.transA;
          (o10 || s10 || r10) && (a10 = t10.getClosest(), i10 ? (n10 = i10.minPointOffset, l10 = i10.pointRangePadding) : t10.series.forEach(function(e11) {
            let i11 = s10 ? 1 : o10 ? sR(e11.options.pointRange, a10, 0) : t10.axisPointRange || 0, h11 = e11.options.pointPlacement;
            if (r10 = Math.max(r10, i11), !t10.single || s10) {
              let t11 = e11.is("xrange") ? !o10 : o10;
              n10 = Math.max(n10, t11 && sD(h11) ? 0 : i11 / 2), l10 = Math.max(l10, t11 && "on" === h11 ? 0 : i11);
            }
          }), h10 = t10.ordinal && t10.ordinal.slope && a10 ? t10.ordinal.slope / a10 : 1, t10.minPointOffset = n10 *= h10, t10.pointRangePadding = l10 *= h10, t10.pointRange = Math.min(r10, t10.single && s10 ? 1 : e10), o10 && a10 && (t10.closestPointRange = a10)), t10.translationSlope = t10.transA = d10 = t10.staticScale || t10.len / (e10 + l10 || 1), t10.transB = t10.horiz ? t10.left : t10.bottom, t10.minPixelPadding = d10 * n10, sP(this, "afterSetAxisTranslation");
        }
        minFromRange() {
          let {
            max: t10,
            min: e10
          } = this;
          return sI(t10) && sI(e10) && t10 - e10 || void 0;
        }
        setTickInterval(t10) {
          let {
            categories: e10,
            chart: i10,
            dataMax: s10,
            dataMin: o10,
            dateTime: r10,
            isXAxis: a10,
            logarithmic: n10,
            options: l10,
            softThreshold: h10
          } = this, d10 = i10.time, c10 = sI(this.threshold) ? this.threshold : void 0, p4 = this.minRange || 0, {
            ceiling: u2,
            floor: g2,
            linkedTo: m2,
            softMax: f2,
            softMin: x2
          } = l10, y2 = sI(m2) && i10[this.coll]?.[m2], b2 = l10.tickPixelInterval, v2 = l10.maxPadding, M2 = l10.minPadding, w2 = 0, k2, S2 = sI(l10.tickInterval) && l10.tickInterval >= 0 ? l10.tickInterval : void 0, T2, C2, A2, P2;
          if (r10 || e10 || y2 || this.getTickAmount(), A2 = sR(this.userMin, d10.parse(l10.min)), P2 = sR(this.userMax, d10.parse(l10.max)), y2 ? (this.linkedParent = y2, k2 = y2.getExtremes(), this.min = sR(k2.min, k2.dataMin), this.max = sR(k2.max, k2.dataMax), this.type !== y2.type && sC(11, true, i10)) : (h10 && sk(c10) && sI(s10) && sI(o10) && (o10 >= c10 ? (T2 = c10, M2 = 0) : s10 <= c10 && (C2 = c10, v2 = 0)), this.min = sR(A2, T2, o10), this.max = sR(P2, C2, s10)), sI(this.max) && sI(this.min) && (n10 && (this.positiveValuesOnly && !t10 && 0 >= Math.min(this.min, sR(o10, this.min)) && sC(10, true, i10), this.min = sw(n10.log2lin(this.min), 16), this.max = sw(n10.log2lin(this.max), 16)), this.range && sI(o10) && (this.userMin = this.min = A2 = Math.max(o10, this.minFromRange() || 0), this.userMax = P2 = this.max, this.range = void 0)), sP(this, "foundExtremes"), this.adjustForMinRange(), sI(this.min) && sI(this.max)) {
            if (!sI(this.userMin) && sI(x2) && x2 < this.min && (this.min = A2 = x2), !sI(this.userMax) && sI(f2) && f2 > this.max && (this.max = P2 = f2), e10 || this.axisPointRange || this.stacking?.usePercentage || y2 || !(w2 = this.max - this.min) || (!sk(A2) && M2 && (this.min -= w2 * M2), sk(P2) || !v2 || (this.max += w2 * v2)), !sI(this.userMin) && sI(g2) && (this.min = Math.max(this.min, g2)), !sI(this.userMax) && sI(u2) && (this.max = Math.min(this.max, u2)), h10 && sI(o10) && sI(s10)) {
              let t11 = c10 || 0;
              !sk(A2) && this.min < t11 && o10 >= t11 ? this.min = l10.minRange ? Math.min(t11, this.max - p4) : t11 : !sk(P2) && this.max > t11 && s10 <= t11 && (this.max = l10.minRange ? Math.max(t11, this.min + p4) : t11);
            }
            !i10.polar && this.min > this.max && (sk(l10.min) ? this.max = this.min : sk(l10.max) && (this.min = this.max)), w2 = this.max - this.min;
          }
          if (this.min !== this.max && sI(this.min) && sI(this.max) ? y2 && !S2 && b2 === y2.options.tickPixelInterval ? this.tickInterval = S2 = y2.tickInterval : this.tickInterval = sR(S2, this.tickAmount ? w2 / Math.max(this.tickAmount - 1, 1) : void 0, e10 ? 1 : w2 * b2 / Math.max(this.len, b2)) : this.tickInterval = 1, a10 && !t10) {
            let t11 = this.min !== this.old?.min || this.max !== this.old?.max;
            this.series.forEach(function(e11) {
              e11.forceCrop = e11.forceCropping?.(), e11.processData(t11);
            }), sP(this, "postProcessData", {
              hasExtremesChanged: t11
            });
          }
          this.setAxisTranslation(), sP(this, "initialAxisTranslation"), this.pointRange && !S2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
          let L2 = sR(l10.minTickInterval, r10 && !this.series.some((t11) => !t11.sorted) ? this.closestPointRange : 0);
          !S2 && this.tickInterval < L2 && (this.tickInterval = L2), r10 || n10 || S2 || (this.tickInterval = sF(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
        }
        setTickPositions() {
          let t10 = this.options, e10 = t10.tickPositions, i10 = t10.tickPositioner, s10 = this.getMinorTickInterval(), o10 = !this.isPanning, r10 = o10 && t10.startOnTick, a10 = o10 && t10.endOnTick, n10 = [], l10;
          if (this.tickmarkOffset = this.categories && "between" === t10.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0, this.single = this.min === this.max && sk(this.min) && !this.tickAmount && (this.min % 1 == 0 || false !== t10.allowDecimals), e10) n10 = e10.slice();
          else if (sI(this.min) && sI(this.max)) {
            if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) n10 = [this.min, this.max], sC(19, false, this.chart);
            else if (this.dateTime) n10 = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t10.units), this.min, this.max, t10.startOfWeek, this.ordinal?.positions, this.closestPointRange, true);
            else if (this.logarithmic) n10 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
            else {
              let t11 = this.tickInterval, e11 = t11;
              for (; e11 <= 2 * t11; ) if (n10 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && n10.length > this.tickAmount) this.tickInterval = sF(this, e11 *= 1.1);
              else break;
            }
            n10.length > this.len && (n10 = [n10[0], n10[n10.length - 1]])[0] === n10[1] && (n10.length = 1), i10 && (this.tickPositions = n10, (l10 = i10.apply(this, [this.min, this.max])) && (n10 = l10));
          }
          this.tickPositions = n10, this.minorTickInterval = "auto" === s10 && this.tickInterval ? this.tickInterval / t10.minorTicksPerMajor : s10, this.paddedTicks = n10.slice(0), this.trimTicks(n10, r10, a10), !this.isLinked && sI(this.min) && sI(this.max) && (this.single && n10.length < 2 && !this.categories && !this.series.some((t11) => t11.is("heatmap") && "between" === t11.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), e10 || l10 || this.adjustTickAmount()), sP(this, "afterSetTickPositions");
        }
        trimTicks(t10, e10, i10) {
          let s10 = t10[0], o10 = t10[t10.length - 1], r10 = !this.isOrdinal && this.minPointOffset || 0;
          if (sP(this, "trimTicks"), !this.isLinked) {
            if (e10 && s10 !== -1 / 0) this.min = s10;
            else for (; this.min - r10 > t10[0]; ) t10.shift();
            if (i10) this.max = o10;
            else for (; this.max + r10 < t10[t10.length - 1]; ) t10.pop();
            0 === t10.length && sk(s10) && !this.options.tickPositions && t10.push((o10 + s10) / 2);
          }
        }
        alignToOthers() {
          let t10;
          let e10 = this, i10 = e10.chart, s10 = [this], o10 = e10.options, r10 = i10.options.chart, a10 = "yAxis" === this.coll && r10.alignThresholds, n10 = [];
          if (e10.thresholdAlignment = void 0, (false !== r10.alignTicks && o10.alignTicks || a10) && false !== o10.startOnTick && false !== o10.endOnTick && !e10.logarithmic) {
            let o11 = (t11) => {
              let {
                horiz: e11,
                options: i11
              } = t11;
              return [e11 ? i11.left : i11.top, i11.width, i11.height, i11.pane].join(",");
            }, r11 = o11(this);
            i10[this.coll].forEach(function(i11) {
              let {
                series: a11
              } = i11;
              a11.length && a11.some((t11) => t11.visible) && i11 !== e10 && o11(i11) === r11 && (t10 = true, s10.push(i11));
            });
          }
          if (t10 && a10) {
            s10.forEach((t12) => {
              let i11 = t12.getThresholdAlignment(e10);
              sI(i11) && n10.push(i11);
            });
            let t11 = n10.length > 1 ? n10.reduce((t12, e11) => t12 += e11, 0) / n10.length : void 0;
            s10.forEach((e11) => {
              e11.thresholdAlignment = t11;
            });
          }
          return t10;
        }
        getThresholdAlignment(t10) {
          if ((!sI(this.dataMin) || this !== t10 && this.series.some((t11) => t11.isDirty || t11.isDirtyData)) && this.getSeriesExtremes(), sI(this.threshold)) {
            let t11 = sM((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
            return this.options.reversed && (t11 = 1 - t11), t11;
          }
        }
        getTickAmount() {
          let t10 = this.options, e10 = t10.tickPixelInterval, i10 = t10.tickAmount;
          sk(t10.tickInterval) || i10 || !(this.len < e10) || this.isRadial || this.logarithmic || !t10.startOnTick || !t10.endOnTick || (i10 = 2), !i10 && this.alignToOthers() && (i10 = Math.ceil(this.len / e10) + 1), i10 < 4 && (this.finalTickAmt = i10, i10 = 5), this.tickAmount = i10;
        }
        adjustTickAmount() {
          let t10 = this, {
            finalTickAmt: e10,
            max: i10,
            min: s10,
            options: o10,
            tickPositions: r10,
            tickAmount: a10,
            thresholdAlignment: n10
          } = t10, l10 = r10?.length, h10 = sR(t10.threshold, t10.softThreshold ? 0 : null), d10, c10, p4 = t10.tickInterval, u2, g2 = () => r10.push(sw(r10[r10.length - 1] + p4)), m2 = () => r10.unshift(sw(r10[0] - p4));
          if (sI(n10) && (u2 = n10 < 0.5 ? Math.ceil(n10 * (a10 - 1)) : Math.floor(n10 * (a10 - 1)), o10.reversed && (u2 = a10 - 1 - u2)), t10.hasData() && sI(s10) && sI(i10)) {
            let n11 = () => {
              t10.transA *= (l10 - 1) / (a10 - 1), t10.min = o10.startOnTick ? r10[0] : Math.min(s10, r10[0]), t10.max = o10.endOnTick ? r10[r10.length - 1] : Math.max(i10, r10[r10.length - 1]);
            };
            if (sI(u2) && sI(t10.threshold)) {
              for (; r10[u2] !== h10 || r10.length !== a10 || r10[0] > s10 || r10[r10.length - 1] < i10; ) {
                for (r10.length = 0, r10.push(t10.threshold); r10.length < a10; ) void 0 === r10[u2] || r10[u2] > t10.threshold ? m2() : g2();
                if (p4 > 8 * t10.tickInterval) break;
                p4 *= 2;
              }
              n11();
            } else if (l10 < a10) {
              for (; r10.length < a10; ) r10.length % 2 || s10 === h10 ? g2() : m2();
              n11();
            }
            if (sk(e10)) {
              for (c10 = d10 = r10.length; c10--; ) (3 === e10 && c10 % 2 == 1 || e10 <= 2 && c10 > 0 && c10 < d10 - 1) && r10.splice(c10, 1);
              t10.finalTickAmt = void 0;
            }
          }
        }
        setScale() {
          let {
            coll: t10,
            stacking: e10
          } = this, i10 = false, s10 = false;
          this.series.forEach((t11) => {
            i10 = i10 || t11.isDirtyData || t11.isDirty, s10 = s10 || t11.xAxis && t11.xAxis.isDirty || false;
          }), this.setAxisSize();
          let o10 = this.len !== (this.old && this.old.len);
          o10 || i10 || s10 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e10 && "yAxis" === t10 && e10.buildStacks(), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e10 && "xAxis" === t10 && e10.buildStacks(), this.isDirty || (this.isDirty = o10 || this.min !== this.old?.min || this.max !== this.old?.max)) : e10 && e10.cleanStacks(), i10 && delete this.allExtremes, sP(this, "afterSetScale");
        }
        setExtremes(t10, e10, i10 = true, s10, o10) {
          let r10 = this.chart;
          this.series.forEach((t11) => {
            delete t11.kdTree;
          }), t10 = r10.time.parse(t10), e10 = r10.time.parse(e10), sP(this, "setExtremes", o10 = sA(o10, {
            min: t10,
            max: e10
          }), (t11) => {
            this.userMin = t11.min, this.userMax = t11.max, this.eventArgs = t11, i10 && r10.redraw(s10);
          });
        }
        setAxisSize() {
          let t10 = this.chart, e10 = this.options, i10 = e10.offsets || [0, 0, 0, 0], s10 = this.horiz, o10 = this.width = Math.round(sW(sR(e10.width, t10.plotWidth - i10[3] + i10[1]), t10.plotWidth)), r10 = this.height = Math.round(sW(sR(e10.height, t10.plotHeight - i10[0] + i10[2]), t10.plotHeight)), a10 = this.top = Math.round(sW(sR(e10.top, t10.plotTop + i10[0]), t10.plotHeight, t10.plotTop)), n10 = this.left = Math.round(sW(sR(e10.left, t10.plotLeft + i10[3]), t10.plotWidth, t10.plotLeft));
          this.bottom = t10.chartHeight - r10 - a10, this.right = t10.chartWidth - o10 - n10, this.len = Math.max(s10 ? o10 : r10, 0), this.pos = s10 ? n10 : a10;
        }
        getExtremes() {
          let t10 = this.logarithmic;
          return {
            min: t10 ? sw(t10.lin2log(this.min)) : this.min,
            max: t10 ? sw(t10.lin2log(this.max)) : this.max,
            dataMin: this.dataMin,
            dataMax: this.dataMax,
            userMin: this.userMin,
            userMax: this.userMax
          };
        }
        getThreshold(t10) {
          let e10 = this.logarithmic, i10 = e10 ? e10.lin2log(this.min) : this.min, s10 = e10 ? e10.lin2log(this.max) : this.max;
          return null === t10 || t10 === -1 / 0 ? t10 = i10 : t10 === 1 / 0 ? t10 = s10 : i10 > t10 ? t10 = i10 : s10 < t10 && (t10 = s10), this.translate(t10, 0, 1, 0, 1);
        }
        autoLabelAlign(t10) {
          let e10 = (sR(t10, 0) - 90 * this.side + 720) % 360, i10 = {
            align: "center"
          };
          return sP(this, "autoLabelAlign", i10, function(t11) {
            e10 > 15 && e10 < 165 ? t11.align = "right" : e10 > 195 && e10 < 345 && (t11.align = "left");
          }), i10.align;
        }
        tickSize(t10) {
          let e10 = this.options, i10 = sR(e10["tick" === t10 ? "tickWidth" : "minorTickWidth"], "tick" === t10 && this.isXAxis && !this.categories ? 1 : 0), s10 = e10["tick" === t10 ? "tickLength" : "minorTickLength"], o10;
          i10 && s10 && ("inside" === e10[t10 + "Position"] && (s10 = -s10), o10 = [s10, i10]);
          let r10 = {
            tickSize: o10
          };
          return sP(this, "afterTickSize", r10), r10.tickSize;
        }
        labelMetrics() {
          let t10 = this.chart.renderer, e10 = this.ticks, i10 = e10[Object.keys(e10)[0]] || {};
          return this.chart.renderer.fontMetrics(i10.label || i10.movedLabel || t10.box);
        }
        unsquish() {
          let t10 = this.options.labels, e10 = t10.padding || 0, i10 = this.horiz, s10 = this.tickInterval, o10 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s10), r10 = t10.rotation, a10 = sw(0.8 * this.labelMetrics().h), n10 = Math.max(this.max - this.min, 0), l10 = function(t11) {
            let i11 = (t11 + 2 * e10) / (o10 || 1);
            return (i11 = i11 > 1 ? Math.ceil(i11) : 1) * s10 > n10 && t11 !== 1 / 0 && o10 !== 1 / 0 && n10 && (i11 = Math.ceil(n10 / s10)), sw(i11 * s10);
          }, h10 = s10, d10, c10 = Number.MAX_VALUE, p4;
          if (i10) {
            if (!t10.staggerLines && (sI(r10) ? p4 = [r10] : o10 < t10.autoRotationLimit && (p4 = t10.autoRotation)), p4) {
              let t11, e11;
              for (let i11 of p4) (i11 === r10 || i11 && i11 >= -90 && i11 <= 90) && (e11 = (t11 = l10(Math.abs(a10 / Math.sin(sy * i11)))) + Math.abs(i11 / 360)) < c10 && (c10 = e11, d10 = i11, h10 = t11);
            }
          } else h10 = l10(0.75 * a10);
          return this.autoRotation = p4, this.labelRotation = sR(d10, sI(r10) ? r10 : 0), t10.step ? s10 : h10;
        }
        getSlotWidth(t10) {
          let e10 = this.chart, i10 = this.horiz, s10 = this.options.labels, o10 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), r10 = e10.margin[3];
          if (t10 && sI(t10.slotWidth)) return t10.slotWidth;
          if (i10 && s10.step < 2 && !this.isRadial) return s10.rotation ? 0 : (this.staggerLines || 1) * this.len / o10;
          if (!i10) {
            let t11 = s10.style.width;
            if (void 0 !== t11) return parseInt(String(t11), 10);
            if (r10) return r10 - e10.spacing[3];
          }
          return 0.33 * e10.chartWidth;
        }
        renderUnsquish() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.tickPositions, s10 = this.ticks, o10 = this.options.labels, r10 = o10.style, a10 = this.horiz, n10 = this.getSlotWidth(), l10 = Math.max(1, Math.round(n10 - (a10 ? 2 * (o10.padding || 0) : o10.distance || 0))), h10 = {}, d10 = this.labelMetrics(), c10 = r10.lineClamp, p4, u2 = c10 ?? (Math.floor(this.len / (i10.length * d10.h)) || 1), g2 = 0;
          sD(o10.rotation) || (h10.rotation = o10.rotation || 0), i10.forEach(function(t11) {
            let e11 = s10[t11];
            e11.movedLabel && e11.replaceMovedLabel();
            let i11 = e11.label?.textPxLength || 0;
            i11 > g2 && (g2 = i11);
          }), this.maxLabelLength = g2, this.autoRotation ? g2 > l10 && g2 > d10.h ? h10.rotation = this.labelRotation : this.labelRotation = 0 : n10 && (p4 = l10), h10.rotation && (p4 = g2 > 0.5 * t10.chartHeight ? 0.33 * t10.chartHeight : g2, c10 || (u2 = 1)), this.labelAlign = o10.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (h10.align = this.labelAlign), i10.forEach(function(t11) {
            let e11 = s10[t11], i11 = e11 && e11.label, o11 = r10.width, a11 = {};
            i11 && (i11.attr(h10), e11.shortenLabel ? e11.shortenLabel() : p4 && !o11 && "nowrap" !== r10.whiteSpace && (p4 < (i11.textPxLength || 0) || "SPAN" === i11.element.tagName) ? i11.css(sA(a11, {
              width: `${p4}px`,
              lineClamp: u2
            })) : !i11.styles.width || a11.width || o11 || i11.css({
              width: "auto"
            }), e11.rotation = h10.rotation);
          }, this), this.tickRotCorr = e10.rotCorr(d10.b, this.labelRotation || 0, 0 !== this.side);
        }
        hasData() {
          return this.series.some(function(t10) {
            return t10.hasData();
          }) || this.options.showEmpty && sk(this.min) && sk(this.max);
        }
        addTitle(t10) {
          let e10;
          let i10 = this.chart.renderer, s10 = this.horiz, o10 = this.opposite, r10 = this.options.title, a10 = this.chart.styledMode;
          this.axisTitle || ((e10 = r10.textAlign) || (e10 = (s10 ? {
            low: "left",
            middle: "center",
            high: "right"
          } : {
            low: o10 ? "right" : "left",
            middle: "center",
            high: o10 ? "left" : "right"
          })[r10.align]), this.axisTitle = i10.text(r10.text || "", 0, 0, r10.useHTML).attr({
            zIndex: 7,
            rotation: r10.rotation || 0,
            align: e10
          }).addClass("highcharts-axis-title"), a10 || this.axisTitle.css(sB(r10.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true), a10 || r10.style.width || this.isRadial || this.axisTitle.css({
            width: this.len + "px"
          }), this.axisTitle[t10 ? "show" : "hide"](t10);
        }
        generateTick(t10) {
          let e10 = this.ticks;
          e10[t10] ? e10[t10].addLabel() : e10[t10] = new sp(this, t10);
        }
        createGroups() {
          let {
            axisParent: t10,
            chart: e10,
            coll: i10,
            options: s10
          } = this, o10 = e10.renderer, r10 = (e11, r11, a10) => o10.g(e11).attr({
            zIndex: a10
          }).addClass(`highcharts-${i10.toLowerCase()}${r11} ` + (this.isRadial ? `highcharts-radial-axis${r11} ` : "") + (s10.className || "")).add(t10);
          this.axisGroup || (this.gridGroup = r10("grid", "-grid", s10.gridZIndex), this.axisGroup = r10("axis", "", s10.zIndex), this.labelGroup = r10("axis-labels", "-labels", s10.labels.zIndex));
        }
        getOffset() {
          let t10 = this, {
            chart: e10,
            horiz: i10,
            options: s10,
            side: o10,
            ticks: r10,
            tickPositions: a10,
            coll: n10
          } = t10, l10 = e10.inverted && !t10.isZAxis ? [1, 0, 3, 2][o10] : o10, h10 = t10.hasData(), d10 = s10.title, c10 = s10.labels, p4 = sI(s10.crossing), u2 = e10.axisOffset, g2 = e10.clipOffset, m2 = [-1, 1, 1, -1][o10], f2, x2 = 0, y2, b2 = 0, v2 = 0, M2, w2;
          if (t10.showAxis = f2 = h10 || s10.showEmpty, t10.staggerLines = t10.horiz && c10.staggerLines || void 0, t10.createGroups(), h10 || t10.isLinked ? (a10.forEach(function(e11) {
            t10.generateTick(e11);
          }), t10.renderUnsquish(), t10.reserveSpaceDefault = 0 === o10 || 2 === o10 || {
            1: "left",
            3: "right"
          }[o10] === t10.labelAlign, sR(c10.reserveSpace, !p4 && null, "center" === t10.labelAlign || null, t10.reserveSpaceDefault) && a10.forEach(function(t11) {
            v2 = Math.max(r10[t11].getLabelSize(), v2);
          }), t10.staggerLines && (v2 *= t10.staggerLines), t10.labelOffset = v2 * (t10.opposite ? -1 : 1)) : sN(r10, function(t11, e11) {
            t11.destroy(), delete r10[e11];
          }), d10?.text && false !== d10.enabled && (t10.addTitle(f2), f2 && !p4 && false !== d10.reserveSpace && (t10.titleOffset = x2 = t10.axisTitle.getBBox()[i10 ? "height" : "width"], b2 = sk(y2 = d10.offset) ? 0 : sR(d10.margin, i10 ? 5 : 10))), t10.renderLine(), t10.offset = m2 * sR(s10.offset, u2[o10] ? u2[o10] + (s10.margin || 0) : 0), t10.tickRotCorr = t10.tickRotCorr || {
            x: 0,
            y: 0
          }, w2 = 0 === o10 ? -t10.labelMetrics().h : 2 === o10 ? t10.tickRotCorr.y : 0, M2 = Math.abs(v2) + b2, v2 && (M2 -= w2, M2 += m2 * (i10 ? sR(c10.y, t10.tickRotCorr.y + m2 * c10.distance) : sR(c10.x, m2 * c10.distance))), t10.axisTitleMargin = sR(y2, M2), t10.getMaxLabelDimensions && (t10.maxLabelDimensions = t10.getMaxLabelDimensions(r10, a10)), "colorAxis" !== n10 && g2) {
            let e11 = this.tickSize("tick");
            u2[o10] = Math.max(u2[o10], (t10.axisTitleMargin || 0) + x2 + m2 * t10.offset, M2, a10 && a10.length && e11 ? e11[0] + m2 * t10.offset : 0);
            let i11 = !t10.axisLine || s10.offset ? 0 : t10.axisLine.strokeWidth() / 2;
            g2[l10] = Math.max(g2[l10], i11);
          }
          sP(this, "afterGetOffset");
        }
        getLinePath(t10) {
          let e10 = this.chart, i10 = this.opposite, s10 = this.offset, o10 = this.horiz, r10 = this.left + (i10 ? this.width : 0) + s10, a10 = e10.chartHeight - this.bottom - (i10 ? this.height : 0) + s10;
          return i10 && (t10 *= -1), e10.renderer.crispLine([["M", o10 ? this.left : r10, o10 ? a10 : this.top], ["L", o10 ? e10.chartWidth - this.right : r10, o10 ? a10 : e10.chartHeight - this.bottom]], t10);
        }
        renderLine() {
          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
            stroke: this.options.lineColor,
            "stroke-width": this.options.lineWidth,
            zIndex: 7
          }));
        }
        getTitlePosition(t10) {
          let e10 = this.horiz, i10 = this.left, s10 = this.top, o10 = this.len, r10 = this.options.title, a10 = e10 ? i10 : s10, n10 = this.opposite, l10 = this.offset, h10 = r10.x, d10 = r10.y, c10 = this.chart.renderer.fontMetrics(t10), p4 = t10 ? Math.max(t10.getBBox(false, 0).height - c10.h - 1, 0) : 0, u2 = {
            low: a10 + (e10 ? 0 : o10),
            middle: a10 + o10 / 2,
            high: a10 + (e10 ? o10 : 0)
          }[r10.align], g2 = (e10 ? s10 + this.height : i10) + (e10 ? 1 : -1) * (n10 ? -1 : 1) * (this.axisTitleMargin || 0) + [-p4, p4, c10.f, -p4][this.side], m2 = {
            x: e10 ? u2 + h10 : g2 + (n10 ? this.width : 0) + l10 + h10,
            y: e10 ? g2 + d10 - (n10 ? this.height : 0) + l10 : u2 + d10
          };
          return sP(this, "afterGetTitlePosition", {
            titlePosition: m2
          }), m2;
        }
        renderMinorTick(t10, e10) {
          let i10 = this.minorTicks;
          i10[t10] || (i10[t10] = new sp(this, t10, "minor")), e10 && i10[t10].isNew && i10[t10].render(null, true), i10[t10].render(null, false, 1);
        }
        renderTick(t10, e10, i10) {
          let s10 = this.isLinked, o10 = this.ticks;
          (!s10 || t10 >= this.min && t10 <= this.max || this.grid && this.grid.isColumn) && (o10[t10] || (o10[t10] = new sp(this, t10)), i10 && o10[t10].isNew && o10[t10].render(e10, true, -1), o10[t10].render(e10));
        }
        render() {
          let t10, e10;
          let i10 = this, s10 = i10.chart, o10 = i10.logarithmic, r10 = s10.renderer, a10 = i10.options, n10 = i10.isLinked, l10 = i10.tickPositions, h10 = i10.axisTitle, d10 = i10.ticks, c10 = i10.minorTicks, p4 = i10.alternateBands, u2 = a10.stackLabels, g2 = a10.alternateGridColor, m2 = a10.crossing, f2 = i10.tickmarkOffset, x2 = i10.axisLine, y2 = i10.showAxis, b2 = su(r10.globalAnimation);
          if (i10.labelEdge.length = 0, i10.overlap = false, [d10, c10, p4].forEach(function(t11) {
            sN(t11, function(t12) {
              t12.isActive = false;
            });
          }), sI(m2)) {
            let t11 = this.isXAxis ? s10.yAxis[0] : s10.xAxis[0], e11 = [1, -1, -1, 1][this.side];
            if (t11) {
              let s11 = t11.toPixels(m2, true);
              i10.horiz && (s11 = t11.len - s11), i10.offset = e11 * s11;
            }
          }
          if (i10.hasData() || n10) {
            let r11 = i10.chart.hasRendered && i10.old && sI(i10.old.min);
            i10.minorTickInterval && !i10.categories && i10.getMinorTickPositions().forEach(function(t11) {
              i10.renderMinorTick(t11, r11);
            }), l10.length && (l10.forEach(function(t11, e11) {
              i10.renderTick(t11, e11, r11);
            }), f2 && (0 === i10.min || i10.single) && (d10[-1] || (d10[-1] = new sp(i10, -1, null, true)), d10[-1].render(-1))), g2 && l10.forEach(function(r12, a11) {
              e10 = void 0 !== l10[a11 + 1] ? l10[a11 + 1] + f2 : i10.max - f2, a11 % 2 == 0 && r12 < i10.max && e10 <= i10.max + (s10.polar ? -f2 : f2) && (p4[r12] || (p4[r12] = new A.PlotLineOrBand(i10, {})), t10 = r12 + f2, p4[r12].options = {
                from: o10 ? o10.lin2log(t10) : t10,
                to: o10 ? o10.lin2log(e10) : e10,
                color: g2,
                className: "highcharts-alternate-grid"
              }, p4[r12].render(), p4[r12].isActive = true);
            }), i10._addedPlotLB || (i10._addedPlotLB = true, (a10.plotLines || []).concat(a10.plotBands || []).forEach(function(t11) {
              i10.addPlotBandOrLine(t11);
            }));
          }
          [d10, c10, p4].forEach(function(t11) {
            let e11 = [], i11 = b2.duration;
            sN(t11, function(t12, i12) {
              t12.isActive || (t12.render(i12, false, 0), t12.isActive = false, e11.push(i12));
            }), sG(function() {
              let i12 = e11.length;
              for (; i12--; ) t11[e11[i12]] && !t11[e11[i12]].isActive && (t11[e11[i12]].destroy(), delete t11[e11[i12]]);
            }, t11 !== p4 && s10.hasRendered && i11 ? i11 : 0);
          }), x2 && (x2[x2.isPlaced ? "animate" : "attr"]({
            d: this.getLinePath(x2.strokeWidth())
          }), x2.isPlaced = true, x2[y2 ? "show" : "hide"](y2)), h10 && y2 && (h10[h10.isNew ? "attr" : "animate"](i10.getTitlePosition(h10)), h10.isNew = false), u2 && u2.enabled && i10.stacking && i10.stacking.renderStackTotals(), i10.old = {
            len: i10.len,
            max: i10.max,
            min: i10.min,
            transA: i10.transA,
            userMax: i10.userMax,
            userMin: i10.userMin
          }, i10.isDirty = false, sP(this, "afterRender");
        }
        redraw() {
          this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t10) {
            t10.render();
          })), this.series.forEach(function(t10) {
            t10.isDirty = true;
          });
        }
        getKeepProps() {
          return this.keepProps || sH.keepProps;
        }
        destroy(t10) {
          let e10 = this, i10 = e10.plotLinesAndBands, s10 = this.eventOptions;
          if (sP(this, "destroy", {
            keepEvents: t10
          }), t10 || sj(e10), [e10.ticks, e10.minorTicks, e10.alternateBands].forEach(function(t11) {
            sS(t11);
          }), i10) {
            let t11 = i10.length;
            for (; t11--; ) i10[t11].destroy();
          }
          for (let t11 in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(t12) {
            e10[t12] && (e10[t12] = e10[t12].destroy());
          }), e10.plotLinesAndBandsGroups) e10.plotLinesAndBandsGroups[t11] = e10.plotLinesAndBandsGroups[t11].destroy();
          sN(e10, function(t11, i11) {
            -1 === e10.getKeepProps().indexOf(i11) && delete e10[i11];
          }), this.eventOptions = s10;
        }
        drawCrosshair(t10, e10) {
          let i10 = this.crosshair, s10 = sR(i10 && i10.snap, true), o10 = this.chart, r10, a10, n10, l10 = this.cross, h10;
          if (sP(this, "drawCrosshair", {
            e: t10,
            point: e10
          }), t10 || (t10 = this.cross && this.cross.e), i10 && false !== (sk(e10) || !s10)) {
            if (s10 ? sk(e10) && (a10 = sR("colorAxis" !== this.coll ? e10.crosshairPos : null, this.isXAxis ? e10.plotX : this.len - e10.plotY)) : a10 = t10 && (this.horiz ? t10.chartX - this.pos : this.len - t10.chartY + this.pos), sk(a10) && (h10 = {
              value: e10 && (this.isXAxis ? e10.x : sR(e10.stackY, e10.y)),
              translatedValue: a10
            }, o10.polar && sA(h10, {
              isCrosshair: true,
              chartX: t10 && t10.chartX,
              chartY: t10 && t10.chartY,
              point: e10
            }), r10 = this.getPlotLinePath(h10) || null), !sk(r10)) {
              this.hideCrosshair();
              return;
            }
            n10 = this.categories && !this.isRadial, l10 || (this.cross = l10 = o10.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (n10 ? "category " : "thin ") + (i10.className || "")).attr({
              zIndex: sR(i10.zIndex, 2)
            }).add(), !o10.styledMode && (l10.attr({
              stroke: i10.color || (n10 ? tA.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"),
              "stroke-width": sR(i10.width, 1)
            }).css({
              "pointer-events": "none"
            }), i10.dashStyle && l10.attr({
              dashstyle: i10.dashStyle
            }))), l10.show().attr({
              d: r10
            }), n10 && !i10.width && l10.attr({
              "stroke-width": this.transA
            }), this.cross.e = t10;
          } else this.hideCrosshair();
          sP(this, "afterDrawCrosshair", {
            e: t10,
            point: e10
          });
        }
        hideCrosshair() {
          this.cross && this.cross.hide(), sP(this, "afterHideCrosshair");
        }
        update(t10, e10) {
          let i10 = this.chart;
          t10 = sB(this.userOptions, t10), this.destroy(true), this.init(i10, t10), i10.isDirtyBox = true, sR(e10, true) && i10.redraw();
        }
        remove(t10) {
          let e10 = this.chart, i10 = this.coll, s10 = this.series, o10 = s10.length;
          for (; o10--; ) s10[o10] && s10[o10].remove(false);
          sT(e10.axes, this), sT(e10[i10] || [], this), e10.orderItems(i10), this.destroy(), e10.isDirtyBox = true, sR(t10, true) && e10.redraw();
        }
        setTitle(t10, e10) {
          this.update({
            title: t10
          }, e10);
        }
        setCategories(t10, e10) {
          this.update({
            categories: t10
          }, e10);
        }
      }
      sH.keepProps = ["coll", "extKey", "hcEvents", "len", "names", "series", "userMax", "userMin"];
      let sY = sH, {
        addEvent: sV,
        getMagnitude: sU,
        normalizeTickInterval: sZ,
        timeUnits: s$
      } = J;
      !function(t10) {
        function e10() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function i10() {
          if ("datetime" !== this.type) {
            this.dateTime = void 0;
            return;
          }
          this.dateTime || (this.dateTime = new s10(this));
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("dateTime") || (t11.keepProps.push("dateTime"), t11.prototype.getTimeTicks = e10, sV(t11, "afterSetType", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          normalizeTimeTickInterval(t11, e11) {
            let i11 = e11 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], s11 = i11[i11.length - 1], o10 = s$[s11[0]], r10 = s11[1], a10;
            for (a10 = 0; a10 < i11.length && (o10 = s$[(s11 = i11[a10])[0]], r10 = s11[1], !i11[a10 + 1] || !(t11 <= (o10 * r10[r10.length - 1] + s$[i11[a10 + 1][0]]) / 2)); a10++) ;
            o10 === s$.year && t11 < 5 * o10 && (r10 = [1, 2, 5]);
            let n10 = sZ(t11 / o10, r10, "year" === s11[0] ? Math.max(sU(t11 / o10), 1) : 1);
            return {
              unitRange: o10,
              count: n10,
              unitName: s11[0]
            };
          }
          getXDateFormat(t11, e11) {
            let {
              axis: i11
            } = this, s11 = i11.chart.time;
            return i11.closestPointRange ? s11.getDateFormat(i11.closestPointRange, t11, i11.options.startOfWeek, e11) || s11.resolveDTLFormat(e11.year).main : s11.resolveDTLFormat(e11.day).main;
          }
        }
        t10.Additions = s10;
      }(l || (l = {}));
      let s_ = l, {
        addEvent: sq,
        normalizeTickInterval: sK,
        pick: sJ
      } = J;
      !function(t10) {
        function e10() {
          "logarithmic" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s10(this));
        }
        function i10() {
          let t11 = this.logarithmic;
          t11 && (this.lin2val = function(e11) {
            return t11.lin2log(e11);
          }, this.val2lin = function(e11) {
            return t11.log2lin(e11);
          });
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("logarithmic") || (t11.keepProps.push("logarithmic"), sq(t11, "afterSetType", e10), sq(t11, "afterInit", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          getLogTickPositions(t11, e11, i11, s11) {
            let o10 = this.axis, r10 = o10.len, a10 = o10.options, n10 = [];
            if (s11 || (this.minorAutoInterval = void 0), t11 >= 0.5) t11 = Math.round(t11), n10 = o10.getLinearTickPositions(t11, e11, i11);
            else if (t11 >= 0.08) {
              let o11, r11, a11, l10, h10, d10, c10;
              let p4 = Math.floor(e11);
              for (o11 = t11 > 0.3 ? [1, 2, 4] : t11 > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r11 = p4; r11 < i11 + 1 && !c10; r11++) for (a11 = 0, l10 = o11.length; a11 < l10 && !c10; a11++) (h10 = this.log2lin(this.lin2log(r11) * o11[a11])) > e11 && (!s11 || d10 <= i11) && void 0 !== d10 && n10.push(d10), d10 > i11 && (c10 = true), d10 = h10;
            } else {
              let l10 = this.lin2log(e11), h10 = this.lin2log(i11), d10 = s11 ? o10.getMinorTickInterval() : a10.tickInterval, c10 = a10.tickPixelInterval / (s11 ? 5 : 1), p4 = s11 ? r10 / o10.tickPositions.length : r10;
              t11 = sK(t11 = sJ("auto" === d10 ? null : d10, this.minorAutoInterval, (h10 - l10) * c10 / (p4 || 1))), n10 = o10.getLinearTickPositions(t11, l10, h10).map(this.log2lin), s11 || (this.minorAutoInterval = t11 / 5);
            }
            return s11 || (o10.tickInterval = t11), n10;
          }
          lin2log(t11) {
            return Math.pow(10, t11);
          }
          log2lin(t11) {
            return Math.log(t11) / Math.LN10;
          }
        }
        t10.Additions = s10;
      }(h || (h = {}));
      let sQ = h, {
        erase: s0,
        extend: s1,
        isNumber: s2
      } = J;
      !function(t10) {
        let e10;
        function i10(t11) {
          return this.addPlotBandOrLine(t11, "plotBands");
        }
        function s10(t11, i11) {
          let s11 = this.userOptions, o11 = new e10(this, t11);
          if (this.visible && (o11 = o11.render()), o11) {
            if (this._addedPlotLB || (this._addedPlotLB = true, (s11.plotLines || []).concat(s11.plotBands || []).forEach((t12) => {
              this.addPlotBandOrLine(t12);
            })), i11) {
              let e11 = s11[i11] || [];
              e11.push(t11), s11[i11] = e11;
            }
            this.plotLinesAndBands.push(o11);
          }
          return o11;
        }
        function o10(t11) {
          return this.addPlotBandOrLine(t11, "plotLines");
        }
        function r10(t11, e11, i11) {
          i11 = i11 || this.options;
          let s11 = this.getPlotLinePath({
            value: e11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), o11 = [], r11 = this.horiz, a11 = !s2(this.min) || !s2(this.max) || t11 < this.min && e11 < this.min || t11 > this.max && e11 > this.max, n11 = this.getPlotLinePath({
            value: t11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), l11, h10 = 1, d10;
          if (n11 && s11) for (a11 && (d10 = n11.toString() === s11.toString(), h10 = 0), l11 = 0; l11 < n11.length; l11 += 2) {
            let t12 = n11[l11], e12 = n11[l11 + 1], i12 = s11[l11], a12 = s11[l11 + 1];
            ("M" === t12[0] || "L" === t12[0]) && ("M" === e12[0] || "L" === e12[0]) && ("M" === i12[0] || "L" === i12[0]) && ("M" === a12[0] || "L" === a12[0]) && (r11 && i12[1] === t12[1] ? (i12[1] += h10, a12[1] += h10) : r11 || i12[2] !== t12[2] || (i12[2] += h10, a12[2] += h10), o11.push(["M", t12[1], t12[2]], ["L", e12[1], e12[2]], ["L", a12[1], a12[2]], ["L", i12[1], i12[2]], ["Z"])), o11.isFlat = d10;
          }
          return o11;
        }
        function a10(t11) {
          this.removePlotBandOrLine(t11);
        }
        function n10(t11) {
          let e11 = this.plotLinesAndBands, i11 = this.options, s11 = this.userOptions;
          if (e11) {
            let o11 = e11.length;
            for (; o11--; ) e11[o11].id === t11 && e11[o11].destroy();
            [i11.plotLines || [], s11.plotLines || [], i11.plotBands || [], s11.plotBands || []].forEach(function(e12) {
              for (o11 = e12.length; o11--; ) (e12[o11] || {}).id === t11 && s0(e12, e12[o11]);
            });
          }
        }
        function l10(t11) {
          this.removePlotBandOrLine(t11);
        }
        t10.compose = function(t11, h10) {
          let d10 = h10.prototype;
          return d10.addPlotBand || (e10 = t11, s1(d10, {
            addPlotBand: i10,
            addPlotLine: o10,
            addPlotBandOrLine: s10,
            getPlotBandPath: r10,
            removePlotBand: a10,
            removePlotLine: l10,
            removePlotBandOrLine: n10
          })), h10;
        };
      }(d || (d = {}));
      let s3 = d, {
        addEvent: s6,
        arrayMax: s5,
        arrayMin: s9,
        defined: s8,
        destroyObjectProperties: s4,
        erase: s7,
        fireEvent: ot,
        merge: oe,
        objectEach: oi,
        pick: os
      } = J;
      class oo {
        static compose(t10, e10) {
          return s6(t10, "afterInit", function() {
            this.labelCollectors.push(() => {
              let t11 = [];
              for (let e11 of this.axes) for (let {
                label: i10,
                options: s10
              } of e11.plotLinesAndBands) i10 && !s10?.label?.allowOverlap && t11.push(i10);
              return t11;
            });
          }), s3.compose(oo, e10);
        }
        constructor(t10, e10) {
          this.axis = t10, this.options = e10, this.id = e10.id;
        }
        render() {
          ot(this, "render");
          let {
            axis: t10,
            options: e10
          } = this, {
            horiz: i10,
            logarithmic: s10
          } = t10, {
            color: o10,
            events: r10,
            zIndex: a10 = 0
          } = e10, {
            renderer: n10,
            time: l10
          } = t10.chart, h10 = {}, d10 = l10.parse(e10.to), c10 = l10.parse(e10.from), p4 = l10.parse(e10.value), u2 = e10.borderWidth, g2 = e10.label, {
            label: m2,
            svgElem: f2
          } = this, x2 = [], y2, b2 = s8(c10) && s8(d10), v2 = s8(p4), M2 = !f2, w2 = {
            class: "highcharts-plot-" + (b2 ? "band " : "line ") + (e10.className || "")
          }, k2 = b2 ? "bands" : "lines";
          if (!t10.chart.styledMode && (v2 ? (w2.stroke = o10 || "#999999", w2["stroke-width"] = os(e10.width, 1), e10.dashStyle && (w2.dashstyle = e10.dashStyle)) : b2 && (w2.fill = o10 || "#e6e9ff", u2 && (w2.stroke = e10.borderColor, w2["stroke-width"] = u2))), h10.zIndex = a10, k2 += "-" + a10, (y2 = t10.plotLinesAndBandsGroups[k2]) || (t10.plotLinesAndBandsGroups[k2] = y2 = n10.g("plot-" + k2).attr(h10).add()), f2 || (this.svgElem = f2 = n10.path().attr(w2).add(y2)), s8(p4)) x2 = t10.getPlotLinePath({
            value: s10?.log2lin(p4) ?? p4,
            lineWidth: f2.strokeWidth(),
            acrossPanes: e10.acrossPanes
          });
          else {
            if (!(s8(c10) && s8(d10))) return;
            x2 = t10.getPlotBandPath(s10?.log2lin(c10) ?? c10, s10?.log2lin(d10) ?? d10, e10);
          }
          return !this.eventsAdded && r10 && (oi(r10, (t11, e11) => {
            f2?.on(e11, (t12) => {
              r10[e11].apply(this, [t12]);
            });
          }), this.eventsAdded = true), (M2 || !f2.d) && x2?.length ? f2.attr({
            d: x2
          }) : f2 && (x2 ? (f2.show(), f2.animate({
            d: x2
          })) : f2.d && (f2.hide(), m2 && (this.label = m2 = m2.destroy()))), g2 && (s8(g2.text) || s8(g2.formatter)) && x2?.length && t10.width > 0 && t10.height > 0 && !x2.isFlat ? (g2 = oe(__spreadValues({
            align: i10 && b2 ? "center" : void 0,
            x: i10 ? !b2 && 4 : 10,
            verticalAlign: !i10 && b2 ? "middle" : void 0,
            y: i10 ? b2 ? 16 : 10 : b2 ? 6 : -4,
            rotation: i10 && !b2 ? 90 : 0
          }, b2 ? {
            inside: true
          } : {}), g2), this.renderLabel(g2, x2, b2, a10)) : m2 && m2.hide(), this;
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart.renderer, a10 = t10.inside, n10 = this.label;
          n10 || (this.label = n10 = r10.text(this.getLabelText(t10), 0, 0, t10.useHTML).attr({
            align: t10.textAlign || t10.align,
            rotation: t10.rotation,
            class: "highcharts-plot-" + (i10 ? "band" : "line") + "-label " + (t10.className || ""),
            zIndex: s10
          }), o10.chart.styledMode || n10.css(oe({
            fontSize: "0.8em",
            textOverflow: i10 && !a10 ? "" : "ellipsis"
          }, t10.style)), n10.add());
          let l10 = e10.xBounds || [e10[0][1], e10[1][1], i10 ? e10[2][1] : e10[0][1]], h10 = e10.yBounds || [e10[0][2], e10[1][2], i10 ? e10[2][2] : e10[0][2]], d10 = s9(l10), c10 = s9(h10), p4 = s5(l10) - d10;
          n10.align(t10, false, {
            x: d10,
            y: c10,
            width: p4,
            height: s5(h10) - c10
          }), (!n10.alignValue || "left" === n10.alignValue || s8(a10)) && n10.css({
            width: (t10.style?.width || (i10 && a10 ? p4 : 90 === n10.rotation ? o10.height - (n10.alignAttr.y - o10.top) : (t10.clip ? o10.width : o10.chart.chartWidth) - (n10.alignAttr.x - o10.left))) + "px"
          }), n10.show(true);
        }
        getLabelText(t10) {
          return s8(t10.formatter) ? t10.formatter.call(this) : t10.text;
        }
        destroy() {
          s7(this.axis.plotLinesAndBands, this), delete this.axis, s4(this);
        }
      }
      let {
        animObject: or
      } = tH, {
        format: oa
      } = ed, {
        composed: on,
        dateFormats: ol,
        doc: oh,
        isSafari: od
      } = A, {
        distribute: oc
      } = ef, {
        addEvent: op,
        clamp: ou,
        css: og,
        discardElement: om,
        extend: of,
        fireEvent: ox,
        isArray: oy,
        isNumber: ob,
        isObject: ov,
        isString: oM,
        merge: ow,
        pick: ok,
        pushUnique: oS,
        splat: oT,
        syncTimeout: oC
      } = J;
      class oA {
        constructor(t10, e10, i10) {
          this.allowShared = true, this.crosshairs = [], this.distance = 0, this.isHidden = true, this.isSticky = false, this.options = {}, this.outside = false, this.chart = t10, this.init(t10, e10), this.pointer = i10;
        }
        bodyFormatter(t10) {
          return t10.map((t11) => {
            let e10 = t11.series.tooltipOptions, i10 = t11.formatPrefix || "point";
            return (e10[i10 + "Formatter"] || t11.tooltipFormatter).call(t11, e10[i10 + "Format"] || "");
          });
        }
        cleanSplit(t10) {
          this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.tt;
            i10 && (!i10.isActive || t10 ? e10.tt = i10.destroy() : i10.isActive = false);
          });
        }
        defaultFormatter(t10) {
          let e10;
          let i10 = this.points || oT(this);
          return (e10 = (e10 = [t10.headerFooterFormatter(i10[0])]).concat(t10.bodyFormatter(i10))).push(t10.headerFooterFormatter(i10[0], true)), e10;
        }
        destroy() {
          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), om(this.container)), J.clearTimeout(this.hideTimer);
        }
        getAnchor(t10, e10) {
          let i10;
          let {
            chart: s10,
            pointer: o10
          } = this, r10 = s10.inverted, a10 = s10.plotTop, n10 = s10.plotLeft;
          if ((t10 = oT(t10))[0].series && t10[0].series.yAxis && !t10[0].series.yAxis.options.reversedStacks && (t10 = t10.slice().reverse()), this.followPointer && e10) void 0 === e10.chartX && (e10 = o10.normalize(e10)), i10 = [e10.chartX - n10, e10.chartY - a10];
          else if (t10[0].tooltipPos) i10 = t10[0].tooltipPos;
          else {
            let s11 = 0, o11 = 0;
            t10.forEach(function(t11) {
              let e11 = t11.pos(true);
              e11 && (s11 += e11[0], o11 += e11[1]);
            }), s11 /= t10.length, o11 /= t10.length, this.shared && t10.length > 1 && e10 && (r10 ? s11 = e10.chartX : o11 = e10.chartY), i10 = [s11 - n10, o11 - a10];
          }
          return i10.map(Math.round);
        }
        getClassName(t10, e10, i10) {
          let s10 = this.options, o10 = t10.series, r10 = o10.options;
          return [s10.className, "highcharts-label", i10 && "highcharts-tooltip-header", e10 ? "highcharts-tooltip-box" : "highcharts-tooltip", !i10 && "highcharts-color-" + ok(t10.colorIndex, o10.colorIndex), r10 && r10.className].filter(oM).join(" ");
        }
        getLabel({
          anchorX: t10,
          anchorY: e10
        } = {
          anchorX: 0,
          anchorY: 0
        }) {
          let i10 = this, s10 = this.chart.styledMode, o10 = this.options, r10 = this.split && this.allowShared, a10 = this.container, n10 = this.chart.renderer;
          if (this.label) {
            let t11 = !this.label.hasClass("highcharts-label");
            (!r10 && t11 || r10 && !t11) && this.destroy();
          }
          if (!this.label) {
            if (this.outside) {
              let t11 = this.chart, e11 = t11.options.chart.style, i11 = ec.getRendererType();
              this.container = a10 = A.doc.createElement("div"), a10.className = "highcharts-tooltip-container " + (t11.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), og(a10, {
                position: "absolute",
                top: "1px",
                pointerEvents: "none",
                zIndex: Math.max(this.options.style.zIndex || 0, (e11 && e11.zIndex || 0) + 3)
              }), this.renderer = n10 = new i11(a10, 0, 0, e11, void 0, void 0, n10.styledMode);
            }
            if (r10 ? this.label = n10.g("tooltip") : (this.label = n10.label("", t10, e10, o10.shape, void 0, void 0, o10.useHTML, void 0, "tooltip").attr({
              padding: o10.padding,
              r: o10.borderRadius
            }), s10 || this.label.attr({
              fill: o10.backgroundColor,
              "stroke-width": o10.borderWidth || 0
            }).css(o10.style).css({
              pointerEvents: o10.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
            })), i10.outside) {
              let t11 = this.label;
              [t11.xSetter, t11.ySetter].forEach((e11, s11) => {
                t11[s11 ? "ySetter" : "xSetter"] = (o11) => {
                  e11.call(t11, i10.distance), t11[s11 ? "y" : "x"] = o11, a10 && (a10.style[s11 ? "top" : "left"] = `${o11}px`);
                };
              });
            }
            this.label.attr({
              zIndex: 8
            }).shadow(o10.shadow).add();
          }
          return a10 && !a10.parentElement && A.doc.body.appendChild(a10), this.label;
        }
        getPlayingField() {
          let {
            body: t10,
            documentElement: e10
          } = oh, {
            chart: i10,
            distance: s10,
            outside: o10
          } = this;
          return {
            width: o10 ? Math.max(t10.scrollWidth, e10.scrollWidth, t10.offsetWidth, e10.offsetWidth, e10.clientWidth) - 2 * s10 - 2 : i10.chartWidth,
            height: o10 ? Math.max(t10.scrollHeight, e10.scrollHeight, t10.offsetHeight, e10.offsetHeight, e10.clientHeight) : i10.chartHeight
          };
        }
        getPosition(t10, e10, i10) {
          let {
            distance: s10,
            chart: o10,
            outside: r10,
            pointer: a10
          } = this, {
            inverted: n10,
            plotLeft: l10,
            plotTop: h10,
            polar: d10
          } = o10, {
            plotX: c10 = 0,
            plotY: p4 = 0
          } = i10, u2 = {}, g2 = n10 && i10.h || 0, {
            height: m2,
            width: f2
          } = this.getPlayingField(), x2 = a10.getChartPosition(), y2 = (t11) => t11 * x2.scaleX, b2 = (t11) => t11 * x2.scaleY, v2 = (i11) => {
            let a11 = "x" === i11;
            return [i11, a11 ? f2 : m2, a11 ? t10 : e10].concat(r10 ? [a11 ? y2(t10) : b2(e10), a11 ? x2.left - s10 + y2(c10 + l10) : x2.top - s10 + b2(p4 + h10), 0, a11 ? f2 : m2] : [a11 ? t10 : e10, a11 ? c10 + l10 : p4 + h10, a11 ? l10 : h10, a11 ? l10 + o10.plotWidth : h10 + o10.plotHeight]);
          }, M2 = v2("y"), w2 = v2("x"), k2, S2 = !!i10.negative;
          !d10 && o10.hoverSeries?.yAxis?.reversed && (S2 = !S2);
          let T2 = !this.followPointer && ok(i10.ttBelow, !d10 && !n10 === S2), C2 = function(t11, e11, i11, o11, a11, n11, l11) {
            let h11 = r10 ? "y" === t11 ? b2(s10) : y2(s10) : s10, d11 = (i11 - o11) / 2, c11 = o11 < a11 - s10, p7 = a11 + s10 + o11 < e11, m3 = a11 - h11 - i11 + d11, f3 = a11 + h11 - d11;
            if (T2 && p7) u2[t11] = f3;
            else if (!T2 && c11) u2[t11] = m3;
            else if (c11) u2[t11] = Math.min(l11 - o11, m3 - g2 < 0 ? m3 : m3 - g2);
            else {
              if (!p7) return false;
              u2[t11] = Math.max(n11, f3 + g2 + i11 > e11 ? f3 : f3 + g2);
            }
          }, A2 = function(t11, e11, i11, o11, r11) {
            if (r11 < s10 || r11 > e11 - s10) return false;
            r11 < i11 / 2 ? u2[t11] = 1 : r11 > e11 - o11 / 2 ? u2[t11] = e11 - o11 - 2 : u2[t11] = r11 - i11 / 2;
          }, P2 = function(t11) {
            [M2, w2] = [w2, M2], k2 = t11;
          }, L2 = () => {
            false !== C2.apply(0, M2) ? false !== A2.apply(0, w2) || k2 || (P2(true), L2()) : k2 ? u2.x = u2.y = 0 : (P2(true), L2());
          };
          return (n10 && !d10 || this.len > 1) && P2(), L2(), u2;
        }
        hide(t10) {
          let e10 = this;
          J.clearTimeout(this.hideTimer), t10 = ok(t10, this.options.hideDelay), this.isHidden || (this.hideTimer = oC(function() {
            let i10 = e10.getLabel();
            e10.getLabel().animate({
              opacity: 0
            }, {
              duration: t10 ? 150 : t10,
              complete: () => {
                i10.hide(), e10.container && e10.container.remove();
              }
            }), e10.isHidden = true;
          }, t10));
        }
        init(t10, e10) {
          this.chart = t10, this.options = e10, this.crosshairs = [], this.isHidden = true, this.split = e10.split && !t10.inverted && !t10.polar, this.shared = e10.shared || this.split, this.outside = ok(e10.outside, !!(t10.scrollablePixelsX || t10.scrollablePixelsY));
        }
        shouldStickOnContact(t10) {
          return !!(!this.followPointer && this.options.stickOnContact && (!t10 || this.pointer.inClass(t10.target, "highcharts-tooltip")));
        }
        move(t10, e10, i10, s10) {
          let o10 = this, r10 = or(!o10.isHidden && o10.options.animation), a10 = o10.followPointer || (o10.len || 0) > 1, n10 = {
            x: t10,
            y: e10
          };
          a10 || (n10.anchorX = i10, n10.anchorY = s10), r10.step = () => o10.drawTracker(), o10.getLabel().animate(n10, r10);
        }
        refresh(t10, e10) {
          let {
            chart: i10,
            options: s10,
            pointer: o10,
            shared: r10
          } = this, a10 = oT(t10), n10 = a10[0], l10 = s10.format, h10 = s10.formatter || this.defaultFormatter, d10 = i10.styledMode, c10 = this.allowShared;
          if (!s10.enabled || !n10.series) return;
          J.clearTimeout(this.hideTimer), this.allowShared = !(!oy(t10) && t10.series && t10.series.noSharedTooltip), c10 = c10 && !this.allowShared, this.followPointer = !this.split && n10.series.tooltipOptions.followPointer;
          let p4 = this.getAnchor(t10, e10), u2 = p4[0], g2 = p4[1];
          r10 && this.allowShared && (o10.applyInactiveState(a10), a10.forEach((t11) => t11.setState("hover")), n10.points = a10), this.len = a10.length;
          let m2 = oM(l10) ? oa(l10, n10, i10) : h10.call(n10, this);
          n10.points = void 0;
          let f2 = n10.series;
          if (this.distance = ok(f2.tooltipOptions.distance, 16), false === m2) this.hide();
          else {
            if (this.split && this.allowShared) this.renderSplit(m2, a10);
            else {
              let t11 = u2, r11 = g2;
              if (e10 && o10.isDirectTouch && (t11 = e10.chartX - i10.plotLeft, r11 = e10.chartY - i10.plotTop), i10.polar || false === f2.options.clip || a10.some((e11) => o10.isDirectTouch || e11.series.shouldShowTooltip(t11, r11))) {
                let t12 = this.getLabel(c10 && this.tt || {});
                (!s10.style.width || d10) && t12.css({
                  width: (this.outside ? this.getPlayingField() : i10.spacingBox).width + "px"
                }), t12.attr({
                  class: this.getClassName(n10),
                  text: m2 && m2.join ? m2.join("") : m2
                }), this.outside && t12.attr({
                  x: ou(t12.x || 0, 0, this.getPlayingField().width - (t12.width || 0) - 1)
                }), d10 || t12.attr({
                  stroke: s10.borderColor || n10.color || f2.color || "#666666"
                }), this.updatePosition({
                  plotX: u2,
                  plotY: g2,
                  negative: n10.negative,
                  ttBelow: n10.ttBelow,
                  h: p4[2] || 0
                });
              } else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show(), this.isHidden = false;
          }
          ox(this, "refresh");
        }
        renderSplit(t10, e10) {
          let i10 = this, {
            chart: s10,
            chart: {
              chartWidth: o10,
              chartHeight: r10,
              plotHeight: a10,
              plotLeft: n10,
              plotTop: l10,
              scrollablePixelsY: h10 = 0,
              scrollablePixelsX: d10,
              styledMode: c10
            },
            distance: p4,
            options: u2,
            options: {
              positioner: g2
            },
            pointer: m2
          } = i10, {
            scrollLeft: f2 = 0,
            scrollTop: x2 = 0
          } = s10.scrollablePlotArea?.scrollingContainer || {}, y2 = i10.outside && "number" != typeof d10 ? oh.documentElement.getBoundingClientRect() : {
            left: f2,
            right: f2 + o10,
            top: x2,
            bottom: x2 + r10
          }, b2 = i10.getLabel(), v2 = this.renderer || s10.renderer, M2 = !!(s10.xAxis[0] && s10.xAxis[0].opposite), {
            left: w2,
            top: k2
          } = m2.getChartPosition(), S2 = l10 + x2, T2 = 0, C2 = a10 - h10;
          function A2(t11, e11, s11, o11, r11 = true) {
            let a11, n11;
            return s11 ? (a11 = M2 ? 0 : C2, n11 = ou(t11 - o11 / 2, y2.left, y2.right - o11 - (i10.outside ? w2 : 0))) : (a11 = e11 - S2, n11 = ou(n11 = r11 ? t11 - o11 - p4 : t11 + p4, r11 ? n11 : y2.left, y2.right)), {
              x: n11,
              y: a11
            };
          }
          oM(t10) && (t10 = [false, t10]);
          let P2 = t10.slice(0, e10.length + 1).reduce(function(t11, s11, o11) {
            if (false !== s11 && "" !== s11) {
              let r11 = e10[o11 - 1] || {
                isHeader: true,
                plotX: e10[0].plotX,
                plotY: a10,
                series: {}
              }, h11 = r11.isHeader, d11 = h11 ? i10 : r11.series, m3 = d11.tt = function(t12, e11, s12) {
                let o12 = t12, {
                  isHeader: r12,
                  series: a11
                } = e11;
                if (!o12) {
                  let t13 = {
                    padding: u2.padding,
                    r: u2.borderRadius
                  };
                  c10 || (t13.fill = u2.backgroundColor, t13["stroke-width"] = u2.borderWidth ?? 1), o12 = v2.label("", 0, 0, u2[r12 ? "headerShape" : "shape"], void 0, void 0, u2.useHTML).addClass(i10.getClassName(e11, true, r12)).attr(t13).add(b2);
                }
                return o12.isActive = true, o12.attr({
                  text: s12
                }), c10 || o12.css(u2.style).attr({
                  stroke: u2.borderColor || e11.color || a11.color || "#333333"
                }), o12;
              }(d11.tt, r11, s11.toString()), f3 = m3.getBBox(), x3 = f3.width + m3.strokeWidth();
              h11 && (T2 = f3.height, C2 += T2, M2 && (S2 -= T2));
              let {
                anchorX: w3,
                anchorY: k3
              } = function(t12) {
                let e11, i11;
                let {
                  isHeader: s12,
                  plotX: o12 = 0,
                  plotY: r12 = 0,
                  series: h12
                } = t12;
                if (s12) e11 = Math.max(n10 + o12, n10), i11 = l10 + a10 / 2;
                else {
                  let {
                    xAxis: t13,
                    yAxis: s13
                  } = h12;
                  e11 = t13.pos + ou(o12, -p4, t13.len + p4), h12.shouldShowTooltip(0, s13.pos - l10 + r12, {
                    ignoreX: true
                  }) && (i11 = s13.pos + r12);
                }
                return {
                  anchorX: e11 = ou(e11, y2.left - p4, y2.right + p4),
                  anchorY: i11
                };
              }(r11);
              if ("number" == typeof k3) {
                let e11 = f3.height + 1, s12 = g2 ? g2.call(i10, x3, e11, r11) : A2(w3, k3, h11, x3);
                t11.push({
                  align: g2 ? 0 : void 0,
                  anchorX: w3,
                  anchorY: k3,
                  boxWidth: x3,
                  point: r11,
                  rank: ok(s12.rank, h11 ? 1 : 0),
                  size: e11,
                  target: s12.y,
                  tt: m3,
                  x: s12.x
                });
              } else m3.isActive = false;
            }
            return t11;
          }, []);
          !g2 && P2.some((t11) => {
            let {
              outside: e11
            } = i10, s11 = (e11 ? w2 : 0) + t11.anchorX;
            return s11 < y2.left && s11 + t11.boxWidth < y2.right || s11 < w2 - y2.left + t11.boxWidth && y2.right - s11 > s11;
          }) && (P2 = P2.map((t11) => {
            let {
              x: e11,
              y: i11
            } = A2(t11.anchorX, t11.anchorY, t11.point.isHeader, t11.boxWidth, false);
            return of(t11, {
              target: i11,
              x: e11
            });
          })), i10.cleanSplit(), oc(P2, C2);
          let L2 = {
            left: w2,
            right: w2
          };
          P2.forEach(function(t11) {
            let {
              x: e11,
              boxWidth: s11,
              isHeader: o11
            } = t11;
            !o11 && (i10.outside && w2 + e11 < L2.left && (L2.left = w2 + e11), !o11 && i10.outside && L2.left + s11 > L2.right && (L2.right = w2 + e11));
          }), P2.forEach(function(t11) {
            let {
              x: e11,
              anchorX: s11,
              anchorY: o11,
              pos: r11,
              point: {
                isHeader: a11
              }
            } = t11, n11 = {
              visibility: void 0 === r11 ? "hidden" : "inherit",
              x: e11,
              y: (r11 || 0) + S2,
              anchorX: s11,
              anchorY: o11
            };
            if (i10.outside && e11 < s11) {
              let t12 = w2 - L2.left;
              t12 > 0 && (a11 || (n11.x = e11 + t12, n11.anchorX = s11 + t12), a11 && (n11.x = (L2.right - L2.left) / 2, n11.anchorX = s11 + t12));
            }
            t11.tt.attr(n11);
          });
          let {
            container: O2,
            outside: E2,
            renderer: I2
          } = i10;
          if (E2 && O2 && I2) {
            let {
              width: t11,
              height: e11,
              x: i11,
              y: s11
            } = b2.getBBox();
            I2.setSize(t11 + i11, e11 + s11, false), O2.style.left = L2.left + "px", O2.style.top = k2 + "px";
          }
          od && b2.attr({
            opacity: 1 === b2.opacity ? 0.999 : 1
          });
        }
        drawTracker() {
          if (!this.shouldStickOnContact()) {
            this.tracker && (this.tracker = this.tracker.destroy());
            return;
          }
          let t10 = this.chart, e10 = this.label, i10 = this.shared ? t10.hoverPoints : t10.hoverPoint;
          if (!e10 || !i10) return;
          let s10 = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }, o10 = this.getAnchor(i10), r10 = e10.getBBox();
          o10[0] += t10.plotLeft - (e10.translateX || 0), o10[1] += t10.plotTop - (e10.translateY || 0), s10.x = Math.min(0, o10[0]), s10.y = Math.min(0, o10[1]), s10.width = o10[0] < 0 ? Math.max(Math.abs(o10[0]), r10.width - o10[0]) : Math.max(Math.abs(o10[0]), r10.width), s10.height = o10[1] < 0 ? Math.max(Math.abs(o10[1]), r10.height - Math.abs(o10[1])) : Math.max(Math.abs(o10[1]), r10.height), this.tracker ? this.tracker.attr(s10) : (this.tracker = e10.renderer.rect(s10).addClass("highcharts-tracker").add(e10), t10.styledMode || this.tracker.attr({
            fill: "rgba(0,0,0,0)"
          }));
        }
        styledModeFormat(t10) {
          return t10.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
        }
        headerFooterFormatter(t10, e10) {
          let i10 = t10.series, s10 = i10.tooltipOptions, o10 = i10.xAxis, r10 = o10 && o10.dateTime, a10 = {
            isFooter: e10,
            point: t10
          }, n10 = s10.xDateFormat || "", l10 = s10[e10 ? "footerFormat" : "headerFormat"];
          return ox(this, "headerFormatter", a10, function(e11) {
            if (r10 && !n10 && ob(t10.key) && (n10 = r10.getXDateFormat(t10.key, s10.dateTimeLabelFormats)), r10 && n10) {
              if (ov(n10)) {
                let t11 = n10;
                ol[0] = (e12) => i10.chart.time.dateFormat(t11, e12), n10 = "%0";
              }
              (t10.tooltipDateKeys || ["key"]).forEach((t11) => {
                l10 = l10.replace(RegExp("point\\." + t11 + "([ \\)}])", ""), `(point.${t11}:${n10})$1`);
              });
            }
            i10.chart.styledMode && (l10 = this.styledModeFormat(l10)), e11.text = oa(l10, t10, this.chart);
          }), a10.text || "";
        }
        update(t10) {
          this.destroy(), this.init(this.chart, ow(true, this.options, t10));
        }
        updatePosition(t10) {
          let {
            chart: e10,
            container: i10,
            distance: s10,
            options: o10,
            pointer: r10,
            renderer: a10
          } = this, {
            height: n10 = 0,
            width: l10 = 0
          } = this.getLabel(), {
            left: h10,
            top: d10,
            scaleX: c10,
            scaleY: p4
          } = r10.getChartPosition(), u2 = (o10.positioner || this.getPosition).call(this, l10, n10, t10), g2 = A.doc, m2 = (t10.plotX || 0) + e10.plotLeft, f2 = (t10.plotY || 0) + e10.plotTop, x2;
          a10 && i10 && (o10.positioner && (u2.x += h10 - s10, u2.y += d10 - s10), x2 = (o10.borderWidth || 0) + 2 * s10 + 2, a10.setSize(ou(l10 + x2, 0, g2.documentElement.clientWidth) - 1, n10 + x2, false), (1 !== c10 || 1 !== p4) && (og(i10, {
            transform: `scale(${c10}, ${p4})`
          }), m2 *= c10, f2 *= p4), m2 += h10 - u2.x, f2 += d10 - u2.y), this.move(Math.round(u2.x), Math.round(u2.y || 0), m2, f2);
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          oS(on, "Core.Tooltip") && op(e10, "afterInit", function() {
            let e11 = this.chart;
            e11.options.tooltip && (e11.tooltip = new t10(e11, e11.options.tooltip, this));
          });
        };
      }(oA || (oA = {}));
      let oP = oA, {
        animObject: oL
      } = tH, {
        defaultOptions: oO
      } = tw, {
        format: oE
      } = ed, {
        addEvent: oI,
        crisp: oD,
        erase: oB,
        extend: oz,
        fireEvent: oN,
        getNestedProperty: oR,
        isArray: oW,
        isFunction: oj,
        isNumber: oX,
        isObject: oG,
        merge: oF,
        pick: oH,
        syncTimeout: oY,
        removeEvent: oV,
        uniqueKey: oU
      } = J;
      class oZ {
        animateBeforeDestroy() {
          let t10 = this, e10 = {
            x: t10.startXPos,
            opacity: 0
          }, i10 = t10.getGraphicalProps();
          i10.singular.forEach(function(i11) {
            t10[i11] = t10[i11].animate("dataLabel" === i11 ? {
              x: t10[i11].startXPos,
              y: t10[i11].startYPos,
              opacity: 0
            } : e10);
          }), i10.plural.forEach(function(e11) {
            t10[e11].forEach(function(e12) {
              e12.element && e12.animate(oz({
                x: t10.startXPos
              }, e12.startYPos ? {
                x: e12.startXPos,
                y: e12.startYPos
              } : {}));
            });
          });
        }
        applyOptions(t10, e10) {
          let i10 = this.series, s10 = i10.options.pointValKey || i10.pointValKey;
          return oz(this, t10 = oZ.prototype.optionsToObject.call(this, t10)), this.options = this.options ? oz(this.options, t10) : t10, t10.group && delete this.group, t10.dataLabels && delete this.dataLabels, s10 && (this.y = oZ.prototype.getNestedProperty.call(this, s10)), this.selected && (this.state = "select"), "name" in this && void 0 === e10 && i10.xAxis && i10.xAxis.hasNames && (this.x = i10.xAxis.nameToX(this)), void 0 === this.x && i10 ? this.x = e10 ?? i10.autoIncrement() : oX(t10.x) && i10.options.relativeXValue ? this.x = i10.autoIncrement(t10.x) : "string" == typeof this.x && (e10 ?? (e10 = i10.chart.time.parse(this.x)), oX(e10) && (this.x = e10)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
        }
        destroy() {
          if (!this.destroyed) {
            let t10 = this, e10 = t10.series, i10 = e10.chart, s10 = e10.options.dataSorting, o10 = i10.hoverPoints, r10 = oL(t10.series.chart.renderer.globalAnimation), a10 = () => {
              for (let e11 in (t10.graphic || t10.graphics || t10.dataLabel || t10.dataLabels) && (oV(t10), t10.destroyElements()), t10) delete t10[e11];
            };
            t10.legendItem && i10.legend.destroyItem(t10), o10 && (t10.setState(), oB(o10, t10), o10.length || (i10.hoverPoints = null)), t10 === i10.hoverPoint && t10.onMouseOut(), s10 && s10.enabled ? (this.animateBeforeDestroy(), oY(a10, r10.duration)) : a10(), i10.pointCount--;
          }
          this.destroyed = true;
        }
        destroyElements(t10) {
          let e10 = this, i10 = e10.getGraphicalProps(t10);
          i10.singular.forEach(function(t11) {
            e10[t11] = e10[t11].destroy();
          }), i10.plural.forEach(function(t11) {
            e10[t11].forEach(function(t12) {
              t12 && t12.element && t12.destroy();
            }), delete e10[t11];
          });
        }
        firePointEvent(t10, e10, i10) {
          let s10 = this, o10 = this.series.options;
          s10.manageEvent(t10), "click" === t10 && o10.allowPointSelect && (i10 = function(t11) {
            !s10.destroyed && s10.select && s10.select(null, t11.ctrlKey || t11.metaKey || t11.shiftKey);
          }), oN(s10, t10, e10, i10);
        }
        getClassName() {
          return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
        }
        getGraphicalProps(t10) {
          let e10, i10;
          let s10 = this, o10 = [], r10 = {
            singular: [],
            plural: []
          };
          for ((t10 = t10 || {
            graphic: 1,
            dataLabel: 1
          }).graphic && o10.push("graphic", "connector"), t10.dataLabel && o10.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i10 = o10.length; i10--; ) s10[e10 = o10[i10]] && r10.singular.push(e10);
          return ["graphic", "dataLabel"].forEach(function(e11) {
            let i11 = e11 + "s";
            t10[e11] && s10[i11] && r10.plural.push(i11);
          }), r10;
        }
        getNestedProperty(t10) {
          return t10 ? 0 === t10.indexOf("custom.") ? oR(t10, this.options) : this[t10] : void 0;
        }
        getZone() {
          let t10 = this.series, e10 = t10.zones, i10 = t10.zoneAxis || "y", s10, o10 = 0;
          for (s10 = e10[0]; this[i10] >= s10.value; ) s10 = e10[++o10];
          return this.nonZonedColor || (this.nonZonedColor = this.color), s10 && s10.color && !this.options.color ? this.color = s10.color : this.color = this.nonZonedColor, s10;
        }
        hasNewShapeType() {
          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
        }
        constructor(t10, e10, i10) {
          this.formatPrefix = "point", this.visible = true, this.point = this, this.series = t10, this.applyOptions(e10, i10), this.id ?? (this.id = oU()), this.resolveColor(), t10.chart.pointCount++, oN(this, "afterInit");
        }
        isValid() {
          return (oX(this.x) || this.x instanceof Date) && oX(this.y);
        }
        optionsToObject(t10) {
          let e10 = this.series, i10 = e10.options.keys, s10 = i10 || e10.pointArrayMap || ["y"], o10 = s10.length, r10 = {}, a10, n10 = 0, l10 = 0;
          if (oX(t10) || null === t10) r10[s10[0]] = t10;
          else if (oW(t10)) for (!i10 && t10.length > o10 && ("string" == (a10 = typeof t10[0]) ? e10.xAxis?.dateTime ? r10.x = e10.chart.time.parse(t10[0]) : r10.name = t10[0] : "number" === a10 && (r10.x = t10[0]), n10++); l10 < o10; ) i10 && void 0 === t10[n10] || (s10[l10].indexOf(".") > 0 ? oZ.prototype.setNestedProperty(r10, t10[n10], s10[l10]) : r10[s10[l10]] = t10[n10]), n10++, l10++;
          else "object" == typeof t10 && (r10 = t10, t10.dataLabels && (e10.hasDataLabels = () => true), t10.marker && (e10._hasPointMarkers = true));
          return r10;
        }
        pos(t10, e10 = this.plotY) {
          if (!this.destroyed) {
            let {
              plotX: i10,
              series: s10
            } = this, {
              chart: o10,
              xAxis: r10,
              yAxis: a10
            } = s10, n10 = 0, l10 = 0;
            if (oX(i10) && oX(e10)) return t10 && (n10 = r10 ? r10.pos : o10.plotLeft, l10 = a10 ? a10.pos : o10.plotTop), o10.inverted && r10 && a10 ? [a10.len - e10 + l10, r10.len - i10 + n10] : [i10 + n10, e10 + l10];
          }
        }
        resolveColor() {
          let t10 = this.series, e10 = t10.chart.options.chart, i10 = t10.chart.styledMode, s10, o10, r10 = e10.colorCount, a10;
          delete this.nonZonedColor, t10.options.colorByPoint ? (i10 || (s10 = (o10 = t10.options.colors || t10.chart.options.colors)[t10.colorCounter], r10 = o10.length), a10 = t10.colorCounter, t10.colorCounter++, t10.colorCounter === r10 && (t10.colorCounter = 0)) : (i10 || (s10 = t10.color), a10 = t10.colorIndex), this.colorIndex = oH(this.options.colorIndex, a10), this.color = oH(this.options.color, s10);
        }
        setNestedProperty(t10, e10, i10) {
          return i10.split(".").reduce(function(t11, i11, s10, o10) {
            let r10 = o10.length - 1 === s10;
            return t11[i11] = r10 ? e10 : oG(t11[i11], true) ? t11[i11] : {}, t11[i11];
          }, t10), t10;
        }
        shouldDraw() {
          return !this.isNull;
        }
        tooltipFormatter(t10) {
          let {
            chart: e10,
            pointArrayMap: i10 = ["y"],
            tooltipOptions: s10
          } = this.series, {
            valueDecimals: o10 = "",
            valuePrefix: r10 = "",
            valueSuffix: a10 = ""
          } = s10;
          return e10.styledMode && (t10 = e10.tooltip?.styledModeFormat(t10) || t10), i10.forEach((e11) => {
            e11 = "{point." + e11, (r10 || a10) && (t10 = t10.replace(RegExp(e11 + "}", "g"), r10 + e11 + "}" + a10)), t10 = t10.replace(RegExp(e11 + "}", "g"), e11 + ":,." + o10 + "f}");
          }), oE(t10, this, e10);
        }
        update(t10, e10, i10, s10) {
          let o10;
          let r10 = this, a10 = r10.series, n10 = r10.graphic, l10 = a10.chart, h10 = a10.options;
          function d10() {
            r10.applyOptions(t10);
            let s11 = n10 && r10.hasMockGraphic, d11 = null === r10.y ? !s11 : s11;
            n10 && d11 && (r10.graphic = n10.destroy(), delete r10.hasMockGraphic), oG(t10, true) && (n10 && n10.element && t10 && t10.marker && void 0 !== t10.marker.symbol && (r10.graphic = n10.destroy()), t10?.dataLabels && r10.dataLabel && (r10.dataLabel = r10.dataLabel.destroy())), o10 = r10.index;
            let c10 = {};
            for (let t11 of a10.dataColumnKeys()) c10[t11] = r10[t11];
            a10.dataTable.setRow(c10, o10), h10.data[o10] = oG(h10.data[o10], true) || oG(t10, true) ? r10.options : oH(t10, h10.data[o10]), a10.isDirty = a10.isDirtyData = true, !a10.fixedBox && a10.hasCartesianSeries && (l10.isDirtyBox = true), "point" === h10.legendType && (l10.isDirtyLegend = true), e10 && l10.redraw(i10);
          }
          e10 = oH(e10, true), false === s10 ? d10() : r10.firePointEvent("update", {
            options: t10
          }, d10);
        }
        remove(t10, e10) {
          this.series.removePoint(this.series.data.indexOf(this), t10, e10);
        }
        select(t10, e10) {
          let i10 = this, s10 = i10.series, o10 = s10.chart;
          t10 = oH(t10, !i10.selected), this.selectedStaging = t10, i10.firePointEvent(t10 ? "select" : "unselect", {
            accumulate: e10
          }, function() {
            i10.selected = i10.options.selected = t10, s10.options.data[s10.data.indexOf(i10)] = i10.options, i10.setState(t10 && "select"), e10 || o10.getSelectedPoints().forEach(function(t11) {
              let e11 = t11.series;
              t11.selected && t11 !== i10 && (t11.selected = t11.options.selected = false, e11.options.data[e11.data.indexOf(t11)] = t11.options, t11.setState(o10.hoverPoints && e11.options.inactiveOtherPoints ? "inactive" : ""), t11.firePointEvent("unselect"));
            });
          }), delete this.selectedStaging;
        }
        onMouseOver(t10) {
          let {
            inverted: e10,
            pointer: i10
          } = this.series.chart;
          i10 && (t10 = t10 ? i10.normalize(t10) : i10.getChartCoordinatesFromPoint(this, e10), i10.runPointActions(t10, this));
        }
        onMouseOut() {
          let t10 = this.series.chart;
          this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t10.hoverPoints || []).forEach(function(t11) {
            t11.setState();
          }), t10.hoverPoints = t10.hoverPoint = null;
        }
        manageEvent(t10) {
          let e10 = oF(this.series.options.point, this.options), i10 = e10.events?.[t10];
          oj(i10) && (!this.hcEvents?.[t10] || this.hcEvents?.[t10]?.map((t11) => t11.fn).indexOf(i10) === -1) ? (this.importedUserEvent?.(), this.importedUserEvent = oI(this, t10, i10), this.hcEvents && (this.hcEvents[t10].userEvent = true)) : this.importedUserEvent && !i10 && this.hcEvents?.[t10] && this.hcEvents?.[t10].userEvent && (oV(this, t10), delete this.hcEvents[t10], Object.keys(this.hcEvents) || delete this.importedUserEvent);
        }
        setState(t10, e10) {
          let i10 = this.series, s10 = this.state, o10 = i10.options.states[t10 || "normal"] || {}, r10 = oO.plotOptions[i10.type].marker && i10.options.marker, a10 = r10 && false === r10.enabled, n10 = r10 && r10.states && r10.states[t10 || "normal"] || {}, l10 = false === n10.enabled, h10 = this.marker || {}, d10 = i10.chart, c10 = r10 && i10.markerAttribs, p4 = i10.halo, u2, g2, m2, f2 = i10.stateMarkerGraphic, x2;
          if ((t10 = t10 || "") === this.state && !e10 || this.selected && "select" !== t10 || false === o10.enabled || t10 && (l10 || a10 && false === n10.enabled) || t10 && h10.states && h10.states[t10] && false === h10.states[t10].enabled) return;
          if (this.state = t10, c10 && (u2 = i10.markerAttribs(this, t10)), this.graphic && !this.hasMockGraphic) {
            if (s10 && this.graphic.removeClass("highcharts-point-" + s10), t10 && this.graphic.addClass("highcharts-point-" + t10), !d10.styledMode) {
              g2 = i10.pointAttribs(this, t10), m2 = oH(d10.options.chart.animation, o10.animation);
              let e11 = g2.opacity;
              i10.options.inactiveOtherPoints && oX(e11) && (this.dataLabels || []).forEach(function(t11) {
                t11 && !t11.hasClass("highcharts-data-label-hidden") && (t11.animate({
                  opacity: e11
                }, m2), t11.connector && t11.connector.animate({
                  opacity: e11
                }, m2));
              }), this.graphic.animate(g2, m2);
            }
            u2 && this.graphic.animate(u2, oH(d10.options.chart.animation, n10.animation, r10.animation)), f2 && f2.hide();
          } else t10 && n10 && (x2 = h10.symbol || i10.symbol, f2 && f2.currentSymbol !== x2 && (f2 = f2.destroy()), u2 && (f2 ? f2[e10 ? "animate" : "attr"]({
            x: u2.x,
            y: u2.y
          }) : x2 && (i10.stateMarkerGraphic = f2 = d10.renderer.symbol(x2, u2.x, u2.y, u2.width, u2.height, oF(r10, n10)).add(i10.markerGroup), f2.currentSymbol = x2)), !d10.styledMode && f2 && "inactive" !== this.state && f2.attr(i10.pointAttribs(this, t10))), f2 && (f2[t10 && this.isInside ? "show" : "hide"](), f2.element.point = this, f2.addClass(this.getClassName(), true));
          let y2 = o10.halo, b2 = this.graphic || f2, v2 = b2 && b2.visibility || "inherit";
          y2 && y2.size && b2 && "hidden" !== v2 && !this.isCluster ? (p4 || (i10.halo = p4 = d10.renderer.path().add(b2.parentGroup)), p4.show()[e10 ? "animate" : "attr"]({
            d: this.haloPath(y2.size)
          }), p4.attr({
            class: "highcharts-halo highcharts-color-" + oH(this.colorIndex, i10.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: v2,
            zIndex: -1
          }), p4.point = this, d10.styledMode || p4.attr(oz({
            fill: this.color || i10.color,
            "fill-opacity": y2.opacity
          }, t3.filterUserAttributes(y2.attributes || {})))) : p4?.point?.haloPath && !p4.point.destroyed && p4.animate({
            d: p4.point.haloPath(0)
          }, null, p4.hide), oN(this, "afterSetState", {
            state: t10
          });
        }
        haloPath(t10) {
          let e10 = this.pos();
          return e10 ? this.series.chart.renderer.symbols.circle(oD(e10[0], 1) - t10, e10[1] - t10, 2 * t10, 2 * t10) : [];
        }
      }
      let o$ = oZ, {
        parse: o_
      } = tA, {
        charts: oq,
        composed: oK,
        isTouchDevice: oJ
      } = A, {
        addEvent: oQ,
        attr: o0,
        css: o1,
        extend: o2,
        find: o3,
        fireEvent: o6,
        isNumber: o5,
        isObject: o9,
        objectEach: o8,
        offset: o4,
        pick: o7,
        pushUnique: rt,
        splat: re
      } = J;
      class ri {
        applyInactiveState(t10) {
          let e10 = [], i10;
          (t10 || []).forEach(function(t11) {
            i10 = t11.series, e10.push(i10), i10.linkedParent && e10.push(i10.linkedParent), i10.linkedSeries && (e10 = e10.concat(i10.linkedSeries)), i10.navigatorSeries && e10.push(i10.navigatorSeries);
          }), this.chart.series.forEach(function(t11) {
            -1 === e10.indexOf(t11) ? t11.setState("inactive", true) : t11.options.inactiveOtherPoints && t11.setAllPointsToState("inactive");
          });
        }
        destroy() {
          let t10 = this;
          this.eventsToUnbind.forEach((t11) => t11()), this.eventsToUnbind = [], !A.chartCount && (ri.unbindDocumentMouseUp.forEach((t11) => t11.unbind()), ri.unbindDocumentMouseUp.length = 0, ri.unbindDocumentTouchEnd && (ri.unbindDocumentTouchEnd = ri.unbindDocumentTouchEnd())), clearInterval(t10.tooltipTimeout), o8(t10, function(e10, i10) {
            t10[i10] = void 0;
          });
        }
        getSelectionMarkerAttrs(t10, e10) {
          let i10 = {
            args: {
              chartX: t10,
              chartY: e10
            },
            attrs: {},
            shapeType: "rect"
          };
          return o6(this, "getSelectionMarkerAttrs", i10, (i11) => {
            let s10;
            let {
              chart: o10,
              zoomHor: r10,
              zoomVert: a10
            } = this, {
              mouseDownX: n10 = 0,
              mouseDownY: l10 = 0
            } = o10, h10 = i11.attrs;
            h10.x = o10.plotLeft, h10.y = o10.plotTop, h10.width = r10 ? 1 : o10.plotWidth, h10.height = a10 ? 1 : o10.plotHeight, r10 && (s10 = t10 - n10, h10.width = Math.max(1, Math.abs(s10)), h10.x = (s10 > 0 ? 0 : s10) + n10), a10 && (s10 = e10 - l10, h10.height = Math.max(1, Math.abs(s10)), h10.y = (s10 > 0 ? 0 : s10) + l10);
          }), i10;
        }
        drag(t10) {
          let {
            chart: e10
          } = this, {
            mouseDownX: i10 = 0,
            mouseDownY: s10 = 0
          } = e10, {
            panning: o10,
            panKey: r10,
            selectionMarkerFill: a10
          } = e10.options.chart, n10 = e10.plotLeft, l10 = e10.plotTop, h10 = e10.plotWidth, d10 = e10.plotHeight, c10 = o9(o10) ? o10.enabled : o10, p4 = r10 && t10[`${r10}Key`], u2 = t10.chartX, g2 = t10.chartY, m2, f2 = this.selectionMarker;
          if ((!f2 || !f2.touch) && (u2 < n10 ? u2 = n10 : u2 > n10 + h10 && (u2 = n10 + h10), g2 < l10 ? g2 = l10 : g2 > l10 + d10 && (g2 = l10 + d10), this.hasDragged = Math.sqrt(Math.pow(i10 - u2, 2) + Math.pow(s10 - g2, 2)), this.hasDragged > 10)) {
            m2 = e10.isInsidePlot(i10 - n10, s10 - l10, {
              visiblePlotOnly: true
            });
            let {
              shapeType: r11,
              attrs: h11
            } = this.getSelectionMarkerAttrs(u2, g2);
            (e10.hasCartesianSeries || e10.mapView) && this.hasZoom && m2 && !p4 && !f2 && (this.selectionMarker = f2 = e10.renderer[r11](), f2.attr({
              class: "highcharts-selection-marker",
              zIndex: 7
            }).add(), e10.styledMode || f2.attr({
              fill: a10 || o_("#334eff").setOpacity(0.25).get()
            })), f2 && f2.attr(h11), m2 && !f2 && c10 && e10.pan(t10, o10);
          }
        }
        dragStart(t10) {
          let e10 = this.chart;
          e10.mouseIsDown = t10.type, e10.cancelClick = false, e10.mouseDownX = t10.chartX, e10.mouseDownY = t10.chartY;
        }
        getSelectionBox(t10) {
          let e10 = {
            args: {
              marker: t10
            },
            result: t10.getBBox()
          };
          return o6(this, "getSelectionBox", e10), e10.result;
        }
        drop(t10) {
          let e10;
          let {
            chart: i10,
            selectionMarker: s10
          } = this;
          for (let t11 of i10.axes) t11.isPanning && (t11.isPanning = false, (t11.options.startOnTick || t11.options.endOnTick || t11.series.some((t12) => t12.boosted)) && (t11.forceRedraw = true, t11.setExtremes(t11.userMin, t11.userMax, false), e10 = true));
          if (e10 && i10.redraw(), s10 && t10) {
            if (this.hasDragged) {
              let e11 = this.getSelectionBox(s10);
              i10.transform({
                axes: i10.axes.filter((t11) => t11.zoomEnabled && ("xAxis" === t11.coll && this.zoomX || "yAxis" === t11.coll && this.zoomY)),
                selection: __spreadValues({
                  originalEvent: t10,
                  xAxis: [],
                  yAxis: []
                }, e11),
                from: e11
              });
            }
            o5(i10.index) && (this.selectionMarker = s10.destroy());
          }
          i10 && o5(i10.index) && (o1(i10.container, {
            cursor: i10._cursor
          }), i10.cancelClick = this.hasDragged > 10, i10.mouseIsDown = false, this.hasDragged = 0, this.pinchDown = []);
        }
        findNearestKDPoint(t10, e10, i10) {
          let s10;
          return t10.forEach(function(t11) {
            let o10 = !(t11.noSharedTooltip && e10) && 0 > t11.options.findNearestPointBy.indexOf("y"), r10 = t11.searchPoint(i10, o10);
            o9(r10, true) && r10.series && (!o9(s10, true) || function(t12, i11) {
              let s11 = t12.distX - i11.distX, o11 = t12.dist - i11.dist, r11 = i11.series.group?.zIndex - t12.series.group?.zIndex;
              return 0 !== s11 && e10 ? s11 : 0 !== o11 ? o11 : 0 !== r11 ? r11 : t12.series.index > i11.series.index ? -1 : 1;
            }(s10, r10) > 0) && (s10 = r10);
          }), s10;
        }
        getChartCoordinatesFromPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = t10.series, o10 = t10.shapeArgs;
          if (i10 && s10) {
            let r10 = t10.clientX ?? t10.plotX ?? 0, a10 = t10.plotY || 0;
            return t10.isNode && o10 && o5(o10.x) && o5(o10.y) && (r10 = o10.x, a10 = o10.y), e10 ? {
              chartX: s10.len + s10.pos - a10,
              chartY: i10.len + i10.pos - r10
            } : {
              chartX: r10 + i10.pos,
              chartY: a10 + s10.pos
            };
          }
          if (o10 && o10.x && o10.y) return {
            chartX: o10.x,
            chartY: o10.y
          };
        }
        getChartPosition() {
          if (this.chartPosition) return this.chartPosition;
          let {
            container: t10
          } = this.chart, e10 = o4(t10);
          this.chartPosition = {
            left: e10.left,
            top: e10.top,
            scaleX: 1,
            scaleY: 1
          };
          let {
            offsetHeight: i10,
            offsetWidth: s10
          } = t10;
          return s10 > 2 && i10 > 2 && (this.chartPosition.scaleX = e10.width / s10, this.chartPosition.scaleY = e10.height / i10), this.chartPosition;
        }
        getCoordinates(t10) {
          let e10 = {
            xAxis: [],
            yAxis: []
          };
          for (let i10 of this.chart.axes) e10[i10.isXAxis ? "xAxis" : "yAxis"].push({
            axis: i10,
            value: i10.toValue(t10[i10.horiz ? "chartX" : "chartY"])
          });
          return e10;
        }
        getHoverData(t10, e10, i10, s10, o10, r10) {
          let a10 = [], n10 = function(t11) {
            return t11.visible && !(!o10 && t11.directTouch) && o7(t11.options.enableMouseTracking, true);
          }, l10 = e10, h10, d10 = {
            chartX: r10 ? r10.chartX : void 0,
            chartY: r10 ? r10.chartY : void 0,
            shared: o10
          };
          o6(this, "beforeGetHoverData", d10), h10 = l10 && !l10.stickyTracking ? [l10] : i10.filter((t11) => t11.stickyTracking && (d10.filter || n10)(t11));
          let c10 = s10 && t10 || !r10 ? t10 : this.findNearestKDPoint(h10, o10, r10);
          return l10 = c10 && c10.series, c10 && (o10 && !l10.noSharedTooltip ? (h10 = i10.filter(function(t11) {
            return d10.filter ? d10.filter(t11) : n10(t11) && !t11.noSharedTooltip;
          })).forEach(function(t11) {
            let e11 = o3(t11.points, function(t12) {
              return t12.x === c10.x && !t12.isNull;
            });
            o9(e11) && (t11.boosted && t11.boost && (e11 = t11.boost.getPoint(e11)), a10.push(e11));
          }) : a10.push(c10)), o6(this, "afterGetHoverData", d10 = {
            hoverPoint: c10
          }), {
            hoverPoint: d10.hoverPoint,
            hoverSeries: l10,
            hoverPoints: a10
          };
        }
        getPointFromEvent(t10) {
          let e10 = t10.target, i10;
          for (; e10 && !i10; ) i10 = e10.point, e10 = e10.parentNode;
          return i10;
        }
        onTrackerMouseOut(t10) {
          let e10 = this.chart, i10 = t10.relatedTarget, s10 = e10.hoverSeries;
          this.isDirectTouch = false, !s10 || !i10 || s10.stickyTracking || this.inClass(i10, "highcharts-tooltip") || this.inClass(i10, "highcharts-series-" + s10.index) && this.inClass(i10, "highcharts-tracker") || s10.onMouseOut();
        }
        inClass(t10, e10) {
          let i10 = t10, s10;
          for (; i10; ) {
            if (s10 = o0(i10, "class")) {
              if (-1 !== s10.indexOf(e10)) return true;
              if (-1 !== s10.indexOf("highcharts-container")) return false;
            }
            i10 = i10.parentElement;
          }
        }
        constructor(t10, e10) {
          this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e10, this.chart = t10, this.runChartClick = !!e10.chart.events?.click, this.pinchDown = [], this.setDOMEvents(), o6(this, "afterInit");
        }
        normalize(t10, e10) {
          let i10 = t10.touches, s10 = i10 ? i10.length ? i10.item(0) : o7(i10.changedTouches, t10.changedTouches)[0] : t10;
          e10 || (e10 = this.getChartPosition());
          let o10 = s10.pageX - e10.left, r10 = s10.pageY - e10.top;
          return o2(t10, {
            chartX: Math.round(o10 /= e10.scaleX),
            chartY: Math.round(r10 /= e10.scaleY)
          });
        }
        onContainerClick(t10) {
          let e10 = this.chart, i10 = e10.hoverPoint, s10 = this.normalize(t10), o10 = e10.plotLeft, r10 = e10.plotTop;
          !e10.cancelClick && (i10 && this.inClass(s10.target, "highcharts-tracker") ? (o6(i10.series, "click", o2(s10, {
            point: i10
          })), e10.hoverPoint && i10.firePointEvent("click", s10)) : (o2(s10, this.getCoordinates(s10)), e10.isInsidePlot(s10.chartX - o10, s10.chartY - r10, {
            visiblePlotOnly: true
          }) && o6(e10, "click", s10)));
        }
        onContainerMouseDown(t10) {
          let e10 = (1 & (t10.buttons || t10.button)) == 1;
          t10 = this.normalize(t10), A.isFirefox && 0 !== t10.button && this.onContainerMouseMove(t10), (void 0 === t10.button || e10) && (this.zoomOption(t10), e10 && t10.preventDefault?.(), this.dragStart(t10));
        }
        onContainerMouseLeave(t10) {
          let {
            pointer: e10
          } = oq[o7(ri.hoverChartIndex, -1)] || {};
          t10 = this.normalize(t10), this.onContainerMouseMove(t10), e10 && !this.inClass(t10.relatedTarget, "highcharts-tooltip") && (e10.reset(), e10.chartPosition = void 0);
        }
        onContainerMouseEnter() {
          delete this.chartPosition;
        }
        onContainerMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.normalize(t10);
          this.setHoverChartIndex(t10), ("mousedown" === e10.mouseIsDown || this.touchSelect(s10)) && this.drag(s10), !e10.openMenu && (this.inClass(s10.target, "highcharts-tracker") || e10.isInsidePlot(s10.chartX - e10.plotLeft, s10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          })) && !(i10 && i10.shouldStickOnContact(s10)) && (this.inClass(s10.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(s10));
        }
        onDocumentTouchEnd(t10) {
          this.onDocumentMouseUp(t10);
        }
        onContainerTouchMove(t10) {
          this.touchSelect(t10) ? this.onContainerMouseMove(t10) : this.touch(t10);
        }
        onContainerTouchStart(t10) {
          this.touchSelect(t10) ? this.onContainerMouseDown(t10) : (this.zoomOption(t10), this.touch(t10, true));
        }
        onDocumentMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.chartPosition, o10 = this.normalize(t10, s10);
          !s10 || e10.isInsidePlot(o10.chartX - e10.plotLeft, o10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          }) || i10 && i10.shouldStickOnContact(o10) || o10.target !== e10.container.ownerDocument && this.inClass(o10.target, "highcharts-tracker") || this.reset();
        }
        onDocumentMouseUp(t10) {
          oq[o7(ri.hoverChartIndex, -1)]?.pointer?.drop(t10);
        }
        pinch(t10) {
          let e10 = this, {
            chart: i10,
            hasZoom: s10,
            lastTouches: o10
          } = e10, r10 = [].map.call(t10.touches || [], (t11) => e10.normalize(t11)), a10 = r10.length, n10 = 1 === a10 && (e10.inClass(t10.target, "highcharts-tracker") && i10.runTrackerClick || e10.runChartClick), l10 = i10.tooltip, h10 = 1 === a10 && o7(l10?.options.followTouchMove, true);
          a10 > 1 ? e10.initiated = true : h10 && (e10.initiated = false), s10 && e10.initiated && !n10 && false !== t10.cancelable && t10.preventDefault(), "touchstart" === t10.type ? (e10.pinchDown = r10, e10.res = true, i10.mouseDownX = t10.chartX) : h10 ? this.runPointActions(e10.normalize(t10)) : o10 && (o6(i10, "touchpan", {
            originalEvent: t10,
            touches: r10
          }, () => {
            let e11 = (t11) => {
              let e12 = t11[0], i11 = t11[1] || e12;
              return {
                x: e12.chartX,
                y: e12.chartY,
                width: i11.chartX - e12.chartX,
                height: i11.chartY - e12.chartY
              };
            };
            i10.transform({
              axes: i10.axes.filter((t11) => t11.zoomEnabled && (this.zoomHor && t11.horiz || this.zoomVert && !t11.horiz)),
              to: e11(r10),
              from: e11(o10),
              trigger: t10.type
            });
          }), e10.res && (e10.res = false, this.reset(false, 0))), e10.lastTouches = r10;
        }
        reset(t10, e10) {
          let i10 = this.chart, s10 = i10.hoverSeries, o10 = i10.hoverPoint, r10 = i10.hoverPoints, a10 = i10.tooltip, n10 = a10 && a10.shared ? r10 : o10;
          t10 && n10 && re(n10).forEach(function(e11) {
            e11.series.isCartesian && void 0 === e11.plotX && (t10 = false);
          }), t10 ? a10 && n10 && re(n10).length && (a10.refresh(n10), a10.shared && r10 ? r10.forEach(function(t11) {
            t11.setState(t11.state, true), t11.series.isCartesian && (t11.series.xAxis.crosshair && t11.series.xAxis.drawCrosshair(null, t11), t11.series.yAxis.crosshair && t11.series.yAxis.drawCrosshair(null, t11));
          }) : o10 && (o10.setState(o10.state, true), i10.axes.forEach(function(t11) {
            t11.crosshair && o10.series[t11.coll] === t11 && t11.drawCrosshair(null, o10);
          }))) : (o10 && o10.onMouseOut(), r10 && r10.forEach(function(t11) {
            t11.setState();
          }), s10 && s10.onMouseOut(), a10 && a10.hide(e10), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i10.axes.forEach(function(t11) {
            t11.hideCrosshair();
          }), i10.hoverPoints = i10.hoverPoint = void 0);
        }
        runPointActions(t10, e10, i10) {
          let s10 = this.chart, o10 = s10.series, r10 = s10.tooltip && s10.tooltip.options.enabled ? s10.tooltip : void 0, a10 = !!r10 && r10.shared, n10 = e10 || s10.hoverPoint, l10 = n10 && n10.series || s10.hoverSeries, h10 = (!t10 || "touchmove" !== t10.type) && (!!e10 || l10 && l10.directTouch && this.isDirectTouch), d10 = this.getHoverData(n10, l10, o10, h10, a10, t10);
          n10 = d10.hoverPoint, l10 = d10.hoverSeries;
          let c10 = d10.hoverPoints, p4 = l10 && l10.tooltipOptions.followPointer && !l10.tooltipOptions.split, u2 = a10 && l10 && !l10.noSharedTooltip;
          if (n10 && (i10 || n10 !== s10.hoverPoint || r10 && r10.isHidden)) {
            if ((s10.hoverPoints || []).forEach(function(t11) {
              -1 === c10.indexOf(t11) && t11.setState();
            }), s10.hoverSeries !== l10 && l10.onMouseOver(), this.applyInactiveState(c10), (c10 || []).forEach(function(t11) {
              t11.setState("hover");
            }), s10.hoverPoint && s10.hoverPoint.firePointEvent("mouseOut"), !n10.series) return;
            s10.hoverPoints = c10, s10.hoverPoint = n10, n10.firePointEvent("mouseOver", void 0, () => {
              r10 && n10 && r10.refresh(u2 ? c10 : n10, t10);
            });
          } else if (p4 && r10 && !r10.isHidden) {
            let e11 = r10.getAnchor([{}], t10);
            s10.isInsidePlot(e11[0], e11[1], {
              visiblePlotOnly: true
            }) && r10.updatePosition({
              plotX: e11[0],
              plotY: e11[1]
            });
          }
          this.unDocMouseMove || (this.unDocMouseMove = oQ(s10.container.ownerDocument, "mousemove", (t11) => oq[ri.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(t11)), this.eventsToUnbind.push(this.unDocMouseMove)), s10.axes.forEach(function(e11) {
            let i11;
            let o11 = o7((e11.crosshair || {}).snap, true);
            !o11 || (i11 = s10.hoverPoint) && i11.series[e11.coll] === e11 || (i11 = o3(c10, (t11) => t11.series && t11.series[e11.coll] === e11)), i11 || !o11 ? e11.drawCrosshair(t10, i11) : e11.hideCrosshair();
          });
        }
        setDOMEvents() {
          let t10 = this.chart.container, e10 = t10.ownerDocument;
          t10.onmousedown = this.onContainerMouseDown.bind(this), t10.onmousemove = this.onContainerMouseMove.bind(this), t10.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(oQ(t10, "mouseenter", this.onContainerMouseEnter.bind(this)), oQ(t10, "mouseleave", this.onContainerMouseLeave.bind(this))), ri.unbindDocumentMouseUp.some((t11) => t11.doc === e10) || ri.unbindDocumentMouseUp.push({
            doc: e10,
            unbind: oQ(e10, "mouseup", this.onDocumentMouseUp.bind(this))
          });
          let i10 = this.chart.renderTo.parentElement;
          for (; i10 && "BODY" !== i10.tagName; ) this.eventsToUnbind.push(oQ(i10, "scroll", () => {
            delete this.chartPosition;
          })), i10 = i10.parentElement;
          this.eventsToUnbind.push(oQ(t10, "touchstart", this.onContainerTouchStart.bind(this), {
            passive: false
          }), oQ(t10, "touchmove", this.onContainerTouchMove.bind(this), {
            passive: false
          })), ri.unbindDocumentTouchEnd || (ri.unbindDocumentTouchEnd = oQ(e10, "touchend", this.onDocumentTouchEnd.bind(this), {
            passive: false
          })), this.setPointerCapture(), oQ(this.chart, "redraw", this.setPointerCapture.bind(this));
        }
        setPointerCapture() {
          if (!oJ) return;
          let t10 = this.pointerCaptureEventsToUnbind, e10 = this.chart, i10 = e10.container, s10 = o7(e10.options.tooltip?.followTouchMove, true) && e10.series.some((t11) => t11.options.findNearestPointBy.indexOf("y") > -1);
          !this.hasPointerCapture && s10 ? (t10.push(oQ(i10, "pointerdown", (t11) => {
            t11.target?.hasPointerCapture(t11.pointerId) && t11.target?.releasePointerCapture(t11.pointerId);
          }), oQ(i10, "pointermove", (t11) => {
            e10.pointer?.getPointFromEvent(t11)?.onMouseOver(t11);
          })), e10.styledMode || o1(i10, {
            "touch-action": "none"
          }), i10.className += " highcharts-no-touch-action", this.hasPointerCapture = true) : this.hasPointerCapture && !s10 && (t10.forEach((t11) => t11()), t10.length = 0, e10.styledMode || o1(i10, {
            "touch-action": o7(e10.options.chart.style?.["touch-action"], "manipulation")
          }), i10.className = i10.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = false);
        }
        setHoverChartIndex(t10) {
          let e10 = this.chart, i10 = A.charts[o7(ri.hoverChartIndex, -1)];
          if (i10 && i10 !== e10) {
            let s10 = {
              relatedTarget: e10.container
            };
            t10 && !t10?.relatedTarget && Object.assign({}, t10, s10), i10.pointer?.onContainerMouseLeave(t10 || s10);
          }
          i10 && i10.mouseIsDown || (ri.hoverChartIndex = e10.index);
        }
        touch(t10, e10) {
          let i10;
          let {
            chart: s10,
            pinchDown: o10 = []
          } = this;
          this.setHoverChartIndex(), 1 === (t10 = this.normalize(t10)).touches.length ? s10.isInsidePlot(t10.chartX - s10.plotLeft, t10.chartY - s10.plotTop, {
            visiblePlotOnly: true
          }) && !s10.openMenu ? (e10 && this.runPointActions(t10), "touchmove" === t10.type && (i10 = !!o10[0] && Math.pow(o10[0].chartX - t10.chartX, 2) + Math.pow(o10[0].chartY - t10.chartY, 2) >= 16), o7(i10, true) && this.pinch(t10)) : e10 && this.reset() : 2 === t10.touches.length && this.pinch(t10);
        }
        touchSelect(t10) {
          return !!(this.chart.zooming.singleTouch && t10.touches && 1 === t10.touches.length);
        }
        zoomOption(t10) {
          let e10 = this.chart, i10 = e10.inverted, s10 = e10.zooming.type || "", o10, r10;
          /touch/.test(t10.type) && (s10 = o7(e10.zooming.pinchType, s10)), this.zoomX = o10 = /x/.test(s10), this.zoomY = r10 = /y/.test(s10), this.zoomHor = o10 && !i10 || r10 && i10, this.zoomVert = r10 && !i10 || o10 && i10, this.hasZoom = o10 || r10;
        }
      }
      ri.unbindDocumentMouseUp = [], function(t10) {
        t10.compose = function(e10) {
          rt(oK, "Core.Pointer") && oQ(e10, "beforeRender", function() {
            this.pointer = new t10(this, this.options);
          });
        };
      }(ri || (ri = {}));
      let rs = ri, {
        fireEvent: ro,
        isArray: rr,
        objectEach: ra,
        uniqueKey: rn
      } = J, rl = class {
        constructor(t10 = {}) {
          this.autoId = !t10.id, this.columns = {}, this.id = t10.id || rn(), this.modified = this, this.rowCount = 0, this.versionTag = rn();
          let e10 = 0;
          ra(t10.columns || {}, (t11, i10) => {
            this.columns[i10] = t11.slice(), e10 = Math.max(e10, t11.length);
          }), this.applyRowCount(e10);
        }
        applyRowCount(t10) {
          this.rowCount = t10, ra(this.columns, (e10) => {
            rr(e10) && (e10.length = t10);
          });
        }
        getColumn(t10, e10) {
          return this.columns[t10];
        }
        getColumns(t10, e10) {
          return (t10 || Object.keys(this.columns)).reduce((t11, e11) => (t11[e11] = this.columns[e11], t11), {});
        }
        getRow(t10, e10) {
          return (e10 || Object.keys(this.columns)).map((e11) => this.columns[e11]?.[t10]);
        }
        setColumn(t10, e10 = [], i10 = 0, s10) {
          this.setColumns({
            [t10]: e10
          }, i10, s10);
        }
        setColumns(t10, e10, i10) {
          let s10 = this.rowCount;
          ra(t10, (t11, e11) => {
            this.columns[e11] = t11.slice(), s10 = t11.length;
          }), this.applyRowCount(s10), i10?.silent || (ro(this, "afterSetColumns"), this.versionTag = rn());
        }
        setRow(t10, e10 = this.rowCount, i10, s10) {
          let {
            columns: o10
          } = this, r10 = i10 ? this.rowCount + 1 : e10 + 1;
          ra(t10, (t11, a10) => {
            let n10 = o10[a10] || s10?.addColumns !== false && Array(r10);
            n10 && (i10 ? n10.splice(e10, 0, t11) : n10[e10] = t11, o10[a10] = n10);
          }), r10 > this.rowCount && this.applyRowCount(r10), s10?.silent || (ro(this, "afterSetRows"), this.versionTag = rn());
        }
      }, {
        extend: rh,
        merge: rd,
        pick: rc
      } = J;
      !function(t10) {
        function e10(t11, e11, i10) {
          let s10 = this.legendItem = this.legendItem || {}, {
            chart: o10,
            options: r10
          } = this, {
            baseline: a10 = 0,
            symbolWidth: n10,
            symbolHeight: l10
          } = t11, h10 = this.symbol || "circle", d10 = l10 / 2, c10 = o10.renderer, p4 = s10.group, u2 = a10 - Math.round((t11.fontMetrics?.b || l10) * (i10 ? 0.4 : 0.3)), g2 = {}, m2, f2 = r10.marker, x2 = 0;
          if (o10.styledMode || (g2["stroke-width"] = Math.min(r10.lineWidth || 0, 24), r10.dashStyle ? g2.dashstyle = r10.dashStyle : "square" === r10.linecap || (g2["stroke-linecap"] = "round")), s10.line = c10.path().addClass("highcharts-graph").attr(g2).add(p4), i10 && (s10.area = c10.path().addClass("highcharts-area").add(p4)), g2["stroke-linecap"] && (x2 = Math.min(s10.line.strokeWidth(), n10) / 2), n10) {
            let t12 = [["M", x2, u2], ["L", n10 - x2, u2]];
            s10.line.attr({
              d: t12
            }), s10.area?.attr({
              d: [...t12, ["L", n10 - x2, a10], ["L", x2, a10]]
            });
          }
          if (f2 && false !== f2.enabled && n10) {
            let t12 = Math.min(rc(f2.radius, d10), d10);
            0 === h10.indexOf("url") && (f2 = rd(f2, {
              width: l10,
              height: l10
            }), t12 = 0), s10.symbol = m2 = c10.symbol(h10, n10 / 2 - t12, u2 - t12, 2 * t12, 2 * t12, rh({
              context: "legend"
            }, f2)).addClass("highcharts-point").add(p4), m2.isMarker = true;
          }
        }
        t10.areaMarker = function(t11, i10) {
          e10.call(this, t11, i10, true);
        }, t10.lineMarker = e10, t10.rectangle = function(t11, e11) {
          let i10 = e11.legendItem || {}, s10 = t11.options, o10 = t11.symbolHeight, r10 = s10.squareSymbol, a10 = r10 ? o10 : t11.symbolWidth;
          i10.symbol = this.chart.renderer.rect(r10 ? (t11.symbolWidth - o10) / 2 : 0, t11.baseline - o10 + 1, a10, o10, rc(t11.options.symbolRadius, o10 / 2)).addClass("highcharts-point").attr({
            zIndex: 3
          }).add(i10.group);
        };
      }(c || (c = {}));
      let rp = c, {
        defaultOptions: ru
      } = tw, {
        extend: rg,
        extendClass: rm,
        merge: rf
      } = J;
      !function(t10) {
        function e10(e11, i10) {
          let s10 = ru.plotOptions || {}, o10 = i10.defaultOptions, r10 = i10.prototype;
          return r10.type = e11, r10.pointClass || (r10.pointClass = o$), !t10.seriesTypes[e11] && (o10 && (s10[e11] = o10), t10.seriesTypes[e11] = i10, true);
        }
        t10.seriesTypes = A.seriesTypes, t10.registerSeriesType = e10, t10.seriesType = function(i10, s10, o10, r10, a10) {
          let n10 = ru.plotOptions || {};
          if (s10 = s10 || "", n10[i10] = rf(n10[s10], o10), delete t10.seriesTypes[i10], e10(i10, rm(t10.seriesTypes[s10] || function() {
          }, r10)), t10.seriesTypes[i10].prototype.type = i10, a10) {
            class e11 extends o$ {
            }
            rg(e11.prototype, a10), t10.seriesTypes[i10].prototype.pointClass = e11;
          }
          return t10.seriesTypes[i10];
        };
      }(p || (p = {}));
      let rx = p, {
        animObject: ry,
        setAnimation: rb
      } = tH, {
        defaultOptions: rv
      } = tw, {
        registerEventOptions: rM
      } = i7, {
        svg: rw,
        win: rk
      } = A, {
        seriesTypes: rS
      } = rx, {
        arrayMax: rT,
        arrayMin: rC,
        clamp: rA,
        correctFloat: rP,
        crisp: rL,
        defined: rO,
        destroyObjectProperties: rE,
        diffObjects: rI,
        erase: rD,
        error: rB,
        extend: rz,
        find: rN,
        fireEvent: rR,
        getClosestDistance: rW,
        getNestedProperty: rj,
        insertItem: rX,
        isArray: rG,
        isNumber: rF,
        isString: rH,
        merge: rY,
        objectEach: rV,
        pick: rU,
        removeEvent: rZ,
        syncTimeout: r$
      } = J;
      class r_ {
        constructor() {
          this.zoneAxis = "y";
        }
        init(t10, e10) {
          let i10;
          rR(this, "init", {
            options: e10
          }), this.dataTable ?? (this.dataTable = new rl());
          let s10 = t10.series;
          this.eventsToUnbind = [], this.chart = t10, this.options = this.setOptions(e10);
          let o10 = this.options, r10 = false !== o10.visible;
          this.linkedSeries = [], this.bindAxes(), rz(this, {
            name: o10.name,
            state: "",
            visible: r10,
            selected: true === o10.selected
          }), rM(this, o10);
          let a10 = o10.events;
          (a10 && a10.click || o10.point && o10.point.events && o10.point.events.click || o10.allowPointSelect) && (t10.runTrackerClick = true), this.getColor(), this.getSymbol(), this.isCartesian && (t10.hasCartesianSeries = true), s10.length && (i10 = s10[s10.length - 1]), this._i = rU(i10 && i10._i, -1) + 1, this.opacity = this.options.opacity, t10.orderItems("series", rX(this, s10)), o10.dataSorting && o10.dataSorting.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o10.data, false), rR(this, "afterInit");
        }
        is(t10) {
          return rS[t10] && this instanceof rS[t10];
        }
        bindAxes() {
          let t10;
          let e10 = this, i10 = e10.options, s10 = e10.chart;
          rR(this, "bindAxes", null, function() {
            (e10.axisTypes || []).forEach(function(o10) {
              (s10[o10] || []).forEach(function(s11) {
                t10 = s11.options, (rU(i10[o10], 0) === s11.index || void 0 !== i10[o10] && i10[o10] === t10.id) && (rX(e10, s11.series), e10[o10] = s11, s11.isDirty = true);
              }), e10[o10] || e10.optionalAxis === o10 || rB(18, true, s10);
            });
          }), rR(this, "afterBindAxes");
        }
        hasData() {
          return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;
        }
        hasMarkerChanged(t10, e10) {
          let i10 = t10.marker, s10 = e10.marker || {};
          return i10 && (s10.enabled && !i10.enabled || s10.symbol !== i10.symbol || s10.height !== i10.height || s10.width !== i10.width);
        }
        autoIncrement(t10) {
          let e10;
          let i10 = this.options, {
            pointIntervalUnit: s10,
            relativeXValue: o10
          } = this.options, r10 = this.chart.time, a10 = this.xIncrement ?? r10.parse(i10.pointStart) ?? 0;
          if (this.pointInterval = e10 = rU(this.pointInterval, i10.pointInterval, 1), o10 && rF(t10) && (e10 *= t10), s10) {
            let t11 = r10.toParts(a10);
            "day" === s10 ? t11[2] += e10 : "month" === s10 ? t11[1] += e10 : "year" === s10 && (t11[0] += e10), e10 = r10.makeTime.apply(r10, t11) - a10;
          }
          return o10 && rF(t10) ? a10 + e10 : (this.xIncrement = a10 + e10, a10);
        }
        setDataSortingOptions() {
          let t10 = this.options;
          rz(this, {
            requireSorting: false,
            sorted: false,
            enabledDataSorting: true,
            allowDG: false
          }), rO(t10.pointRange) || (t10.pointRange = 1);
        }
        setOptions(t10) {
          let e10;
          let i10 = this.chart, s10 = i10.options.plotOptions, o10 = i10.userOptions || {}, r10 = rY(t10), a10 = i10.styledMode, n10 = {
            plotOptions: s10,
            userOptions: r10
          };
          rR(this, "setOptions", n10);
          let l10 = n10.plotOptions[this.type], h10 = o10.plotOptions || {}, d10 = h10.series || {}, c10 = rv.plotOptions[this.type] || {}, p4 = h10[this.type] || {};
          this.userOptions = n10.userOptions;
          let u2 = rY(l10, s10.series, p4, r10);
          this.tooltipOptions = rY(rv.tooltip, rv.plotOptions.series?.tooltip, c10?.tooltip, i10.userOptions.tooltip, h10.series?.tooltip, p4.tooltip, r10.tooltip), this.stickyTracking = rU(r10.stickyTracking, p4.stickyTracking, d10.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || u2.stickyTracking), null === l10.marker && delete u2.marker, this.zoneAxis = u2.zoneAxis || "y";
          let g2 = this.zones = (u2.zones || []).map((t11) => __spreadValues({}, t11));
          return (u2.negativeColor || u2.negativeFillColor) && !u2.zones && (e10 = {
            value: u2[this.zoneAxis + "Threshold"] || u2.threshold || 0,
            className: "highcharts-negative"
          }, a10 || (e10.color = u2.negativeColor, e10.fillColor = u2.negativeFillColor), g2.push(e10)), g2.length && rO(g2[g2.length - 1].value) && g2.push(a10 ? {} : {
            color: this.color,
            fillColor: this.fillColor
          }), rR(this, "afterSetOptions", {
            options: u2
          }), u2;
        }
        getName() {
          return rU(this.options.name, "Series " + (this.index + 1));
        }
        getCyclic(t10, e10, i10) {
          let s10, o10;
          let r10 = this.chart, a10 = `${t10}Index`, n10 = `${t10}Counter`, l10 = i10?.length || r10.options.chart.colorCount;
          !e10 && (rO(o10 = rU("color" === t10 ? this.options.colorIndex : void 0, this[a10])) ? s10 = o10 : (r10.series.length || (r10[n10] = 0), s10 = r10[n10] % l10, r10[n10] += 1), i10 && (e10 = i10[s10])), void 0 !== s10 && (this[a10] = s10), this[t10] = e10;
        }
        getColor() {
          this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || rv.plotOptions[this.type].color, this.chart.options.colors);
        }
        getPointsCollection() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        }
        getSymbol() {
          let t10 = this.options.marker;
          this.getCyclic("symbol", t10.symbol, this.chart.options.symbols);
        }
        getColumn(t10, e10) {
          return (e10 ? this.dataTable.modified : this.dataTable).getColumn(t10, true) || [];
        }
        findPointIndex(t10, e10) {
          let i10, s10, o10;
          let r10 = t10.id, a10 = t10.x, n10 = this.points, l10 = this.options.dataSorting;
          if (r10) {
            let t11 = this.chart.get(r10);
            t11 instanceof o$ && (i10 = t11);
          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            let e11 = (e12) => !e12.touched && e12.index === t10.index;
            if (l10 && l10.matchByName ? e11 = (e12) => !e12.touched && e12.name === t10.name : this.options.relativeXValue && (e11 = (e12) => !e12.touched && e12.options.x === t10.x), !(i10 = rN(n10, e11))) return;
          }
          return i10 && void 0 !== (o10 = i10 && i10.index) && (s10 = true), void 0 === o10 && rF(a10) && (o10 = this.getColumn("x").indexOf(a10, e10)), -1 !== o10 && void 0 !== o10 && this.cropped && (o10 = o10 >= this.cropStart ? o10 - this.cropStart : o10), !s10 && rF(o10) && n10[o10] && n10[o10].touched && (o10 = void 0), o10;
        }
        updateData(t10, e10) {
          let i10 = this.options, s10 = i10.dataSorting, o10 = this.points, r10 = [], a10 = this.requireSorting, n10 = t10.length === o10.length, l10, h10, d10, c10, p4 = true;
          if (this.xIncrement = null, t10.forEach(function(t11, e11) {
            let h11;
            let d11 = rO(t11) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, t11) || {}, p7 = d11.x;
            d11.id || rF(p7) ? (-1 === (h11 = this.findPointIndex(d11, c10)) || void 0 === h11 ? r10.push(t11) : o10[h11] && t11 !== i10.data[h11] ? (o10[h11].update(t11, false, null, false), o10[h11].touched = true, a10 && (c10 = h11 + 1)) : o10[h11] && (o10[h11].touched = true), (!n10 || e11 !== h11 || s10 && s10.enabled || this.hasDerivedData) && (l10 = true)) : r10.push(t11);
          }, this), l10) for (h10 = o10.length; h10--; ) (d10 = o10[h10]) && !d10.touched && d10.remove && d10.remove(false, e10);
          else !n10 || s10 && s10.enabled ? p4 = false : (t10.forEach(function(t11, e11) {
            t11 === o10[e11].y || o10[e11].destroyed || o10[e11].update(t11, false, null, false);
          }), r10.length = 0);
          if (o10.forEach(function(t11) {
            t11 && (t11.touched = false);
          }), !p4) return false;
          r10.forEach(function(t11) {
            this.addPoint(t11, false, null, null, false);
          }, this);
          let u2 = this.getColumn("x");
          return null === this.xIncrement && u2.length && (this.xIncrement = rT(u2), this.autoIncrement()), true;
        }
        dataColumnKeys() {
          return ["x", ...this.pointArrayMap || ["y"]];
        }
        setData(t10, e10 = true, i10, s10) {
          let o10 = this.points, r10 = o10 && o10.length || 0, a10 = this.options, n10 = this.chart, l10 = a10.dataSorting, h10 = this.xAxis, d10 = a10.turboThreshold, c10 = this.dataTable, p4 = this.dataColumnKeys(), u2 = this.pointValKey || "y", g2 = (this.pointArrayMap || []).length, m2 = a10.keys, f2, x2, y2 = 0, b2 = 1, v2;
          n10.options.chart.allowMutatingData || (a10.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v2 = rY(true, t10));
          let M2 = (t10 = v2 || t10 || []).length;
          if (l10 && l10.enabled && (t10 = this.sortData(t10)), n10.options.chart.allowMutatingData && false !== s10 && M2 && r10 && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x2 = this.updateData(t10, i10)), !x2) {
            this.xIncrement = null, this.colorCounter = 0;
            let e11 = d10 && M2 > d10;
            if (e11) {
              let i11 = this.getFirstValidPoint(t10), s11 = this.getFirstValidPoint(t10, M2 - 1, -1), o11 = (t11) => !!(rG(t11) && (m2 || rF(t11[0])));
              if (rF(i11) && rF(s11)) {
                let e12 = [], i12 = [];
                for (let s12 of t10) e12.push(this.autoIncrement()), i12.push(s12);
                c10.setColumns({
                  x: e12,
                  [u2]: i12
                });
              } else if (o11(i11) && o11(s11)) {
                if (g2) {
                  let e12 = i11.length === g2 ? 1 : 0, s12 = Array(p4.length).fill(0).map(() => []);
                  for (let i12 of t10) {
                    e12 && s12[0].push(this.autoIncrement());
                    for (let t11 = e12; t11 <= g2; t11++) s12[t11]?.push(i12[t11 - e12]);
                  }
                  c10.setColumns(p4.reduce((t11, e13, i12) => (t11[e13] = s12[i12], t11), {}));
                } else {
                  m2 && (y2 = m2.indexOf("x"), b2 = m2.indexOf("y"), y2 = y2 >= 0 ? y2 : 0, b2 = b2 >= 0 ? b2 : 1), 1 === i11.length && (b2 = 0);
                  let e12 = [], s12 = [];
                  if (y2 === b2) for (let i12 of t10) e12.push(this.autoIncrement()), s12.push(i12[b2]);
                  else for (let i12 of t10) e12.push(i12[y2]), s12.push(i12[b2]);
                  c10.setColumns({
                    x: e12,
                    [u2]: s12
                  });
                }
              } else e11 = false;
            }
            if (!e11) {
              let e12 = p4.reduce((t11, e13) => (t11[e13] = [], t11), {});
              for (f2 = 0; f2 < M2; f2++) {
                let i11 = this.pointClass.prototype.applyOptions.apply({
                  series: this
                }, [t10[f2]]);
                for (let t11 of p4) e12[t11][f2] = i11[t11];
              }
              c10.setColumns(e12);
            }
            for (rH(this.getColumn("y")[0]) && rB(14, true, n10), this.data = [], this.options.data = this.userOptions.data = t10, f2 = r10; f2--; ) o10[f2]?.destroy();
            h10 && (h10.minRange = h10.userMinRange), this.isDirty = n10.isDirtyBox = true, this.isDirtyData = !!o10, i10 = false;
          }
          "point" === a10.legendType && (this.processData(), this.generatePoints()), e10 && n10.redraw(i10);
        }
        sortData(t10) {
          let e10 = this, i10 = e10.options.dataSorting.sortKey || "y", s10 = function(t11, e11) {
            return rO(e11) && t11.pointClass.prototype.optionsToObject.call({
              series: t11
            }, e11) || {};
          };
          return t10.forEach(function(i11, o10) {
            t10[o10] = s10(e10, i11), t10[o10].index = o10;
          }, this), t10.concat().sort((t11, e11) => {
            let s11 = rj(i10, t11), o10 = rj(i10, e11);
            return o10 < s11 ? -1 : o10 > s11 ? 1 : 0;
          }).forEach(function(t11, e11) {
            t11.x = e11;
          }, this), e10.linkedSeries && e10.linkedSeries.forEach(function(e11) {
            let i11 = e11.options, o10 = i11.data;
            i11.dataSorting && i11.dataSorting.enabled || !o10 || (o10.forEach(function(i12, r10) {
              o10[r10] = s10(e11, i12), t10[r10] && (o10[r10].x = t10[r10].x, o10[r10].index = r10);
            }), e11.setData(o10, false));
          }), t10;
        }
        getProcessedData(t10) {
          let e10 = this, {
            dataTable: i10,
            isCartesian: s10,
            options: o10,
            xAxis: r10
          } = e10, a10 = o10.cropThreshold, n10 = t10 || e10.getExtremesFromAll, l10 = r10?.logarithmic, h10 = i10.rowCount, d10, c10, p4 = 0, u2, g2, m2, f2 = e10.getColumn("x"), x2 = i10, y2 = false;
          return r10 && (g2 = (u2 = r10.getExtremes()).min, m2 = u2.max, y2 = !!(r10.categories && !r10.names.length), s10 && e10.sorted && !n10 && (!a10 || h10 > a10 || e10.forceCrop) && (f2[h10 - 1] < g2 || f2[0] > m2 ? x2 = new rl() : e10.getColumn(e10.pointValKey || "y").length && (f2[0] < g2 || f2[h10 - 1] > m2) && (x2 = (d10 = this.cropData(i10, g2, m2)).modified, p4 = d10.start, c10 = true))), f2 = x2.getColumn("x") || [], {
            modified: x2,
            cropped: c10,
            cropStart: p4,
            closestPointRange: rW([l10 ? f2.map(l10.log2lin) : f2], () => e10.requireSorting && !y2 && rB(15, false, e10.chart))
          };
        }
        processData(t10) {
          let e10 = this.xAxis, i10 = this.dataTable;
          if (this.isCartesian && !this.isDirty && !e10.isDirty && !this.yAxis.isDirty && !t10) return false;
          let s10 = this.getProcessedData();
          i10.modified = s10.modified, this.cropped = s10.cropped, this.cropStart = s10.cropStart, this.closestPointRange = this.basePointRange = s10.closestPointRange, rR(this, "afterProcessData");
        }
        cropData(t10, e10, i10) {
          let s10 = t10.getColumn("x", true) || [], o10 = s10.length, r10 = {}, a10, n10, l10 = 0, h10 = o10;
          for (a10 = 0; a10 < o10; a10++) if (s10[a10] >= e10) {
            l10 = Math.max(0, a10 - 1);
            break;
          }
          for (n10 = a10; n10 < o10; n10++) if (s10[n10] > i10) {
            h10 = n10 + 1;
            break;
          }
          for (let e11 of this.dataColumnKeys()) {
            let i11 = t10.getColumn(e11, true);
            i11 && (r10[e11] = i11.slice(l10, h10));
          }
          return {
            modified: new rl({
              columns: r10
            }),
            start: l10,
            end: h10
          };
        }
        generatePoints() {
          let t10 = this.options, e10 = this.processedData || t10.data, i10 = this.dataTable.modified, s10 = this.getColumn("x", true), o10 = this.pointClass, r10 = i10.rowCount, a10 = this.cropStart || 0, n10 = this.hasGroupedData, l10 = t10.keys, h10 = [], d10 = t10.dataGrouping && t10.dataGrouping.groupAll ? a10 : 0, c10 = this.xAxis?.categories, p4 = this.pointArrayMap || ["y"], u2 = this.dataColumnKeys(), g2, m2, f2, x2, y2 = this.data, b2;
          if (!y2 && !n10) {
            let t11 = [];
            t11.length = e10?.length || 0, y2 = this.data = t11;
          }
          for (l10 && n10 && (this.options.keys = false), x2 = 0; x2 < r10; x2++) m2 = a10 + x2, n10 ? ((f2 = new o10(this, i10.getRow(x2, u2) || [])).dataGroup = this.groupMap[d10 + x2], f2.dataGroup?.options && (f2.options = f2.dataGroup.options, rz(f2, f2.dataGroup.options), delete f2.dataLabels)) : (f2 = y2[m2], b2 = e10 ? e10[m2] : i10.getRow(x2, p4), f2 || void 0 === b2 || (y2[m2] = f2 = new o10(this, b2, s10[x2]))), f2 && (f2.index = n10 ? d10 + x2 : m2, h10[x2] = f2, f2.category = c10?.[f2.x] ?? f2.x, f2.key = f2.name ?? f2.category);
          if (this.options.keys = l10, y2 && (r10 !== (g2 = y2.length) || n10)) for (x2 = 0; x2 < g2; x2++) x2 !== a10 || n10 || (x2 += r10), y2[x2] && (y2[x2].destroyElements(), y2[x2].plotX = void 0);
          this.data = y2, this.points = h10, rR(this, "afterGeneratePoints");
        }
        getXExtremes(t10) {
          return {
            min: rC(t10),
            max: rT(t10)
          };
        }
        getExtremes(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = e10 || this.getExtremesFromAll || this.options.getExtremesFromAll, r10 = o10 && this.cropped ? this.dataTable : this.dataTable.modified, a10 = r10.rowCount, n10 = t10 || this.stackedYData, l10 = n10 ? [n10] : (this.keysAffectYAxis || this.pointArrayMap || ["y"])?.map((t11) => r10.getColumn(t11, true) || []) || [], h10 = this.getColumn("x", true), d10 = [], c10 = this.requireSorting && !this.is("column") ? 1 : 0, p4 = !!s10 && s10.positiveValuesOnly, u2 = o10 || this.cropped || !i10, g2, m2, f2, x2 = 0, y2 = 0;
          for (i10 && (x2 = (g2 = i10.getExtremes()).min, y2 = g2.max), f2 = 0; f2 < a10; f2++) if (m2 = h10[f2], u2 || (h10[f2 + c10] || m2) >= x2 && (h10[f2 - c10] || m2) <= y2) for (let t11 of l10) {
            let e11 = t11[f2];
            rF(e11) && (e11 > 0 || !p4) && d10.push(e11);
          }
          let b2 = {
            activeYData: d10,
            dataMin: rC(d10),
            dataMax: rT(d10)
          };
          return rR(this, "afterGetExtremes", {
            dataExtremes: b2
          }), b2;
        }
        applyExtremes() {
          let t10 = this.getExtremes();
          return this.dataMin = t10.dataMin, this.dataMax = t10.dataMax, t10;
        }
        getFirstValidPoint(t10, e10 = 0, i10 = 1) {
          let s10 = t10.length, o10 = e10;
          for (; o10 >= 0 && o10 < s10; ) {
            if (rO(t10[o10])) return t10[o10];
            o10 += i10;
          }
        }
        translate() {
          this.generatePoints();
          let t10 = this.options, e10 = t10.stacking, i10 = this.xAxis, s10 = this.enabledDataSorting, o10 = this.yAxis, r10 = this.points, a10 = r10.length, n10 = this.pointPlacementToXValue(), l10 = !!n10, h10 = t10.threshold, d10 = t10.startFromThreshold ? h10 : 0, c10, p4, u2, g2, m2 = Number.MAX_VALUE;
          function f2(t11) {
            return rA(t11, -1e9, 1e9);
          }
          for (c10 = 0; c10 < a10; c10++) {
            let t11;
            let a11 = r10[c10], x2 = a11.x, y2, b2, v2 = a11.y, M2 = a11.low, w2 = e10 && o10.stacking?.stacks[(this.negStacks && v2 < (d10 ? 0 : h10) ? "-" : "") + this.stackKey];
            p4 = i10.translate(x2, false, false, false, true, n10), a11.plotX = rF(p4) ? rP(f2(p4)) : void 0, e10 && this.visible && w2 && w2[x2] && (g2 = this.getStackIndicator(g2, x2, this.index), !a11.isNull && g2.key && (b2 = (y2 = w2[x2]).points[g2.key]), y2 && rG(b2) && (M2 = b2[0], v2 = b2[1], M2 === d10 && g2.key === w2[x2].base && (M2 = rU(rF(h10) ? h10 : o10.min)), o10.positiveValuesOnly && rO(M2) && M2 <= 0 && (M2 = void 0), a11.total = a11.stackTotal = rU(y2.total), a11.percentage = rO(a11.y) && y2.total ? a11.y / y2.total * 100 : void 0, a11.stackY = v2, this.irregularWidths || y2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a11.yBottom = rO(M2) ? f2(o10.translate(M2, false, true, false, true)) : void 0, this.dataModify && (v2 = this.dataModify.modifyValue(v2, c10)), rF(v2) && void 0 !== a11.plotX && (t11 = rF(t11 = o10.translate(v2, false, true, false, true)) ? f2(t11) : void 0), a11.plotY = t11, a11.isInside = this.isPointInside(a11), a11.clientX = l10 ? rP(i10.translate(x2, false, false, false, true, n10)) : p4, a11.negative = (a11.y || 0) < (h10 || 0), a11.isNull || false === a11.visible || (void 0 !== u2 && (m2 = Math.min(m2, Math.abs(p4 - u2))), u2 = p4), a11.zone = this.zones.length ? a11.getZone() : void 0, !a11.graphic && this.group && s10 && (a11.isNew = true);
          }
          this.closestPointRangePx = m2, rR(this, "afterTranslate");
        }
        getValidPoints(t10, e10, i10) {
          let s10 = this.chart;
          return (t10 || this.points || []).filter(function(t11) {
            let {
              plotX: o10,
              plotY: r10
            } = t11;
            return !!((i10 || !t11.isNull && rF(r10)) && (!e10 || s10.isInsidePlot(o10, r10, {
              inverted: s10.inverted
            }))) && false !== t11.visible;
          });
        }
        getClipBox() {
          let {
            chart: t10,
            xAxis: e10,
            yAxis: i10
          } = this, {
            x: s10,
            y: o10,
            width: r10,
            height: a10
          } = rY(t10.clipBox);
          return e10 && e10.len !== t10.plotSizeX && (r10 = e10.len), i10 && i10.len !== t10.plotSizeY && (a10 = i10.len), t10.inverted && !this.invertible && ([r10, a10] = [a10, r10]), {
            x: s10,
            y: o10,
            width: r10,
            height: a10
          };
        }
        getSharedClipKey() {
          return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
        }
        setClip() {
          let {
            chart: t10,
            group: e10,
            markerGroup: i10
          } = this, s10 = t10.sharedClips, o10 = t10.renderer, r10 = this.getClipBox(), a10 = this.getSharedClipKey(), n10 = s10[a10];
          n10 ? n10.animate(r10) : s10[a10] = n10 = o10.clipRect(r10), e10 && e10.clip(false === this.options.clip ? void 0 : n10), i10 && i10.clip();
        }
        animate(t10) {
          let {
            chart: e10,
            group: i10,
            markerGroup: s10
          } = this, o10 = e10.inverted, r10 = ry(this.options.animation), a10 = [this.getSharedClipKey(), r10.duration, r10.easing, r10.defer].join(","), n10 = e10.sharedClips[a10], l10 = e10.sharedClips[a10 + "m"];
          if (t10 && i10) {
            let t11 = this.getClipBox();
            if (n10) n10.attr("height", t11.height);
            else {
              t11.width = 0, o10 && (t11.x = e10.plotHeight), n10 = e10.renderer.clipRect(t11), e10.sharedClips[a10] = n10;
              let i11 = {
                x: -99,
                y: -99,
                width: o10 ? e10.plotWidth + 199 : 99,
                height: o10 ? 99 : e10.plotHeight + 199
              };
              l10 = e10.renderer.clipRect(i11), e10.sharedClips[a10 + "m"] = l10;
            }
            i10.clip(n10), s10?.clip(l10);
          } else if (n10 && !n10.hasClass("highcharts-animating")) {
            let t11 = this.getClipBox(), i11 = r10.step;
            (s10?.element.childNodes.length || e10.series.length > 1) && (r10.step = function(t12, e11) {
              i11 && i11.apply(e11, arguments), "width" === e11.prop && l10?.element && l10.attr(o10 ? "height" : "width", t12 + 99);
            }), n10.addClass("highcharts-animating").animate(t11, r10);
          }
        }
        afterAnimate() {
          this.setClip(), rV(this.chart.sharedClips, (t10, e10, i10) => {
            t10 && !this.chart.container.querySelector(`[clip-path="url(#${t10.id})"]`) && (t10.destroy(), delete i10[e10]);
          }), this.finishedAnimating = true, rR(this, "afterAnimate");
        }
        drawPoints(t10 = this.points) {
          let e10, i10, s10, o10, r10, a10, n10;
          let l10 = this.chart, h10 = l10.styledMode, {
            colorAxis: d10,
            options: c10
          } = this, p4 = c10.marker, u2 = this[this.specialGroup || "markerGroup"], g2 = this.xAxis, m2 = rU(p4.enabled, !g2 || !!g2.isRadial || null, this.closestPointRangePx >= p4.enabledThreshold * p4.radius);
          if (false !== p4.enabled || this._hasPointMarkers) for (e10 = 0; e10 < t10.length; e10++) if (o10 = (s10 = (i10 = t10[e10]).graphic) ? "animate" : "attr", r10 = i10.marker || {}, a10 = !!i10.marker, (m2 && void 0 === r10.enabled || r10.enabled) && !i10.isNull && false !== i10.visible) {
            let t11 = rU(r10.symbol, this.symbol, "rect");
            n10 = this.markerAttribs(i10, i10.selected && "select"), this.enabledDataSorting && (i10.startXPos = g2.reversed ? -(n10.width || 0) : g2.width);
            let e11 = false !== i10.isInside;
            if (!s10 && e11 && ((n10.width || 0) > 0 || i10.hasImage) && (i10.graphic = s10 = l10.renderer.symbol(t11, n10.x, n10.y, n10.width, n10.height, a10 ? r10 : p4).add(u2), this.enabledDataSorting && l10.hasRendered && (s10.attr({
              x: i10.startXPos
            }), o10 = "animate")), s10 && "animate" === o10 && s10[e11 ? "show" : "hide"](e11).animate(n10), s10) {
              let t12 = this.pointAttribs(i10, h10 || !i10.selected ? void 0 : "select");
              h10 ? d10 && s10.css({
                fill: t12.fill
              }) : s10[o10](t12);
            }
            s10 && s10.addClass(i10.getClassName(), true);
          } else s10 && (i10.graphic = s10.destroy());
        }
        markerAttribs(t10, e10) {
          let i10 = this.options, s10 = i10.marker, o10 = t10.marker || {}, r10 = o10.symbol || s10.symbol, a10 = {}, n10, l10, h10 = rU(o10.radius, s10 && s10.radius);
          e10 && (n10 = s10.states[e10], h10 = rU((l10 = o10.states && o10.states[e10]) && l10.radius, n10 && n10.radius, h10 && h10 + (n10 && n10.radiusPlus || 0))), t10.hasImage = r10 && 0 === r10.indexOf("url"), t10.hasImage && (h10 = 0);
          let d10 = t10.pos();
          return rF(h10) && d10 && (i10.crisp && (d10[0] = rL(d10[0], t10.hasImage ? 0 : "rect" === r10 ? s10?.lineWidth || 0 : 1)), a10.x = d10[0] - h10, a10.y = d10[1] - h10), h10 && (a10.width = a10.height = 2 * h10), a10;
        }
        pointAttribs(t10, e10) {
          let i10 = this.options.marker, s10 = t10 && t10.options, o10 = s10 && s10.marker || {}, r10 = s10 && s10.color, a10 = t10 && t10.color, n10 = t10 && t10.zone && t10.zone.color, l10, h10, d10 = this.color, c10, p4, u2 = rU(o10.lineWidth, i10.lineWidth), g2 = 1;
          return d10 = r10 || n10 || a10 || d10, c10 = o10.fillColor || i10.fillColor || d10, p4 = o10.lineColor || i10.lineColor || d10, e10 = e10 || "normal", l10 = i10.states[e10] || {}, u2 = rU((h10 = o10.states && o10.states[e10] || {}).lineWidth, l10.lineWidth, u2 + rU(h10.lineWidthPlus, l10.lineWidthPlus, 0)), c10 = h10.fillColor || l10.fillColor || c10, {
            stroke: p4 = h10.lineColor || l10.lineColor || p4,
            "stroke-width": u2,
            fill: c10,
            opacity: g2 = rU(h10.opacity, l10.opacity, g2)
          };
        }
        destroy(t10) {
          let e10, i10, s10;
          let o10 = this, r10 = o10.chart, a10 = /AppleWebKit\/533/.test(rk.navigator.userAgent), n10 = o10.data || [];
          for (rR(o10, "destroy", {
            keepEventsForUpdate: t10
          }), this.removeEvents(t10), (o10.axisTypes || []).forEach(function(t11) {
            (s10 = o10[t11]) && s10.series && (rD(s10.series, o10), s10.isDirty = s10.forceRedraw = true);
          }), o10.legendItem && o10.chart.legend.destroyItem(o10), e10 = n10.length; e10--; ) (i10 = n10[e10]) && i10.destroy && i10.destroy();
          for (let t11 of o10.zones) rE(t11, void 0, true);
          J.clearTimeout(o10.animationTimeout), rV(o10, function(t11, e11) {
            t11 instanceof eq && !t11.survive && t11[a10 && "group" === e11 ? "hide" : "destroy"]();
          }), r10.hoverSeries === o10 && (r10.hoverSeries = void 0), rD(r10.series, o10), r10.orderItems("series"), rV(o10, function(e11, i11) {
            t10 && "hcEvents" === i11 || delete o10[i11];
          });
        }
        applyZones() {
          let {
            area: t10,
            chart: e10,
            graph: i10,
            zones: s10,
            points: o10,
            xAxis: r10,
            yAxis: a10,
            zoneAxis: n10
          } = this, {
            inverted: l10,
            renderer: h10
          } = e10, d10 = this[`${n10}Axis`], {
            isXAxis: c10,
            len: p4 = 0,
            minPointOffset: u2 = 0
          } = d10 || {}, g2 = (i10?.strokeWidth() || 0) / 2 + 1, m2 = (t11, e11 = 0, i11 = 0) => {
            l10 && (i11 = p4 - i11);
            let {
              translated: s11 = 0,
              lineClip: o11
            } = t11, r11 = i11 - s11;
            o11?.push(["L", e11, Math.abs(r11) < g2 ? i11 - g2 * (r11 <= 0 ? -1 : 1) : s11]);
          };
          if (s10.length && (i10 || t10) && d10 && rF(d10.min)) {
            let e11 = d10.getExtremes().max + u2, g3 = (t11) => {
              t11.forEach((e12, i11) => {
                ("M" === e12[0] || "L" === e12[0]) && (t11[i11] = [e12[0], c10 ? p4 - e12[1] : e12[1], c10 ? e12[2] : p4 - e12[2]]);
              });
            };
            if (s10.forEach((t11) => {
              t11.lineClip = [], t11.translated = rA(d10.toPixels(rU(t11.value, e11), true) || 0, 0, p4);
            }), i10 && !this.showLine && i10.hide(), t10 && t10.hide(), "y" === n10 && o10.length < r10.len) for (let t11 of o10) {
              let {
                plotX: e12,
                plotY: i11,
                zone: o11
              } = t11, r11 = o11 && s10[s10.indexOf(o11) - 1];
              o11 && m2(o11, e12, i11), r11 && m2(r11, e12, i11);
            }
            let f2 = [], x2 = d10.toPixels(d10.getExtremes().min - u2, true);
            s10.forEach((e12) => {
              let s11 = e12.lineClip || [], o11 = Math.round(e12.translated || 0);
              r10.reversed && s11.reverse();
              let {
                clip: n11,
                simpleClip: d11
              } = e12, p7 = 0, u3 = 0, m3 = r10.len, y2 = a10.len;
              c10 ? (p7 = o11, m3 = x2) : (u3 = o11, y2 = x2);
              let b2 = [["M", p7, u3], ["L", m3, u3], ["L", m3, y2], ["L", p7, y2], ["Z"]], v2 = [b2[0], ...s11, b2[1], b2[2], ...f2, b2[3], b2[4]];
              f2 = s11.reverse(), x2 = o11, l10 && (g3(v2), t10 && g3(b2)), n11 ? (n11.animate({
                d: v2
              }), d11?.animate({
                d: b2
              })) : (n11 = e12.clip = h10.path(v2), t10 && (d11 = e12.simpleClip = h10.path(b2))), i10 && e12.graph?.clip(n11), t10 && e12.area?.clip(d11);
            });
          } else this.visible && (i10 && i10.show(), t10 && t10.show());
        }
        plotGroup(t10, e10, i10, s10, o10) {
          let r10 = this[t10], a10 = !r10, n10 = {
            visibility: i10,
            zIndex: s10 || 0.1
          };
          return rO(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n10.opacity = this.opacity), r10 || (this[t10] = r10 = this.chart.renderer.g().add(o10)), r10.addClass("highcharts-" + e10 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (rO(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r10.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true), r10.attr(n10)[a10 ? "attr" : "animate"](this.getPlotBox(e10)), r10;
        }
        getPlotBox(t10) {
          let e10 = this.xAxis, i10 = this.yAxis, s10 = this.chart, o10 = s10.inverted && !s10.polar && e10 && this.invertible && "series" === t10;
          return s10.inverted && (e10 = i10, i10 = this.xAxis), {
            translateX: e10 ? e10.left : s10.plotLeft,
            translateY: i10 ? i10.top : s10.plotTop,
            rotation: o10 ? 90 : 0,
            rotationOriginX: o10 ? (e10.len - i10.len) / 2 : 0,
            rotationOriginY: o10 ? (e10.len + i10.len) / 2 : 0,
            scaleX: o10 ? -1 : 1,
            scaleY: 1
          };
        }
        removeEvents(t10) {
          let {
            eventsToUnbind: e10
          } = this;
          t10 || rZ(this), e10.length && (e10.forEach((t11) => {
            t11();
          }), e10.length = 0);
        }
        render() {
          let t10 = this, {
            chart: e10,
            options: i10,
            hasRendered: s10
          } = t10, o10 = ry(i10.animation), r10 = t10.visible ? "inherit" : "hidden", a10 = i10.zIndex, n10 = e10.seriesGroup, l10 = t10.finishedAnimating ? 0 : o10.duration;
          rR(this, "render"), t10.plotGroup("group", "series", r10, a10, n10), t10.markerGroup = t10.plotGroup("markerGroup", "markers", r10, a10, n10), false !== i10.clip && t10.setClip(), l10 && t10.animate?.(true), t10.drawGraph && (t10.drawGraph(), t10.applyZones()), t10.visible && t10.drawPoints(), t10.drawDataLabels?.(), t10.redrawPoints?.(), i10.enableMouseTracking && t10.drawTracker?.(), l10 && t10.animate?.(), s10 || (l10 && o10.defer && (l10 += o10.defer), t10.animationTimeout = r$(() => {
            t10.afterAnimate();
          }, l10 || 0)), t10.isDirty = false, t10.hasRendered = true, rR(t10, "afterRender");
        }
        redraw() {
          let t10 = this.isDirty || this.isDirtyData;
          this.translate(), this.render(), t10 && delete this.kdTree;
        }
        reserveSpace() {
          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
        }
        searchPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = this.chart.inverted;
          return this.searchKDTree({
            clientX: o10 ? i10.len - t10.chartY + i10.pos : t10.chartX - i10.pos,
            plotY: o10 ? s10.len - t10.chartX + s10.pos : t10.chartY - s10.pos
          }, e10, t10);
        }
        buildKDTree(t10) {
          this.buildingKdTree = true;
          let e10 = this, i10 = e10.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          delete e10.kdTree, r$(function() {
            e10.kdTree = function t11(i11, s10, o10) {
              let r10, a10;
              let n10 = i11?.length;
              if (n10) return r10 = e10.kdAxisArray[s10 % o10], i11.sort((t12, e11) => (t12[r10] || 0) - (e11[r10] || 0)), {
                point: i11[a10 = Math.floor(n10 / 2)],
                left: t11(i11.slice(0, a10), s10 + 1, o10),
                right: t11(i11.slice(a10 + 1), s10 + 1, o10)
              };
            }(e10.getValidPoints(void 0, !e10.directTouch), i10, i10), e10.buildingKdTree = false;
          }, e10.options.kdNow || t10?.type === "touchstart" ? 0 : 1);
        }
        searchKDTree(t10, e10, i10, s10, o10) {
          let r10 = this, [a10, n10] = this.kdAxisArray, l10 = e10 ? "distX" : "dist", h10 = (r10.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d10 = !!r10.isBubble, c10 = s10 || ((t11, e11, i11) => [(t11[i11] || 0) < (e11[i11] || 0) ? t11 : e11, false]), p4 = o10 || ((t11, e11) => t11 < e11);
          if (this.kdTree || this.buildingKdTree || this.buildKDTree(i10), this.kdTree) return function t11(e11, i11, s11, o11) {
            let h11 = i11.point, u2 = r10.kdAxisArray[s11 % o11], g2 = h11, m2 = false;
            !function(t12, e12) {
              let i12 = t12[a10], s12 = e12[a10], o12 = rO(i12) && rO(s12) ? i12 - s12 : null, r11 = t12[n10], l11 = e12[n10], h12 = rO(r11) && rO(l11) ? r11 - l11 : 0, c11 = d10 && e12.marker?.radius || 0;
              e12.dist = Math.sqrt((o12 && o12 * o12 || 0) + h12 * h12) - c11, e12.distX = rO(o12) ? Math.abs(o12) - c11 : Number.MAX_VALUE;
            }(e11, h11);
            let f2 = (e11[u2] || 0) - (h11[u2] || 0) + (d10 && h11.marker?.radius || 0), x2 = f2 < 0 ? "left" : "right", y2 = f2 < 0 ? "right" : "left";
            return i11[x2] && ([g2, m2] = c10(h11, t11(e11, i11[x2], s11 + 1, o11), l10)), i11[y2] && p4(Math.sqrt(f2 * f2), g2[l10], m2) && (g2 = c10(g2, t11(e11, i11[y2], s11 + 1, o11), l10)[0]), g2;
          }(t10, this.kdTree, h10, h10);
        }
        pointPlacementToXValue() {
          let {
            options: t10,
            xAxis: e10
          } = this, i10 = t10.pointPlacement;
          return "between" === i10 && (i10 = e10.reversed ? -0.5 : 0.5), rF(i10) ? i10 * (t10.pointRange || e10.pointRange) : 0;
        }
        isPointInside(t10) {
          let {
            chart: e10,
            xAxis: i10,
            yAxis: s10
          } = this, {
            plotX: o10 = -1,
            plotY: r10 = -1
          } = t10;
          return r10 >= 0 && r10 <= (s10 ? s10.len : e10.plotHeight) && o10 >= 0 && o10 <= (i10 ? i10.len : e10.plotWidth);
        }
        drawTracker() {
          let t10 = this, e10 = t10.options, i10 = e10.trackByArea, s10 = [].concat((i10 ? t10.areaPath : t10.graphPath) || []), o10 = t10.chart, r10 = o10.pointer, a10 = o10.renderer, n10 = o10.options.tooltip?.snap || 0, l10 = () => {
            e10.enableMouseTracking && o10.hoverSeries !== t10 && t10.onMouseOver();
          }, h10 = "rgba(192,192,192," + (rw ? 1e-4 : 2e-3) + ")", d10 = t10.tracker;
          d10 ? d10.attr({
            d: s10
          }) : t10.graph && (t10.tracker = d10 = a10.path(s10).attr({
            visibility: t10.visible ? "inherit" : "hidden",
            zIndex: 2
          }).addClass(i10 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t10.group), o10.styledMode || d10.attr({
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            stroke: h10,
            fill: i10 ? h10 : "none",
            "stroke-width": t10.graph.strokeWidth() + (i10 ? 0 : 2 * n10)
          }), [t10.tracker, t10.markerGroup, t10.dataLabelsGroup].forEach((t11) => {
            t11 && (t11.addClass("highcharts-tracker").on("mouseover", l10).on("mouseout", (t12) => {
              r10?.onTrackerMouseOut(t12);
            }), e10.cursor && !o10.styledMode && t11.css({
              cursor: e10.cursor
            }), t11.on("touchstart", l10));
          })), rR(this, "afterDrawTracker");
        }
        addPoint(t10, e10, i10, s10, o10) {
          let r10, a10;
          let n10 = this.options, {
            chart: l10,
            data: h10,
            dataTable: d10,
            xAxis: c10
          } = this, p4 = c10 && c10.hasNames && c10.names, u2 = n10.data, g2 = this.getColumn("x");
          e10 = rU(e10, true);
          let m2 = {
            series: this
          };
          this.pointClass.prototype.applyOptions.apply(m2, [t10]);
          let f2 = m2.x;
          if (a10 = g2.length, this.requireSorting && f2 < g2[a10 - 1]) for (r10 = true; a10 && g2[a10 - 1] > f2; ) a10--;
          d10.setRow(m2, a10, true, {
            addColumns: false
          }), p4 && m2.name && (p4[f2] = m2.name), u2?.splice(a10, 0, t10), (r10 || this.processedData) && (this.data.splice(a10, 0, null), this.processData()), "point" === n10.legendType && this.generatePoints(), i10 && (h10[0] && h10[0].remove ? h10[0].remove(false) : ([h10, u2, ...Object.values(d10.getColumns())].filter(rO).forEach((t11) => {
            t11.shift();
          }), d10.rowCount -= 1, rR(d10, "afterDeleteRows"))), false !== o10 && rR(this, "addPoint", {
            point: m2
          }), this.isDirty = true, this.isDirtyData = true, e10 && l10.redraw(s10);
        }
        removePoint(t10, e10, i10) {
          let s10 = this, {
            chart: o10,
            data: r10,
            points: a10,
            dataTable: n10
          } = s10, l10 = r10[t10], h10 = function() {
            [a10?.length === r10.length ? a10 : void 0, r10, s10.options.data, ...Object.values(n10.getColumns())].filter(rO).forEach((e11) => {
              e11.splice(t10, 1);
            }), n10.rowCount -= 1, rR(n10, "afterDeleteRows"), l10?.destroy(), s10.isDirty = true, s10.isDirtyData = true, e10 && o10.redraw();
          };
          rb(i10, o10), e10 = rU(e10, true), l10 ? l10.firePointEvent("remove", null, h10) : h10();
        }
        remove(t10, e10, i10, s10) {
          let o10 = this, r10 = o10.chart;
          function a10() {
            o10.destroy(s10), r10.isDirtyLegend = r10.isDirtyBox = true, r10.linkSeries(s10), rU(t10, true) && r10.redraw(e10);
          }
          false !== i10 ? rR(o10, "remove", null, a10) : a10();
        }
        update(t10, e10) {
          rR(this, "update", {
            options: t10 = rI(t10, this.userOptions)
          });
          let i10 = this, s10 = i10.chart, o10 = i10.userOptions, r10 = i10.initialType || i10.type, a10 = s10.options.plotOptions, n10 = rS[r10].prototype, l10 = i10.finishedAnimating && {
            animation: false
          }, h10 = {}, d10, c10, p4 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], u2 = t10.type || o10.type || s10.options.chart.type, g2 = !(this.hasDerivedData || u2 && u2 !== this.type || void 0 !== t10.keys || void 0 !== t10.pointStart || void 0 !== t10.pointInterval || void 0 !== t10.relativeXValue || t10.joinBy || t10.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some((t11) => i10.hasOptionChanged(t11)));
          u2 = u2 || r10, g2 ? (p4.push("data", "isDirtyData", "isDirtyCanvas", "points", "dataTable", "processedData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), false !== t10.visible && p4.push("area", "graph"), i10.parallelArrays.forEach(function(t11) {
            p4.push(t11 + "Data");
          }), t10.data && (t10.dataSorting && rz(i10.options.dataSorting, t10.dataSorting), this.setData(t10.data, false))) : this.dataTable.modified = this.dataTable, t10 = rY(o10, {
            index: void 0 === o10.index ? i10.index : o10.index,
            pointStart: a10?.series?.pointStart ?? o10.pointStart ?? i10.getColumn("x")[0]
          }, !g2 && {
            data: i10.options.data
          }, t10, l10), g2 && t10.data && (t10.data = i10.options.data), (p4 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p4)).forEach(function(t11) {
            p4[t11] = i10[t11], delete i10[t11];
          });
          let m2 = false;
          if (rS[u2]) {
            if (m2 = u2 !== i10.type, i10.remove(false, false, false, true), m2) {
              if (s10.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i10, rS[u2].prototype);
              else {
                let t11 = Object.hasOwnProperty.call(i10, "hcEvents") && i10.hcEvents;
                for (c10 in n10) i10[c10] = void 0;
                rz(i10, rS[u2].prototype), t11 ? i10.hcEvents = t11 : delete i10.hcEvents;
              }
            }
          } else rB(17, true, s10, {
            missingModuleFor: u2
          });
          if (p4.forEach(function(t11) {
            i10[t11] = p4[t11];
          }), i10.init(s10, t10), g2 && this.points) for (let t11 of (false === (d10 = i10.options).visible ? (h10.graphic = 1, h10.dataLabel = 1) : (this.hasMarkerChanged(d10, o10) && (h10.graphic = 1), i10.hasDataLabels?.() || (h10.dataLabel = 1)), this.points)) t11 && t11.series && (t11.resolveColor(), Object.keys(h10).length && t11.destroyElements(h10), false === d10.showInLegend && t11.legendItem && s10.legend.destroyItem(t11));
          i10.initialType = r10, s10.linkSeries(), s10.setSortedData(), m2 && i10.linkedSeries.length && (i10.isDirtyData = true), rR(this, "afterUpdate"), rU(e10, true) && s10.redraw(!!g2 && void 0);
        }
        setName(t10) {
          this.name = this.options.name = this.userOptions.name = t10, this.chart.isDirtyLegend = true;
        }
        hasOptionChanged(t10) {
          let e10 = this.chart, i10 = this.options[t10], s10 = e10.options.plotOptions, o10 = this.userOptions[t10], r10 = rU(s10?.[this.type]?.[t10], s10?.series?.[t10]);
          return o10 && !rO(r10) ? i10 !== o10 : i10 !== rU(r10, i10);
        }
        onMouseOver() {
          let t10 = this.chart, e10 = t10.hoverSeries, i10 = t10.pointer;
          i10?.setHoverChartIndex(), e10 && e10 !== this && e10.onMouseOut(), this.options.events.mouseOver && rR(this, "mouseOver"), this.setState("hover"), t10.hoverSeries = this;
        }
        onMouseOut() {
          let t10 = this.options, e10 = this.chart, i10 = e10.tooltip, s10 = e10.hoverPoint;
          e10.hoverSeries = null, s10 && s10.onMouseOut(), this && t10.events.mouseOut && rR(this, "mouseOut"), i10 && !this.stickyTracking && (!i10.shared || this.noSharedTooltip) && i10.hide(), e10.series.forEach(function(t11) {
            t11.setState("", true);
          });
        }
        setState(t10, e10) {
          let i10 = this, s10 = i10.options, o10 = i10.graph, r10 = s10.inactiveOtherPoints, a10 = s10.states, n10 = rU(a10[t10 || "normal"] && a10[t10 || "normal"].animation, i10.chart.options.chart.animation), l10 = s10.lineWidth, h10 = s10.opacity;
          if (t10 = t10 || "", i10.state !== t10 && ([i10.group, i10.markerGroup, i10.dataLabelsGroup].forEach(function(e11) {
            e11 && (i10.state && e11.removeClass("highcharts-series-" + i10.state), t10 && e11.addClass("highcharts-series-" + t10));
          }), i10.state = t10, !i10.chart.styledMode)) {
            if (a10[t10] && false === a10[t10].enabled) return;
            if (t10 && (l10 = a10[t10].lineWidth || l10 + (a10[t10].lineWidthPlus || 0), h10 = rU(a10[t10].opacity, h10)), o10 && !o10.dashstyle && rF(l10)) for (let t11 of [o10, ...this.zones.map((t12) => t12.graph)]) t11?.animate({
              "stroke-width": l10
            }, n10);
            r10 || [i10.group, i10.markerGroup, i10.dataLabelsGroup, i10.labelBySeries].forEach(function(t11) {
              t11 && t11.animate({
                opacity: h10
              }, n10);
            });
          }
          e10 && r10 && i10.points && i10.setAllPointsToState(t10 || void 0);
        }
        setAllPointsToState(t10) {
          this.points.forEach(function(e10) {
            e10.setState && e10.setState(t10);
          });
        }
        setVisible(t10, e10) {
          let i10 = this, s10 = i10.chart, o10 = s10.options.chart.ignoreHiddenSeries, r10 = i10.visible;
          i10.visible = t10 = i10.options.visible = i10.userOptions.visible = void 0 === t10 ? !r10 : t10;
          let a10 = t10 ? "show" : "hide";
          ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach((t11) => {
            i10[t11]?.[a10]();
          }), (s10.hoverSeries === i10 || s10.hoverPoint?.series === i10) && i10.onMouseOut(), i10.legendItem && s10.legend.colorizeItem(i10, t10), i10.isDirty = true, i10.options.stacking && s10.series.forEach((t11) => {
            t11.options.stacking && t11.visible && (t11.isDirty = true);
          }), i10.linkedSeries.forEach((e11) => {
            e11.setVisible(t10, false);
          }), o10 && (s10.isDirtyBox = true), rR(i10, a10), false !== e10 && s10.redraw();
        }
        show() {
          this.setVisible(true);
        }
        hide() {
          this.setVisible(false);
        }
        select(t10) {
          this.selected = t10 = this.options.selected = void 0 === t10 ? !this.selected : t10, this.checkbox && (this.checkbox.checked = t10), rR(this, t10 ? "select" : "unselect");
        }
        shouldShowTooltip(t10, e10, i10 = {}) {
          return i10.series = this, i10.visiblePlotOnly = true, this.chart.isInsidePlot(t10, e10, i10);
        }
        drawLegendSymbol(t10, e10) {
          rp[this.options.legendSymbol || "rectangle"]?.call(this, t10, e10);
        }
      }
      r_.defaultOptions = {
        lineWidth: 2,
        allowPointSelect: false,
        crisp: true,
        showCheckbox: false,
        animation: {
          duration: 1e3
        },
        enableMouseTracking: true,
        events: {},
        marker: {
          enabledThreshold: 2,
          lineColor: "#ffffff",
          lineWidth: 0,
          radius: 4,
          states: {
            normal: {
              animation: true
            },
            hover: {
              animation: {
                duration: 150
              },
              enabled: true,
              radiusPlus: 2,
              lineWidthPlus: 1
            },
            select: {
              fillColor: "#cccccc",
              lineColor: "#000000",
              lineWidth: 2
            }
          }
        },
        point: {
          events: {}
        },
        dataLabels: {
          animation: {},
          align: "center",
          borderWidth: 0,
          defer: true,
          formatter: function() {
            let {
              numberFormatter: t10
            } = this.series.chart;
            return "number" != typeof this.y ? "" : t10(this.y, -1);
          },
          padding: 5,
          style: {
            fontSize: "0.7em",
            fontWeight: "bold",
            color: "contrast",
            textOutline: "1px contrast"
          },
          verticalAlign: "bottom",
          x: 0,
          y: 0
        },
        cropThreshold: 300,
        opacity: 1,
        pointRange: 0,
        softThreshold: true,
        states: {
          normal: {
            animation: true
          },
          hover: {
            animation: {
              duration: 150
            },
            lineWidthPlus: 1,
            marker: {},
            halo: {
              size: 10,
              opacity: 0.25
            }
          },
          select: {
            animation: {
              duration: 0
            }
          },
          inactive: {
            animation: {
              duration: 150
            },
            opacity: 0.2
          }
        },
        stickyTracking: true,
        turboThreshold: 1e3,
        findNearestPointBy: "x"
      }, r_.types = rx.seriesTypes, r_.registerType = rx.registerSeriesType, rz(r_.prototype, {
        axisTypes: ["xAxis", "yAxis"],
        coll: "series",
        colorCounter: 0,
        directTouch: false,
        invertible: true,
        isCartesian: true,
        kdAxisArray: ["clientX", "plotY"],
        parallelArrays: ["x", "y"],
        pointClass: o$,
        requireSorting: true,
        sorted: true
      }), rx.series = r_;
      let rq = r_, {
        animObject: rK,
        setAnimation: rJ
      } = tH, {
        registerEventOptions: rQ
      } = i7, {
        composed: r0,
        marginNames: r1
      } = A, {
        distribute: r2
      } = ef, {
        format: r3
      } = ed, {
        addEvent: r6,
        createElement: r5,
        css: r9,
        defined: r8,
        discardElement: r4,
        find: r7,
        fireEvent: at,
        isNumber: ae,
        merge: ai,
        pick: as,
        pushUnique: ao,
        relativeLength: ar,
        stableSort: aa,
        syncTimeout: an
      } = J;
      class al {
        constructor(t10, e10) {
          this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t10, this.setOptions(e10), e10.enabled && (this.render(), rQ(this, e10), r6(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          })), r6(this.chart, "render", () => {
            this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
          });
        }
        setOptions(t10) {
          let e10 = as(t10.padding, 8);
          this.options = t10, this.chart.styledMode || (this.itemStyle = t10.itemStyle, this.itemHiddenStyle = ai(this.itemStyle, t10.itemHiddenStyle)), this.itemMarginTop = t10.itemMarginTop, this.itemMarginBottom = t10.itemMarginBottom, this.padding = e10, this.initialItemY = e10 - 5, this.symbolWidth = as(t10.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t10.layout && !this.chart.inverted, this.baseline = void 0;
        }
        update(t10, e10) {
          let i10 = this.chart;
          this.setOptions(ai(true, this.options, t10)), "events" in this.options && rQ(this, this.options), this.destroy(), i10.isDirtyLegend = i10.isDirtyBox = true, as(e10, true) && i10.redraw(), at(this, "afterUpdate", {
            redraw: e10
          });
        }
        colorizeItem(t10, e10) {
          let i10 = t10.color, {
            area: s10,
            group: o10,
            label: r10,
            line: a10,
            symbol: n10
          } = t10.legendItem || {};
          if ((t10 instanceof rq || t10 instanceof o$) && (t10.color = t10.options?.legendSymbolColor || i10), o10?.[e10 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
            let {
              itemHiddenStyle: i11 = {}
            } = this, o11 = i11.color, {
              fillColor: l10,
              fillOpacity: h10,
              lineColor: d10,
              marker: c10
            } = t10.options, p4 = (t11) => (!e10 && (t11.fill && (t11.fill = o11), t11.stroke && (t11.stroke = o11)), t11);
            r10?.css(ai(e10 ? this.itemStyle : i11)), a10?.attr(p4({
              stroke: d10 || t10.color
            })), n10 && n10.attr(p4(c10 && n10.isMarker ? t10.pointAttribs() : {
              fill: t10.color
            })), s10?.attr(p4({
              fill: l10 || t10.color,
              "fill-opacity": l10 ? 1 : h10 ?? 0.75
            }));
          }
          t10.color = i10, at(this, "afterColorizeItem", {
            item: t10,
            visible: e10
          });
        }
        positionItems() {
          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
        }
        positionItem(t10) {
          let {
            group: e10,
            x: i10 = 0,
            y: s10 = 0
          } = t10.legendItem || {}, o10 = this.options, r10 = o10.symbolPadding, a10 = !o10.rtl, n10 = t10.checkbox;
          if (e10 && e10.element) {
            let o11 = {
              translateX: a10 ? i10 : this.legendWidth - i10 - 2 * r10 - 4,
              translateY: s10
            };
            e10[r8(e10.translateY) ? "animate" : "attr"](o11, void 0, () => {
              at(this, "afterPositionItem", {
                item: t10
              });
            });
          }
          n10 && (n10.x = i10, n10.y = s10);
        }
        destroyItem(t10) {
          let e10 = t10.checkbox, i10 = t10.legendItem || {};
          for (let t11 of ["group", "label", "line", "symbol"]) i10[t11] && (i10[t11] = i10[t11].destroy());
          e10 && r4(e10), t10.legendItem = void 0;
        }
        destroy() {
          for (let t10 of this.getAllItems()) this.destroyItem(t10);
          for (let t10 of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t10] && (this[t10] = this[t10].destroy());
          this.display = null;
        }
        positionCheckboxes() {
          let t10;
          let e10 = this.group && this.group.alignAttr, i10 = this.clipHeight || this.legendHeight, s10 = this.titleHeight;
          e10 && (t10 = e10.translateY, this.allItems.forEach(function(o10) {
            let r10;
            let a10 = o10.checkbox;
            a10 && (r10 = t10 + s10 + a10.y + (this.scrollOffset || 0) + 3, r9(a10, {
              left: e10.translateX + o10.checkboxOffset + a10.x - 20 + "px",
              top: r10 + "px",
              display: this.proximate || r10 > t10 - 6 && r10 < t10 + i10 - 6 ? "" : "none"
            }));
          }, this));
        }
        renderTitle() {
          let t10 = this.options, e10 = this.padding, i10 = t10.title, s10, o10 = 0;
          i10.text && (this.title || (this.title = this.chart.renderer.label(i10.text, e10 - 3, e10 - 4, void 0, void 0, void 0, t10.useHTML, void 0, "legend-title").attr({
            zIndex: 1
          }), this.chart.styledMode || this.title.css(i10.style), this.title.add(this.group)), i10.width || this.title.css({
            width: this.maxLegendWidth + "px"
          }), o10 = (s10 = this.title.getBBox()).height, this.offsetWidth = s10.width, this.contentGroup.attr({
            translateY: o10
          })), this.titleHeight = o10;
        }
        setText(t10) {
          let e10 = this.options;
          t10.legendItem.label.attr({
            text: e10.labelFormat ? r3(e10.labelFormat, t10, this.chart) : e10.labelFormatter.call(t10)
          });
        }
        renderItem(t10) {
          let e10 = t10.legendItem = t10.legendItem || {}, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = "horizontal" === o10.layout, a10 = this.symbolWidth, n10 = o10.symbolPadding || 0, l10 = this.itemStyle, h10 = this.itemHiddenStyle, d10 = r10 ? as(o10.itemDistance, 20) : 0, c10 = !o10.rtl, p4 = !t10.series, u2 = !p4 && t10.series.drawLegendSymbol ? t10.series : t10, g2 = u2.options, m2 = !!this.createCheckboxForItem && g2 && g2.showCheckbox, f2 = o10.useHTML, x2 = t10.options.className, y2 = e10.label, b2 = a10 + n10 + d10 + (m2 ? 20 : 0);
          !y2 && (e10.group = s10.g("legend-item").addClass("highcharts-" + u2.type + "-series highcharts-color-" + t10.colorIndex + (x2 ? " " + x2 : "") + (p4 ? " highcharts-series-" + t10.index : "")).attr({
            zIndex: 1
          }).add(this.scrollGroup), e10.label = y2 = s10.text("", c10 ? a10 + n10 : -n10, this.baseline || 0, f2), i10.styledMode || y2.css(ai(t10.visible ? l10 : h10)), y2.attr({
            align: c10 ? "left" : "right",
            zIndex: 2
          }).add(e10.group), !this.baseline && (this.fontMetrics = s10.fontMetrics(y2), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y2.attr("y", this.baseline), this.symbolHeight = as(o10.symbolHeight, this.fontMetrics.f), o10.squareSymbol && (this.symbolWidth = as(o10.symbolWidth, Math.max(this.symbolHeight, 16)), b2 = this.symbolWidth + n10 + d10 + (m2 ? 20 : 0), c10 && y2.attr("x", this.symbolWidth + n10))), u2.drawLegendSymbol(this, t10), this.setItemEvents && this.setItemEvents(t10, y2, f2)), m2 && !t10.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t10), this.colorizeItem(t10, t10.visible), (i10.styledMode || !l10.width) && y2.css({
            width: (o10.itemWidth || this.widthOption || i10.spacingBox.width) - b2 + "px"
          }), this.setText(t10);
          let v2 = y2.getBBox(), M2 = this.fontMetrics && this.fontMetrics.h || 0;
          t10.itemWidth = t10.checkboxOffset = o10.itemWidth || e10.labelWidth || v2.width + b2, this.maxItemWidth = Math.max(this.maxItemWidth, t10.itemWidth), this.totalItemWidth += t10.itemWidth, this.itemHeight = t10.itemHeight = Math.round(e10.labelHeight || (v2.height > 1.5 * M2 ? v2.height : M2));
        }
        layoutItem(t10) {
          let e10 = this.options, i10 = this.padding, s10 = "horizontal" === e10.layout, o10 = t10.itemHeight, r10 = this.itemMarginBottom, a10 = this.itemMarginTop, n10 = s10 ? as(e10.itemDistance, 20) : 0, l10 = this.maxLegendWidth, h10 = e10.alignColumns && this.totalItemWidth > l10 ? this.maxItemWidth : t10.itemWidth, d10 = t10.legendItem || {};
          s10 && this.itemX - i10 + h10 > l10 && (this.itemX = i10, this.lastLineHeight && (this.itemY += a10 + this.lastLineHeight + r10), this.lastLineHeight = 0), this.lastItemY = a10 + this.itemY + r10, this.lastLineHeight = Math.max(o10, this.lastLineHeight), d10.x = this.itemX, d10.y = this.itemY, s10 ? this.itemX += h10 : (this.itemY += a10 + o10 + r10, this.lastLineHeight = o10), this.offsetWidth = this.widthOption || Math.max((s10 ? this.itemX - i10 - (t10.checkbox ? 0 : n10) : h10) + i10, this.offsetWidth);
        }
        getAllItems() {
          let t10 = [];
          return this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.options;
            e10 && as(i10.showInLegend, !r8(i10.linkedTo) && void 0, true) && (t10 = t10.concat((e10.legendItem || {}).labels || ("point" === i10.legendType ? e10.data : e10)));
          }), at(this, "afterGetAllItems", {
            allItems: t10
          }), t10;
        }
        getAlignment() {
          let t10 = this.options;
          return this.proximate ? t10.align.charAt(0) + "tv" : t10.floating ? "" : t10.align.charAt(0) + t10.verticalAlign.charAt(0) + t10.layout.charAt(0);
        }
        adjustMargins(t10, e10) {
          let i10 = this.chart, s10 = this.options, o10 = this.getAlignment();
          o10 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(r10, a10) {
            r10.test(o10) && !r8(t10[a10]) && (i10[r1[a10]] = Math.max(i10[r1[a10]], i10.legend[(a10 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][a10] * s10[a10 % 2 ? "x" : "y"] + as(s10.margin, 12) + e10[a10] + (i10.titleOffset[a10] || 0)));
          });
        }
        proximatePositions() {
          let t10;
          let e10 = this.chart, i10 = [], s10 = "left" === this.options.align;
          for (let o10 of (this.allItems.forEach(function(t11) {
            let o11, r10, a10 = s10, n10, l10;
            t11.yAxis && (t11.xAxis.options.reversed && (a10 = !a10), t11.points && (o11 = r7(a10 ? t11.points : t11.points.slice(0).reverse(), function(t12) {
              return ae(t12.plotY);
            })), r10 = this.itemMarginTop + t11.legendItem.label.getBBox().height + this.itemMarginBottom, l10 = t11.yAxis.top - e10.plotTop, n10 = t11.visible ? (o11 ? o11.plotY : t11.yAxis.height) + (l10 - 0.3 * r10) : l10 + t11.yAxis.height, i10.push({
              target: n10,
              size: r10,
              item: t11
            }));
          }, this), r2(i10, e10.plotHeight))) t10 = o10.item.legendItem || {}, ae(o10.pos) && (t10.y = e10.plotTop - e10.spacing[0] + o10.pos);
        }
        render() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.options, s10 = this.padding, o10 = this.getAllItems(), r10, a10, n10, l10 = this.group, h10, d10 = this.box;
          this.itemX = s10, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = ar(i10.width, t10.spacingBox.width - s10), h10 = t10.spacingBox.width - 2 * s10 - i10.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (h10 /= 2), this.maxLegendWidth = this.widthOption || h10, l10 || (this.group = l10 = e10.g("legend").addClass(i10.className || "").attr({
            zIndex: 7
          }).add(), this.contentGroup = e10.g().attr({
            zIndex: 1
          }).add(l10), this.scrollGroup = e10.g().add(this.contentGroup)), this.renderTitle(), aa(o10, (t11, e11) => (t11.options && t11.options.legendIndex || 0) - (e11.options && e11.options.legendIndex || 0)), i10.reversed && o10.reverse(), this.allItems = o10, this.display = r10 = !!o10.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o10.forEach(this.renderItem, this), o10.forEach(this.layoutItem, this), a10 = (this.widthOption || this.offsetWidth) + s10, n10 = this.lastItemY + this.lastLineHeight + this.titleHeight, n10 = this.handleOverflow(n10) + s10, d10 || (this.box = d10 = e10.rect().addClass("highcharts-legend-box").attr({
            r: i10.borderRadius
          }).add(l10)), t10.styledMode || d10.attr({
            stroke: i10.borderColor,
            "stroke-width": i10.borderWidth || 0,
            fill: i10.backgroundColor || "none"
          }).shadow(i10.shadow), a10 > 0 && n10 > 0 && d10[d10.placed ? "animate" : "attr"](d10.crisp.call({}, {
            x: 0,
            y: 0,
            width: a10,
            height: n10
          }, d10.strokeWidth())), l10[r10 ? "show" : "hide"](), t10.styledMode && "none" === l10.getStyle("display") && (a10 = n10 = 0), this.legendWidth = a10, this.legendHeight = n10, r10 && this.align(), this.proximate || this.positionItems(), at(this, "afterRender");
        }
        align(t10 = this.chart.spacingBox) {
          let e10 = this.chart, i10 = this.options, s10 = t10.y;
          /(lth|ct|rth)/.test(this.getAlignment()) && e10.titleOffset[0] > 0 ? s10 += e10.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e10.titleOffset[2] > 0 && (s10 -= e10.titleOffset[2]), s10 !== t10.y && (t10 = ai(t10, {
            y: s10
          })), e10.hasRendered || (this.group.placed = false), this.group.align(ai(i10, {
            width: this.legendWidth,
            height: this.legendHeight,
            verticalAlign: this.proximate ? "top" : i10.verticalAlign
          }), true, t10);
        }
        handleOverflow(t10) {
          let e10 = this, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = o10.y, a10 = "top" === o10.verticalAlign, n10 = this.padding, l10 = o10.maxHeight, h10 = o10.navigation, d10 = as(h10.animation, true), c10 = h10.arrowSize || 12, p4 = this.pages, u2 = this.allItems, g2 = function(t11) {
            "number" == typeof t11 ? M2.attr({
              height: t11
            }) : M2 && (e10.clipRect = M2.destroy(), e10.contentGroup.clip()), e10.contentGroup.div && (e10.contentGroup.div.style.clip = t11 ? "rect(" + n10 + "px,9999px," + (n10 + t11) + "px,0)" : "auto");
          }, m2 = function(t11) {
            return e10[t11] = s10.circle(0, 0, 1.3 * c10).translate(c10 / 2, c10 / 2).add(v2), i10.styledMode || e10[t11].attr("fill", "rgba(0,0,0,0.0001)"), e10[t11];
          }, f2, x2, y2, b2 = i10.spacingBox.height + (a10 ? -r10 : r10) - n10, v2 = this.nav, M2 = this.clipRect;
          return "horizontal" !== o10.layout || "middle" === o10.verticalAlign || o10.floating || (b2 /= 2), l10 && (b2 = Math.min(b2, l10)), p4.length = 0, t10 && b2 > 0 && t10 > b2 && false !== h10.enabled ? (this.clipHeight = f2 = Math.max(b2 - 20 - this.titleHeight - n10, 0), this.currentPage = as(this.currentPage, 1), this.fullHeight = t10, u2.forEach((t11, e11) => {
            let i11 = (y2 = t11.legendItem || {}).y || 0, s11 = Math.round(y2.label.getBBox().height), o11 = p4.length;
            (!o11 || i11 - p4[o11 - 1] > f2 && (x2 || i11) !== p4[o11 - 1]) && (p4.push(x2 || i11), o11++), y2.pageIx = o11 - 1, x2 && ((u2[e11 - 1].legendItem || {}).pageIx = o11 - 1), e11 === u2.length - 1 && i11 + s11 - p4[o11 - 1] > f2 && i11 > p4[o11 - 1] && (p4.push(i11), y2.pageIx = o11), i11 !== x2 && (x2 = i11);
          }), M2 || (M2 = e10.clipRect = s10.clipRect(0, n10 - 2, 9999, 0), e10.contentGroup.clip(M2)), g2(f2), v2 || (this.nav = v2 = s10.g().attr({
            zIndex: 1
          }).add(this.group), this.up = s10.symbol("triangle", 0, 0, c10, c10).add(v2), m2("upTracker").on("click", function() {
            e10.scroll(-1, d10);
          }), this.pager = s10.text("", 15, 10).addClass("highcharts-legend-navigation"), !i10.styledMode && h10.style && this.pager.css(h10.style), this.pager.add(v2), this.down = s10.symbol("triangle-down", 0, 0, c10, c10).add(v2), m2("downTracker").on("click", function() {
            e10.scroll(1, d10);
          })), e10.scroll(0), t10 = b2) : v2 && (g2(), this.nav = v2.destroy(), this.scrollGroup.attr({
            translateY: 1
          }), this.clipHeight = 0), t10;
        }
        scroll(t10, e10) {
          let i10 = this.chart, s10 = this.pages, o10 = s10.length, r10 = this.clipHeight, a10 = this.options.navigation, n10 = this.pager, l10 = this.padding, h10 = this.currentPage + t10;
          h10 > o10 && (h10 = o10), h10 > 0 && (void 0 !== e10 && rJ(e10, i10), this.nav.attr({
            translateX: l10,
            translateY: r10 + this.padding + 7 + this.titleHeight,
            visibility: "inherit"
          }), [this.up, this.upTracker].forEach(function(t11) {
            t11.attr({
              class: 1 === h10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }), n10.attr({
            text: h10 + "/" + o10
          }), [this.down, this.downTracker].forEach(function(t11) {
            t11.attr({
              x: 18 + this.pager.getBBox().width,
              class: h10 === o10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }, this), i10.styledMode || (this.up.attr({
            fill: 1 === h10 ? a10.inactiveColor : a10.activeColor
          }), this.upTracker.css({
            cursor: 1 === h10 ? "default" : "pointer"
          }), this.down.attr({
            fill: h10 === o10 ? a10.inactiveColor : a10.activeColor
          }), this.downTracker.css({
            cursor: h10 === o10 ? "default" : "pointer"
          })), this.scrollOffset = -s10[h10 - 1] + this.initialItemY, this.scrollGroup.animate({
            translateY: this.scrollOffset
          }), this.currentPage = h10, this.positionCheckboxes(), an(() => {
            at(this, "afterScroll", {
              currentPage: h10
            });
          }, rK(as(e10, i10.renderer.globalAnimation, true)).duration));
        }
        setItemEvents(t10, e10, i10) {
          let s10 = this, o10 = t10.legendItem || {}, r10 = s10.chart.renderer.boxWrapper, a10 = t10 instanceof o$, n10 = t10 instanceof rq, l10 = "highcharts-legend-" + (a10 ? "point" : "series") + "-active", h10 = s10.chart.styledMode, d10 = i10 ? [e10, o10.symbol] : [o10.group], c10 = (e11) => {
            s10.allItems.forEach((i11) => {
              t10 !== i11 && [i11].concat(i11.linkedSeries || []).forEach((t11) => {
                t11.setState(e11, !a10);
              });
            });
          };
          for (let i11 of d10) i11 && i11.on("mouseover", function() {
            t10.visible && c10("inactive"), t10.setState("hover"), t10.visible && r10.addClass(l10), h10 || e10.css(s10.options.itemHoverStyle);
          }).on("mouseout", function() {
            s10.chart.styledMode || e10.css(ai(t10.visible ? s10.itemStyle : s10.itemHiddenStyle)), c10(""), r10.removeClass(l10), t10.setState();
          }).on("click", function(e11) {
            let i12 = function() {
              t10.setVisible && t10.setVisible(), c10(t10.visible ? "inactive" : "");
            };
            r10.removeClass(l10), at(s10, "itemClick", {
              browserEvent: e11,
              legendItem: t10
            }, i12), a10 ? t10.firePointEvent("legendItemClick", {
              browserEvent: e11
            }) : n10 && at(t10, "legendItemClick", {
              browserEvent: e11
            });
          });
        }
        createCheckboxForItem(t10) {
          t10.checkbox = r5("input", {
            type: "checkbox",
            className: "highcharts-legend-checkbox",
            checked: t10.selected,
            defaultChecked: t10.selected
          }, this.options.itemCheckboxStyle, this.chart.container), r6(t10.checkbox, "click", function(e10) {
            let i10 = e10.target;
            at(t10.series || t10, "checkboxClick", {
              checked: i10.checked,
              item: t10
            }, function() {
              t10.select();
            });
          });
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          ao(r0, "Core.Legend") && r6(e10, "beforeMargins", function() {
            this.legend = new t10(this, this.options.legend);
          });
        };
      }(al || (al = {}));
      let ah = al, {
        animate: ad,
        animObject: ac,
        setAnimation: ap
      } = tH, {
        defaultOptions: au
      } = tw, {
        numberFormat: ag
      } = ed, {
        registerEventOptions: am
      } = i7, {
        charts: af,
        doc: ax,
        marginNames: ay,
        svg: ab,
        win: av
      } = A, {
        seriesTypes: aM
      } = rx, {
        addEvent: aw,
        attr: ak,
        createElement: aS,
        css: aT,
        defined: aC,
        diffObjects: aA,
        discardElement: aP,
        erase: aL,
        error: aO,
        extend: aE,
        find: aI,
        fireEvent: aD,
        getAlignFactor: aB,
        getStyle: az,
        isArray: aN,
        isNumber: aR,
        isObject: aW,
        isString: aj,
        merge: aX,
        objectEach: aG,
        pick: aF,
        pInt: aH,
        relativeLength: aY,
        removeEvent: aV,
        splat: aU,
        syncTimeout: aZ,
        uniqueKey: a$
      } = J;
      class a_ {
        static chart(t10, e10, i10) {
          return new a_(t10, e10, i10);
        }
        constructor(t10, e10, i10) {
          this.sharedClips = {};
          let s10 = [...arguments];
          (aj(t10) || t10.nodeName) && (this.renderTo = s10.shift()), this.init(s10[0], s10[1]);
        }
        setZoomOptions() {
          let t10 = this.options.chart, e10 = t10.zooming;
          this.zooming = __spreadProps(__spreadValues({}, e10), {
            type: aF(t10.zoomType, e10.type),
            key: aF(t10.zoomKey, e10.key),
            pinchType: aF(t10.pinchType, e10.pinchType),
            singleTouch: aF(t10.zoomBySingleTouch, e10.singleTouch, false),
            resetButton: aX(e10.resetButton, t10.resetZoomButton)
          });
        }
        init(t10, e10) {
          aD(this, "init", {
            args: arguments
          }, function() {
            let i10 = aX(au, t10), s10 = i10.chart, o10 = this.renderTo || s10.renderTo;
            this.userOptions = aE({}, t10), (this.renderTo = aj(o10) ? ax.getElementById(o10) : o10) || aO(13, true, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e10, this.isResizing = 0, this.options = i10, this.axes = [], this.series = [], this.locale = i10.lang.locale ?? this.renderTo.closest("[lang]")?.lang, this.time = new tf(aE(i10.time || {}, {
              locale: this.locale
            })), i10.time = this.time.options, this.numberFormatter = (s10.numberFormatter || ag).bind(this), this.styledMode = s10.styledMode, this.hasCartesianSeries = s10.showAxes, this.index = af.length, af.push(this), A.chartCount++, am(this, s10), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), aD(this, "afterInit"), this.firstRender();
          });
        }
        initSeries(t10) {
          let e10 = this.options.chart, i10 = t10.type || e10.type, s10 = aM[i10];
          s10 || aO(17, true, this, {
            missingModuleFor: i10
          });
          let o10 = new s10();
          return "function" == typeof o10.init && o10.init(this, t10), o10;
        }
        setSortedData() {
          this.getSeriesOrderByLinks().forEach(function(t10) {
            t10.points || t10.data || !t10.enabledDataSorting || t10.setData(t10.options.data, false);
          });
        }
        getSeriesOrderByLinks() {
          return this.series.concat().sort(function(t10, e10) {
            return t10.linkedSeries.length || e10.linkedSeries.length ? e10.linkedSeries.length - t10.linkedSeries.length : 0;
          });
        }
        orderItems(t10, e10 = 0) {
          let i10 = this[t10], s10 = this.options[t10] = aU(this.options[t10]).slice(), o10 = this.userOptions[t10] = this.userOptions[t10] ? aU(this.userOptions[t10]).slice() : [];
          if (this.hasRendered && (s10.splice(e10), o10.splice(e10)), i10) for (let t11 = e10, r10 = i10.length; t11 < r10; ++t11) {
            let e11 = i10[t11];
            e11 && (e11.index = t11, e11 instanceof rq && (e11.name = e11.getName()), e11.options.isInternal || (s10[t11] = e11.options, o10[t11] = e11.userOptions));
          }
        }
        isInsidePlot(t10, e10, i10 = {}) {
          let {
            inverted: s10,
            plotBox: o10,
            plotLeft: r10,
            plotTop: a10,
            scrollablePlotBox: n10
          } = this, {
            scrollLeft: l10 = 0,
            scrollTop: h10 = 0
          } = i10.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, d10 = i10.series, c10 = i10.visiblePlotOnly && n10 || o10, p4 = i10.inverted ? e10 : t10, u2 = i10.inverted ? t10 : e10, g2 = {
            x: p4,
            y: u2,
            isInsidePlot: true,
            options: i10
          };
          if (!i10.ignoreX) {
            let t11 = d10 && (s10 && !this.polar ? d10.yAxis : d10.xAxis) || {
              pos: r10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + p4 : r10 + p4;
            e11 >= Math.max(l10 + r10, t11.pos) && e11 <= Math.min(l10 + r10 + c10.width, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          if (!i10.ignoreY && g2.isInsidePlot) {
            let t11 = !s10 && i10.axis && !i10.axis.isXAxis && i10.axis || d10 && (s10 ? d10.xAxis : d10.yAxis) || {
              pos: a10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + u2 : a10 + u2;
            e11 >= Math.max(h10 + a10, t11.pos) && e11 <= Math.min(h10 + a10 + c10.height, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          return aD(this, "afterIsInsidePlot", g2), g2.isInsidePlot;
        }
        redraw(t10) {
          aD(this, "beforeRedraw");
          let e10 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i10 = this.series, s10 = this.pointer, o10 = this.legend, r10 = this.userOptions.legend, a10 = this.renderer, n10 = a10.isHidden(), l10 = [], h10, d10, c10, p4 = this.isDirtyBox, u2 = this.isDirtyLegend, g2;
          for (a10.rootFontSize = a10.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(false), ap(!!this.hasRendered && t10, this), n10 && this.temporaryDisplay(), this.layOutTitles(false), c10 = i10.length; c10--; ) if (((g2 = i10[c10]).options.stacking || g2.options.centerInCategory) && (d10 = true, g2.isDirty)) {
            h10 = true;
            break;
          }
          if (h10) for (c10 = i10.length; c10--; ) (g2 = i10[c10]).options.stacking && (g2.isDirty = true);
          i10.forEach(function(t11) {
            t11.isDirty && ("point" === t11.options.legendType ? ("function" == typeof t11.updateTotals && t11.updateTotals(), u2 = true) : r10 && (r10.labelFormatter || r10.labelFormat) && (u2 = true)), t11.isDirtyData && aD(t11, "updatedData");
          }), u2 && o10 && o10.options.enabled && (o10.render(), this.isDirtyLegend = false), d10 && this.getStacks(), e10.forEach(function(t11) {
            t11.updateNames(), t11.setScale();
          }), this.getMargins(), e10.forEach(function(t11) {
            t11.isDirty && (p4 = true);
          }), e10.forEach(function(t11) {
            let e11 = t11.min + "," + t11.max;
            t11.extKey !== e11 && (t11.extKey = e11, l10.push(function() {
              aD(t11, "afterSetExtremes", aE(t11.eventArgs, t11.getExtremes())), delete t11.eventArgs;
            })), (p4 || d10) && t11.redraw();
          }), p4 && this.drawChartBox(), aD(this, "predraw"), i10.forEach(function(t11) {
            (p4 || t11.isDirty) && t11.visible && t11.redraw(), t11.isDirtyData = false;
          }), s10 && s10.reset(true), a10.draw(), aD(this, "redraw"), aD(this, "render"), n10 && this.temporaryDisplay(true), l10.forEach(function(t11) {
            t11.call();
          });
        }
        get(t10) {
          let e10 = this.series;
          function i10(e11) {
            return e11.id === t10 || e11.options && e11.options.id === t10;
          }
          let s10 = aI(this.axes, i10) || aI(this.series, i10);
          for (let t11 = 0; !s10 && t11 < e10.length; t11++) s10 = aI(e10[t11].points || [], i10);
          return s10;
        }
        createAxes() {
          let t10 = this.userOptions;
          for (let e10 of (aD(this, "createAxes"), ["xAxis", "yAxis"])) for (let i10 of t10[e10] = aU(t10[e10] || {})) new sY(this, i10, e10);
          aD(this, "afterCreateAxes");
        }
        getSelectedPoints() {
          return this.series.reduce((t10, e10) => (e10.getPointsCollection().forEach((e11) => {
            aF(e11.selectedStaging, e11.selected) && t10.push(e11);
          }), t10), []);
        }
        getSelectedSeries() {
          return this.series.filter((t10) => t10.selected);
        }
        setTitle(t10, e10, i10) {
          this.applyDescription("title", t10), this.applyDescription("subtitle", e10), this.applyDescription("caption", void 0), this.layOutTitles(i10);
        }
        applyDescription(t10, e10) {
          let i10 = this, s10 = this.options[t10] = aX(this.options[t10], e10), o10 = this[t10];
          o10 && e10 && (this[t10] = o10 = o10.destroy()), s10 && !o10 && ((o10 = this.renderer.text(s10.text, 0, 0, s10.useHTML).attr({
            align: s10.align,
            class: "highcharts-" + t10,
            zIndex: s10.zIndex || 4
          }).css({
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          }).add()).update = function(e11, s11) {
            i10.applyDescription(t10, e11), i10.layOutTitles(s11);
          }, this.styledMode || o10.css(aE("title" === t10 ? {
            fontSize: this.options.isStock ? "1em" : "1.2em"
          } : {}, s10.style)), o10.textPxLength = o10.getBBox().width, o10.css({
            whiteSpace: s10.style?.whiteSpace
          }), this[t10] = o10);
        }
        layOutTitles(t10 = true) {
          let e10 = [0, 0, 0], {
            options: i10,
            renderer: s10,
            spacingBox: o10
          } = this;
          ["title", "subtitle", "caption"].forEach((t11) => {
            let i11 = this[t11], r11 = this.options[t11], a10 = aX(o10), n10 = i11?.textPxLength || 0;
            if (i11 && r11) {
              aD(this, "layOutTitle", {
                alignTo: a10,
                key: t11,
                textPxLength: n10
              });
              let o11 = s10.fontMetrics(i11), l10 = o11.b, h10 = o11.h, d10 = r11.verticalAlign || "top", c10 = "top" === d10, p4 = c10 && r11.minScale || 1, u2 = "title" === t11 ? c10 ? -3 : 0 : c10 ? e10[0] + 2 : 0, g2 = Math.min(a10.width / n10, 1), m2 = Math.max(p4, g2), f2 = aX({
                y: "bottom" === d10 ? l10 : u2 + l10
              }, {
                align: "title" === t11 ? g2 < p4 ? "left" : "center" : this.title?.alignValue
              }, r11), x2 = r11.width || (g2 > p4 ? this.chartWidth : a10.width) / m2;
              i11.alignValue !== f2.align && (i11.placed = false);
              let y2 = Math.round(i11.css({
                width: `${x2}px`
              }).getBBox(r11.useHTML).height);
              if (f2.height = y2, i11.align(f2, false, a10).attr({
                align: f2.align,
                scaleX: m2,
                scaleY: m2,
                "transform-origin": `${a10.x + n10 * m2 * aB(f2.align)} ${h10}`
              }), !r11.floating) {
                let t12 = y2 * (y2 < 1.2 * h10 ? 1 : m2);
                "top" === d10 ? e10[0] = Math.ceil(e10[0] + t12) : "bottom" === d10 && (e10[2] = Math.ceil(e10[2] + t12));
              }
            }
          }, this), e10[0] && "top" === (i10.title?.verticalAlign || "top") && (e10[0] += i10.title?.margin || 0), e10[2] && i10.caption?.verticalAlign === "bottom" && (e10[2] += i10.caption?.margin || 0);
          let r10 = !this.titleOffset || this.titleOffset.join(",") !== e10.join(",");
          this.titleOffset = e10, aD(this, "afterLayOutTitles"), !this.isDirtyBox && r10 && (this.isDirtyBox = this.isDirtyLegend = r10, this.hasRendered && t10 && this.isDirtyBox && this.redraw());
        }
        getContainerBox() {
          let t10 = [].map.call(this.renderTo.children, (t11) => {
            if (t11 !== this.container) {
              let e11 = t11.style.display;
              return t11.style.display = "none", [t11, e11];
            }
          }), e10 = {
            width: az(this.renderTo, "width", true) || 0,
            height: az(this.renderTo, "height", true) || 0
          };
          return t10.filter(Boolean).forEach(([t11, e11]) => {
            t11.style.display = e11;
          }), e10;
        }
        getChartSize() {
          let t10 = this.options.chart, e10 = t10.width, i10 = t10.height, s10 = this.getContainerBox(), o10 = s10.height <= 1 || !this.renderTo.parentElement?.style.height && "100%" === this.renderTo.style.height;
          this.chartWidth = Math.max(0, e10 || s10.width || 600), this.chartHeight = Math.max(0, aY(i10, this.chartWidth) || (o10 ? 400 : s10.height)), this.containerBox = s10;
        }
        temporaryDisplay(t10) {
          let e10 = this.renderTo, i10;
          if (t10) for (; e10 && e10.style; ) e10.hcOrigStyle && (aT(e10, e10.hcOrigStyle), delete e10.hcOrigStyle), e10.hcOrigDetached && (ax.body.removeChild(e10), e10.hcOrigDetached = false), e10 = e10.parentNode;
          else for (; e10 && e10.style && (ax.body.contains(e10) || e10.parentNode || (e10.hcOrigDetached = true, ax.body.appendChild(e10)), ("none" === az(e10, "display", false) || e10.hcOricDetached) && (e10.hcOrigStyle = {
            display: e10.style.display,
            height: e10.style.height,
            overflow: e10.style.overflow
          }, i10 = {
            display: "block",
            overflow: "hidden"
          }, e10 !== this.renderTo && (i10.height = 0), aT(e10, i10), e10.offsetWidth || e10.style.setProperty("display", "block", "important")), (e10 = e10.parentNode) !== ax.body); ) ;
        }
        setClassName(t10) {
          this.container.className = "highcharts-container " + (t10 || "");
        }
        getContainer() {
          let t10;
          let e10 = this.options, i10 = e10.chart, s10 = "data-highcharts-chart", o10 = a$(), r10 = this.renderTo, a10 = aH(ak(r10, s10));
          aR(a10) && af[a10] && af[a10].hasRendered && af[a10].destroy(), ak(r10, s10, this.index), r10.innerHTML = t3.emptyHTML, i10.skipClone || r10.offsetWidth || this.temporaryDisplay(), this.getChartSize();
          let n10 = this.chartHeight, l10 = this.chartWidth;
          aT(r10, {
            overflow: "hidden"
          }), this.styledMode || (t10 = aE({
            position: "relative",
            overflow: "hidden",
            width: l10 + "px",
            height: n10 + "px",
            textAlign: "left",
            lineHeight: "normal",
            zIndex: 0,
            "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
            userSelect: "none",
            "touch-action": "manipulation",
            outline: "none",
            padding: "0px"
          }, i10.style || {}));
          let h10 = aS("div", {
            id: o10
          }, t10, r10);
          this.container = h10, this.getChartSize(), l10 === this.chartWidth || (l10 = this.chartWidth, this.styledMode || aT(h10, {
            width: aF(i10.style?.width, l10 + "px")
          })), this.containerBox = this.getContainerBox(), this._cursor = h10.style.cursor;
          let d10 = i10.renderer || !ab ? ec.getRendererType(i10.renderer) : iH;
          if (this.renderer = new d10(h10, l10, n10, void 0, i10.forExport, e10.exporting && e10.exporting.allowHTML, this.styledMode), ap(void 0, this), this.setClassName(i10.className), this.styledMode) for (let t11 in e10.defs) this.renderer.definition(e10.defs[t11]);
          else this.renderer.setStyle(i10.style);
          this.renderer.chartIndex = this.index, aD(this, "afterGetContainer");
        }
        getMargins(t10) {
          let {
            spacing: e10,
            margin: i10,
            titleOffset: s10
          } = this;
          this.resetMargins(), s10[0] && !aC(i10[0]) && (this.plotTop = Math.max(this.plotTop, s10[0] + e10[0])), s10[2] && !aC(i10[2]) && (this.marginBottom = Math.max(this.marginBottom, s10[2] + e10[2])), this.legend && this.legend.display && this.legend.adjustMargins(i10, e10), aD(this, "getMargins"), t10 || this.getAxisMargins();
        }
        getAxisMargins() {
          let t10 = this, e10 = t10.axisOffset = [0, 0, 0, 0], i10 = t10.colorAxis, s10 = t10.margin, o10 = function(t11) {
            t11.forEach(function(t12) {
              t12.visible && t12.getOffset();
            });
          };
          t10.hasCartesianSeries ? o10(t10.axes) : i10 && i10.length && o10(i10), ay.forEach(function(i11, o11) {
            aC(s10[o11]) || (t10[i11] += e10[o11]);
          }), t10.setChartSize();
        }
        getOptions() {
          return aA(this.userOptions, au);
        }
        reflow(t10) {
          let e10 = this, i10 = e10.containerBox, s10 = e10.getContainerBox();
          delete e10.pointer?.chartPosition, !e10.isPrinting && !e10.isResizing && i10 && s10.width && ((s10.width !== i10.width || s10.height !== i10.height) && (J.clearTimeout(e10.reflowTimeout), e10.reflowTimeout = aZ(function() {
            e10.container && e10.setSize(void 0, void 0, false);
          }, t10 ? 100 : 0)), e10.containerBox = s10);
        }
        setReflow() {
          let t10 = this, e10 = (e11) => {
            t10.options?.chart.reflow && t10.hasLoaded && t10.reflow(e11);
          };
          if ("function" == typeof ResizeObserver) new ResizeObserver(e10).observe(t10.renderTo);
          else {
            let t11 = aw(av, "resize", e10);
            aw(this, "destroy", t11);
          }
        }
        setSize(t10, e10, i10) {
          let s10 = this, o10 = s10.renderer;
          s10.isResizing += 1, ap(i10, s10);
          let r10 = o10.globalAnimation;
          s10.oldChartHeight = s10.chartHeight, s10.oldChartWidth = s10.chartWidth, void 0 !== t10 && (s10.options.chart.width = t10), void 0 !== e10 && (s10.options.chart.height = e10), s10.getChartSize();
          let {
            chartWidth: a10,
            chartHeight: n10,
            scrollablePixelsX: l10 = 0,
            scrollablePixelsY: h10 = 0
          } = s10;
          (s10.isDirtyBox || a10 !== s10.oldChartWidth || n10 !== s10.oldChartHeight) && (s10.styledMode || (r10 ? ad : aT)(s10.container, {
            width: `${a10 + l10}px`,
            height: `${n10 + h10}px`
          }, r10), s10.setChartSize(true), o10.setSize(a10, n10, r10), s10.axes.forEach(function(t11) {
            t11.isDirty = true, t11.setScale();
          }), s10.isDirtyLegend = true, s10.isDirtyBox = true, s10.layOutTitles(), s10.getMargins(), s10.redraw(r10), s10.oldChartHeight = void 0, aD(s10, "resize"), setTimeout(() => {
            s10 && aD(s10, "endResize");
          }, ac(r10).duration)), s10.isResizing -= 1;
        }
        setChartSize(t10) {
          let e10, i10, s10, o10;
          let {
            chartHeight: r10,
            chartWidth: a10,
            inverted: n10,
            spacing: l10,
            renderer: h10
          } = this, d10 = this.clipOffset, c10 = Math[n10 ? "floor" : "round"];
          this.plotLeft = e10 = Math.round(this.plotLeft), this.plotTop = i10 = Math.round(this.plotTop), this.plotWidth = s10 = Math.max(0, Math.round(a10 - e10 - this.marginRight)), this.plotHeight = o10 = Math.max(0, Math.round(r10 - i10 - this.marginBottom)), this.plotSizeX = n10 ? o10 : s10, this.plotSizeY = n10 ? s10 : o10, this.spacingBox = h10.spacingBox = {
            x: l10[3],
            y: l10[0],
            width: a10 - l10[3] - l10[1],
            height: r10 - l10[0] - l10[2]
          }, this.plotBox = h10.plotBox = {
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }, d10 && (this.clipBox = {
            x: c10(d10[3]),
            y: c10(d10[0]),
            width: c10(this.plotSizeX - d10[1] - d10[3]),
            height: c10(this.plotSizeY - d10[0] - d10[2])
          }), t10 || (this.axes.forEach(function(t11) {
            t11.setAxisSize(), t11.setAxisTranslation();
          }), h10.alignElements()), aD(this, "afterSetChartSize", {
            skipAxes: t10
          });
        }
        resetMargins() {
          aD(this, "resetMargins");
          let t10 = this, e10 = t10.options.chart, i10 = e10.plotBorderWidth || 0, s10 = i10 / 2;
          ["margin", "spacing"].forEach(function(i11) {
            let s11 = e10[i11], o10 = aW(s11) ? s11 : [s11, s11, s11, s11];
            ["Top", "Right", "Bottom", "Left"].forEach(function(s12, r10) {
              t10[i11][r10] = aF(e10[i11 + s12], o10[r10]);
            });
          }), ay.forEach(function(e11, i11) {
            t10[e11] = aF(t10.margin[i11], t10.spacing[i11]);
          }), t10.axisOffset = [0, 0, 0, 0], t10.clipOffset = [s10, s10, s10, s10], t10.plotBorderWidth = i10;
        }
        drawChartBox() {
          let t10 = this.options.chart, e10 = this.renderer, i10 = this.chartWidth, s10 = this.chartHeight, o10 = this.styledMode, r10 = this.plotBGImage, a10 = t10.backgroundColor, n10 = t10.plotBackgroundColor, l10 = t10.plotBackgroundImage, h10 = this.plotLeft, d10 = this.plotTop, c10 = this.plotWidth, p4 = this.plotHeight, u2 = this.plotBox, g2 = this.clipRect, m2 = this.clipBox, f2 = this.chartBackground, x2 = this.plotBackground, y2 = this.plotBorder, b2, v2, M2, w2 = "animate";
          f2 || (this.chartBackground = f2 = e10.rect().addClass("highcharts-background").add(), w2 = "attr"), o10 ? b2 = v2 = f2.strokeWidth() : (v2 = (b2 = t10.borderWidth || 0) + (t10.shadow ? 8 : 0), M2 = {
            fill: a10 || "none"
          }, (b2 || f2["stroke-width"]) && (M2.stroke = t10.borderColor, M2["stroke-width"] = b2), f2.attr(M2).shadow(t10.shadow)), f2[w2]({
            x: v2 / 2,
            y: v2 / 2,
            width: i10 - v2 - b2 % 2,
            height: s10 - v2 - b2 % 2,
            r: t10.borderRadius
          }), w2 = "animate", x2 || (w2 = "attr", this.plotBackground = x2 = e10.rect().addClass("highcharts-plot-background").add()), x2[w2](u2), !o10 && (x2.attr({
            fill: n10 || "none"
          }).shadow(t10.plotShadow), l10 && (r10 ? (l10 !== r10.attr("href") && r10.attr("href", l10), r10.animate(u2)) : this.plotBGImage = e10.image(l10, h10, d10, c10, p4).add())), g2 ? g2.animate({
            width: m2.width,
            height: m2.height
          }) : this.clipRect = e10.clipRect(m2), w2 = "animate", y2 || (w2 = "attr", this.plotBorder = y2 = e10.rect().addClass("highcharts-plot-border").attr({
            zIndex: 1
          }).add()), o10 || y2.attr({
            stroke: t10.plotBorderColor,
            "stroke-width": t10.plotBorderWidth || 0,
            fill: "none"
          }), y2[w2](y2.crisp({
            x: h10,
            y: d10,
            width: c10,
            height: p4
          }, -y2.strokeWidth())), this.isDirtyBox = false, aD(this, "afterDrawChartBox");
        }
        propFromSeries() {
          let t10, e10, i10;
          let s10 = this, o10 = s10.options.chart, r10 = s10.options.series;
          ["inverted", "angular", "polar"].forEach(function(a10) {
            for (e10 = aM[o10.type], i10 = o10[a10] || e10 && e10.prototype[a10], t10 = r10 && r10.length; !i10 && t10--; ) (e10 = aM[r10[t10].type]) && e10.prototype[a10] && (i10 = true);
            s10[a10] = i10;
          });
        }
        linkSeries(t10) {
          let e10 = this, i10 = e10.series;
          i10.forEach(function(t11) {
            t11.linkedSeries.length = 0;
          }), i10.forEach(function(t11) {
            let {
              linkedTo: i11
            } = t11.options;
            if (aj(i11)) {
              let s10;
              (s10 = ":previous" === i11 ? e10.series[t11.index - 1] : e10.get(i11)) && s10.linkedParent !== t11 && (s10.linkedSeries.push(t11), t11.linkedParent = s10, s10.enabledDataSorting && t11.setDataSortingOptions(), t11.visible = aF(t11.options.visible, s10.options.visible, t11.visible));
            }
          }), aD(this, "afterLinkSeries", {
            isUpdating: t10
          });
        }
        renderSeries() {
          this.series.forEach(function(t10) {
            t10.translate(), t10.render();
          });
        }
        render() {
          let t10 = this.axes, e10 = this.colorAxis, i10 = this.renderer, s10 = this.options.chart.axisLayoutRuns || 2, o10 = (t11) => {
            t11.forEach((t12) => {
              t12.visible && t12.render();
            });
          }, r10 = 0, a10 = true, n10, l10 = 0;
          for (let e11 of (this.setTitle(), aD(this, "beforeMargins"), this.getStacks?.(), this.getMargins(true), this.setChartSize(), t10)) {
            let {
              options: t11
            } = e11, {
              labels: i11
            } = t11;
            if (this.hasCartesianSeries && e11.horiz && e11.visible && i11.enabled && e11.series.length && "colorAxis" !== e11.coll && !this.polar) {
              r10 = t11.tickLength, e11.createGroups();
              let s11 = new sp(e11, 0, "", true), o11 = s11.createLabel("x", i11);
              if (s11.destroy(), o11 && aF(i11.reserveSpace, !aR(t11.crossing)) && (r10 = o11.getBBox().height + i11.distance + Math.max(t11.offset || 0, 0)), r10) {
                o11?.destroy();
                break;
              }
            }
          }
          for (this.plotHeight = Math.max(this.plotHeight - r10, 0); (a10 || n10 || s10 > 1) && l10 < s10; ) {
            let e11 = this.plotWidth, i11 = this.plotHeight;
            for (let e12 of t10) 0 === l10 ? e12.setScale() : (e12.horiz && a10 || !e12.horiz && n10) && e12.setTickInterval(true);
            0 === l10 ? this.getAxisMargins() : this.getMargins(), a10 = e11 / this.plotWidth > (l10 ? 1 : 1.1), n10 = i11 / this.plotHeight > (l10 ? 1 : 1.05), l10++;
          }
          this.drawChartBox(), this.hasCartesianSeries ? o10(t10) : e10 && e10.length && o10(e10), this.seriesGroup || (this.seriesGroup = i10.g("series-group").attr({
            zIndex: 3
          }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = true;
        }
        addCredits(t10) {
          let e10 = this, i10 = aX(true, this.options.credits, t10);
          i10.enabled && !this.credits && (this.credits = this.renderer.text(i10.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
            i10.href && (av.location.href = i10.href);
          }).attr({
            align: i10.position.align,
            zIndex: 8
          }), e10.styledMode || this.credits.css(i10.style), this.credits.add().align(i10.position), this.credits.update = function(t11) {
            e10.credits = e10.credits.destroy(), e10.addCredits(t11);
          });
        }
        destroy() {
          let t10;
          let e10 = this, i10 = e10.axes, s10 = e10.series, o10 = e10.container, r10 = o10 && o10.parentNode;
          for (aD(e10, "destroy"), e10.renderer.forExport ? aL(af, e10) : af[e10.index] = void 0, A.chartCount--, e10.renderTo.removeAttribute("data-highcharts-chart"), aV(e10), t10 = i10.length; t10--; ) i10[t10] = i10[t10].destroy();
          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t10 = s10.length; t10--; ) s10[t10] = s10[t10].destroy();
          ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(t11) {
            let i11 = e10[t11];
            i11 && i11.destroy && (e10[t11] = i11.destroy());
          }), o10 && (o10.innerHTML = t3.emptyHTML, aV(o10), r10 && aP(o10)), aG(e10, function(t11, i11) {
            delete e10[i11];
          });
        }
        firstRender() {
          let t10 = this, e10 = t10.options;
          t10.getContainer(), t10.resetMargins(), t10.setChartSize(), t10.propFromSeries(), t10.createAxes();
          let i10 = aN(e10.series) ? e10.series : [];
          e10.series = [], i10.forEach(function(e11) {
            t10.initSeries(e11);
          }), t10.linkSeries(), t10.setSortedData(), aD(t10, "beforeRender"), t10.render(), t10.pointer?.getChartPosition(), t10.renderer.imgCount || t10.hasLoaded || t10.onload(), t10.temporaryDisplay(true);
        }
        onload() {
          this.callbacks.concat([this.callback]).forEach(function(t10) {
            t10 && void 0 !== this.index && t10.apply(this, [this]);
          }, this), aD(this, "load"), aD(this, "render"), aC(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = true;
        }
        warnIfA11yModuleNotLoaded() {
          let {
            options: t10,
            title: e10
          } = this;
          !t10 || this.accessibility || (this.renderer.boxWrapper.attr({
            role: "img",
            "aria-label": (e10 && e10.element.textContent || "").replace(/</g, "&lt;")
          }), t10.accessibility && false === t10.accessibility.enabled || aO('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this));
        }
        addSeries(t10, e10, i10) {
          let s10;
          let o10 = this;
          return t10 && (e10 = aF(e10, true), aD(o10, "addSeries", {
            options: t10
          }, function() {
            s10 = o10.initSeries(t10), o10.isDirtyLegend = true, o10.linkSeries(), s10.enabledDataSorting && s10.setData(t10.data, false), aD(o10, "afterAddSeries", {
              series: s10
            }), e10 && o10.redraw(i10);
          })), s10;
        }
        addAxis(t10, e10, i10, s10) {
          return this.createAxis(e10 ? "xAxis" : "yAxis", {
            axis: t10,
            redraw: i10,
            animation: s10
          });
        }
        addColorAxis(t10, e10, i10) {
          return this.createAxis("colorAxis", {
            axis: t10,
            redraw: e10,
            animation: i10
          });
        }
        createAxis(t10, e10) {
          let i10 = new sY(this, e10.axis, t10);
          return aF(e10.redraw, true) && this.redraw(e10.animation), i10;
        }
        showLoading(t10) {
          let e10 = this, i10 = e10.options, s10 = i10.loading, o10 = function() {
            r10 && aT(r10, {
              left: e10.plotLeft + "px",
              top: e10.plotTop + "px",
              width: e10.plotWidth + "px",
              height: e10.plotHeight + "px"
            });
          }, r10 = e10.loadingDiv, a10 = e10.loadingSpan;
          r10 || (e10.loadingDiv = r10 = aS("div", {
            className: "highcharts-loading highcharts-loading-hidden"
          }, null, e10.container)), a10 || (e10.loadingSpan = a10 = aS("span", {
            className: "highcharts-loading-inner"
          }, null, r10), aw(e10, "redraw", o10)), r10.className = "highcharts-loading", t3.setElementHTML(a10, aF(t10, i10.lang.loading, "")), e10.styledMode || (aT(r10, aE(s10.style, {
            zIndex: 10
          })), aT(a10, s10.labelStyle), e10.loadingShown || (aT(r10, {
            opacity: 0,
            display: ""
          }), ad(r10, {
            opacity: s10.style.opacity || 0.5
          }, {
            duration: s10.showDuration || 0
          }))), e10.loadingShown = true, o10();
        }
        hideLoading() {
          let t10 = this.options, e10 = this.loadingDiv;
          e10 && (e10.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || ad(e10, {
            opacity: 0
          }, {
            duration: t10.loading.hideDuration || 100,
            complete: function() {
              aT(e10, {
                display: "none"
              });
            }
          })), this.loadingShown = false;
        }
        update(t10, e10, i10, s10) {
          let o10, r10, a10;
          let n10 = this, l10 = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }, h10 = t10.isResponsiveOptions, d10 = [];
          aD(n10, "update", {
            options: t10
          }), h10 || n10.setResponsive(false, true), t10 = aA(t10, n10.options), n10.userOptions = aX(n10.userOptions, t10);
          let c10 = t10.chart;
          c10 && (aX(true, n10.options.chart, c10), this.setZoomOptions(), "className" in c10 && n10.setClassName(c10.className), ("inverted" in c10 || "polar" in c10 || "type" in c10) && (n10.propFromSeries(), o10 = true), "alignTicks" in c10 && (o10 = true), "events" in c10 && am(this, c10), aG(c10, function(t11, e11) {
            -1 !== n10.propsRequireUpdateSeries.indexOf("chart." + e11) && (r10 = true), -1 !== n10.propsRequireDirtyBox.indexOf(e11) && (n10.isDirtyBox = true), -1 === n10.propsRequireReflow.indexOf(e11) || (n10.isDirtyBox = true, h10 || (a10 = true));
          }), !n10.styledMode && c10.style && n10.renderer.setStyle(n10.options.chart.style || {})), !n10.styledMode && t10.colors && (this.options.colors = t10.colors), aG(t10, function(e11, i11) {
            n10[i11] && "function" == typeof n10[i11].update ? n10[i11].update(e11, false) : "function" == typeof n10[l10[i11]] ? n10[l10[i11]](e11) : "colors" !== i11 && -1 === n10.collectionsWithUpdate.indexOf(i11) && aX(true, n10.options[i11], t10[i11]), "chart" !== i11 && -1 !== n10.propsRequireUpdateSeries.indexOf(i11) && (r10 = true);
          }), this.collectionsWithUpdate.forEach(function(e11) {
            t10[e11] && (aU(t10[e11]).forEach(function(t11, s11) {
              let o11;
              let r11 = aC(t11.id);
              r11 && (o11 = n10.get(t11.id)), !o11 && n10[e11] && (o11 = n10[e11][aF(t11.index, s11)]) && (r11 && aC(o11.options.id) || o11.options.isInternal) && (o11 = void 0), o11 && o11.coll === e11 && (o11.update(t11, false), i10 && (o11.touched = true)), !o11 && i10 && n10.collectionsWithInit[e11] && (n10.collectionsWithInit[e11][0].apply(n10, [t11].concat(n10.collectionsWithInit[e11][1] || []).concat([false])).touched = true);
            }), i10 && n10[e11].forEach(function(t11) {
              t11.touched || t11.options.isInternal ? delete t11.touched : d10.push(t11);
            }));
          }), d10.forEach(function(t11) {
            t11.chart && t11.remove && t11.remove(false);
          }), o10 && n10.axes.forEach(function(t11) {
            t11.update({}, false);
          }), r10 && n10.getSeriesOrderByLinks().forEach(function(t11) {
            t11.chart && t11.update({}, false);
          }, this);
          let p4 = c10 && c10.width, u2 = c10 && (aj(c10.height) ? aY(c10.height, p4 || n10.chartWidth) : c10.height);
          a10 || aR(p4) && p4 !== n10.chartWidth || aR(u2) && u2 !== n10.chartHeight ? n10.setSize(p4, u2, s10) : aF(e10, true) && n10.redraw(s10), aD(n10, "afterUpdate", {
            options: t10,
            redraw: e10,
            animation: s10
          });
        }
        setSubtitle(t10, e10) {
          this.applyDescription("subtitle", t10), this.layOutTitles(e10);
        }
        setCaption(t10, e10) {
          this.applyDescription("caption", t10), this.layOutTitles(e10);
        }
        showResetZoom() {
          let t10 = this, e10 = au.lang, i10 = t10.zooming.resetButton, s10 = i10.theme, o10 = "chart" === i10.relativeTo || "spacingBox" === i10.relativeTo ? null : "plotBox";
          function r10() {
            t10.zoomOut();
          }
          aD(this, "beforeShowResetZoom", null, function() {
            t10.resetZoomButton = t10.renderer.button(e10.resetZoom, null, null, r10, s10).attr({
              align: i10.position.align,
              title: e10.resetZoomTitle
            }).addClass("highcharts-reset-zoom").add().align(i10.position, false, o10);
          }), aD(this, "afterShowResetZoom");
        }
        zoomOut() {
          aD(this, "selection", {
            resetSelection: true
          }, () => this.transform({
            reset: true,
            trigger: "zoom"
          }));
        }
        pan(t10, e10) {
          let i10 = this, s10 = "object" == typeof e10 ? e10 : {
            enabled: e10,
            type: "x"
          }, o10 = s10.type, r10 = o10 && i10[{
            x: "xAxis",
            xy: "axes",
            y: "yAxis"
          }[o10]].filter((t11) => t11.options.panningEnabled && !t11.options.isInternal), a10 = i10.options.chart;
          a10?.panning && (a10.panning = s10), aD(this, "pan", {
            originalEvent: t10
          }, () => {
            i10.transform({
              axes: r10,
              event: t10,
              to: {
                x: t10.chartX - (i10.mouseDownX || 0),
                y: t10.chartY - (i10.mouseDownY || 0)
              },
              trigger: "pan"
            }), aT(i10.container, {
              cursor: "move"
            });
          });
        }
        transform(t10) {
          let {
            axes: e10 = this.axes,
            event: i10,
            from: s10 = {},
            reset: o10,
            selection: r10,
            to: a10 = {},
            trigger: n10
          } = t10, {
            inverted: l10,
            time: h10
          } = this, d10 = false, c10, p4;
          for (let t11 of (this.hoverPoints?.forEach((t12) => t12.setState()), e10)) {
            let {
              horiz: e11,
              len: u2,
              minPointOffset: g2 = 0,
              options: m2,
              reversed: f2
            } = t11, x2 = e11 ? "width" : "height", y2 = e11 ? "x" : "y", b2 = aF(a10[x2], t11.len), v2 = aF(s10[x2], t11.len), M2 = 10 > Math.abs(b2) ? 1 : b2 / v2, w2 = (s10[y2] || 0) + v2 / 2 - t11.pos, k2 = w2 - ((a10[y2] ?? t11.pos) + b2 / 2 - t11.pos) / M2, S2 = f2 && !l10 || !f2 && l10 ? -1 : 1;
            if (!o10 && (w2 < 0 || w2 > t11.len)) continue;
            let T2 = t11.toValue(k2, true) + (r10 || t11.isOrdinal ? 0 : g2 * S2), C2 = t11.toValue(k2 + u2 / M2, true) - (r10 || t11.isOrdinal ? 0 : g2 * S2 || 0), A2 = t11.allExtremes;
            if (T2 > C2 && ([T2, C2] = [C2, T2]), 1 === M2 && !o10 && "yAxis" === t11.coll && !A2) {
              for (let e12 of t11.series) {
                let t12 = e12.getExtremes(e12.getProcessedData(true).modified.getColumn("y") || [], true);
                A2 ?? (A2 = {
                  dataMin: Number.MAX_VALUE,
                  dataMax: -Number.MAX_VALUE
                }), aR(t12.dataMin) && aR(t12.dataMax) && (A2.dataMin = Math.min(t12.dataMin, A2.dataMin), A2.dataMax = Math.max(t12.dataMax, A2.dataMax));
              }
              t11.allExtremes = A2;
            }
            let {
              dataMin: P2,
              dataMax: L2,
              min: O2,
              max: E2
            } = aE(t11.getExtremes(), A2 || {}), I2 = h10.parse(m2.min), D2 = h10.parse(m2.max), B2 = P2 ?? I2, z2 = L2 ?? D2, N2 = C2 - T2, R2 = t11.categories ? 0 : Math.min(N2, z2 - B2), W2 = B2 - R2 * (aC(I2) ? 0 : m2.minPadding), j2 = z2 + R2 * (aC(D2) ? 0 : m2.maxPadding), X2 = t11.allowZoomOutside || 1 === M2 || "zoom" !== n10 && M2 > 1, G2 = Math.min(I2 ?? W2, W2, X2 ? O2 : W2), F2 = Math.max(D2 ?? j2, j2, X2 ? E2 : j2);
            (!t11.isOrdinal || t11.options.overscroll || 1 !== M2 || o10) && (T2 < G2 && (T2 = G2, M2 >= 1 && (C2 = T2 + N2)), C2 > F2 && (C2 = F2, M2 >= 1 && (T2 = C2 - N2)), (o10 || t11.series.length && (T2 !== O2 || C2 !== E2) && T2 >= G2 && C2 <= F2) && (r10 ? r10[t11.coll].push({
              axis: t11,
              min: T2,
              max: C2
            }) : (t11.isPanning = "zoom" !== n10, t11.isPanning && (p4 = true), t11.setExtremes(o10 ? void 0 : T2, o10 ? void 0 : C2, false, false, {
              move: k2,
              trigger: n10,
              scale: M2
            }), !o10 && (T2 > G2 || C2 < F2) && "mousewheel" !== n10 && (c10 = true)), d10 = true), i10 && (this[e11 ? "mouseDownX" : "mouseDownY"] = i10[e11 ? "chartX" : "chartY"]));
          }
          return d10 && (r10 ? aD(this, "selection", r10, () => {
            delete t10.selection, t10.trigger = "zoom", this.transform(t10);
          }) : (!c10 || p4 || this.resetZoomButton ? !c10 && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw("zoom" === n10 && (this.options.chart.animation ?? this.pointCount < 100)))), d10;
        }
      }
      aE(a_.prototype, {
        callbacks: [],
        collectionsWithInit: {
          xAxis: [a_.prototype.addAxis, [true]],
          yAxis: [a_.prototype.addAxis, [false]],
          series: [a_.prototype.addSeries]
        },
        collectionsWithUpdate: ["xAxis", "yAxis", "series"],
        propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],
        propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],
        propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]
      });
      let aq = a_, {
        stop: aK
      } = tH, {
        composed: aJ
      } = A, {
        addEvent: aQ,
        createElement: a0,
        css: a1,
        defined: a2,
        erase: a3,
        merge: a6,
        pushUnique: a5
      } = J;
      function a9() {
        let t10 = this.scrollablePlotArea;
        (this.scrollablePixelsX || this.scrollablePixelsY) && !t10 && (this.scrollablePlotArea = t10 = new a4(this)), t10?.applyFixed();
      }
      function a8() {
        this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = true);
      }
      class a4 {
        static compose(t10, e10, i10) {
          a5(aJ, this.compose) && (aQ(t10, "afterInit", a8), aQ(e10, "afterSetChartSize", (t11) => this.afterSetSize(t11.target, t11)), aQ(e10, "render", a9), aQ(i10, "show", a8));
        }
        static afterSetSize(t10, e10) {
          let i10, s10, o10;
          let {
            minWidth: r10,
            minHeight: a10
          } = t10.options.chart.scrollablePlotArea || {}, {
            clipBox: n10,
            plotBox: l10,
            inverted: h10,
            renderer: d10
          } = t10;
          if (!d10.forExport && (r10 ? (t10.scrollablePixelsX = i10 = Math.max(0, r10 - t10.chartWidth), i10 && (t10.scrollablePlotBox = a6(t10.plotBox), l10.width = t10.plotWidth += i10, n10[h10 ? "height" : "width"] += i10, o10 = true)) : a10 && (t10.scrollablePixelsY = s10 = Math.max(0, a10 - t10.chartHeight), a2(s10) && (t10.scrollablePlotBox = a6(t10.plotBox), l10.height = t10.plotHeight += s10, n10[h10 ? "width" : "height"] += s10, o10 = false)), a2(o10) && !e10.skipAxes)) for (let e11 of t10.axes) (e11.horiz === o10 || t10.hasParallelCoordinates && "yAxis" === e11.coll) && (e11.setAxisSize(), e11.setAxisTranslation());
        }
        constructor(t10) {
          let e10;
          let i10 = t10.options.chart, s10 = ec.getRendererType(), o10 = i10.scrollablePlotArea || {}, r10 = this.moveFixedElements.bind(this), a10 = {
            WebkitOverflowScrolling: "touch",
            overflowX: "hidden",
            overflowY: "hidden"
          };
          t10.scrollablePixelsX && (a10.overflowX = "auto"), t10.scrollablePixelsY && (a10.overflowY = "auto"), this.chart = t10;
          let n10 = this.parentDiv = a0("div", {
            className: "highcharts-scrolling-parent"
          }, {
            position: "relative"
          }, t10.renderTo), l10 = this.scrollingContainer = a0("div", {
            className: "highcharts-scrolling"
          }, a10, n10), h10 = this.innerContainer = a0("div", {
            className: "highcharts-inner-container"
          }, void 0, l10), d10 = this.fixedDiv = a0("div", {
            className: "highcharts-fixed"
          }, {
            position: "absolute",
            overflow: "hidden",
            pointerEvents: "none",
            zIndex: (i10.style?.zIndex || 0) + 2,
            top: 0
          }, void 0, true), c10 = this.fixedRenderer = new s10(d10, t10.chartWidth, t10.chartHeight, i10.style);
          this.mask = c10.path().attr({
            fill: i10.backgroundColor || "#fff",
            "fill-opacity": o10.opacity ?? 0.85,
            zIndex: -1
          }).addClass("highcharts-scrollable-mask").add(), l10.parentNode.insertBefore(d10, l10), a1(t10.renderTo, {
            overflow: "visible"
          }), aQ(t10, "afterShowResetZoom", r10), aQ(t10, "afterApplyDrilldown", r10), aQ(t10, "afterLayOutTitles", r10), aQ(l10, "scroll", () => {
            let {
              pointer: i11,
              hoverPoint: s11
            } = t10;
            i11 && (delete i11.chartPosition, s11 && (e10 = s11), i11.runPointActions(void 0, e10, true));
          }), h10.appendChild(t10.container);
        }
        applyFixed() {
          let {
            chart: t10,
            fixedRenderer: e10,
            isDirty: i10,
            scrollingContainer: s10
          } = this, {
            axisOffset: o10,
            chartWidth: r10,
            chartHeight: a10,
            container: n10,
            plotHeight: l10,
            plotLeft: h10,
            plotTop: d10,
            plotWidth: c10,
            scrollablePixelsX: p4 = 0,
            scrollablePixelsY: u2 = 0
          } = t10, {
            scrollPositionX: g2 = 0,
            scrollPositionY: m2 = 0
          } = t10.options.chart.scrollablePlotArea || {}, f2 = r10 + p4, x2 = a10 + u2;
          e10.setSize(r10, a10), (i10 ?? true) && (this.isDirty = false, this.moveFixedElements()), aK(t10.container), a1(n10, {
            width: `${f2}px`,
            height: `${x2}px`
          }), t10.renderer.boxWrapper.attr({
            width: f2,
            height: x2,
            viewBox: [0, 0, f2, x2].join(" ")
          }), t10.chartBackground?.attr({
            width: f2,
            height: x2
          }), a1(s10, {
            width: `${r10}px`,
            height: `${a10}px`
          }), a2(i10) || (s10.scrollLeft = p4 * g2, s10.scrollTop = u2 * m2);
          let y2 = d10 - o10[0] - 1, b2 = h10 - o10[3] - 1, v2 = d10 + l10 + o10[2] + 1, M2 = h10 + c10 + o10[1] + 1, w2 = h10 + c10 - p4, k2 = d10 + l10 - u2, S2 = [["M", 0, 0]];
          p4 ? S2 = [["M", 0, y2], ["L", h10 - 1, y2], ["L", h10 - 1, v2], ["L", 0, v2], ["Z"], ["M", w2, y2], ["L", r10, y2], ["L", r10, v2], ["L", w2, v2], ["Z"]] : u2 && (S2 = [["M", b2, 0], ["L", b2, d10 - 1], ["L", M2, d10 - 1], ["L", M2, 0], ["Z"], ["M", b2, k2], ["L", b2, a10], ["L", M2, a10], ["L", M2, k2], ["Z"]]), "adjustHeight" !== t10.redrawTrigger && this.mask.attr({
            d: S2
          });
        }
        moveFixedElements() {
          let t10;
          let {
            container: e10,
            inverted: i10,
            scrollablePixelsX: s10,
            scrollablePixelsY: o10
          } = this.chart, r10 = this.fixedRenderer, a10 = a4.fixedSelectors;
          if (s10 && !i10 ? t10 = ".highcharts-yaxis" : s10 && i10 ? t10 = ".highcharts-xaxis" : o10 && !i10 ? t10 = ".highcharts-xaxis" : o10 && i10 && (t10 = ".highcharts-yaxis"), t10 && !(this.chart.hasParallelCoordinates && ".highcharts-yaxis" === t10)) for (let e11 of [`${t10}:not(.highcharts-radial-axis)`, `${t10}-labels:not(.highcharts-radial-axis-labels)`]) a5(a10, e11);
          else for (let t11 of [".highcharts-xaxis", ".highcharts-yaxis"]) for (let e11 of [`${t11}:not(.highcharts-radial-axis)`, `${t11}-labels:not(.highcharts-radial-axis-labels)`]) a3(a10, e11);
          for (let t11 of a10) [].forEach.call(e10.querySelectorAll(t11), (t12) => {
            (t12.namespaceURI === r10.SVG_NS ? r10.box : r10.box.parentNode).appendChild(t12), t12.style.pointerEvents = "auto";
          });
        }
      }
      a4.fixedSelectors = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-drillup-button", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-range-selector-group", ".highcharts-reset-zoom", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];
      let {
        format: a7
      } = ed, {
        series: nt
      } = rx, {
        destroyObjectProperties: ne,
        fireEvent: ni,
        getAlignFactor: ns,
        isNumber: no,
        pick: nr
      } = J, na = class {
        constructor(t10, e10, i10, s10, o10) {
          let r10 = t10.chart.inverted, a10 = t10.reversed;
          this.axis = t10;
          let n10 = this.isNegative = !!i10 != !!a10;
          this.options = e10 = e10 || {}, this.x = s10, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = false, this.stack = o10, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
            align: e10.align || (r10 ? n10 ? "left" : "right" : "center"),
            verticalAlign: e10.verticalAlign || (r10 ? "middle" : n10 ? "bottom" : "top"),
            y: e10.y,
            x: e10.x
          }, this.textAlign = e10.textAlign || (r10 ? n10 ? "right" : "left" : "center");
        }
        destroy() {
          ne(this, this.axis);
        }
        render(t10) {
          let e10 = this.axis.chart, i10 = this.options, s10 = i10.format, o10 = s10 ? a7(s10, this, e10) : i10.formatter.call(this);
          if (this.label) this.label.attr({
            text: o10,
            visibility: "hidden"
          });
          else {
            this.label = e10.renderer.label(o10, null, void 0, i10.shape, void 0, void 0, i10.useHTML, false, "stack-labels");
            let s11 = {
              r: i10.borderRadius || 0,
              text: o10,
              padding: nr(i10.padding, 5),
              visibility: "hidden"
            };
            e10.styledMode || (s11.fill = i10.backgroundColor, s11.stroke = i10.borderColor, s11["stroke-width"] = i10.borderWidth, this.label.css(i10.style || {})), this.label.attr(s11), this.label.added || this.label.add(t10);
          }
          this.label.labelrank = e10.plotSizeY, ni(this, "afterRender");
        }
        setOffset(t10, e10, i10, s10, o10, r10) {
          let {
            alignOptions: a10,
            axis: n10,
            label: l10,
            options: h10,
            textAlign: d10
          } = this, c10 = n10.chart, p4 = this.getStackBox({
            xOffset: t10,
            width: e10,
            boxBottom: i10,
            boxTop: s10,
            defaultX: o10,
            xAxis: r10
          }), {
            verticalAlign: u2
          } = a10;
          if (l10 && p4) {
            let t11 = l10.getBBox(void 0, 0), e11 = l10.padding, i11 = "justify" === nr(h10.overflow, "justify"), s11;
            a10.x = h10.x || 0, a10.y = h10.y || 0;
            let {
              x: o11,
              y: r11
            } = this.adjustStackPosition({
              labelBox: t11,
              verticalAlign: u2,
              textAlign: d10
            });
            p4.x -= o11, p4.y -= r11, l10.align(a10, false, p4), (s11 = c10.isInsidePlot(l10.alignAttr.x + a10.x + o11, l10.alignAttr.y + a10.y + r11)) || (i11 = false), i11 && nt.prototype.justifyDataLabel.call(n10, l10, a10, l10.alignAttr, t11, p4), l10.attr({
              x: l10.alignAttr.x,
              y: l10.alignAttr.y,
              rotation: h10.rotation,
              rotationOriginX: t11.width * ns(h10.textAlign || "center"),
              rotationOriginY: t11.height / 2
            }), nr(!i11 && h10.crop, true) && (s11 = no(l10.x) && no(l10.y) && c10.isInsidePlot(l10.x - e11 + (l10.width || 0), l10.y) && c10.isInsidePlot(l10.x + e11, l10.y)), l10[s11 ? "show" : "hide"]();
          }
          ni(this, "afterSetOffset", {
            xOffset: t10,
            width: e10
          });
        }
        adjustStackPosition({
          labelBox: t10,
          verticalAlign: e10,
          textAlign: i10
        }) {
          return {
            x: t10.width / 2 + t10.width / 2 * (2 * ns(i10) - 1),
            y: t10.height / 2 * 2 * (1 - ns(e10))
          };
        }
        getStackBox(t10) {
          let e10 = this.axis, i10 = e10.chart, {
            boxTop: s10,
            defaultX: o10,
            xOffset: r10,
            width: a10,
            boxBottom: n10
          } = t10, l10 = e10.stacking.usePercentage ? 100 : nr(s10, this.total, 0), h10 = e10.toPixels(l10), d10 = t10.xAxis || i10.xAxis[0], c10 = nr(o10, d10.translate(this.x)) + r10, p4 = Math.abs(h10 - e10.toPixels(n10 || no(e10.min) && e10.logarithmic && e10.logarithmic.lin2log(e10.min) || 0)), u2 = i10.inverted, g2 = this.isNegative;
          return u2 ? {
            x: (g2 ? h10 : h10 - p4) - i10.plotLeft,
            y: d10.height - c10 - a10 + d10.top - i10.plotTop,
            width: p4,
            height: a10
          } : {
            x: c10 + d10.transB - i10.plotLeft,
            y: (g2 ? h10 - p4 : h10) - i10.plotTop,
            width: a10,
            height: p4
          };
        }
      }, {
        getDeferredAnimation: nn
      } = tH, {
        series: {
          prototype: nl
        }
      } = rx, {
        addEvent: nh,
        correctFloat: nd,
        defined: nc,
        destroyObjectProperties: np,
        fireEvent: nu,
        isNumber: ng,
        objectEach: nm,
        pick: nf
      } = J;
      function nx() {
        let t10 = this.inverted;
        this.axes.forEach((t11) => {
          t11.stacking && t11.stacking.stacks && t11.hasVisibleSeries && (t11.stacking.oldStacks = t11.stacking.stacks);
        }), this.series.forEach((e10) => {
          let i10 = e10.xAxis && e10.xAxis.options || {};
          e10.options.stacking && e10.reserveSpace() && (e10.stackKey = [e10.type, nf(e10.options.stack, ""), t10 ? i10.top : i10.left, t10 ? i10.height : i10.width].join(","));
        });
      }
      function ny() {
        let t10 = this.stacking;
        if (t10) {
          let e10 = t10.stacks;
          nm(e10, (t11, i10) => {
            np(t11), delete e10[i10];
          }), t10.stackTotalGroup?.destroy();
        }
      }
      function nb() {
        this.stacking || (this.stacking = new nT(this));
      }
      function nv(t10, e10, i10, s10) {
        return !nc(t10) || t10.x !== e10 || s10 && t10.stackKey !== s10 ? t10 = {
          x: e10,
          index: 0,
          key: s10,
          stackKey: s10
        } : t10.index++, t10.key = [i10, e10, t10.index].join(","), t10;
      }
      function nM() {
        let t10;
        let e10 = this, i10 = e10.yAxis, s10 = e10.stackKey || "", o10 = i10.stacking.stacks, r10 = e10.getColumn("x", true), a10 = e10.options.stacking, n10 = e10[a10 + "Stacker"];
        n10 && [s10, "-" + s10].forEach((i11) => {
          let s11 = r10.length, a11, l10, h10;
          for (; s11--; ) a11 = r10[s11], t10 = e10.getStackIndicator(t10, a11, e10.index, i11), l10 = o10[i11]?.[a11], (h10 = l10?.points[t10.key || ""]) && n10.call(e10, h10, l10, s11);
        });
      }
      function nw(t10, e10, i10) {
        let s10 = e10.total ? 100 / e10.total : 0;
        t10[0] = nd(t10[0] * s10), t10[1] = nd(t10[1] * s10), this.stackedYData[i10] = t10[1];
      }
      function nk(t10) {
        (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? nl.setStackedPoints.call(this, t10, "group") : t10.stacking.resetStacks());
      }
      function nS(t10, e10) {
        let i10, s10, o10, r10, a10, n10, l10;
        let h10 = e10 || this.options.stacking;
        if (!h10 || !this.reserveSpace() || ({
          group: "xAxis"
        }[h10] || "yAxis") !== t10.coll) return;
        let d10 = this.getColumn("x", true), c10 = this.getColumn(this.pointValKey || "y", true), p4 = [], u2 = c10.length, g2 = this.options, m2 = g2.threshold || 0, f2 = g2.startFromThreshold ? m2 : 0, x2 = g2.stack, y2 = e10 ? `${this.type},${h10}` : this.stackKey || "", b2 = "-" + y2, v2 = this.negStacks, M2 = t10.stacking, w2 = M2.stacks, k2 = M2.oldStacks;
        for (M2.stacksTouched += 1, l10 = 0; l10 < u2; l10++) {
          let e11 = d10[l10] || 0, u3 = c10[l10], g3 = ng(u3) && u3 || 0;
          n10 = (i10 = this.getStackIndicator(i10, e11, this.index)).key || "", w2[a10 = (s10 = v2 && g3 < (f2 ? 0 : m2)) ? b2 : y2] || (w2[a10] = {}), w2[a10][e11] || (k2[a10]?.[e11] ? (w2[a10][e11] = k2[a10][e11], w2[a10][e11].total = null) : w2[a10][e11] = new na(t10, t10.options.stackLabels, !!s10, e11, x2)), o10 = w2[a10][e11], null !== u3 ? (o10.points[n10] = o10.points[this.index] = [nf(o10.cumulative, f2)], nc(o10.cumulative) || (o10.base = n10), o10.touched = M2.stacksTouched, i10.index > 0 && false === this.singleStacks && (o10.points[n10][0] = o10.points[this.index + "," + e11 + ",0"][0])) : (delete o10.points[n10], delete o10.points[this.index]);
          let S2 = o10.total || 0;
          "percent" === h10 ? (r10 = s10 ? y2 : b2, S2 = v2 && w2[r10]?.[e11] ? (r10 = w2[r10][e11]).total = Math.max(r10.total || 0, S2) + Math.abs(g3) : nd(S2 + Math.abs(g3))) : "group" === h10 ? ng(u3) && S2++ : S2 = nd(S2 + g3), "group" === h10 ? o10.cumulative = (S2 || 1) - 1 : o10.cumulative = nd(nf(o10.cumulative, f2) + g3), o10.total = S2, null !== u3 && (o10.points[n10].push(o10.cumulative), p4[l10] = o10.cumulative, o10.hasValidPoints = true);
        }
        "percent" === h10 && (M2.usePercentage = true), "group" !== h10 && (this.stackedYData = p4), M2.oldStacks = {};
      }
      class nT {
        constructor(t10) {
          this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t10;
        }
        buildStacks() {
          let t10, e10;
          let i10 = this.axis, s10 = i10.series, o10 = "xAxis" === i10.coll, r10 = i10.options.reversedStacks, a10 = s10.length;
          for (this.resetStacks(), this.usePercentage = false, e10 = a10; e10--; ) t10 = s10[r10 ? e10 : a10 - e10 - 1], o10 && t10.setGroupedPoints(i10), t10.setStackedPoints(i10);
          if (!o10) for (e10 = 0; e10 < a10; e10++) s10[e10].modifyStacks();
          nu(i10, "afterBuildStacks");
        }
        cleanStacks() {
          this.oldStacks && (this.stacks = this.oldStacks, nm(this.stacks, (t10) => {
            nm(t10, (t11) => {
              t11.cumulative = t11.total;
            });
          }));
        }
        resetStacks() {
          nm(this.stacks, (t10) => {
            nm(t10, (e10, i10) => {
              ng(e10.touched) && e10.touched < this.stacksTouched ? (e10.destroy(), delete t10[i10]) : (e10.total = null, e10.cumulative = null);
            });
          });
        }
        renderStackTotals() {
          let t10 = this.axis, e10 = t10.chart, i10 = e10.renderer, s10 = this.stacks, o10 = nn(e10, t10.options.stackLabels?.animation || false), r10 = this.stackTotalGroup = this.stackTotalGroup || i10.g("stack-labels").attr({
            zIndex: 6,
            opacity: 0
          }).add();
          r10.translate(e10.plotLeft, e10.plotTop), nm(s10, (t11) => {
            nm(t11, (t12) => {
              t12.render(r10);
            });
          }), r10.animate({
            opacity: 1
          }, o10);
        }
      }
      (u || (u = {})).compose = function(t10, e10, i10) {
        let s10 = e10.prototype, o10 = i10.prototype;
        s10.getStacks || (nh(t10, "init", nb), nh(t10, "destroy", ny), s10.getStacks = nx, o10.getStackIndicator = nv, o10.modifyStacks = nM, o10.percentStacker = nw, o10.setGroupedPoints = nk, o10.setStackedPoints = nS);
      };
      let nC = u, {
        defined: nA,
        merge: nP,
        isObject: nL
      } = J;
      class nO extends rq {
        drawGraph() {
          let t10 = this.options, e10 = (this.gappedPath || this.getGraphPath).call(this), i10 = this.chart.styledMode;
          [this, ...this.zones].forEach((s10, o10) => {
            let r10, a10 = s10.graph, n10 = a10 ? "animate" : "attr", l10 = s10.dashStyle || t10.dashStyle;
            a10 ? (a10.endX = this.preventGraphAnimation ? null : e10.xMap, a10.animate({
              d: e10
            })) : e10.length && (s10.graph = a10 = this.chart.renderer.path(e10).addClass("highcharts-graph" + (o10 ? ` highcharts-zone-graph-${o10 - 1} ` : " ") + (o10 && s10.className || "")).attr({
              zIndex: 1
            }).add(this.group)), a10 && !i10 && (r10 = {
              stroke: !o10 && t10.lineColor || s10.color || this.color || "#cccccc",
              "stroke-width": t10.lineWidth || 0,
              fill: this.fillGraph && this.color || "none"
            }, l10 ? r10.dashstyle = l10 : "square" !== t10.linecap && (r10["stroke-linecap"] = r10["stroke-linejoin"] = "round"), a10[n10](r10).shadow(t10.shadow && nP({
              filterUnits: "userSpaceOnUse"
            }, nL(t10.shadow) ? t10.shadow : {}))), a10 && (a10.startX = e10.xMap, a10.isArea = e10.isArea);
          });
        }
        getGraphPath(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = [], a10 = [], n10, l10 = o10.step, h10 = (t10 = t10 || s10.points).reversed;
          return h10 && t10.reverse(), (l10 = {
            right: 1,
            center: 2
          }[l10] || l10 && 3) && h10 && (l10 = 4 - l10), (t10 = this.getValidPoints(t10, false, !(o10.connectNulls && !e10 && !i10))).forEach(function(h11, d10) {
            let c10;
            let p4 = h11.plotX, u2 = h11.plotY, g2 = t10[d10 - 1], m2 = h11.isNull || "number" != typeof u2;
            (h11.leftCliff || g2 && g2.rightCliff) && !i10 && (n10 = true), m2 && !nA(e10) && d10 > 0 ? n10 = !o10.connectNulls : m2 && !e10 ? n10 = true : (0 === d10 || n10 ? c10 = [["M", h11.plotX, h11.plotY]] : s10.getPointSpline ? c10 = [s10.getPointSpline(t10, h11, d10)] : l10 ? (c10 = 1 === l10 ? [["L", g2.plotX, u2]] : 2 === l10 ? [["L", (g2.plotX + p4) / 2, g2.plotY], ["L", (g2.plotX + p4) / 2, u2]] : [["L", p4, g2.plotY]]).push(["L", p4, u2]) : c10 = [["L", p4, u2]], a10.push(h11.x), l10 && (a10.push(h11.x), 2 === l10 && a10.push(h11.x)), r10.push.apply(r10, c10), n10 = false);
          }), r10.xMap = a10, s10.graphPath = r10, r10;
        }
      }
      nO.defaultOptions = nP(rq.defaultOptions, {
        legendSymbol: "lineMarker"
      }), rx.registerSeriesType("line", nO);
      let {
        seriesTypes: {
          line: nE
        }
      } = rx, {
        extend: nI,
        merge: nD,
        objectEach: nB,
        pick: nz
      } = J;
      class nN extends nE {
        drawGraph() {
          this.areaPath = [], super.drawGraph.apply(this);
          let {
            areaPath: t10,
            options: e10
          } = this;
          [this, ...this.zones].forEach((i10, s10) => {
            let o10 = {}, r10 = i10.fillColor || e10.fillColor, a10 = i10.area, n10 = a10 ? "animate" : "attr";
            a10 ? (a10.endX = this.preventGraphAnimation ? null : t10.xMap, a10.animate({
              d: t10
            })) : (o10.zIndex = 0, (a10 = i10.area = this.chart.renderer.path(t10).addClass("highcharts-area" + (s10 ? ` highcharts-zone-area-${s10 - 1} ` : " ") + (s10 && i10.className || "")).add(this.group)).isArea = true), this.chart.styledMode || (o10.fill = r10 || i10.color || this.color, o10["fill-opacity"] = r10 ? 1 : e10.fillOpacity ?? 0.75, a10.css({
              pointerEvents: this.stickyTracking ? "none" : "auto"
            })), a10[n10](o10), a10.startX = t10.xMap, a10.shiftUnit = e10.step ? 2 : 1;
          });
        }
        getGraphPath(t10) {
          let e10, i10, s10;
          let o10 = nE.prototype.getGraphPath, r10 = this.options, a10 = r10.stacking, n10 = this.yAxis, l10 = [], h10 = [], d10 = this.index, c10 = n10.stacking.stacks[this.stackKey], p4 = r10.threshold, u2 = Math.round(n10.getThreshold(r10.threshold)), g2 = nz(r10.connectNulls, "percent" === a10), m2 = function(i11, s11, o11) {
            let r11 = t10[i11], g3 = a10 && c10[r11.x].points[d10], m3 = r11[o11 + "Null"] || 0, f3 = r11[o11 + "Cliff"] || 0, x3, y3, b3 = true;
            f3 || m3 ? (x3 = (m3 ? g3[0] : g3[1]) + f3, y3 = g3[0] + f3, b3 = !!m3) : !a10 && t10[s11] && t10[s11].isNull && (x3 = y3 = p4), void 0 !== x3 && (h10.push({
              plotX: e10,
              plotY: null === x3 ? u2 : n10.getThreshold(x3),
              isNull: b3,
              isCliff: true
            }), l10.push({
              plotX: e10,
              plotY: null === y3 ? u2 : n10.getThreshold(y3),
              doCurve: false
            }));
          };
          t10 = t10 || this.points, a10 && (t10 = this.getStackPoints(t10));
          for (let o11 = 0, r11 = t10.length; o11 < r11; ++o11) a10 || (t10[o11].leftCliff = t10[o11].rightCliff = t10[o11].leftNull = t10[o11].rightNull = void 0), i10 = t10[o11].isNull, e10 = nz(t10[o11].rectPlotX, t10[o11].plotX), s10 = a10 ? nz(t10[o11].yBottom, u2) : u2, i10 && !g2 || (g2 || m2(o11, o11 - 1, "left"), i10 && !a10 && g2 || (h10.push(t10[o11]), l10.push({
            x: o11,
            plotX: e10,
            plotY: s10
          })), g2 || m2(o11, o11 + 1, "right"));
          let f2 = o10.call(this, h10, true, true);
          l10.reversed = true;
          let x2 = o10.call(this, l10, true, true), y2 = x2[0];
          y2 && "M" === y2[0] && (x2[0] = ["L", y2[1], y2[2]]);
          let b2 = f2.concat(x2);
          b2.length && b2.push(["Z"]);
          let v2 = o10.call(this, h10, false, g2);
          return this.chart.series.length > 1 && a10 && h10.some((t11) => t11.isCliff) && (b2.hasStackedCliffs = v2.hasStackedCliffs = true), b2.xMap = f2.xMap, this.areaPath = b2, v2;
        }
        getStackPoints(t10) {
          let e10 = this, i10 = [], s10 = [], o10 = this.xAxis, r10 = this.yAxis, a10 = r10.stacking.stacks[this.stackKey], n10 = {}, l10 = r10.series, h10 = l10.length, d10 = r10.options.reversedStacks ? 1 : -1, c10 = l10.indexOf(e10);
          if (t10 = t10 || this.points, this.options.stacking) {
            for (let e11 = 0; e11 < t10.length; e11++) t10[e11].leftNull = t10[e11].rightNull = void 0, n10[t10[e11].x] = t10[e11];
            nB(a10, function(t11, e11) {
              null !== t11.total && s10.push(e11);
            }), s10.sort(function(t11, e11) {
              return t11 - e11;
            });
            let p4 = l10.map((t11) => t11.visible);
            s10.forEach(function(t11, u2) {
              let g2 = 0, m2, f2;
              if (n10[t11] && !n10[t11].isNull) i10.push(n10[t11]), [-1, 1].forEach(function(i11) {
                let o11 = 1 === i11 ? "rightNull" : "leftNull", r11 = a10[s10[u2 + i11]], g3 = 0;
                if (r11) {
                  let i12 = c10;
                  for (; i12 >= 0 && i12 < h10; ) {
                    let s11 = l10[i12].index;
                    !(m2 = r11.points[s11]) && (s11 === e10.index ? n10[t11][o11] = true : p4[i12] && (f2 = a10[t11].points[s11]) && (g3 -= f2[1] - f2[0])), i12 += d10;
                  }
                }
                n10[t11][1 === i11 ? "rightCliff" : "leftCliff"] = g3;
              });
              else {
                let e11 = c10;
                for (; e11 >= 0 && e11 < h10; ) {
                  let i11 = l10[e11].index;
                  if (m2 = a10[t11].points[i11]) {
                    g2 = m2[1];
                    break;
                  }
                  e11 += d10;
                }
                g2 = nz(g2, 0), g2 = r10.translate(g2, 0, 1, 0, 1), i10.push({
                  isNull: true,
                  plotX: o10.translate(t11, 0, 0, 0, 1),
                  x: t11,
                  plotY: g2,
                  yBottom: g2
                });
              }
            });
          }
          return i10;
        }
      }
      nN.defaultOptions = nD(nE.defaultOptions, {
        threshold: 0,
        legendSymbol: "areaMarker"
      }), nI(nN.prototype, {
        singleStacks: false
      }), rx.registerSeriesType("area", nN);
      let {
        line: nR
      } = rx.seriesTypes, {
        merge: nW,
        pick: nj
      } = J;
      class nX extends nR {
        getPointSpline(t10, e10, i10) {
          let s10, o10, r10, a10;
          let n10 = e10.plotX || 0, l10 = e10.plotY || 0, h10 = t10[i10 - 1], d10 = t10[i10 + 1];
          function c10(t11) {
            return t11 && !t11.isNull && false !== t11.doCurve && !e10.isCliff;
          }
          if (c10(h10) && c10(d10)) {
            let t11 = h10.plotX || 0, i11 = h10.plotY || 0, c11 = d10.plotX || 0, p7 = d10.plotY || 0, u2 = 0;
            s10 = (1.5 * n10 + t11) / 2.5, o10 = (1.5 * l10 + i11) / 2.5, r10 = (1.5 * n10 + c11) / 2.5, a10 = (1.5 * l10 + p7) / 2.5, r10 !== s10 && (u2 = (a10 - o10) * (r10 - n10) / (r10 - s10) + l10 - a10), o10 += u2, a10 += u2, o10 > i11 && o10 > l10 ? (o10 = Math.max(i11, l10), a10 = 2 * l10 - o10) : o10 < i11 && o10 < l10 && (o10 = Math.min(i11, l10), a10 = 2 * l10 - o10), a10 > p7 && a10 > l10 ? (a10 = Math.max(p7, l10), o10 = 2 * l10 - a10) : a10 < p7 && a10 < l10 && (a10 = Math.min(p7, l10), o10 = 2 * l10 - a10), e10.rightContX = r10, e10.rightContY = a10, e10.controlPoints = {
              low: [s10, o10],
              high: [r10, a10]
            };
          }
          let p4 = ["C", nj(h10.rightContX, h10.plotX, 0), nj(h10.rightContY, h10.plotY, 0), nj(s10, n10, 0), nj(o10, l10, 0), n10, l10];
          return h10.rightContX = h10.rightContY = void 0, p4;
        }
      }
      nX.defaultOptions = nW(nR.defaultOptions), rx.registerSeriesType("spline", nX);
      let nG = nX, {
        area: nF,
        area: {
          prototype: nH
        }
      } = rx.seriesTypes, {
        extend: nY,
        merge: nV
      } = J;
      class nU extends nG {
      }
      nU.defaultOptions = nV(nG.defaultOptions, nF.defaultOptions), nY(nU.prototype, {
        getGraphPath: nH.getGraphPath,
        getStackPoints: nH.getStackPoints,
        drawGraph: nH.drawGraph
      }), rx.registerSeriesType("areaspline", nU);
      let {
        animObject: nZ
      } = tH, {
        parse: n$
      } = tA, {
        noop: n_
      } = A, {
        clamp: nq,
        crisp: nK,
        defined: nJ,
        extend: nQ,
        fireEvent: n0,
        isArray: n1,
        isNumber: n2,
        merge: n3,
        pick: n6,
        objectEach: n5
      } = J;
      class n9 extends rq {
        animate(t10) {
          let e10, i10;
          let s10 = this, o10 = this.yAxis, r10 = o10.pos, a10 = o10.reversed, n10 = s10.options, {
            clipOffset: l10,
            inverted: h10
          } = this.chart, d10 = {}, c10 = h10 ? "translateX" : "translateY";
          t10 && l10 ? (d10.scaleY = 1e-3, i10 = nq(o10.toPixels(n10.threshold || 0), r10, r10 + o10.len), h10 ? (i10 += a10 ? -Math.floor(l10[0]) : Math.ceil(l10[2]), d10.translateX = i10 - o10.len) : (i10 += a10 ? Math.ceil(l10[0]) : -Math.floor(l10[2]), d10.translateY = i10), s10.clipBox && s10.setClip(), s10.group.attr(d10)) : (e10 = Number(s10.group.attr(c10)), s10.group.animate({
            scaleY: 1
          }, nQ(nZ(s10.options.animation), {
            step: function(t11, i11) {
              s10.group && (d10[c10] = e10 + i11.pos * (r10 - e10), s10.group.attr(d10));
            }
          })));
        }
        init(t10, e10) {
          super.init.apply(this, arguments);
          let i10 = this;
          (t10 = i10.chart).hasRendered && t10.series.forEach(function(t11) {
            t11.type === i10.type && (t11.isDirty = true);
          });
        }
        getColumnMetrics() {
          let t10 = this, e10 = t10.options, i10 = t10.xAxis, s10 = t10.yAxis, o10 = i10.options.reversedStacks, r10 = i10.reversed && !o10 || !i10.reversed && o10, a10 = {}, n10, l10 = 0;
          false === e10.grouping ? l10 = 1 : t10.chart.series.forEach(function(e11) {
            let i11;
            let o11 = e11.yAxis, r11 = e11.options;
            e11.type === t10.type && e11.reserveSpace() && s10.len === o11.len && s10.pos === o11.pos && (r11.stacking && "group" !== r11.stacking ? (void 0 === a10[n10 = e11.stackKey] && (a10[n10] = l10++), i11 = a10[n10]) : false !== r11.grouping && (i11 = l10++), e11.columnIndex = i11);
          });
          let h10 = Math.min(Math.abs(i10.transA) * (!i10.brokenAxis?.hasBreaks && i10.ordinal?.slope || e10.pointRange || i10.closestPointRange || i10.tickInterval || 1), i10.len), d10 = h10 * e10.groupPadding, c10 = (h10 - 2 * d10) / (l10 || 1), p4 = Math.min(e10.maxPointWidth || i10.len, n6(e10.pointWidth, c10 * (1 - 2 * e10.pointPadding))), u2 = (t10.columnIndex || 0) + (r10 ? 1 : 0);
          return t10.columnMetrics = {
            width: p4,
            offset: (c10 - p4) / 2 + (d10 + u2 * c10 - h10 / 2) * (r10 ? -1 : 1),
            paddedWidth: c10,
            columnCount: l10
          }, t10.columnMetrics;
        }
        crispCol(t10, e10, i10, s10) {
          let o10 = this.borderWidth, r10 = this.chart.inverted;
          return s10 = nK(e10 + s10, o10, r10) - (e10 = nK(e10, o10, r10)), this.options.crisp && (i10 = nK(t10 + i10, o10) - (t10 = nK(t10, o10))), {
            x: t10,
            y: e10,
            width: i10,
            height: s10
          };
        }
        adjustForMissingColumns(t10, e10, i10, s10) {
          if (!i10.isNull && s10.columnCount > 1) {
            let o10 = this.xAxis.series.filter((t11) => t11.visible).map((t11) => t11.index), r10 = 0, a10 = 0;
            n5(this.xAxis.stacking?.stacks, (t11) => {
              let e11 = "number" == typeof i10.x ? t11[i10.x.toString()]?.points : void 0, s11 = e11?.[this.index], n11 = {};
              if (e11 && n1(s11)) {
                let t12 = this.index, i11 = Object.keys(e11).filter((t13) => !t13.match(",") && e11[t13] && e11[t13].length > 1).map(parseFloat).filter((t13) => -1 !== o10.indexOf(t13)).filter((e12) => {
                  let i12 = this.chart.series[e12].options, s12 = i12.stacking && i12.stack;
                  if (nJ(s12)) {
                    if (n2(n11[s12])) return t12 === e12 && (t12 = n11[s12]), false;
                    n11[s12] = e12;
                  }
                  return true;
                }).sort((t13, e12) => e12 - t13);
                r10 = i11.indexOf(t12), a10 = i11.length;
              }
            }), r10 = this.xAxis.reversed ? a10 - 1 - r10 : r10;
            let n10 = (a10 - 1) * s10.paddedWidth + e10;
            t10 = (i10.plotX || 0) + n10 / 2 - e10 - r10 * s10.paddedWidth;
          }
          return t10;
        }
        translate() {
          let t10 = this, e10 = t10.chart, i10 = t10.options, s10 = t10.dense = t10.closestPointRange * t10.xAxis.transA < 2, o10 = t10.borderWidth = n6(i10.borderWidth, s10 ? 0 : 1), r10 = t10.xAxis, a10 = t10.yAxis, n10 = i10.threshold, l10 = n6(i10.minPointLength, 5), h10 = t10.getColumnMetrics(), d10 = h10.width, c10 = t10.pointXOffset = h10.offset, p4 = t10.dataMin, u2 = t10.dataMax, g2 = t10.translatedThreshold = a10.getThreshold(n10), m2 = t10.barW = Math.max(d10, 1 + 2 * o10);
          i10.pointPadding && i10.crisp && (m2 = Math.ceil(m2)), rq.prototype.translate.apply(t10), t10.points.forEach(function(s11) {
            let o11 = n6(s11.yBottom, g2), f2 = 999 + Math.abs(o11), x2 = s11.plotX || 0, y2 = nq(s11.plotY, -f2, a10.len + f2), b2, v2 = Math.min(y2, o11), M2 = Math.max(y2, o11) - v2, w2 = d10, k2 = x2 + c10, S2 = m2;
            l10 && Math.abs(M2) < l10 && (M2 = l10, b2 = !a10.reversed && !s11.negative || a10.reversed && s11.negative, n2(n10) && n2(u2) && s11.y === n10 && u2 <= n10 && (a10.min || 0) < n10 && (p4 !== u2 || (a10.max || 0) <= n10) && (b2 = !b2, s11.negative = !s11.negative), v2 = Math.abs(v2 - g2) > l10 ? o11 - l10 : g2 - (b2 ? l10 : 0)), nJ(s11.options.pointWidth) && (k2 -= Math.round(((w2 = S2 = Math.ceil(s11.options.pointWidth)) - d10) / 2)), i10.centerInCategory && (k2 = t10.adjustForMissingColumns(k2, w2, s11, h10)), s11.barX = k2, s11.pointWidth = w2, s11.tooltipPos = e10.inverted ? [nq(a10.len + a10.pos - e10.plotLeft - y2, a10.pos - e10.plotLeft, a10.len + a10.pos - e10.plotLeft), r10.len + r10.pos - e10.plotTop - k2 - S2 / 2, M2] : [r10.left - e10.plotLeft + k2 + S2 / 2, nq(y2 + a10.pos - e10.plotTop, a10.pos - e10.plotTop, a10.len + a10.pos - e10.plotTop), M2], s11.shapeType = t10.pointClass.prototype.shapeType || "roundedRect", s11.shapeArgs = t10.crispCol(k2, s11.isNull ? g2 : v2, S2, s11.isNull ? 0 : M2);
          }), n0(this, "afterColumnTranslate");
        }
        drawGraph() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = this.pointAttrToOptions || {}, o10 = s10.stroke || "borderColor", r10 = s10["stroke-width"] || "borderWidth", a10, n10, l10, h10 = t10 && t10.color || this.color, d10 = t10 && t10[o10] || i10[o10] || h10, c10 = t10 && t10.options.dashStyle || i10.dashStyle, p4 = t10 && t10[r10] || i10[r10] || this[r10] || 0, u2 = n6(t10 && t10.opacity, i10.opacity, 1);
          t10 && this.zones.length && (n10 = t10.getZone(), h10 = t10.options.color || n10 && (n10.color || t10.nonZonedColor) || this.color, n10 && (d10 = n10.borderColor || d10, c10 = n10.dashStyle || c10, p4 = n10.borderWidth || p4)), e10 && t10 && (l10 = (a10 = n3(i10.states[e10], t10.options.states && t10.options.states[e10] || {})).brightness, h10 = a10.color || void 0 !== l10 && n$(h10).brighten(a10.brightness).get() || h10, d10 = a10[o10] || d10, p4 = a10[r10] || p4, c10 = a10.dashStyle || c10, u2 = n6(a10.opacity, u2));
          let g2 = {
            fill: h10,
            stroke: d10,
            "stroke-width": p4,
            opacity: u2
          };
          return c10 && (g2.dashstyle = c10), g2;
        }
        drawPoints(t10 = this.points) {
          let e10;
          let i10 = this, s10 = this.chart, o10 = i10.options, r10 = s10.renderer, a10 = o10.animationLimit || 250;
          t10.forEach(function(t11) {
            let n10 = t11.plotY, l10 = t11.graphic, h10 = !!l10, d10 = l10 && s10.pointCount < a10 ? "animate" : "attr";
            n2(n10) && null !== t11.y ? (e10 = t11.shapeArgs, l10 && t11.hasNewShapeType() && (l10 = l10.destroy()), i10.enabledDataSorting && (t11.startXPos = i10.xAxis.reversed ? -(e10 && e10.width || 0) : i10.xAxis.width), !l10 && (t11.graphic = l10 = r10[t11.shapeType](e10).add(t11.group || i10.group), l10 && i10.enabledDataSorting && s10.hasRendered && s10.pointCount < a10 && (l10.attr({
              x: t11.startXPos
            }), h10 = true, d10 = "animate")), l10 && h10 && l10[d10](n3(e10)), s10.styledMode || l10[d10](i10.pointAttribs(t11, t11.selected && "select")).shadow(false !== t11.allowShadow && o10.shadow), l10 && (l10.addClass(t11.getClassName(), true), l10.attr({
              visibility: t11.visible ? "inherit" : "hidden"
            }))) : l10 && (t11.graphic = l10.destroy());
          });
        }
        drawTracker(t10 = this.points) {
          let e10;
          let i10 = this, s10 = i10.chart, o10 = s10.pointer, r10 = function(t11) {
            o10?.normalize(t11);
            let e11 = o10?.getPointFromEvent(t11), r11 = !s10.scrollablePlotArea || s10.isInsidePlot(t11.chartX - s10.plotLeft, t11.chartY - s10.plotTop, {
              visiblePlotOnly: true
            });
            o10 && e11 && i10.options.enableMouseTracking && r11 && (o10.isDirectTouch = true, e11.onMouseOver(t11));
          };
          t10.forEach(function(t11) {
            e10 = n1(t11.dataLabels) ? t11.dataLabels : t11.dataLabel ? [t11.dataLabel] : [], t11.graphic && (t11.graphic.element.point = t11), e10.forEach(function(e11) {
              (e11.div || e11.element).point = t11;
            });
          }), i10._hasTracking || (i10.trackerGroups.forEach(function(t11) {
            i10[t11] && (i10[t11].addClass("highcharts-tracker").on("mouseover", r10).on("mouseout", function(t12) {
              o10?.onTrackerMouseOut(t12);
            }).on("touchstart", r10), !s10.styledMode && i10.options.cursor && i10[t11].css({
              cursor: i10.options.cursor
            }));
          }), i10._hasTracking = true), n0(this, "afterDrawTracker");
        }
        remove() {
          let t10 = this, e10 = t10.chart;
          e10.hasRendered && e10.series.forEach(function(e11) {
            e11.type === t10.type && (e11.isDirty = true);
          }), rq.prototype.remove.apply(t10, arguments);
        }
      }
      n9.defaultOptions = n3(rq.defaultOptions, {
        borderRadius: 3,
        centerInCategory: false,
        groupPadding: 0.2,
        marker: null,
        pointPadding: 0.1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: false,
            brightness: 0.1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: true,
        stickyTracking: false,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      }), nQ(n9.prototype, {
        directTouch: true,
        getSymbol: n_,
        negStacks: true,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), rx.registerSeriesType("column", n9);
      let n8 = n9, {
        getDeferredAnimation: n4
      } = tH, {
        format: n7
      } = ed, {
        defined: lt,
        extend: le,
        fireEvent: li,
        getAlignFactor: ls,
        isArray: lo,
        isString: lr,
        merge: la,
        objectEach: ln,
        pick: ll,
        pInt: lh,
        splat: ld
      } = J;
      !function(t10) {
        function e10() {
          return l10(this).some((t11) => t11?.enabled);
        }
        function i10(t11, e11, i11, s11, o11) {
          let {
            chart: r11,
            enabledDataSorting: a11
          } = this, n11 = this.isCartesian && r11.inverted, l11 = t11.plotX, h11 = t11.plotY, d10 = i11.rotation || 0, c10 = lt(l11) && lt(h11) && r11.isInsidePlot(l11, Math.round(h11), {
            inverted: n11,
            paneCoordinates: true,
            series: this
          }), p4 = 0 === d10 && "justify" === ll(i11.overflow, a11 ? "none" : "justify"), u2 = this.visible && false !== t11.visible && lt(l11) && (t11.series.forceDL || a11 && !p4 || c10 || ll(i11.inside, !!this.options.stacking) && s11 && r11.isInsidePlot(l11, n11 ? s11.x + 1 : s11.y + s11.height - 1, {
            inverted: n11,
            paneCoordinates: true,
            series: this
          })), g2 = t11.pos();
          if (u2 && g2) {
            var m2;
            let l12 = e11.getBBox(), h12 = e11.getBBox(void 0, 0);
            if (s11 = le({
              x: g2[0],
              y: Math.round(g2[1]),
              width: 0,
              height: 0
            }, s11 || {}), "plotEdges" === i11.alignTo && this.isCartesian && (s11[n11 ? "x" : "y"] = 0, s11[n11 ? "width" : "height"] = this.yAxis?.len || 0), le(i11, {
              width: l12.width,
              height: l12.height
            }), m2 = s11, a11 && this.xAxis && !p4 && this.setDataLabelStartPos(t11, e11, o11, c10, m2), e11.align(la(i11, {
              width: h12.width,
              height: h12.height
            }), false, s11, false), e11.alignAttr.x += ls(i11.align) * (h12.width - l12.width), e11.alignAttr.y += ls(i11.verticalAlign) * (h12.height - l12.height), e11[e11.placed ? "animate" : "attr"]({
              "text-align": e11.alignAttr["text-align"] || "center",
              x: e11.alignAttr.x + (l12.width - h12.width) / 2,
              y: e11.alignAttr.y + (l12.height - h12.height) / 2,
              rotationOriginX: (e11.width || 0) / 2,
              rotationOriginY: (e11.height || 0) / 2
            }), p4 && s11.height >= 0) this.justifyDataLabel(e11, i11, e11.alignAttr, l12, s11, o11);
            else if (ll(i11.crop, true)) {
              let {
                x: t12,
                y: i12
              } = e11.alignAttr;
              u2 = r11.isInsidePlot(t12, i12, {
                paneCoordinates: true,
                series: this
              }) && r11.isInsidePlot(t12 + l12.width - 1, i12 + l12.height - 1, {
                paneCoordinates: true,
                series: this
              });
            }
            i11.shape && !d10 && e11[o11 ? "attr" : "animate"]({
              anchorX: g2[0],
              anchorY: g2[1]
            });
          }
          o11 && a11 && (e11.placed = false), u2 || a11 && !p4 ? (e11.show(), e11.placed = true) : (e11.hide(), e11.placed = false);
        }
        function s10() {
          return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
        }
        function o10(t11) {
          let e11 = this.hasRendered || 0, i11 = this.initDataLabelsGroup().attr({
            opacity: +e11
          });
          return !e11 && i11 && (this.visible && i11.show(), this.options.animation ? i11.animate({
            opacity: 1
          }, t11) : i11.attr({
            opacity: 1
          })), i11;
        }
        function r10(t11) {
          let e11;
          t11 = t11 || this.points;
          let i11 = this, s11 = i11.chart, o11 = i11.options, r11 = s11.renderer, {
            backgroundColor: a11,
            plotBackgroundColor: h11
          } = s11.options.chart, d10 = r11.getContrast(lr(h11) && h11 || lr(a11) && a11 || "#000000"), c10 = l10(i11), {
            animation: p4,
            defer: u2
          } = c10[0], g2 = u2 ? n4(s11, p4, i11) : {
            defer: 0,
            duration: 0
          };
          li(this, "drawDataLabels"), i11.hasDataLabels?.() && (e11 = this.initDataLabels(g2), t11.forEach((t12) => {
            let a12 = t12.dataLabels || [];
            ld(n10(c10, t12.dlOptions || t12.options?.dataLabels)).forEach((n11, l12) => {
              let h12 = n11.enabled && (t12.visible || t12.dataLabelOnHidden) && (!t12.isNull || t12.dataLabelOnNull) && function(t13, e12) {
                let i12 = e12.filter;
                if (i12) {
                  let e13 = i12.operator, s12 = t13[i12.property], o12 = i12.value;
                  return ">" === e13 && s12 > o12 || "<" === e13 && s12 < o12 || ">=" === e13 && s12 >= o12 || "<=" === e13 && s12 <= o12 || "==" === e13 && s12 == o12 || "===" === e13 && s12 === o12 || "!=" === e13 && s12 != o12 || "!==" === e13 && s12 !== o12;
                }
                return true;
              }(t12, n11), {
                backgroundColor: c11,
                borderColor: p7,
                distance: u3,
                style: g3 = {}
              } = n11, m2, f2, x2, y2 = {}, b2 = a12[l12], v2 = !b2, M2;
              h12 && (f2 = lt(m2 = ll(n11[t12.formatPrefix + "Format"], n11.format)) ? n7(m2, t12, s11) : (n11[t12.formatPrefix + "Formatter"] || n11.formatter).call(t12, n11), x2 = n11.rotation, !s11.styledMode && (g3.color = ll(n11.color, g3.color, lr(i11.color) ? i11.color : void 0, "#000000"), "contrast" === g3.color ? ("none" !== c11 && (M2 = c11), t12.contrastColor = r11.getContrast("auto" !== M2 && M2 || t12.color || i11.color), g3.color = M2 || !lt(u3) && n11.inside || 0 > lh(u3 || 0) || o11.stacking ? t12.contrastColor : d10) : delete t12.contrastColor, o11.cursor && (g3.cursor = o11.cursor)), y2 = {
                r: n11.borderRadius || 0,
                rotation: x2,
                padding: n11.padding,
                zIndex: 1
              }, s11.styledMode || (y2.fill = "auto" === c11 ? t12.color : c11, y2.stroke = "auto" === p7 ? t12.color : p7, y2["stroke-width"] = n11.borderWidth), ln(y2, (t13, e12) => {
                void 0 === t13 && delete y2[e12];
              })), !b2 || h12 && lt(f2) && !!b2.div == !!n11.useHTML && (b2.rotation && n11.rotation || b2.rotation === n11.rotation) || (b2 = void 0, v2 = true), h12 && lt(f2) && (b2 ? y2.text = f2 : (b2 = r11.label(f2, 0, 0, n11.shape, void 0, void 0, n11.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + t12.colorIndex + " " + (n11.className || "") + (n11.useHTML ? " highcharts-tracker" : "")), b2 && (b2.options = n11, b2.attr(y2), s11.styledMode ? g3.width && b2.css({
                width: g3.width,
                textOverflow: g3.textOverflow,
                whiteSpace: g3.whiteSpace
              }) : b2.css(g3).shadow(n11.shadow), li(b2, "beforeAddingDataLabel", {
                labelOptions: n11,
                point: t12
              }), b2.added || b2.add(e11), i11.alignDataLabel(t12, b2, n11, void 0, v2), b2.isActive = true, a12[l12] && a12[l12] !== b2 && a12[l12].destroy(), a12[l12] = b2));
            });
            let l11 = a12.length;
            for (; l11--; ) a12[l11] && a12[l11].isActive ? a12[l11].isActive = false : (a12[l11]?.destroy(), a12.splice(l11, 1));
            t12.dataLabel = a12[0], t12.dataLabels = a12;
          })), li(this, "afterDrawDataLabels");
        }
        function a10(t11, e11, i11, s11, o11, r11) {
          let a11 = this.chart, n11 = e11.align, l11 = e11.verticalAlign, h11 = t11.box ? 0 : t11.padding || 0, d10 = a11.inverted ? this.yAxis : this.xAxis, c10 = d10 ? d10.left - a11.plotLeft : 0, p4 = a11.inverted ? this.xAxis : this.yAxis, u2 = p4 ? p4.top - a11.plotTop : 0, {
            x: g2 = 0,
            y: m2 = 0
          } = e11, f2, x2;
          return (f2 = (i11.x || 0) + h11 + c10) < 0 && ("right" === n11 && g2 >= 0 ? (e11.align = "left", e11.inside = true) : g2 -= f2, x2 = true), (f2 = (i11.x || 0) + s11.width - h11 + c10) > a11.plotWidth && ("left" === n11 && g2 <= 0 ? (e11.align = "right", e11.inside = true) : g2 += a11.plotWidth - f2, x2 = true), (f2 = i11.y + h11 + u2) < 0 && ("bottom" === l11 && m2 >= 0 ? (e11.verticalAlign = "top", e11.inside = true) : m2 -= f2, x2 = true), (f2 = (i11.y || 0) + s11.height - h11 + u2) > a11.plotHeight && ("top" === l11 && m2 <= 0 ? (e11.verticalAlign = "bottom", e11.inside = true) : m2 += a11.plotHeight - f2, x2 = true), x2 && (e11.x = g2, e11.y = m2, t11.placed = !r11, t11.align(e11, void 0, o11)), x2;
        }
        function n10(t11, e11) {
          let i11 = [], s11;
          if (lo(t11) && !lo(e11)) i11 = t11.map(function(t12) {
            return la(t12, e11);
          });
          else if (lo(e11) && !lo(t11)) i11 = e11.map(function(e12) {
            return la(t11, e12);
          });
          else if (lo(t11) || lo(e11)) {
            if (lo(t11) && lo(e11)) for (s11 = Math.max(t11.length, e11.length); s11--; ) i11[s11] = la(t11[s11], e11[s11]);
          } else i11 = la(t11, e11);
          return i11;
        }
        function l10(t11) {
          let e11 = t11.chart.options.plotOptions;
          return ld(n10(n10(e11?.series?.dataLabels, e11?.[t11.type]?.dataLabels), t11.options.dataLabels));
        }
        function h10(t11, e11, i11, s11, o11) {
          let r11 = this.chart, a11 = r11.inverted, n11 = this.xAxis, l11 = n11.reversed, h11 = ((a11 ? e11.height : e11.width) || 0) / 2, d10 = t11.pointWidth, c10 = d10 ? d10 / 2 : 0;
          e11.startXPos = a11 ? o11.x : l11 ? -h11 - c10 : n11.width - h11 + c10, e11.startYPos = a11 ? l11 ? this.yAxis.height - h11 + c10 : -h11 - c10 : o11.y, s11 ? "hidden" === e11.visibility && (e11.show(), e11.attr({
            opacity: 0
          }).animate({
            opacity: 1
          })) : e11.attr({
            opacity: 1
          }).animate({
            opacity: 0
          }, void 0, e11.hide), r11.hasRendered && (i11 && e11.attr({
            x: e11.startXPos,
            y: e11.startYPos
          }), e11.placed = true);
        }
        t10.compose = function(t11) {
          let n11 = t11.prototype;
          n11.initDataLabels || (n11.initDataLabels = o10, n11.initDataLabelsGroup = s10, n11.alignDataLabel = i10, n11.drawDataLabels = r10, n11.justifyDataLabel = a10, n11.setDataLabelStartPos = h10, n11.hasDataLabels = e10);
        };
      }(g || (g = {}));
      let lc = g, {
        composed: lp
      } = A, {
        series: lu
      } = rx, {
        merge: lg,
        pick: lm,
        pushUnique: lf
      } = J;
      !function(t10) {
        function e10(t11, e11, i10, s10, o10) {
          let r10 = this.chart.inverted, a10 = t11.series, n10 = (a10.xAxis ? a10.xAxis.len : this.chart.plotSizeX) || 0, l10 = (a10.yAxis ? a10.yAxis.len : this.chart.plotSizeY) || 0, h10 = t11.dlBox || t11.shapeArgs, d10 = lm(t11.below, t11.plotY > lm(this.translatedThreshold, l10)), c10 = lm(i10.inside, !!this.options.stacking);
          if (h10) {
            if (s10 = lg(h10), !("allow" === i10.overflow && false === i10.crop)) {
              s10.y < 0 && (s10.height += s10.y, s10.y = 0);
              let t12 = s10.y + s10.height - l10;
              t12 > 0 && t12 < s10.height - 1 && (s10.height -= t12);
            }
            r10 && (s10 = {
              x: l10 - s10.y - s10.height,
              y: n10 - s10.x - s10.width,
              width: s10.height,
              height: s10.width
            }), c10 || (r10 ? (s10.x += d10 ? 0 : s10.width, s10.width = 0) : (s10.y += d10 ? s10.height : 0, s10.height = 0));
          }
          i10.align = lm(i10.align, !r10 || c10 ? "center" : d10 ? "right" : "left"), i10.verticalAlign = lm(i10.verticalAlign, r10 || c10 ? "middle" : d10 ? "top" : "bottom"), lu.prototype.alignDataLabel.call(this, t11, e11, i10, s10, o10), i10.inside && t11.contrastColor && e11.css({
            color: t11.contrastColor
          });
        }
        t10.compose = function(t11) {
          lc.compose(lu), lf(lp, "ColumnDataLabel") && (t11.prototype.alignDataLabel = e10);
        };
      }(m || (m = {}));
      let lx = m, {
        extend: ly,
        merge: lb
      } = J;
      class lv extends n8 {
      }
      lv.defaultOptions = lb(n8.defaultOptions, {}), ly(lv.prototype, {
        inverted: true
      }), rx.registerSeriesType("bar", lv);
      let {
        column: lM,
        line: lw
      } = rx.seriesTypes, {
        addEvent: lk,
        extend: lS,
        merge: lT
      } = J;
      class lC extends lw {
        applyJitter() {
          let t10 = this, e10 = this.options.jitter, i10 = this.points.length;
          e10 && this.points.forEach(function(s10, o10) {
            ["x", "y"].forEach(function(r10, a10) {
              if (e10[r10] && !s10.isNull) {
                let n10 = `plot${r10.toUpperCase()}`, l10 = t10[`${r10}Axis`], h10 = e10[r10] * l10.transA;
                if (l10 && !l10.logarithmic) {
                  let t11 = Math.max(0, (s10[n10] || 0) - h10), e11 = Math.min(l10.len, (s10[n10] || 0) + h10);
                  s10[n10] = t11 + (e11 - t11) * function(t12) {
                    let e12 = 1e4 * Math.sin(t12);
                    return e12 - Math.floor(e12);
                  }(o10 + a10 * i10), "x" === r10 && (s10.clientX = s10.plotX);
                }
              }
            });
          });
        }
        drawGraph() {
          this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
        }
      }
      lC.defaultOptions = lT(lw.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: true
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      }), lS(lC.prototype, {
        drawTracker: lM.prototype.drawTracker,
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]
      }), lk(lC, "afterTranslate", function() {
        this.applyJitter();
      }), rx.registerSeriesType("scatter", lC);
      let {
        deg2rad: lA
      } = A, {
        fireEvent: lP,
        isNumber: lL,
        pick: lO,
        relativeLength: lE
      } = J;
      !function(t10) {
        t10.getCenter = function() {
          let t11 = this.options, e10 = this.chart, i10 = 2 * (t11.slicedOffset || 0), s10 = e10.plotWidth - 2 * i10, o10 = e10.plotHeight - 2 * i10, r10 = t11.center, a10 = Math.min(s10, o10), n10 = t11.thickness, l10, h10 = t11.size, d10 = t11.innerSize || 0, c10, p4;
          "string" == typeof h10 && (h10 = parseFloat(h10)), "string" == typeof d10 && (d10 = parseFloat(d10));
          let u2 = [lO(r10?.[0], "50%"), lO(r10?.[1], "50%"), lO(h10 && h10 < 0 ? void 0 : t11.size, "100%"), lO(d10 && d10 < 0 ? void 0 : t11.innerSize || 0, "0%")];
          for (!e10.angular || this instanceof rq || (u2[3] = 0), c10 = 0; c10 < 4; ++c10) p4 = u2[c10], l10 = c10 < 2 || 2 === c10 && /%$/.test(p4), u2[c10] = lE(p4, [s10, o10, a10, u2[2]][c10]) + (l10 ? i10 : 0);
          return u2[3] > u2[2] && (u2[3] = u2[2]), lL(n10) && 2 * n10 < u2[2] && n10 > 0 && (u2[3] = u2[2] - 2 * n10), lP(this, "afterGetCenter", {
            positions: u2
          }), u2;
        }, t10.getStartAndEndRadians = function(t11, e10) {
          let i10 = lL(t11) ? t11 : 0, s10 = lL(e10) && e10 > i10 && e10 - i10 < 360 ? e10 : i10 + 360;
          return {
            start: lA * (i10 + -90),
            end: lA * (s10 + -90)
          };
        };
      }(f || (f = {}));
      let lI = f, {
        setAnimation: lD
      } = tH, {
        addEvent: lB,
        defined: lz,
        extend: lN,
        isNumber: lR,
        pick: lW,
        relativeLength: lj
      } = J;
      class lX extends o$ {
        getConnectorPath(t10) {
          let e10 = t10.dataLabelPosition, i10 = t10.options || {}, s10 = i10.connectorShape, o10 = this.connectorShapes[s10] || s10;
          return e10 && o10.call(this, __spreadProps(__spreadValues({}, e10.computed), {
            alignment: e10.alignment
          }), e10.connectorPosition, i10) || [];
        }
        getTranslate() {
          return this.sliced && this.slicedTranslation || {
            translateX: 0,
            translateY: 0
          };
        }
        haloPath(t10) {
          let e10 = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e10.x, e10.y, e10.r + t10, e10.r + t10, {
            innerR: e10.r - 1,
            start: e10.start,
            end: e10.end,
            borderRadius: e10.borderRadius
          });
        }
        constructor(t10, e10, i10) {
          super(t10, e10, i10), this.half = 0, this.name ?? (this.name = "Slice");
          let s10 = (t11) => {
            this.slice("select" === t11.type);
          };
          lB(this, "select", s10), lB(this, "unselect", s10);
        }
        isValid() {
          return lR(this.y) && this.y >= 0;
        }
        setVisible(t10, e10 = true) {
          t10 !== this.visible && this.update({
            visible: t10 ?? !this.visible
          }, e10, void 0, false);
        }
        slice(t10, e10, i10) {
          let s10 = this.series;
          lD(i10, s10.chart), e10 = lW(e10, true), this.sliced = this.options.sliced = t10 = lz(t10) ? t10 : !this.sliced, s10.options.data[s10.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
        }
      }
      lN(lX.prototype, {
        connectorShapes: {
          fixedOffset: function(t10, e10, i10) {
            let s10 = e10.breakAt, o10 = e10.touchingSliceAt, r10 = i10.softConnector ? ["C", t10.x + ("left" === t10.alignment ? -5 : 5), t10.y, 2 * s10.x - o10.x, 2 * s10.y - o10.y, s10.x, s10.y] : ["L", s10.x, s10.y];
            return [["M", t10.x, t10.y], r10, ["L", o10.x, o10.y]];
          },
          straight: function(t10, e10) {
            let i10 = e10.touchingSliceAt;
            return [["M", t10.x, t10.y], ["L", i10.x, i10.y]];
          },
          crookedLine: function(t10, e10, i10) {
            let {
              angle: s10 = this.angle || 0,
              breakAt: o10,
              touchingSliceAt: r10
            } = e10, {
              series: a10
            } = this, [n10, l10, h10] = a10.center, d10 = h10 / 2, {
              plotLeft: c10,
              plotWidth: p4
            } = a10.chart, u2 = "left" === t10.alignment, {
              x: g2,
              y: m2
            } = t10, f2 = o10.x;
            if (i10.crookDistance) {
              let t11 = lj(i10.crookDistance, 1);
              f2 = u2 ? n10 + d10 + (p4 + c10 - n10 - d10) * (1 - t11) : c10 + (n10 - d10) * t11;
            } else f2 = n10 + (l10 - m2) * Math.tan(s10 - Math.PI / 2);
            let x2 = [["M", g2, m2]];
            return (u2 ? f2 <= g2 && f2 >= o10.x : f2 >= g2 && f2 <= o10.x) && x2.push(["L", f2, m2]), x2.push(["L", o10.x, o10.y], ["L", r10.x, r10.y]), x2;
          }
        }
      });
      let {
        getStartAndEndRadians: lG
      } = lI, {
        noop: lF
      } = A, {
        clamp: lH,
        extend: lY,
        fireEvent: lV,
        merge: lU,
        pick: lZ
      } = J;
      class l$ extends rq {
        animate(t10) {
          let e10 = this, i10 = e10.points, s10 = e10.startAngleRad;
          t10 || i10.forEach(function(t11) {
            let i11 = t11.graphic, o10 = t11.shapeArgs;
            i11 && o10 && (i11.attr({
              r: lZ(t11.startR, e10.center && e10.center[3] / 2),
              start: s10,
              end: s10
            }), i11.animate({
              r: o10.r,
              start: o10.start,
              end: o10.end
            }, e10.options.animation));
          });
        }
        drawEmpty() {
          let t10, e10;
          let i10 = this.startAngleRad, s10 = this.endAngleRad, o10 = this.options;
          0 === this.total && this.center ? (t10 = this.center[0], e10 = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t10, e10, this.center[1] / 2, 0, i10, s10).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
            d: ie.arc(t10, e10, this.center[2] / 2, 0, {
              start: i10,
              end: s10,
              innerR: this.center[3] / 2
            })
          }), this.chart.styledMode || this.graph.attr({
            "stroke-width": o10.borderWidth,
            fill: o10.fillColor || "none",
            stroke: o10.color || "#cccccc"
          })) : this.graph && (this.graph = this.graph.destroy());
        }
        drawPoints() {
          let t10 = this.chart.renderer;
          this.points.forEach(function(e10) {
            e10.graphic && e10.hasNewShapeType() && (e10.graphic = e10.graphic.destroy()), e10.graphic || (e10.graphic = t10[e10.shapeType](e10.shapeArgs).add(e10.series.group), e10.delayedRendering = true);
          });
        }
        generatePoints() {
          super.generatePoints(), this.updateTotals();
        }
        getX(t10, e10, i10, s10) {
          let o10 = this.center, r10 = this.radii ? this.radii[i10.index] || 0 : o10[2] / 2, a10 = s10.dataLabelPosition, n10 = a10?.distance || 0, l10 = Math.asin(lH((t10 - o10[1]) / (r10 + n10), -1, 1));
          return o10[0] + Math.cos(l10) * (r10 + n10) * (e10 ? -1 : 1) + (n10 > 0 ? (e10 ? -1 : 1) * (s10.padding || 0) : 0);
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        redrawPoints() {
          let t10, e10, i10, s10;
          let o10 = this, r10 = o10.chart;
          this.drawEmpty(), o10.group && !r10.styledMode && o10.group.shadow(o10.options.shadow), o10.points.forEach(function(a10) {
            let n10 = {};
            e10 = a10.graphic, !a10.isNull && e10 ? (s10 = a10.shapeArgs, t10 = a10.getTranslate(), r10.styledMode || (i10 = o10.pointAttribs(a10, a10.selected && "select")), a10.delayedRendering ? (e10.setRadialReference(o10.center).attr(s10).attr(t10), r10.styledMode || e10.attr(i10).attr({
              "stroke-linejoin": "round"
            }), a10.delayedRendering = false) : (e10.setRadialReference(o10.center), r10.styledMode || lU(true, n10, i10), lU(true, n10, s10, t10), e10.animate(n10)), e10.attr({
              visibility: a10.visible ? "inherit" : "hidden"
            }), e10.addClass(a10.getClassName(), true)) : e10 && (a10.graphic = e10.destroy());
          });
        }
        sortByAngle(t10, e10) {
          t10.sort(function(t11, i10) {
            return void 0 !== t11.angle && (i10.angle - t11.angle) * e10;
          });
        }
        translate(t10) {
          lV(this, "translate"), this.generatePoints();
          let e10 = this.options, i10 = e10.slicedOffset, s10 = lG(e10.startAngle, e10.endAngle), o10 = this.startAngleRad = s10.start, r10 = (this.endAngleRad = s10.end) - o10, a10 = this.points, n10 = e10.ignoreHiddenPoint, l10 = a10.length, h10, d10, c10, p4, u2, g2, m2, f2 = 0;
          for (t10 || (this.center = t10 = this.getCenter()), g2 = 0; g2 < l10; g2++) {
            m2 = a10[g2], h10 = o10 + f2 * r10, m2.isValid() && (!n10 || m2.visible) && (f2 += m2.percentage / 100), d10 = o10 + f2 * r10;
            let e11 = {
              x: t10[0],
              y: t10[1],
              r: t10[2] / 2,
              innerR: t10[3] / 2,
              start: Math.round(1e3 * h10) / 1e3,
              end: Math.round(1e3 * d10) / 1e3
            };
            m2.shapeType = "arc", m2.shapeArgs = e11, (c10 = (d10 + h10) / 2) > 1.5 * Math.PI ? c10 -= 2 * Math.PI : c10 < -Math.PI / 2 && (c10 += 2 * Math.PI), m2.slicedTranslation = {
              translateX: Math.round(Math.cos(c10) * i10),
              translateY: Math.round(Math.sin(c10) * i10)
            }, p4 = Math.cos(c10) * t10[2] / 2, u2 = Math.sin(c10) * t10[2] / 2, m2.tooltipPos = [t10[0] + 0.7 * p4, t10[1] + 0.7 * u2], m2.half = c10 < -Math.PI / 2 || c10 > Math.PI / 2 ? 1 : 0, m2.angle = c10;
          }
          lV(this, "afterTranslate");
        }
        updateTotals() {
          let t10 = this.points, e10 = t10.length, i10 = this.options.ignoreHiddenPoint, s10, o10, r10 = 0;
          for (s10 = 0; s10 < e10; s10++) (o10 = t10[s10]).isValid() && (!i10 || o10.visible) && (r10 += o10.y);
          for (s10 = 0, this.total = r10; s10 < e10; s10++) (o10 = t10[s10]).percentage = r10 > 0 && (o10.visible || !i10) ? o10.y / r10 * 100 : 0, o10.total = r10;
        }
      }
      l$.defaultOptions = lU(rq.defaultOptions, {
        borderRadius: 3,
        center: [null, null],
        clip: false,
        colorByPoint: true,
        dataLabels: {
          connectorPadding: 5,
          connectorShape: "crookedLine",
          crookDistance: void 0,
          distance: 30,
          enabled: true,
          formatter: function() {
            return this.isNull ? void 0 : this.name;
          },
          softConnector: true,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: true,
        inactiveOtherPoints: true,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: false,
        slicedOffset: 10,
        stickyTracking: false,
        tooltip: {
          followPointer: true
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: 0.1
          }
        }
      }), lY(l$.prototype, {
        axisTypes: [],
        directTouch: true,
        drawGraph: void 0,
        drawTracker: n8.prototype.drawTracker,
        getCenter: lI.getCenter,
        getSymbol: lF,
        invertible: false,
        isCartesian: false,
        noSharedTooltip: true,
        pointAttribs: n8.prototype.pointAttribs,
        pointClass: lX,
        requireSorting: false,
        searchPoint: lF,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), rx.registerSeriesType("pie", l$);
      let {
        composed: l_,
        noop: lq
      } = A, {
        distribute: lK
      } = ef, {
        series: lJ
      } = rx, {
        arrayMax: lQ,
        clamp: l0,
        defined: l1,
        pick: l2,
        pushUnique: l3,
        relativeLength: l6
      } = J;
      !function(t10) {
        let e10 = {
          radialDistributionY: function(t11, e11) {
            return (e11.dataLabelPosition?.top || 0) + t11.distributeBox.pos;
          },
          radialDistributionX: function(t11, e11, i11, s11, o11) {
            let r11 = o11.dataLabelPosition;
            return t11.getX(i11 < (r11?.top || 0) + 2 || i11 > (r11?.bottom || 0) - 2 ? s11 : i11, e11.half, e11, o11);
          },
          justify: function(t11, e11, i11, s11) {
            return s11[0] + (t11.half ? -1 : 1) * (i11 + (e11.dataLabelPosition?.distance || 0));
          },
          alignToPlotEdges: function(t11, e11, i11, s11) {
            let o11 = t11.getBBox().width;
            return e11 ? o11 + s11 : i11 - o11 - s11;
          },
          alignToConnectors: function(t11, e11, i11, s11) {
            let o11 = 0, r11;
            return t11.forEach(function(t12) {
              (r11 = t12.dataLabel.getBBox().width) > o11 && (o11 = r11);
            }), e11 ? o11 + s11 : i11 - o11 - s11;
          }
        };
        function i10(t11, e11) {
          let i11 = Math.PI / 2, {
            start: s11 = 0,
            end: o11 = 0
          } = t11.shapeArgs || {}, r11 = t11.angle || 0;
          e11 > 0 && s11 < i11 && o11 > i11 && r11 > i11 / 2 && r11 < 1.5 * i11 && (r11 = r11 <= i11 ? Math.max(i11 / 2, (s11 + i11) / 2) : Math.min(1.5 * i11, (i11 + o11) / 2));
          let {
            center: a10,
            options: n10
          } = this, l10 = a10[2] / 2, h10 = Math.cos(r11), d10 = Math.sin(r11), c10 = a10[0] + h10 * l10, p4 = a10[1] + d10 * l10, u2 = Math.min((n10.slicedOffset || 0) + (n10.borderWidth || 0), e11 / 5);
          return {
            natural: {
              x: c10 + h10 * e11,
              y: p4 + d10 * e11
            },
            computed: {},
            alignment: e11 < 0 ? "center" : t11.half ? "right" : "left",
            connectorPosition: {
              angle: r11,
              breakAt: {
                x: c10 + h10 * u2,
                y: p4 + d10 * u2
              },
              touchingSliceAt: {
                x: c10,
                y: p4
              }
            },
            distance: e11
          };
        }
        function s10() {
          let t11 = this, e11 = t11.points, i11 = t11.chart, s11 = i11.plotWidth, o11 = i11.plotHeight, r11 = i11.plotLeft, a10 = Math.round(i11.chartWidth / 3), n10 = t11.center, l10 = n10[2] / 2, h10 = n10[1], d10 = [[], []], c10 = [0, 0, 0, 0], p4 = t11.dataLabelPositioners, u2, g2, m2, f2 = 0;
          t11.visible && t11.hasDataLabels?.() && (e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((t13) => {
              t13.shortened && (t13.attr({
                width: "auto"
              }).css({
                width: "auto",
                textOverflow: "clip"
              }), t13.shortened = false);
            });
          }), lJ.prototype.drawDataLabels.apply(t11), e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((e12, i12) => {
              let s12 = n10[2] / 2, o12 = e12.options, r12 = l6(o12?.distance || 0, s12);
              0 === i12 && d10[t12.half].push(t12), !l1(o12?.style?.width) && e12.getBBox().width > a10 && (e12.css({
                width: Math.round(0.7 * a10) + "px"
              }), e12.shortened = true), e12.dataLabelPosition = this.getDataLabelPosition(t12, r12), f2 = Math.max(f2, r12);
            });
          }), d10.forEach((e12, a11) => {
            let d11 = e12.length, u3 = [], x2, y2, b2 = 0, v2;
            d11 && (t11.sortByAngle(e12, a11 - 0.5), f2 > 0 && (x2 = Math.max(0, h10 - l10 - f2), y2 = Math.min(h10 + l10 + f2, i11.plotHeight), e12.forEach((t12) => {
              (t12.dataLabels || []).forEach((e13) => {
                let s12 = e13.dataLabelPosition;
                s12 && s12.distance > 0 && (s12.top = Math.max(0, h10 - l10 - s12.distance), s12.bottom = Math.min(h10 + l10 + s12.distance, i11.plotHeight), b2 = e13.getBBox().height || 21, e13.lineHeight = i11.renderer.fontMetrics(e13.text || e13).h + 2 * e13.padding, t12.distributeBox = {
                  target: (e13.dataLabelPosition?.natural.y || 0) - s12.top + e13.lineHeight / 2,
                  size: b2,
                  rank: t12.y
                }, u3.push(t12.distributeBox));
              });
            }), lK(u3, v2 = y2 + b2 - x2, v2 / 5)), e12.forEach((i12) => {
              (i12.dataLabels || []).forEach((h11) => {
                let d12 = h11.options || {}, f3 = i12.distributeBox, x3 = h11.dataLabelPosition, y3 = x3?.natural.y || 0, b3 = d12.connectorPadding || 0, v3 = h11.lineHeight || 21, M2 = (v3 - h11.getBBox().height) / 2, w2 = 0, k2 = y3, S2 = "inherit";
                if (x3) {
                  if (u3 && l1(f3) && x3.distance > 0 && (void 0 === f3.pos ? S2 = "hidden" : (m2 = f3.size, k2 = p4.radialDistributionY(i12, h11))), d12.justify) w2 = p4.justify(i12, h11, l10, n10);
                  else switch (d12.alignTo) {
                    case "connectors":
                      w2 = p4.alignToConnectors(e12, a11, s11, r11);
                      break;
                    case "plotEdges":
                      w2 = p4.alignToPlotEdges(h11, a11, s11, r11);
                      break;
                    default:
                      w2 = p4.radialDistributionX(t11, i12, k2 - M2, y3, h11);
                  }
                  if (x3.attribs = {
                    visibility: S2,
                    align: x3.alignment
                  }, x3.posAttribs = {
                    x: w2 + (d12.x || 0) + ({
                      left: b3,
                      right: -b3
                    }[x3.alignment] || 0),
                    y: k2 + (d12.y || 0) - v3 / 2
                  }, x3.computed.x = w2, x3.computed.y = k2 - M2, l2(d12.crop, true)) {
                    let t12;
                    w2 - (g2 = h11.getBBox().width) < b3 && 1 === a11 ? (t12 = Math.round(g2 - w2 + b3), c10[3] = Math.max(t12, c10[3])) : w2 + g2 > s11 - b3 && 0 === a11 && (t12 = Math.round(w2 + g2 - s11 + b3), c10[1] = Math.max(t12, c10[1])), k2 - m2 / 2 < 0 ? c10[0] = Math.max(Math.round(-k2 + m2 / 2), c10[0]) : k2 + m2 / 2 > o11 && (c10[2] = Math.max(Math.round(k2 + m2 / 2 - o11), c10[2])), x3.sideOverflow = t12;
                  }
                }
              });
            }));
          }), (0 === lQ(c10) || this.verifyDataLabelOverflow(c10)) && (this.placeDataLabels(), this.points.forEach((e12) => {
            (e12.dataLabels || []).forEach((s12) => {
              let {
                connectorColor: o12,
                connectorWidth: r12 = 1
              } = s12.options || {}, a11 = s12.dataLabelPosition;
              if (r12) {
                let n11;
                u2 = s12.connector, a11 && a11.distance > 0 ? (n11 = !u2, u2 || (s12.connector = u2 = i11.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e12.colorIndex + (e12.className ? " " + e12.className : "")).add(t11.dataLabelsGroup)), i11.styledMode || u2.attr({
                  "stroke-width": r12,
                  stroke: o12 || e12.color || "#666666"
                }), u2[n11 ? "attr" : "animate"]({
                  d: e12.getConnectorPath(s12)
                }), u2.attr({
                  visibility: a11.attribs?.visibility
                })) : u2 && (s12.connector = u2.destroy());
              }
            });
          })));
        }
        function o10() {
          this.points.forEach((t11) => {
            (t11.dataLabels || []).forEach((t12) => {
              let e11 = t12.dataLabelPosition;
              e11 ? (e11.sideOverflow && (t12.css({
                width: Math.max(t12.getBBox().width - e11.sideOverflow, 0) + "px",
                textOverflow: (t12.options?.style || {}).textOverflow || "ellipsis"
              }), t12.shortened = true), t12.attr(e11.attribs), t12[t12.moved ? "animate" : "attr"](e11.posAttribs), t12.moved = true) : t12 && t12.attr({
                y: -9999
              });
            }), delete t11.distributeBox;
          }, this);
        }
        function r10(t11) {
          let e11 = this.center, i11 = this.options, s11 = i11.center, o11 = i11.minSize || 80, r11 = o11, a10 = null !== i11.size;
          return !a10 && (null !== s11[0] ? r11 = Math.max(e11[2] - Math.max(t11[1], t11[3]), o11) : (r11 = Math.max(e11[2] - t11[1] - t11[3], o11), e11[0] += (t11[3] - t11[1]) / 2), null !== s11[1] ? r11 = l0(r11, o11, e11[2] - Math.max(t11[0], t11[2])) : (r11 = l0(r11, o11, e11[2] - t11[0] - t11[2]), e11[1] += (t11[0] - t11[2]) / 2), r11 < e11[2] ? (e11[2] = r11, e11[3] = Math.min(i11.thickness ? Math.max(0, r11 - 2 * i11.thickness) : Math.max(0, l6(i11.innerSize || 0, r11)), r11), this.translate(e11), this.drawDataLabels && this.drawDataLabels()) : a10 = true), a10;
        }
        t10.compose = function(t11) {
          if (lc.compose(lJ), l3(l_, "PieDataLabel")) {
            let a10 = t11.prototype;
            a10.dataLabelPositioners = e10, a10.alignDataLabel = lq, a10.drawDataLabels = s10, a10.getDataLabelPosition = i10, a10.placeDataLabels = o10, a10.verifyDataLabelOverflow = r10;
          }
        };
      }(x || (x = {}));
      let l5 = x;
      !function(t10) {
        t10.getCenterOfPoints = function(t11) {
          let e10 = t11.reduce((t12, e11) => (t12.x += e11.x, t12.y += e11.y, t12), {
            x: 0,
            y: 0
          });
          return {
            x: e10.x / t11.length,
            y: e10.y / t11.length
          };
        }, t10.getDistanceBetweenPoints = function(t11, e10) {
          return Math.sqrt(Math.pow(e10.x - t11.x, 2) + Math.pow(e10.y - t11.y, 2));
        }, t10.getAngleBetweenPoints = function(t11, e10) {
          return Math.atan2(e10.x - t11.x, e10.y - t11.y);
        }, t10.pointInPolygon = function({
          x: t11,
          y: e10
        }, i10) {
          let s10 = i10.length, o10, r10, a10 = false;
          for (o10 = 0, r10 = s10 - 1; o10 < s10; r10 = o10++) {
            let [s11, n10] = i10[o10], [l10, h10] = i10[r10];
            n10 > e10 != h10 > e10 && t11 < (l10 - s11) * (e10 - n10) / (h10 - n10) + s11 && (a10 = !a10);
          }
          return a10;
        };
      }(y || (y = {}));
      let l9 = y, {
        pointInPolygon: l8
      } = l9, {
        addEvent: l4,
        fireEvent: l7,
        objectEach: ht,
        pick: he
      } = J;
      function hi(t10) {
        let e10 = t10.length, i10 = (t11, e11) => !(e11.x >= t11.x + t11.width || e11.x + e11.width <= t11.x || e11.y >= t11.y + t11.height || e11.y + e11.height <= t11.y), s10 = (t11, e11) => {
          for (let i11 of t11) if (l8({
            x: i11[0],
            y: i11[1]
          }, e11)) return true;
          return false;
        }, o10, r10, a10, n10, l10, h10 = false;
        for (let i11 = 0; i11 < e10; i11++) (o10 = t10[i11]) && (o10.oldOpacity = o10.opacity, o10.newOpacity = 1, o10.absoluteBox = function(t11) {
          if (t11 && (!t11.alignAttr || t11.placed)) {
            let e11 = t11.box ? 0 : t11.padding || 0, i12 = t11.alignAttr || {
              x: t11.attr("x"),
              y: t11.attr("y")
            }, s11 = t11.getBBox();
            return t11.width = s11.width, t11.height = s11.height, {
              x: i12.x + (t11.parentGroup?.translateX || 0) + e11,
              y: i12.y + (t11.parentGroup?.translateY || 0) + e11,
              width: (t11.width || 0) - 2 * e11,
              height: (t11.height || 0) - 2 * e11,
              polygon: s11?.polygon
            };
          }
        }(o10));
        t10.sort((t11, e11) => (e11.labelrank || 0) - (t11.labelrank || 0));
        for (let o11 = 0; o11 < e10; ++o11) {
          n10 = (r10 = t10[o11]) && r10.absoluteBox;
          let h11 = n10?.polygon;
          for (let d10 = o11 + 1; d10 < e10; ++d10) {
            l10 = (a10 = t10[d10]) && a10.absoluteBox;
            let e11 = false;
            if (n10 && l10 && r10 !== a10 && 0 !== r10.newOpacity && 0 !== a10.newOpacity && "hidden" !== r10.visibility && "hidden" !== a10.visibility) {
              let t11 = l10.polygon;
              if (h11 && t11 && h11 !== t11 ? s10(h11, t11) && (e11 = true) : i10(n10, l10) && (e11 = true), e11) {
                let t12 = r10.labelrank < a10.labelrank ? r10 : a10, e12 = t12.text;
                t12.newOpacity = 0, e12?.element.querySelector("textPath") && e12.hide();
              }
            }
          }
        }
        for (let e11 of t10) hs(e11, this) && (h10 = true);
        h10 && l7(this, "afterHideAllOverlappingLabels");
      }
      function hs(t10, e10) {
        let i10, s10, o10 = false;
        return t10 && (s10 = t10.newOpacity, t10.oldOpacity !== s10 && (t10.hasClass("highcharts-data-label") ? (t10[s10 ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), i10 = function() {
          e10.styledMode || t10.css({
            pointerEvents: s10 ? "auto" : "none"
          });
        }, o10 = true, t10[t10.isOld ? "animate" : "attr"]({
          opacity: s10
        }, void 0, i10), l7(e10, "afterHideOverlappingLabel")) : t10.attr({
          opacity: s10
        })), t10.isOld = true), o10;
      }
      function ho() {
        let t10 = this, e10 = [];
        for (let i10 of t10.labelCollectors || []) e10 = e10.concat(i10());
        for (let i10 of t10.yAxis || []) i10.stacking && i10.options.stackLabels && !i10.options.stackLabels.allowOverlap && ht(i10.stacking.stacks, (t11) => {
          ht(t11, (t12) => {
            t12.label && e10.push(t12.label);
          });
        });
        for (let i10 of t10.series || []) if (i10.visible && i10.hasDataLabels?.()) {
          let s10 = (i11) => {
            for (let s11 of i11) s11.visible && (s11.dataLabels || []).forEach((i12) => {
              let o10 = i12.options || {};
              i12.labelrank = he(o10.labelrank, s11.labelrank, s11.shapeArgs?.height), o10.allowOverlap ?? Number(o10.distance) > 0 ? (i12.oldOpacity = i12.opacity, i12.newOpacity = 1, hs(i12, t10)) : e10.push(i12);
            });
          };
          s10(i10.nodes || []), s10(i10.points);
        }
        this.hideOverlappingLabels(e10);
      }
      let hr = {
        compose: function(t10) {
          let e10 = t10.prototype;
          e10.hideOverlappingLabels || (e10.hideOverlappingLabels = hi, l4(t10, "render", ho));
        }
      }, {
        defaultOptions: ha
      } = tw, {
        noop: hn
      } = A, {
        addEvent: hl,
        extend: hh,
        isObject: hd,
        merge: hc,
        relativeLength: hp
      } = J, hu = {
        radius: 0,
        scope: "stack",
        where: void 0
      }, hg = hn, hm = hn;
      function hf(t10, e10, i10, s10, o10 = {}) {
        let r10 = hg(t10, e10, i10, s10, o10), {
          innerR: a10 = 0,
          r: n10 = i10,
          start: l10 = 0,
          end: h10 = 0
        } = o10;
        if (o10.open || !o10.borderRadius) return r10;
        let d10 = h10 - l10, c10 = Math.sin(d10 / 2), p4 = Math.max(Math.min(hp(o10.borderRadius || 0, n10 - a10), (n10 - a10) / 2, n10 * c10 / (1 + c10)), 0), u2 = Math.min(p4, d10 / Math.PI * 2 * a10), g2 = r10.length - 1;
        for (; g2--; ) !function(t11, e11, i11) {
          let s11, o11, r11;
          let a11 = t11[e11], n11 = t11[e11 + 1];
          if ("Z" === n11[0] && (n11 = t11[0]), ("M" === a11[0] || "L" === a11[0]) && "A" === n11[0] ? (s11 = a11, o11 = n11, r11 = true) : "A" === a11[0] && ("M" === n11[0] || "L" === n11[0]) && (s11 = n11, o11 = a11), s11 && o11 && o11.params) {
            let a12 = o11[1], n12 = o11[5], l11 = o11.params, {
              start: h11,
              end: d11,
              cx: c11,
              cy: p7
            } = l11, u3 = n12 ? a12 - i11 : a12 + i11, g3 = u3 ? Math.asin(i11 / u3) : 0, m2 = n12 ? g3 : -g3, f2 = Math.cos(g3) * u3;
            r11 ? (l11.start = h11 + m2, s11[1] = c11 + f2 * Math.cos(h11), s11[2] = p7 + f2 * Math.sin(h11), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + a12 * Math.cos(l11.start), p7 + a12 * Math.sin(l11.start)])) : (l11.end = d11 - m2, o11[6] = c11 + a12 * Math.cos(l11.end), o11[7] = p7 + a12 * Math.sin(l11.end), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + f2 * Math.cos(d11), p7 + f2 * Math.sin(d11)])), o11[4] = Math.abs(l11.end - l11.start) < Math.PI ? 0 : 1;
          }
        }(r10, g2, g2 > 1 ? u2 : p4);
        return r10;
      }
      function hx() {
        if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
          let {
            options: t10,
            yAxis: e10
          } = this, i10 = "percent" === t10.stacking, s10 = ha.plotOptions?.[this.type]?.borderRadius, o10 = hy(t10.borderRadius, hd(s10) ? s10 : {}), r10 = e10.options.reversed;
          for (let s11 of this.points) {
            let {
              shapeArgs: a10
            } = s11;
            if ("roundedRect" === s11.shapeType && a10) {
              let {
                width: n10 = 0,
                height: l10 = 0,
                y: h10 = 0
              } = a10, d10 = h10, c10 = l10;
              if ("stack" === o10.scope && s11.stackTotal) {
                let o11 = e10.translate(i10 ? 100 : s11.stackTotal, false, true, false, true), r11 = e10.translate(t10.threshold || 0, false, true, false, true), a11 = this.crispCol(0, Math.min(o11, r11), 0, Math.abs(o11 - r11));
                d10 = a11.y, c10 = a11.height;
              }
              let p4 = (s11.negative ? -1 : 1) * (r10 ? -1 : 1) == -1, u2 = o10.where;
              !u2 && this.is("waterfall") && Math.abs((s11.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (u2 = "all"), u2 || (u2 = "end");
              let g2 = Math.min(hp(o10.radius, n10), n10 / 2, "all" === u2 ? l10 / 2 : 1 / 0) || 0;
              "end" === u2 && (p4 && (d10 -= g2), c10 += g2), hh(a10, {
                brBoxHeight: c10,
                brBoxY: d10,
                r: g2
              });
            }
          }
        }
      }
      function hy(t10, e10) {
        return hd(t10) || (t10 = {
          radius: t10 || 0
        }), hc(hu, e10, t10);
      }
      function hb() {
        let t10 = hy(this.options.borderRadius);
        for (let e10 of this.points) {
          let i10 = e10.shapeArgs;
          i10 && (i10.borderRadius = hp(t10.radius, (i10.r || 0) - (i10.innerR || 0)));
        }
      }
      function hv(t10, e10, i10, s10, o10 = {}) {
        let r10 = hm(t10, e10, i10, s10, o10), {
          r: a10 = 0,
          brBoxHeight: n10 = s10,
          brBoxY: l10 = e10
        } = o10, h10 = e10 - l10, d10 = l10 + n10 - (e10 + s10), c10 = h10 - a10 > -0.1 ? 0 : a10, p4 = d10 - a10 > -0.1 ? 0 : a10, u2 = Math.max(c10 && h10, 0), g2 = Math.max(p4 && d10, 0), m2 = [t10 + c10, e10], f2 = [t10 + i10 - c10, e10], x2 = [t10 + i10, e10 + c10], y2 = [t10 + i10, e10 + s10 - p4], b2 = [t10 + i10 - p4, e10 + s10], v2 = [t10 + p4, e10 + s10], M2 = [t10, e10 + s10 - p4], w2 = [t10, e10 + c10], k2 = (t11, e11) => Math.sqrt(Math.pow(t11, 2) - Math.pow(e11, 2));
        if (u2) {
          let t11 = k2(c10, c10 - u2);
          m2[0] -= t11, f2[0] += t11, x2[1] = w2[1] = e10 + c10 - u2;
        }
        if (s10 < c10 - u2) {
          let o11 = k2(c10, c10 - u2 - s10);
          x2[0] = y2[0] = t10 + i10 - c10 + o11, b2[0] = Math.min(x2[0], b2[0]), v2[0] = Math.max(y2[0], v2[0]), M2[0] = w2[0] = t10 + c10 - o11, x2[1] = w2[1] = e10 + s10;
        }
        if (g2) {
          let t11 = k2(p4, p4 - g2);
          b2[0] += t11, v2[0] -= t11, y2[1] = M2[1] = e10 + s10 - p4 + g2;
        }
        if (s10 < p4 - g2) {
          let o11 = k2(p4, p4 - g2 - s10);
          x2[0] = y2[0] = t10 + i10 - p4 + o11, f2[0] = Math.min(x2[0], f2[0]), m2[0] = Math.max(y2[0], m2[0]), M2[0] = w2[0] = t10 + p4 - o11, y2[1] = M2[1] = e10;
        }
        return r10.length = 0, r10.push(["M", ...m2], ["L", ...f2], ["A", c10, c10, 0, 0, 1, ...x2], ["L", ...y2], ["A", p4, p4, 0, 0, 1, ...b2], ["L", ...v2], ["A", p4, p4, 0, 0, 1, ...M2], ["L", ...w2], ["A", c10, c10, 0, 0, 1, ...m2], ["Z"]), r10;
      }
      let {
        diffObjects: hM,
        extend: hw,
        find: hk,
        merge: hS,
        pick: hT,
        uniqueKey: hC
      } = J;
      !function(t10) {
        function e10(t11, e11) {
          let i11 = t11.condition;
          (i11.callback || function() {
            return this.chartWidth <= hT(i11.maxWidth, Number.MAX_VALUE) && this.chartHeight <= hT(i11.maxHeight, Number.MAX_VALUE) && this.chartWidth >= hT(i11.minWidth, 0) && this.chartHeight >= hT(i11.minHeight, 0);
          }).call(this) && e11.push(t11._id);
        }
        function i10(t11, e11) {
          let i11 = this.options.responsive, s10 = this.currentResponsive, o10 = [], r10;
          !e11 && i11 && i11.rules && i11.rules.forEach((t12) => {
            void 0 === t12._id && (t12._id = hC()), this.matchResponsiveRule(t12, o10);
          }, this);
          let a10 = hS(...o10.map((t12) => hk((i11 || {}).rules || [], (e12) => e12._id === t12)).map((t12) => t12 && t12.chartOptions));
          a10.isResponsiveOptions = true, o10 = o10.toString() || void 0;
          let n10 = s10 && s10.ruleIds;
          o10 === n10 || (s10 && (this.currentResponsive = void 0, this.updatingResponsive = true, this.update(s10.undoOptions, t11, true), this.updatingResponsive = false), o10 ? ((r10 = hM(a10, this.options, true, this.collectionsWithUpdate)).isResponsiveOptions = true, this.currentResponsive = {
            ruleIds: o10,
            mergedOptions: a10,
            undoOptions: r10
          }, this.updatingResponsive || this.update(a10, t11, true)) : this.currentResponsive = void 0);
        }
        t10.compose = function(t11) {
          let s10 = t11.prototype;
          return s10.matchResponsiveRule || hw(s10, {
            matchResponsiveRule: e10,
            setResponsive: i10
          }), t11;
        };
      }(b || (b = {}));
      let hA = b;
      A.AST = t3, A.Axis = sY, A.Chart = aq, A.Color = tA, A.DataLabel = lc, A.DataTableCore = rl, A.Fx = tI, A.HTMLElement = i2, A.Legend = ah, A.LegendSymbol = rp, A.OverlappingDataLabels = A.OverlappingDataLabels || hr, A.PlotLineOrBand = oo, A.Point = o$, A.Pointer = rs, A.RendererRegistry = ec, A.Series = rq, A.SeriesRegistry = rx, A.StackItem = na, A.SVGElement = eq, A.SVGRenderer = iH, A.Templating = ed, A.Tick = sp, A.Time = tf, A.Tooltip = oP, A.animate = tH.animate, A.animObject = tH.animObject, A.chart = aq.chart, A.color = tA.parse, A.dateFormat = ed.dateFormat, A.defaultOptions = tw.defaultOptions, A.distribute = ef.distribute, A.format = ed.format, A.getDeferredAnimation = tH.getDeferredAnimation, A.getOptions = tw.getOptions, A.numberFormat = ed.numberFormat, A.seriesType = rx.seriesType, A.setAnimation = tH.setAnimation, A.setOptions = tw.setOptions, A.stop = tH.stop, A.time = tw.defaultTime, A.timers = tI.timers, {
        compose: function(t10, e10, i10) {
          let s10 = t10.types.pie;
          if (!e10.symbolCustomAttribs.includes("borderRadius")) {
            let o10 = i10.prototype.symbols;
            hl(t10, "afterColumnTranslate", hx, {
              order: 9
            }), hl(s10, "afterTranslate", hb), e10.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), hg = o10.arc, hm = o10.roundedRect, o10.arc = hf, o10.roundedRect = hv;
          }
        },
        optionsToObject: hy
      }.compose(A.Series, A.SVGElement, A.SVGRenderer), lx.compose(A.Series.types.column), lc.compose(A.Series), s_.compose(A.Axis), i2.compose(A.SVGRenderer), ah.compose(A.Chart), sQ.compose(A.Axis), hr.compose(A.Chart), l5.compose(A.Series.types.pie), oo.compose(A.Chart, A.Axis), rs.compose(A.Chart), hA.compose(A.Chart), a4.compose(A.Axis, A.Chart, A.Series), nC.compose(A.Axis, A.Chart, A.Series), oP.compose(A.Pointer), J.extend(A, J);
      let {
        parse: hP
      } = tA, {
        addEvent: hL,
        extend: hO,
        merge: hE,
        pick: hI,
        splat: hD
      } = J;
      !function(t10) {
        let e10;
        function i10() {
          let {
            userOptions: t11
          } = this;
          this.colorAxis = [], t11.colorAxis && (t11.colorAxis = hD(t11.colorAxis), t11.colorAxis.map((t12) => new e10(this, t12)));
        }
        function s10(t11) {
          let e11 = this.chart.colorAxis || [], i11 = (e12) => {
            let i12 = t11.allItems.indexOf(e12);
            -1 !== i12 && (this.destroyItem(t11.allItems[i12]), t11.allItems.splice(i12, 1));
          }, s11 = [], o11, r11;
          for (e11.forEach(function(t12) {
            (o11 = t12.options) && o11.showInLegend && (o11.dataClasses && o11.visible ? s11 = s11.concat(t12.getDataClassLegendSymbols()) : o11.visible && s11.push(t12), t12.series.forEach(function(t13) {
              (!t13.options.showInLegend || o11.dataClasses) && ("point" === t13.options.legendType ? t13.points.forEach(function(t14) {
                i11(t14);
              }) : i11(t13));
            }));
          }), r11 = s11.length; r11--; ) t11.allItems.unshift(s11[r11]);
        }
        function o10(t11) {
          t11.visible && t11.item.legendColor && t11.item.legendItem.symbol.attr({
            fill: t11.item.legendColor
          });
        }
        function r10(t11) {
          this.chart.colorAxis?.forEach((e11) => {
            e11.update({}, t11.redraw);
          });
        }
        function a10() {
          (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
        }
        function n10() {
          let t11 = this.axisTypes;
          t11 ? -1 === t11.indexOf("colorAxis") && t11.push("colorAxis") : this.axisTypes = ["colorAxis"];
        }
        function l10(t11) {
          let e11 = this, i11 = t11 ? "show" : "hide";
          e11.visible = e11.options.visible = !!t11, ["graphic", "dataLabel"].forEach(function(t12) {
            e11[t12] && e11[t12][i11]();
          }), this.series.buildKDTree();
        }
        function h10() {
          let t11 = this, e11 = this.getPointsCollection(), i11 = this.options.nullColor, s11 = this.colorAxis, o11 = this.colorKey;
          e11.forEach((e12) => {
            let r11 = e12.getNestedProperty(o11), a11 = e12.options.color || (e12.isNull || null === e12.value ? i11 : s11 && void 0 !== r11 ? s11.toColor(r11, e12) : e12.color || t11.color);
            a11 && e12.color !== a11 && (e12.color = a11, "point" === t11.options.legendType && e12.legendItem && e12.legendItem.label && t11.chart.legend.colorizeItem(e12, e12.visible));
          });
        }
        function d10() {
          this.elem.attr("fill", hP(this.start).tweenTo(hP(this.end), this.pos), void 0, true);
        }
        function c10() {
          this.elem.attr("stroke", hP(this.start).tweenTo(hP(this.end), this.pos), void 0, true);
        }
        t10.compose = function(t11, p4, u2, g2, m2) {
          let f2 = p4.prototype, x2 = u2.prototype, y2 = m2.prototype;
          f2.collectionsWithUpdate.includes("colorAxis") || (e10 = t11, f2.collectionsWithUpdate.push("colorAxis"), f2.collectionsWithInit.colorAxis = [f2.addColorAxis], hL(p4, "afterCreateAxes", i10), function(t12) {
            let i11 = t12.prototype.createAxis;
            t12.prototype.createAxis = function(t13, s11) {
              if ("colorAxis" !== t13) return i11.apply(this, arguments);
              let o11 = new e10(this, hE(s11.axis, {
                index: this[t13].length,
                isX: false
              }));
              return this.isDirtyLegend = true, this.axes.forEach((t14) => {
                t14.series = [];
              }), this.series.forEach((t14) => {
                t14.bindAxes(), t14.isDirtyData = true;
              }), hI(s11.redraw, true) && this.redraw(s11.animation), o11;
            };
          }(p4), x2.fillSetter = d10, x2.strokeSetter = c10, hL(g2, "afterGetAllItems", s10), hL(g2, "afterColorizeItem", o10), hL(g2, "afterUpdate", r10), hO(y2, {
            optionalAxis: "colorAxis",
            translateColors: h10
          }), hO(y2.pointClass.prototype, {
            setVisible: l10
          }), hL(m2, "afterTranslate", a10, {
            order: 1
          }), hL(m2, "bindAxes", n10));
        }, t10.pointSetVisible = l10;
      }(v || (v = {}));
      let hB = v, {
        parse: hz
      } = tA, {
        merge: hN
      } = J;
      !function(t10) {
        t10.initDataClasses = function(t11) {
          let e10 = this.chart, i10 = this.legendItem = this.legendItem || {}, s10 = this.options, o10 = t11.dataClasses || [], r10, a10, n10 = e10.options.chart.colorCount, l10 = 0, h10;
          this.dataClasses = a10 = [], i10.labels = [];
          for (let t12 = 0, i11 = o10.length; t12 < i11; ++t12) r10 = hN(r10 = o10[t12]), a10.push(r10), (e10.styledMode || !r10.color) && ("category" === s10.dataClassColor ? (e10.styledMode || (n10 = (h10 = e10.options.colors || []).length, r10.color = h10[l10]), r10.colorIndex = l10, ++l10 === n10 && (l10 = 0)) : r10.color = hz(s10.minColor).tweenTo(hz(s10.maxColor), i11 < 2 ? 0.5 : t12 / (i11 - 1)));
        }, t10.initStops = function() {
          let t11 = this.options, e10 = this.stops = t11.stops || [[0, t11.minColor || ""], [1, t11.maxColor || ""]];
          for (let t12 = 0, i10 = e10.length; t12 < i10; ++t12) e10[t12].color = hz(e10[t12][1]);
        }, t10.normalizedValue = function(t11) {
          let e10 = this.max || 0, i10 = this.min || 0;
          return this.logarithmic && (t11 = this.logarithmic.log2lin(t11)), 1 - (e10 - t11) / (e10 - i10 || 1);
        }, t10.toColor = function(t11, e10) {
          let i10, s10, o10, r10, a10, n10;
          let l10 = this.dataClasses, h10 = this.stops;
          if (l10) {
            for (n10 = l10.length; n10--; ) if (s10 = (a10 = l10[n10]).from, o10 = a10.to, (void 0 === s10 || t11 >= s10) && (void 0 === o10 || t11 <= o10)) {
              r10 = a10.color, e10 && (e10.dataClass = n10, e10.colorIndex = a10.colorIndex);
              break;
            }
          } else {
            for (i10 = this.normalizedValue(t11), n10 = h10.length; n10-- && !(i10 > h10[n10][0]); ) ;
            s10 = h10[n10] || h10[n10 + 1], i10 = 1 - ((o10 = h10[n10 + 1] || s10)[0] - i10) / (o10[0] - s10[0] || 1), r10 = s10.color.tweenTo(o10.color, i10);
          }
          return r10;
        };
      }(M || (M = {}));
      let hR = M, {
        defaultOptions: hW
      } = tw, {
        series: hj
      } = rx, {
        defined: hX,
        extend: hG,
        fireEvent: hF,
        isArray: hH,
        isNumber: hY,
        merge: hV,
        pick: hU,
        relativeLength: hZ
      } = J;
      hW.colorAxis = hV(hW.xAxis, {
        lineWidth: 0,
        minPadding: 0,
        maxPadding: 0,
        gridLineColor: "#ffffff",
        gridLineWidth: 1,
        tickPixelInterval: 72,
        startOnTick: true,
        endOnTick: true,
        offset: 0,
        marker: {
          animation: {
            duration: 50
          },
          width: 0.01,
          color: "#999999"
        },
        labels: {
          distance: 8,
          overflow: "justify",
          rotation: 0
        },
        minColor: "#e6e9ff",
        maxColor: "#0022ff",
        tickLength: 5,
        showInLegend: true
      });
      class h$ extends sY {
        static compose(t10, e10, i10, s10) {
          hB.compose(h$, t10, e10, i10, s10);
        }
        constructor(t10, e10) {
          super(t10, e10), this.coll = "colorAxis", this.visible = true, this.init(t10, e10);
        }
        init(t10, e10) {
          let i10 = t10.options.legend || {}, s10 = e10.layout ? "vertical" !== e10.layout : "vertical" !== i10.layout;
          this.side = e10.side || s10 ? 2 : 1, this.reversed = e10.reversed || !s10, this.opposite = !s10, super.init(t10, e10, "colorAxis"), this.userOptions = e10, hH(t10.userOptions.colorAxis) && (t10.userOptions.colorAxis[this.index] = e10), e10.dataClasses && this.initDataClasses(e10), this.initStops(), this.horiz = s10, this.zoomEnabled = false;
        }
        hasData() {
          return !!(this.tickPositions || []).length;
        }
        setTickPositions() {
          if (!this.dataClasses) return super.setTickPositions();
        }
        setOptions(t10) {
          let e10 = hV(hW.colorAxis, t10, {
            showEmpty: false,
            title: null,
            visible: this.chart.options.legend.enabled && false !== t10.visible
          });
          super.setOptions(e10), this.options.crosshair = this.options.marker;
        }
        setAxisSize() {
          let t10 = this.chart, e10 = this.legendItem?.symbol, {
            width: i10,
            height: s10
          } = this.getSize();
          e10 && (this.left = +e10.attr("x"), this.top = +e10.attr("y"), this.width = i10 = +e10.attr("width"), this.height = s10 = +e10.attr("height"), this.right = t10.chartWidth - this.left - i10, this.bottom = t10.chartHeight - this.top - s10, this.pos = this.horiz ? this.left : this.top), this.len = (this.horiz ? i10 : s10) || h$.defaultLegendLength;
        }
        getOffset() {
          let t10 = this.legendItem?.group, e10 = this.chart.axisOffset[this.side];
          if (t10) {
            this.axisParent = t10, super.getOffset();
            let i10 = this.chart.legend;
            i10.allItems.forEach(function(t11) {
              t11 instanceof h$ && t11.drawLegendSymbol(i10, t11);
            }), i10.render(), this.chart.getMargins(true), this.chart.series.some((t11) => t11.isDrilling) || (this.isDirty = true), this.added || (this.added = true, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = e10;
          }
        }
        setLegendColor() {
          let t10 = this.horiz, e10 = this.reversed, i10 = e10 ? 1 : 0, s10 = e10 ? 0 : 1, o10 = t10 ? [i10, 0, s10, 0] : [0, s10, 0, i10];
          this.legendColor = {
            linearGradient: {
              x1: o10[0],
              y1: o10[1],
              x2: o10[2],
              y2: o10[3]
            },
            stops: this.stops
          };
        }
        drawLegendSymbol(t10, e10) {
          let i10 = e10.legendItem || {}, s10 = t10.padding, o10 = t10.options, r10 = this.options.labels, a10 = hU(o10.itemDistance, 10), n10 = this.horiz, {
            width: l10,
            height: h10
          } = this.getSize(), d10 = hU(o10.labelPadding, n10 ? 16 : 30);
          this.setLegendColor(), i10.symbol || (i10.symbol = this.chart.renderer.symbol("roundedRect").attr({
            r: o10.symbolRadius ?? 3,
            zIndex: 1
          }).add(i10.group)), i10.symbol.attr({
            x: 0,
            y: (t10.baseline || 0) - 11,
            width: l10,
            height: h10
          }), i10.labelWidth = l10 + s10 + (n10 ? a10 : hU(r10.x, r10.distance) + (this.maxLabelLength || 0)), i10.labelHeight = h10 + s10 + (n10 ? d10 : 0);
        }
        setState(t10) {
          this.series.forEach(function(e10) {
            e10.setState(t10);
          });
        }
        setVisible() {
        }
        getSeriesExtremes() {
          let t10 = this.series, e10, i10, s10, o10, r10 = t10.length;
          for (this.dataMin = 1 / 0, this.dataMax = -1 / 0; r10--; ) {
            for (let a10 of (i10 = (o10 = t10[r10]).colorKey = hU(o10.options.colorKey, o10.colorKey, o10.pointValKey, o10.zoneAxis, "y"), s10 = o10[i10 + "Min"] && o10[i10 + "Max"], [i10, "value", "y"])) if ((e10 = o10.getColumn(a10)).length) break;
            if (s10) o10.minColorValue = o10[i10 + "Min"], o10.maxColorValue = o10[i10 + "Max"];
            else {
              let t11 = hj.prototype.getExtremes.call(o10, e10);
              o10.minColorValue = t11.dataMin, o10.maxColorValue = t11.dataMax;
            }
            hX(o10.minColorValue) && hX(o10.maxColorValue) && (this.dataMin = Math.min(this.dataMin, o10.minColorValue), this.dataMax = Math.max(this.dataMax, o10.maxColorValue)), s10 || hj.prototype.applyExtremes.call(o10);
          }
        }
        drawCrosshair(t10, e10) {
          let i10;
          let s10 = this.legendItem || {}, o10 = e10 && e10.plotX, r10 = e10 && e10.plotY, a10 = this.pos, n10 = this.len;
          e10 && ((i10 = this.toPixels(e10.getNestedProperty(e10.series.colorKey))) < a10 ? i10 = a10 - 2 : i10 > a10 + n10 && (i10 = a10 + n10 + 2), e10.plotX = i10, e10.plotY = this.len - i10, super.drawCrosshair(t10, e10), e10.plotX = o10, e10.plotY = r10, this.cross && !this.cross.addedToColorAxis && s10.group && (this.cross.addClass("highcharts-coloraxis-marker").add(s10.group), this.cross.addedToColorAxis = true, this.chart.styledMode || "object" != typeof this.crosshair || this.cross.attr({
            fill: this.crosshair.color
          })));
        }
        getPlotLinePath(t10) {
          let e10 = this.left, i10 = t10.translatedValue, s10 = this.top;
          return hY(i10) ? this.horiz ? [["M", i10 - 4, s10 - 6], ["L", i10 + 4, s10 - 6], ["L", i10, s10], ["Z"]] : [["M", e10, i10], ["L", e10 - 6, i10 + 6], ["L", e10 - 6, i10 - 6], ["Z"]] : super.getPlotLinePath(t10);
        }
        update(t10, e10) {
          let i10 = this.chart.legend;
          this.series.forEach((t11) => {
            t11.isDirtyData = true;
          }), (t10.dataClasses && i10.allItems || this.dataClasses) && this.destroyItems(), super.update(t10, e10), this.legendItem && this.legendItem.label && (this.setLegendColor(), i10.colorizeItem(this, true));
        }
        destroyItems() {
          let t10 = this.chart, e10 = this.legendItem || {};
          if (e10.label) t10.legend.destroyItem(this);
          else if (e10.labels) for (let i10 of e10.labels) t10.legend.destroyItem(i10);
          t10.isDirtyLegend = true;
        }
        destroy() {
          this.chart.isDirtyLegend = true, this.destroyItems(), super.destroy(...[].slice.call(arguments));
        }
        remove(t10) {
          this.destroyItems(), super.remove(t10);
        }
        getDataClassLegendSymbols() {
          let t10;
          let e10 = this, i10 = e10.chart, s10 = e10.legendItem && e10.legendItem.labels || [], o10 = i10.options.legend, r10 = hU(o10.valueDecimals, -1), a10 = hU(o10.valueSuffix, ""), n10 = (t11) => e10.series.reduce((e11, i11) => (e11.push(...i11.points.filter((e12) => e12.dataClass === t11)), e11), []);
          return s10.length || e10.dataClasses.forEach((o11, l10) => {
            let h10 = o11.from, d10 = o11.to, {
              numberFormatter: c10
            } = i10, p4 = true;
            t10 = "", void 0 === h10 ? t10 = "< " : void 0 === d10 && (t10 = "> "), void 0 !== h10 && (t10 += c10(h10, r10) + a10), void 0 !== h10 && void 0 !== d10 && (t10 += " - "), void 0 !== d10 && (t10 += c10(d10, r10) + a10), s10.push(hG({
              chart: i10,
              name: t10,
              options: {},
              drawLegendSymbol: rp.rectangle,
              visible: true,
              isDataClass: true,
              setState: (t11) => {
                for (let e11 of n10(l10)) e11.setState(t11);
              },
              setVisible: function() {
                this.visible = p4 = e10.visible = !p4;
                let t11 = [];
                for (let e11 of n10(l10)) e11.setVisible(p4), e11.hiddenInDataClass = !p4, -1 === t11.indexOf(e11.series) && t11.push(e11.series);
                i10.legend.colorizeItem(this, p4), t11.forEach((t12) => {
                  hF(t12, "afterDataClassLegendClick");
                });
              }
            }, o11));
          }), s10;
        }
        getSize() {
          let {
            chart: t10,
            horiz: e10
          } = this, {
            height: i10,
            width: s10
          } = this.options, {
            legend: o10
          } = t10.options;
          return {
            width: hU(hX(s10) ? hZ(s10, t10.chartWidth) : void 0, o10?.symbolWidth, e10 ? h$.defaultLegendLength : 12),
            height: hU(hX(i10) ? hZ(i10, t10.chartHeight) : void 0, o10?.symbolHeight, e10 ? 12 : h$.defaultLegendLength)
          };
        }
      }
      h$.defaultLegendLength = 200, h$.keepProps = ["legendItem"], hG(h$.prototype, hR), Array.prototype.push.apply(sY.keepProps, h$.keepProps), A.ColorAxis = A.ColorAxis || h$, A.ColorAxis.compose(A.Chart, A.Fx, A.Legend, A.Series);
      let h_ = {
        lang: {
          zoomIn: "Zoom in",
          zoomOut: "Zoom out"
        },
        mapNavigation: {
          buttonOptions: {
            alignTo: "plotBox",
            align: "left",
            verticalAlign: "top",
            x: 0,
            width: 18,
            height: 18,
            padding: 5,
            style: {
              color: "#666666",
              fontSize: "1em",
              fontWeight: "bold"
            },
            theme: {
              fill: "#ffffff",
              stroke: "#e6e6e6",
              "stroke-width": 1,
              "text-align": "center"
            }
          },
          buttons: {
            zoomIn: {
              onclick: function() {
                this.mapZoom(0.5);
              },
              text: "+",
              y: 0
            },
            zoomOut: {
              onclick: function() {
                this.mapZoom(2);
              },
              text: "-",
              y: 28
            }
          },
          mouseWheelSensitivity: 1.1
        }
      }, {
        defined: hq,
        extend: hK,
        pick: hJ,
        wrap: hQ
      } = J;
      !function(t10) {
        let e10, i10 = 0;
        function s10(t11) {
          let e11 = this.chart;
          t11 = this.normalize(t11), e11.options.mapNavigation.enableDoubleClickZoomTo ? e11.pointer.inClass(t11.target, "highcharts-tracker") && e11.hoverPoint && e11.hoverPoint.zoomTo() : e11.isInsidePlot(t11.chartX - e11.plotLeft, t11.chartY - e11.plotTop) && e11.mapZoom(0.5, void 0, void 0, t11.chartX, t11.chartY);
        }
        function o10(t11) {
          let s11 = this.chart, o11 = hq((t11 = this.normalize(t11)).wheelDelta) && -t11.wheelDelta / 120 || t11.deltaY || t11.detail;
          Math.abs(o11) >= 1 && (i10 += Math.abs(o11), e10 && clearTimeout(e10), e10 = setTimeout(() => {
            i10 = 0;
          }, 50)), i10 < 10 && s11.isInsidePlot(t11.chartX - s11.plotLeft, t11.chartY - s11.plotTop) && s11.mapView && s11.mapView.zoomBy(-((s11.options.mapNavigation.mouseWheelSensitivity - 1) * o11), void 0, [t11.chartX, t11.chartY], !(1 > Math.abs(o11)) && void 0);
        }
        function r10(t11, e11, i11) {
          let s11 = this.chart;
          if (e11 = t11.call(this, e11, i11), s11 && s11.mapView) {
            let t12 = s11.mapView.pixelsToLonLat({
              x: e11.chartX - s11.plotLeft,
              y: e11.chartY - s11.plotTop
            });
            t12 && hK(e11, t12);
          }
          return e11;
        }
        function a10(t11) {
          let e11 = this.chart.options.mapNavigation;
          e11 && hJ(e11.enableTouchZoom, e11.enabled) && (this.chart.zooming.pinchType = "xy"), t11.apply(this, [].slice.call(arguments, 1));
        }
        t10.compose = function(t11) {
          let e11 = t11.prototype;
          e11.onContainerDblClick || (hK(e11, {
            onContainerDblClick: s10,
            onContainerMouseWheel: o10
          }), hQ(e11, "normalize", r10), hQ(e11, "zoomOption", a10));
        };
      }(w || (w = {}));
      let h0 = w;
      function h1(t10, e10, s10, o10, r10) {
        if (r10) {
          let t11 = r10?.r || 0;
          r10.brBoxY = e10 - t11, r10.brBoxHeight = o10 + t11;
        }
        return i.roundedRect(t10, e10, s10, o10, r10);
      }
      function h2(t10, e10, s10, o10, r10) {
        if (r10) {
          let t11 = r10?.r || 0;
          r10.brBoxHeight = o10 + t11;
        }
        return i.roundedRect(t10, e10, s10, o10, r10);
      }
      let h3 = {
        compose: function(t10) {
          (i = t10.prototype.symbols).bottombutton = h1, i.topbutton = h2;
        }
      }, {
        setOptions: h6
      } = tw, {
        composed: h5
      } = A, {
        addEvent: h9,
        extend: h8,
        merge: h4,
        objectEach: h7,
        pick: dt,
        pushUnique: de
      } = J;
      function di(t10) {
        t10 && (t10.preventDefault?.(), t10.stopPropagation?.(), t10.cancelBubble = true);
      }
      class ds {
        static compose(t10, e10, i10) {
          h0.compose(e10), h3.compose(i10), de(h5, "Map.Navigation") && (h9(t10, "beforeRender", function() {
            this.mapNavigation = new ds(this), this.mapNavigation.update();
          }), h6(h_));
        }
        constructor(t10) {
          this.chart = t10, this.navButtons = [];
        }
        update(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.navButtons, o10 = function(t11) {
            this.handler.call(i10, t11), di(t11);
          }, r10 = i10.options.mapNavigation;
          for (t10 && (r10 = i10.options.mapNavigation = h4(i10.options.mapNavigation, t10)); s10.length; ) s10.pop()?.destroy();
          if (!i10.renderer.forExport && dt(r10.enableButtons, r10.enabled)) {
            e10.navButtonsGroup || (e10.navButtonsGroup = i10.renderer.g().attr({
              zIndex: 7
            }).add()), h7(r10.buttons, (t12, a10) => {
              let n10 = {
                padding: (t12 = h4(r10.buttonOptions, t12)).padding
              };
              !i10.styledMode && t12.theme && (h8(n10, t12.theme), n10.style = h4(t12.theme.style, t12.style));
              let {
                text: l10,
                width: h10 = 0,
                height: d10 = 0,
                padding: c10 = 0
              } = t12, p4 = i10.renderer.button("+" !== l10 && "-" !== l10 && l10 || "", 0, 0, o10, n10, void 0, void 0, void 0, "zoomIn" === a10 ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + {
                zoomIn: "zoom-in",
                zoomOut: "zoom-out"
              }[a10]).attr({
                width: h10,
                height: d10,
                title: i10.options.lang[a10],
                zIndex: 5
              }).add(e10.navButtonsGroup);
              if ("+" === l10 || "-" === l10) {
                let e11 = h10 + 1, s11 = [["M", c10 + 3, c10 + d10 / 2], ["L", c10 + e11 - 3, c10 + d10 / 2]];
                "+" === l10 && s11.push(["M", c10 + e11 / 2, c10 + 3], ["L", c10 + e11 / 2, c10 + d10 - 3]), i10.renderer.path(s11).addClass("highcharts-button-symbol").attr(i10.styledMode ? {} : {
                  stroke: t12.style?.color,
                  "stroke-width": 3,
                  "stroke-linecap": "round"
                }).add(p4);
              }
              if (p4.handler = t12.onclick, h9(p4.element, "dblclick", di), s10.push(p4), h8(t12, {
                width: p4.width,
                height: 2 * (p4.height || 0)
              }), i10.hasLoaded) p4.align(t12, false, t12.alignTo);
              else {
                let e11 = h9(i10, "load", () => {
                  p4.element && p4.align(t12, false, t12.alignTo), e11();
                });
              }
            });
            let t11 = (t12, e11) => !(e11.x >= t12.x + t12.width || e11.x + e11.width <= t12.x || e11.y >= t12.y + t12.height || e11.y + e11.height <= t12.y);
            i10.hasLoaded || h9(i10, "render", function() {
              let s11 = i10.exportingGroup?.getBBox();
              if (s11) {
                let i11 = e10.navButtonsGroup.getBBox();
                if (t11(s11, i11)) {
                  let t12 = -i11.y - i11.height + s11.y - 5, o11 = s11.y + s11.height - i11.y + 5, a10 = r10.buttonOptions && r10.buttonOptions.verticalAlign;
                  e10.navButtonsGroup.attr({
                    translateY: "bottom" === a10 ? t12 : o11
                  });
                }
              }
            });
          }
          this.updateEvents(r10);
        }
        updateEvents(t10) {
          let e10 = this.chart;
          dt(t10.enableDoubleClickZoom, t10.enabled) || t10.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || h9(e10.container, "dblclick", function(t11) {
            e10.pointer.onContainerDblClick(t11);
          }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick()), dt(t10.enableMouseWheelZoom, t10.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || h9(e10.container, "wheel", function(t11) {
            if (!e10.pointer.inClass(t11.target, "highcharts-no-mousewheel")) {
              let i10 = e10.mapView?.zoom;
              e10.pointer.onContainerMouseWheel(t11), i10 !== e10.mapView?.zoom && di(t11);
            }
            return false;
          }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
        }
      }
      let {
        column: {
          prototype: dr
        }
      } = rx.seriesTypes, {
        addEvent: da,
        defined: dn
      } = J;
      !function(t10) {
        function e10(t11) {
          let e11 = this.series, i10 = e11.chart.renderer;
          this.moveToTopOnHover && this.graphic && (e11.stateMarkerGraphic || (e11.stateMarkerGraphic = new eq(i10, "use").css({
            pointerEvents: "none"
          }).add(this.graphic.parentGroup)), t11?.state === "hover" ? (this.graphic.attr({
            id: this.id
          }), e11.stateMarkerGraphic.attr({
            href: `${i10.url}#${this.id}`,
            visibility: "visible"
          })) : e11.stateMarkerGraphic.attr({
            href: ""
          }));
        }
        t10.pointMembers = {
          dataLabelOnNull: true,
          moveToTopOnHover: true,
          isValid: function() {
            return null !== this.value && this.value !== 1 / 0 && this.value !== -1 / 0 && (void 0 === this.value || !isNaN(this.value));
          }
        }, t10.seriesMembers = {
          colorKey: "value",
          axisTypes: ["xAxis", "yAxis", "colorAxis"],
          parallelArrays: ["x", "y", "value"],
          pointArrayMap: ["value"],
          trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
          colorAttribs: function(t11) {
            let e11 = {};
            return dn(t11.color) && (!t11.state || "normal" === t11.state) && (e11[this.colorProp || "fill"] = t11.color), e11;
          },
          pointAttribs: dr.pointAttribs
        }, t10.compose = function(t11) {
          return da(t11.prototype.pointClass, "afterSetState", e10), t11;
        };
      }(k || (k = {}));
      let dl = k, {
        getOptions: dh
      } = tw, {
        isNumber: dd,
        merge: dc,
        pick: dp
      } = J;
      class du extends aq {
        init(t10, e10) {
          let i10 = dh().credits, s10 = dc({
            chart: {
              panning: {
                enabled: true,
                type: "xy"
              },
              type: "map"
            },
            credits: {
              mapText: dp(i10.mapText, ' © <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'),
              mapTextFull: dp(i10.mapTextFull, "{geojson.copyright}")
            },
            mapView: {},
            tooltip: {
              followTouchMove: false
            }
          }, t10);
          super.init(s10, e10);
        }
        mapZoom(t10, e10, i10, s10, o10) {
          this.mapView && (dd(t10) && (t10 = Math.log(t10) / Math.log(0.5)), this.mapView.zoomBy(t10, dd(e10) && dd(i10) ? this.mapView.projection.inverse([e10, i10]) : void 0, dd(s10) && dd(o10) ? [s10, o10] : void 0));
        }
        update(t10) {
          t10.chart && "map" in t10.chart && this.mapView?.recommendMapView(this, [t10.chart.map, ...(this.options.series || []).map((t11) => t11.mapData)], true), super.update.apply(this, arguments);
        }
      }
      !function(t10) {
        t10.maps = {}, t10.mapChart = function(e10, i10, s10) {
          return new t10(e10, i10, s10);
        }, t10.splitPath = function(t11) {
          let e10;
          return e10 = "string" == typeof t11 ? (t11 = t11.replace(/([A-Z])/gi, " $1 ").replace(/^\s*/, "").replace(/\s*$/, "")).split(/[ ,;]+/).map((t12) => /[A-Z]/i.test(t12) ? t12 : parseFloat(t12)) : t11, iH.prototype.pathToSegments(e10);
        };
      }(du || (du = {}));
      let dg = du, dm = {
        boundsFromPath: function(t10) {
          let e10 = -Number.MAX_VALUE, i10 = Number.MAX_VALUE, s10 = -Number.MAX_VALUE, o10 = Number.MAX_VALUE, r10;
          if (t10.forEach((t11) => {
            let a10 = t11[t11.length - 2], n10 = t11[t11.length - 1];
            "number" == typeof a10 && "number" == typeof n10 && (i10 = Math.min(i10, a10), e10 = Math.max(e10, a10), o10 = Math.min(o10, n10), s10 = Math.max(s10, n10), r10 = true);
          }), r10) return {
            x1: i10,
            y1: o10,
            x2: e10,
            y2: s10
          };
        }
      }, {
        boundsFromPath: df
      } = dm, dx = rx.seriesTypes.scatter.prototype.pointClass, {
        extend: dy,
        isNumber: db,
        pick: dv
      } = J;
      class dM extends dx {
        static getProjectedPath(t10, e10) {
          return t10.projectedPath || (e10 && t10.geometry ? (e10.hasCoordinates = true, t10.projectedPath = e10.path(t10.geometry)) : t10.projectedPath = t10.path), t10.projectedPath || [];
        }
        applyOptions(t10, e10) {
          let i10 = this.series, s10 = super.applyOptions(t10, e10), o10 = i10.joinBy;
          if (i10.mapData && i10.mapMap) {
            let t11 = o10[1], e11 = super.getNestedProperty(t11), r10 = void 0 !== e11 && i10.mapMap[e11];
            r10 ? dy(s10, __spreadProps(__spreadValues({}, r10), {
              name: s10.name ?? r10.name
            })) : -1 !== i10.pointArrayMap.indexOf("value") && (s10.value = s10.value || null);
          }
          return s10;
        }
        getProjectedBounds(t10) {
          let e10 = df(dM.getProjectedPath(this, t10)), i10 = this.properties, s10 = this.series.chart.mapView;
          if (e10) {
            let o10 = i10 && i10["hc-middle-lon"], r10 = i10 && i10["hc-middle-lat"];
            if (s10 && db(o10) && db(r10)) {
              let i11 = t10.forward([o10, r10]);
              e10.midX = i11[0], e10.midY = i11[1];
            } else {
              let t11 = i10 && i10["hc-middle-x"], s11 = i10 && i10["hc-middle-y"];
              e10.midX = e10.x1 + (e10.x2 - e10.x1) * dv(this.middleX, db(t11) ? t11 : 0.5);
              let o11 = dv(this.middleY, db(s11) ? s11 : 0.5);
              this.geometry || (o11 = 1 - o11), e10.midY = e10.y2 - (e10.y2 - e10.y1) * o11;
            }
            return e10;
          }
        }
        onMouseOver(t10) {
          J.clearTimeout(this.colorInterval), !this.isNull && this.visible || this.series.options.nullInteraction ? super.onMouseOver.call(this, t10) : this.series.onMouseOut();
        }
        setVisible(t10) {
          this.visible = this.options.visible = !!t10, this.dataLabel && this.dataLabel[t10 ? "show" : "hide"](), this.graphic && this.graphic.attr(this.series.pointAttribs(this));
        }
        zoomTo(t10) {
          let e10 = this.series.chart, i10 = e10.mapView, s10 = this.bounds;
          if (i10 && s10) {
            let o10 = db(this.insetIndex) && i10.insets[this.insetIndex];
            if (o10) {
              let t11 = o10.projectedUnitsToPixels({
                x: s10.x1,
                y: s10.y1
              }), e11 = o10.projectedUnitsToPixels({
                x: s10.x2,
                y: s10.y2
              }), r10 = i10.pixelsToProjectedUnits({
                x: t11.x,
                y: t11.y
              }), a10 = i10.pixelsToProjectedUnits({
                x: e11.x,
                y: e11.y
              });
              s10 = {
                x1: r10.x,
                y1: r10.y,
                x2: a10.x,
                y2: a10.y
              };
            }
            i10.fitToBounds(s10, void 0, false), this.series.isDirty = true, e10.redraw(t10);
          }
        }
      }
      dy(dM.prototype, {
        dataLabelOnNull: dl.pointMembers.dataLabelOnNull,
        moveToTopOnHover: dl.pointMembers.moveToTopOnHover,
        isValid: dl.pointMembers.isValid
      });
      let {
        isNumber: dw
      } = J, dk = {
        center: [0, 0],
        fitToGeometry: void 0,
        maxZoom: void 0,
        padding: 0,
        projection: {
          name: void 0,
          parallels: void 0,
          rotation: void 0
        },
        zoom: void 0,
        insetOptions: {
          borderColor: "#cccccc",
          borderWidth: 1,
          padding: "10%",
          relativeTo: "mapBoundingBox",
          units: "percent"
        }
      }, {
        win: dS
      } = A, {
        format: dT
      } = ed, {
        error: dC,
        extend: dA,
        merge: dP,
        wrap: dL
      } = J;
      !function(t10) {
        function e10(t11) {
          return this.mapView && this.mapView.lonLatToProjectedUnits(t11);
        }
        function i10(t11) {
          return this.mapView && this.mapView.projectedUnitsToLonLat(t11);
        }
        function s10(t11, e11) {
          let i11 = this.options.chart.proj4 || dS.proj4;
          if (!i11) {
            dC(21, false, this);
            return;
          }
          let {
            jsonmarginX: s11 = 0,
            jsonmarginY: o11 = 0,
            jsonres: r11 = 1,
            scale: a11 = 1,
            xoffset: n10 = 0,
            xpan: l10 = 0,
            yoffset: h10 = 0,
            ypan: d10 = 0
          } = e11, c10 = i11(e11.crs, [t11.lon, t11.lat]), p4 = e11.cosAngle || e11.rotation && Math.cos(e11.rotation), u2 = e11.sinAngle || e11.rotation && Math.sin(e11.rotation), g2 = e11.rotation ? [c10[0] * p4 + c10[1] * u2, -c10[0] * u2 + c10[1] * p4] : c10;
          return {
            x: ((g2[0] - n10) * a11 + l10) * r11 + s11,
            y: -(((h10 - g2[1]) * a11 + d10) * r11 - o11)
          };
        }
        function o10(t11, e11) {
          let i11 = this.options.chart.proj4 || dS.proj4;
          if (!i11) {
            dC(21, false, this);
            return;
          }
          if (null === t11.y) return;
          let {
            jsonmarginX: s11 = 0,
            jsonmarginY: o11 = 0,
            jsonres: r11 = 1,
            scale: a11 = 1,
            xoffset: n10 = 0,
            xpan: l10 = 0,
            yoffset: h10 = 0,
            ypan: d10 = 0
          } = e11, c10 = {
            x: ((t11.x - s11) / r11 - l10) / a11 + n10,
            y: ((t11.y - o11) / r11 + d10) / a11 + h10
          }, p4 = e11.cosAngle || e11.rotation && Math.cos(e11.rotation), u2 = e11.sinAngle || e11.rotation && Math.sin(e11.rotation), g2 = i11(e11.crs, "WGS84", e11.rotation ? {
            x: c10.x * p4 + -(c10.y * u2),
            y: c10.x * u2 + c10.y * p4
          } : c10);
          return {
            lat: g2.y,
            lon: g2.x
          };
        }
        function r10(t11, e11) {
          e11 || (e11 = Object.keys(t11.objects)[0]);
          let i11 = t11.objects[e11];
          if (i11["hc-decoded-geojson"] && i11["hc-decoded-geojson"].title === t11.title) return i11["hc-decoded-geojson"];
          let s11 = t11.arcs;
          if (t11.transform) {
            let e12, i12, o12;
            let r12 = t11.arcs, {
              scale: a12,
              translate: n11
            } = t11.transform;
            s11 = [];
            for (let t12 = 0, l10 = r12.length; t12 < l10; ++t12) {
              let l11 = r12[t12];
              s11.push(e12 = []), i12 = 0, o12 = 0;
              for (let t13 = 0, s12 = l11.length; t13 < s12; ++t13) e12.push([(i12 += l11[t13][0]) * a12[0] + n11[0], (o12 += l11[t13][1]) * a12[1] + n11[1]]);
            }
          }
          let o11 = (t12) => "number" == typeof t12[0] ? t12.reduce((t13, e12, i12) => {
            let o12 = e12 < 0 ? s11[~e12] : s11[e12];
            return e12 < 0 ? (o12 = o12.slice(0, 0 === i12 ? o12.length : o12.length - 1)).reverse() : i12 && (o12 = o12.slice(1)), t13.concat(o12);
          }, []) : t12.map(o11), r11 = i11.geometries, a11 = [];
          for (let t12 = 0, e12 = r11.length; t12 < e12; ++t12) a11.push({
            type: "Feature",
            properties: r11[t12].properties,
            geometry: {
              type: r11[t12].type,
              coordinates: r11[t12].coordinates || o11(r11[t12].arcs)
            }
          });
          let n10 = {
            type: "FeatureCollection",
            copyright: t11.copyright,
            copyrightShort: t11.copyrightShort,
            copyrightUrl: t11.copyrightUrl,
            features: a11,
            "hc-recommended-mapview": i11["hc-recommended-mapview"],
            bbox: t11.bbox,
            title: t11.title
          };
          return i11["hc-decoded-geojson"] = n10, n10;
        }
        function a10(t11, e11) {
          e11 = dP(true, this.options.credits, e11), t11.call(this, e11), this.credits && this.mapCreditsFull && this.credits.attr({
            title: this.mapCreditsFull
          });
        }
        t10.compose = function(t11) {
          let r11 = t11.prototype;
          r11.transformFromLatLon || (r11.fromLatLonToPoint = e10, r11.fromPointToLatLon = i10, r11.transformFromLatLon = s10, r11.transformToLatLon = o10, dL(r11, "addCredits", a10));
        }, t10.geojson = function(t11, e11 = "map", i11) {
          let s11 = [], o11 = "Topology" === t11.type ? r10(t11) : t11, a11 = o11.features;
          for (let t12 = 0, i12 = a11.length; t12 < i12; ++t12) {
            let i13;
            let o12 = a11[t12], r11 = o12.geometry || {}, n10 = r11.type, l10 = r11.coordinates, h10 = o12.properties;
            if (("map" === e11 || "mapbubble" === e11) && ("Polygon" === n10 || "MultiPolygon" === n10) ? l10.length && (i13 = {
              geometry: {
                coordinates: l10,
                type: n10
              }
            }) : "mapline" === e11 && ("LineString" === n10 || "MultiLineString" === n10) ? l10.length && (i13 = {
              geometry: {
                coordinates: l10,
                type: n10
              }
            }) : "mappoint" === e11 && "Point" === n10 && l10.length && (i13 = {
              geometry: {
                coordinates: l10,
                type: n10
              }
            }), i13) {
              let t13 = h10 && (h10.name || h10.NAME), e12 = h10 && h10.lon, o13 = h10 && h10.lat;
              s11.push(dA(i13, {
                lat: "number" == typeof o13 ? o13 : void 0,
                lon: "number" == typeof e12 ? e12 : void 0,
                name: "string" == typeof t13 ? t13 : void 0,
                properties: h10
              }));
            }
          }
          return i11 && o11.copyrightShort && (i11.chart.mapCredits = dT(i11.chart.options.credits?.mapText, {
            geojson: o11
          }), i11.chart.mapCreditsFull = dT(i11.chart.options.credits?.mapTextFull, {
            geojson: o11
          })), s11;
        }, t10.topo2geo = r10;
      }(S || (S = {}));
      let dO = S;
      function dE(t10, e10, i10 = true) {
        let s10 = e10[e10.length - 1], o10, r10, a10, n10 = t10;
        for (let t11 = 0; t11 < e10.length; t11++) {
          let l10 = n10;
          o10 = e10[t11], n10 = [], r10 = i10 ? l10[l10.length - 1] : l10[0];
          for (let t12 = 0; t12 < l10.length; t12++) dI(s10, o10, a10 = l10[t12]) ? (dI(s10, o10, r10) || n10.push(dD(s10, o10, r10, a10)), n10.push(a10)) : dI(s10, o10, r10) && n10.push(dD(s10, o10, r10, a10)), r10 = a10;
          s10 = o10;
        }
        return n10;
      }
      function dI(t10, e10, i10) {
        return (e10[0] - t10[0]) * (i10[1] - t10[1]) > (e10[1] - t10[1]) * (i10[0] - t10[0]);
      }
      function dD(t10, e10, i10, s10) {
        let o10 = [t10[0] - e10[0], t10[1] - e10[1]], r10 = [i10[0] - s10[0], i10[1] - s10[1]], a10 = t10[0] * e10[1] - t10[1] * e10[0], n10 = i10[0] * s10[1] - i10[1] * s10[0], l10 = 1 / (o10[0] * r10[1] - o10[1] * r10[0]), h10 = [(a10 * r10[0] - n10 * o10[0]) * l10, (a10 * r10[1] - n10 * o10[1]) * l10];
        return h10.isIntersection = true, h10;
      }
      let dB = Math.sign || ((t10) => 0 === t10 ? 0 : t10 > 0 ? 1 : -1), dz = Math.PI / 180, dN = Math.PI / 2, dR = (t10) => Math.tan((dN + t10) / 2), dW = class {
        constructor(t10) {
          let e10 = (t10.parallels || []).map((t11) => t11 * dz), i10 = e10[0] || 0, s10 = e10[1] ?? i10, o10 = Math.cos(i10);
          "object" == typeof t10.projectedBounds && (this.projectedBounds = t10.projectedBounds);
          let r10 = i10 === s10 ? Math.sin(i10) : Math.log(o10 / Math.cos(s10)) / Math.log(dR(s10) / dR(i10));
          1e-10 > Math.abs(r10) && (r10 = 1e-10 * (dB(r10) || 1)), this.n = r10, this.c = o10 * Math.pow(dR(i10), r10) / r10;
        }
        forward(t10) {
          let {
            c: e10,
            n: i10,
            projectedBounds: s10
          } = this, o10 = t10[0] * dz, r10 = t10[1] * dz;
          e10 > 0 ? r10 < -dN + 1e-6 && (r10 = -dN + 1e-6) : r10 > dN - 1e-6 && (r10 = dN - 1e-6);
          let a10 = e10 / Math.pow(dR(r10), i10), n10 = a10 * Math.sin(i10 * o10) * 63.78137, l10 = (e10 - a10 * Math.cos(i10 * o10)) * 63.78137, h10 = [n10, l10];
          return s10 && (n10 < s10.x1 || n10 > s10.x2 || l10 < s10.y1 || l10 > s10.y2) && (h10.outside = true), h10;
        }
        inverse(t10) {
          let {
            c: e10,
            n: i10
          } = this, s10 = t10[0] / 63.78137, o10 = e10 - t10[1] / 63.78137, r10 = dB(i10) * Math.sqrt(s10 * s10 + o10 * o10), a10 = Math.atan2(s10, Math.abs(o10)) * dB(o10);
          return o10 * i10 < 0 && (a10 -= Math.PI * dB(s10) * dB(o10)), [a10 / i10 / dz, (2 * Math.atan(Math.pow(e10 / r10, 1 / i10)) - dN) / dz];
        }
      }, dj = Math.sqrt(3) / 2, dX = class {
        constructor() {
          this.bounds = {
            x1: -200.37508342789243,
            x2: 200.37508342789243,
            y1: -97.52595454902263,
            y2: 97.52595454902263
          };
        }
        forward(t10) {
          let e10 = Math.PI / 180, i10 = Math.asin(dj * Math.sin(t10[1] * e10)), s10 = i10 * i10, o10 = s10 * s10 * s10;
          return [t10[0] * e10 * Math.cos(i10) * 74.03120656864502 / (dj * (1.340264 + -0.24331799999999998 * s10 + o10 * (0.0062510000000000005 + 0.034164 * s10))), 74.03120656864502 * i10 * (1.340264 + -0.081106 * s10 + o10 * (893e-6 + 3796e-6 * s10))];
        }
        inverse(t10) {
          let e10 = t10[0] / 74.03120656864502, i10 = t10[1] / 74.03120656864502, s10 = 180 / Math.PI, o10 = i10, r10, a10, n10, l10;
          for (let t11 = 0; t11 < 12 && (a10 = (r10 = o10 * o10) * r10 * r10, n10 = o10 * (1.340264 + -0.081106 * r10 + a10 * (893e-6 + 3796e-6 * r10)) - i10, o10 -= l10 = n10 / (1.340264 + -0.24331799999999998 * r10 + a10 * (0.0062510000000000005 + 0.034164 * r10)), !(1e-9 > Math.abs(l10))); ++t11) ;
          a10 = (r10 = o10 * o10) * r10 * r10;
          let h10 = s10 * dj * e10 * (1.340264 + -0.24331799999999998 * r10 + a10 * (0.0062510000000000005 + 0.034164 * r10)) / Math.cos(o10), d10 = s10 * Math.asin(Math.sin(o10) / dj);
          return Math.abs(h10) > 180 ? [NaN, NaN] : [h10, d10];
        }
      }, dG = Math.PI / 4, dF = Math.PI / 180, dH = class {
        constructor() {
          this.bounds = {
            x1: -200.37508342789243,
            x2: 200.37508342789243,
            y1: -146.91480769173063,
            y2: 146.91480769173063
          };
        }
        forward(t10) {
          return [t10[0] * dF * 63.78137, 79.7267125 * Math.log(Math.tan(dG + 0.4 * t10[1] * dF))];
        }
        inverse(t10) {
          return [t10[0] / 63.78137 / dF, 2.5 * (Math.atan(Math.exp(0.8 * (t10[1] / 63.78137))) - dG) / dF];
        }
      }, dY = Math.PI / 180, dV = class {
        constructor() {
          this.antimeridianCutting = false, this.bounds = {
            x1: -63.78460826781007,
            x2: 63.78460826781007,
            y1: -63.78460826781007,
            y2: 63.78460826781007
          };
        }
        forward(t10) {
          let e10 = t10[0], i10 = t10[1] * dY, s10 = [Math.cos(i10) * Math.sin(e10 * dY) * 63.78460826781007, 63.78460826781007 * Math.sin(i10)];
          return (e10 < -90 || e10 > 90) && (s10.outside = true), s10;
        }
        inverse(t10) {
          let e10 = t10[0] / 63.78460826781007, i10 = t10[1] / 63.78460826781007, s10 = Math.sqrt(e10 * e10 + i10 * i10), o10 = Math.asin(s10), r10 = Math.sin(o10);
          return [Math.atan2(e10 * r10, s10 * Math.cos(o10)) / dY, Math.asin(s10 && i10 * r10 / s10) / dY];
        }
      }, dU = Math.PI / 180, dZ = class {
        constructor() {
          this.bounds = {
            x1: -200.37508342789243,
            x2: 200.37508342789243,
            y1: -200.3750834278071,
            y2: 200.3750834278071
          }, this.maxLatitude = 85.0511287798;
        }
        forward(t10) {
          let e10 = Math.sin(t10[1] * dU), i10 = [63.78137 * t10[0] * dU, 63.78137 * Math.log((1 + e10) / (1 - e10)) / 2];
          return Math.abs(t10[1]) > this.maxLatitude && (i10.outside = true), i10;
        }
        inverse(t10) {
          return [t10[0] / (63.78137 * dU), (2 * Math.atan(Math.exp(t10[1] / 63.78137)) - Math.PI / 2) / dU];
        }
      }, {
        clipLineString: d$,
        clipPolygon: d_
      } = {
        clipLineString: function(t10, e10) {
          let i10 = [], s10 = dE(t10, e10, false);
          for (let t11 = 1; t11 < s10.length; t11++) s10[t11].isIntersection && s10[t11 - 1].isIntersection && (i10.push(s10.splice(0, t11)), t11 = 0), t11 === s10.length - 1 && i10.push(s10);
          return i10;
        },
        clipPolygon: dE
      }, {
        clamp: dq,
        erase: dK
      } = J, dJ = 2 * Math.PI / 360, dQ = (t10) => (t10 < -180 && (t10 += 360), t10 > 180 && (t10 -= 360), t10), d0 = (t10) => (1 - Math.cos(t10)) / 2, d1 = (t10, e10) => {
        let i10 = Math.cos, s10 = t10[1] * dJ, o10 = t10[0] * dJ, r10 = e10[1] * dJ, a10 = e10[0] * dJ;
        return d0(r10 - s10) + i10(s10) * i10(r10) * d0(a10 - o10);
      };
      class d2 {
        static add(t10, e10) {
          d2.registry[t10] = e10;
        }
        static distance(t10, e10) {
          let {
            atan2: i10,
            sqrt: s10
          } = Math, o10 = d1(t10, e10);
          return 6371e3 * (2 * i10(s10(o10), s10(1 - o10)));
        }
        static geodesic(t10, e10, i10, s10 = 5e5) {
          let {
            atan2: o10,
            cos: r10,
            sin: a10,
            sqrt: n10
          } = Math, l10 = d2.distance, h10 = t10[1] * dJ, d10 = t10[0] * dJ, c10 = e10[1] * dJ, p4 = e10[0] * dJ, u2 = r10(h10) * r10(d10), g2 = r10(c10) * r10(p4), m2 = r10(h10) * a10(d10), f2 = r10(c10) * a10(p4), x2 = a10(h10), y2 = a10(c10), b2 = l10(t10, e10), v2 = b2 / 6371e3, M2 = a10(v2), w2 = Math.round(b2 / s10), k2 = [];
          if (i10 && k2.push(t10), w2 > 1) {
            let t11 = 1 / w2;
            for (let e11 = t11; e11 < 0.999; e11 += t11) {
              let t12 = a10((1 - e11) * v2) / M2, i11 = a10(e11 * v2) / M2, s11 = t12 * u2 + i11 * g2, r11 = t12 * m2 + i11 * f2, l11 = o10(t12 * x2 + i11 * y2, n10(s11 * s11 + r11 * r11)), h11 = o10(r11, s11);
              k2.push([h11 / dJ, l11 / dJ]);
            }
          }
          return i10 && k2.push(e10), k2;
        }
        static insertGeodesics(t10) {
          let e10 = t10.length - 1;
          for (; e10--; ) if (Math.max(Math.abs(t10[e10][0] - t10[e10 + 1][0]), Math.abs(t10[e10][1] - t10[e10 + 1][1])) > 10) {
            let i10 = d2.geodesic(t10[e10], t10[e10 + 1]);
            i10.length && t10.splice(e10 + 1, 0, ...i10);
          }
        }
        static toString(t10) {
          let {
            name: e10,
            rotation: i10
          } = t10 || {};
          return [e10, i10 && i10.join(",")].join(";");
        }
        constructor(t10 = {}) {
          this.hasCoordinates = false, this.hasGeoProjection = false, this.maxLatitude = 90, this.options = t10;
          let {
            name: e10,
            projectedBounds: i10,
            rotation: s10
          } = t10;
          this.rotator = s10 ? this.getRotator(s10) : void 0;
          let o10 = e10 ? d2.registry[e10] : void 0;
          o10 && (this.def = new o10(t10));
          let {
            def: r10,
            rotator: a10
          } = this;
          r10 && (this.maxLatitude = r10.maxLatitude || 90, this.hasGeoProjection = true), a10 && r10 ? (this.forward = (t11) => r10.forward(a10.forward(t11)), this.inverse = (t11) => a10.inverse(r10.inverse(t11))) : r10 ? (this.forward = (t11) => r10.forward(t11), this.inverse = (t11) => r10.inverse(t11)) : a10 && (this.forward = a10.forward, this.inverse = a10.inverse), this.bounds = "world" === i10 ? r10 && r10.bounds : i10;
        }
        lineIntersectsBounds(t10) {
          let {
            x1: e10,
            x2: i10,
            y1: s10,
            y2: o10
          } = this.bounds || {}, r10 = (t11, e11, i11) => {
            let [s11, o11] = t11, r11 = e11 ? 0 : 1;
            if ("number" == typeof i11 && s11[e11] >= i11 != o11[e11] >= i11) {
              let t12 = (i11 - s11[e11]) / (o11[e11] - s11[e11]), a11 = s11[r11] + t12 * (o11[r11] - s11[r11]);
              return e11 ? [a11, i11] : [i11, a11];
            }
          }, a10, n10 = t10[0];
          return (a10 = r10(t10, 0, e10)) ? (n10 = a10, t10[1] = a10) : (a10 = r10(t10, 0, i10)) && (n10 = a10, t10[1] = a10), (a10 = r10(t10, 1, s10)) ? n10 = a10 : (a10 = r10(t10, 1, o10)) && (n10 = a10), n10;
        }
        getRotator(t10) {
          let e10 = t10[0] * dJ, i10 = (t10[1] || 0) * dJ, s10 = (t10[2] || 0) * dJ, o10 = Math.cos(i10), r10 = Math.sin(i10), a10 = Math.cos(s10), n10 = Math.sin(s10);
          if (0 !== e10 || 0 !== i10 || 0 !== s10) return {
            forward: (t11) => {
              let i11 = t11[0] * dJ + e10, s11 = t11[1] * dJ, l10 = Math.cos(s11), h10 = Math.cos(i11) * l10, d10 = Math.sin(i11) * l10, c10 = Math.sin(s11), p4 = c10 * o10 + h10 * r10;
              return [Math.atan2(d10 * a10 - p4 * n10, h10 * o10 - c10 * r10) / dJ, Math.asin(p4 * a10 + d10 * n10) / dJ];
            },
            inverse: (t11) => {
              let i11 = t11[0] * dJ, s11 = t11[1] * dJ, l10 = Math.cos(s11), h10 = Math.cos(i11) * l10, d10 = Math.sin(i11) * l10, c10 = Math.sin(s11), p4 = c10 * a10 - d10 * n10;
              return [(Math.atan2(d10 * a10 + c10 * n10, h10 * o10 + p4 * r10) - e10) / dJ, Math.asin(p4 * o10 - h10 * r10) / dJ];
            }
          };
        }
        forward(t10) {
          return t10;
        }
        inverse(t10) {
          return t10;
        }
        cutOnAntimeridian(t10, e10) {
          let i10;
          let s10 = [], o10 = [t10];
          for (let i11 = 0, o11 = t10.length; i11 < o11; ++i11) {
            let o12 = t10[i11], r10 = t10[i11 - 1];
            if (!i11) {
              if (!e10) continue;
              r10 = t10[t10.length - 1];
            }
            let a10 = r10[0], n10 = o12[0];
            if ((a10 < -90 || a10 > 90) && (n10 < -90 || n10 > 90) && a10 > 0 != n10 > 0) {
              let t11 = dq((180 - (a10 + 360) % 360) / ((n10 + 360) % 360 - (a10 + 360) % 360), 0, 1), e11 = r10[1] + t11 * (o12[1] - r10[1]);
              s10.push({
                i: i11,
                lat: e11,
                direction: a10 < 0 ? 1 : -1,
                previousLonLat: r10,
                lonLat: o12
              });
            }
          }
          if (s10.length) {
            if (e10) {
              s10.length % 2 == 1 && (i10 = s10.slice().sort((t11, e12) => Math.abs(e12.lat) - Math.abs(t11.lat))[0], dK(s10, i10));
              let e11 = s10.length - 2;
              for (; e11 >= 0; ) {
                let i11 = s10[e11].i, r10 = dQ(180 + 1e-6 * s10[e11].direction), a10 = dQ(180 - 1e-6 * s10[e11].direction), n10 = t10.splice(i11, s10[e11 + 1].i - i11, ...d2.geodesic([r10, s10[e11].lat], [r10, s10[e11 + 1].lat], true));
                n10.push(...d2.geodesic([a10, s10[e11 + 1].lat], [a10, s10[e11].lat], true)), o10.push(n10), e11 -= 2;
              }
              if (i10) for (let t11 = 0; t11 < o10.length; t11++) {
                let {
                  direction: e12,
                  lat: s11
                } = i10, r10 = o10[t11], a10 = r10.indexOf(i10.lonLat);
                if (a10 > -1) {
                  let t12 = (s11 < 0 ? -1 : 1) * this.maxLatitude, o11 = dQ(180 + 1e-6 * e12), n10 = dQ(180 - 1e-6 * e12), l10 = d2.geodesic([o11, s11], [o11, t12], true);
                  for (let i11 = o11 + 120 * e12; i11 > -180 && i11 < 180; i11 += 120 * e12) l10.push([i11, t12]);
                  l10.push(...d2.geodesic([n10, t12], [n10, i10.lat], true)), r10.splice(a10, 0, ...l10);
                  break;
                }
              }
            } else {
              let e11 = s10.length;
              for (; e11--; ) {
                let i11 = s10[e11].i, r10 = t10.splice(i11, t10.length, [dQ(180 + 1e-6 * s10[e11].direction), s10[e11].lat]);
                r10.unshift([dQ(180 - 1e-6 * s10[e11].direction), s10[e11].lat]), o10.push(r10);
              }
            }
          }
          return o10;
        }
        path(t10) {
          let e10;
          let {
            bounds: i10,
            def: s10,
            rotator: o10
          } = this, r10 = [], a10 = "Polygon" === t10.type || "MultiPolygon" === t10.type, n10 = this.hasGeoProjection, l10 = !s10 || false !== s10.antimeridianCutting, h10 = l10 ? o10 : void 0, d10 = l10 && s10 || this;
          i10 && (e10 = [[i10.x1, i10.y1], [i10.x2, i10.y1], [i10.x2, i10.y2], [i10.x1, i10.y2]]);
          let c10 = (t11) => {
            let s11 = t11.map((t12) => {
              if (l10) {
                h10 && (t12 = h10.forward(t12));
                let e11 = t12[0];
                1e-6 > Math.abs(e11 - 180) && (e11 = e11 < 180 ? 179.999999 : 180.000001), t12 = [e11, t12[1]];
              }
              return t12;
            }), o11 = [s11];
            n10 && (d2.insertGeodesics(s11), l10 && (o11 = this.cutOnAntimeridian(s11, a10))), o11.forEach((t12) => {
              let s12, o12;
              if (t12.length < 2) return;
              let h11 = false, c11 = false, p4 = (t13) => {
                h11 ? r10.push(["L", t13[0], t13[1]]) : (r10.push(["M", t13[0], t13[1]]), h11 = true);
              }, u2 = false, g2 = false, m2 = t12.map((t13) => {
                let e11 = d10.forward(t13);
                return e11.outside ? u2 = true : g2 = true, e11[1] === 1 / 0 ? e11[1] = 1e10 : e11[1] === -1 / 0 && (e11[1] = -1e10), e11;
              });
              if (l10) {
                if (a10 && m2.push(m2[0]), u2) {
                  if (!g2) return;
                  if (e10) {
                    if (a10) m2 = d_(m2, e10);
                    else if (i10) {
                      d$(m2, e10).forEach((t13) => {
                        h11 = false, t13.forEach(p4);
                      });
                      return;
                    }
                  }
                }
                m2.forEach(p4);
              } else for (let e11 = 0; e11 < m2.length; e11++) {
                let i11 = t12[e11], r11 = m2[e11];
                r11.outside ? c11 = true : (a10 && !s12 && (s12 = i11, t12.push(i11), m2.push(r11)), c11 && o12 && (a10 && n10 ? d2.geodesic(o12, i11).forEach((t13) => p4(d10.forward(t13))) : h11 = false), p4(r11), o12 = i11, c11 = false);
              }
            });
          };
          return "LineString" === t10.type ? c10(t10.coordinates) : "MultiLineString" === t10.type ? t10.coordinates.forEach((t11) => c10(t11)) : "Polygon" === t10.type ? (t10.coordinates.forEach((t11) => c10(t11)), r10.length && r10.push(["Z"])) : "MultiPolygon" === t10.type && (t10.coordinates.forEach((t11) => {
            t11.forEach((t12) => c10(t12));
          }), r10.length && r10.push(["Z"])), r10;
        }
      }
      d2.registry = {
        EqualEarth: dX,
        LambertConformalConic: dW,
        Miller: dH,
        Orthographic: dV,
        WebMercator: dZ
      };
      let {
        composed: d3
      } = A, {
        pointInPolygon: d6
      } = l9, {
        topo2geo: d5
      } = dO, {
        boundsFromPath: d9
      } = dm, {
        addEvent: d8,
        clamp: d4,
        crisp: d7,
        fireEvent: ct,
        isArray: ce,
        isNumber: ci,
        isObject: cs,
        isString: co,
        merge: cr,
        pick: ca,
        pushUnique: cn,
        relativeLength: cl
      } = J, ch = {};
      function cd(t10, e10) {
        let {
          width: i10,
          height: s10
        } = e10;
        return Math.log(400.979322 / Math.max((t10.x2 - t10.x1) / (i10 / 256), (t10.y2 - t10.y1) / (s10 / 256))) / Math.log(2);
      }
      function cc(t10) {
        t10.seriesOptions.mapData && this.mapView?.recommendMapView(this, [this.options.chart.map, t10.seriesOptions.mapData], this.options.drilldown?.mapZooming);
      }
      class cp {
        static compose(t10) {
          cn(d3, "MapView") && (ch = t10.maps, d8(t10, "afterInit", function() {
            this.mapView = new cp(this, this.options.mapView);
          }, {
            order: 0
          }), d8(t10, "addSeriesAsDrilldown", cc), d8(t10, "afterDrillUp", cc));
        }
        static compositeBounds(t10) {
          if (t10.length) return t10.slice(1).reduce((t11, e10) => (t11.x1 = Math.min(t11.x1, e10.x1), t11.y1 = Math.min(t11.y1, e10.y1), t11.x2 = Math.max(t11.x2, e10.x2), t11.y2 = Math.max(t11.y2, e10.y2), t11), cr(t10[0]));
        }
        static mergeInsets(t10, e10) {
          let i10 = (t11) => {
            let e11 = {};
            return t11.forEach((t12, i11) => {
              e11[t12 && t12.id || `i${i11}`] = t12;
            }), e11;
          }, s10 = cr(i10(t10), i10(e10));
          return Object.keys(s10).map((t11) => s10[t11]);
        }
        constructor(t10, e10) {
          this.allowTransformAnimation = true, this.eventsToUnbind = [], this.insets = [], this.padding = [0, 0, 0, 0], this.recommendedMapView = {}, this instanceof cu || this.recommendMapView(t10, [t10.options.chart.map, ...(t10.options.series || []).map((t11) => t11.mapData)]), this.userOptions = e10 || {};
          let i10 = cr(dk, this.recommendedMapView, e10), s10 = this.recommendedMapView?.insets, o10 = e10 && e10.insets;
          s10 && o10 && (i10.insets = cp.mergeInsets(s10, o10)), this.chart = t10, this.center = i10.center, this.options = i10, this.projection = new d2(i10.projection), this.playingField = t10.plotBox, this.zoom = i10.zoom || 0, this.minZoom = i10.minZoom, this.createInsets(), this.eventsToUnbind.push(d8(t10, "afterSetChartSize", () => {
            this.playingField = this.getField(), (void 0 === this.minZoom || this.minZoom === this.zoom) && (this.fitToBounds(void 0, void 0, false), !this.chart.hasRendered && ci(this.userOptions.zoom) && (this.zoom = this.userOptions.zoom), this.userOptions.center && cr(true, this.center, this.userOptions.center));
          })), this.setUpEvents();
        }
        createInsets() {
          let t10 = this.options, e10 = t10.insets;
          e10 && e10.forEach((e11) => {
            let i10 = new cu(this, cr(t10.insetOptions, e11));
            this.insets.push(i10);
          });
        }
        fitToBounds(t10, e10, i10 = true, s10) {
          let o10 = t10 || this.getProjectedBounds();
          if (o10) {
            let r10 = ca(e10, t10 ? 0 : this.options.padding), a10 = this.getField(false), n10 = ce(r10) ? r10 : [r10, r10, r10, r10];
            this.padding = [cl(n10[0], a10.height), cl(n10[1], a10.width), cl(n10[2], a10.height), cl(n10[3], a10.width)], this.playingField = this.getField();
            let l10 = cd(o10, this.playingField);
            t10 || (this.minZoom = l10);
            let h10 = this.projection.inverse([(o10.x2 + o10.x1) / 2, (o10.y2 + o10.y1) / 2]);
            this.setView(h10, l10, i10, s10);
          }
        }
        getField(t10 = true) {
          let e10 = t10 ? this.padding : [0, 0, 0, 0];
          return {
            x: e10[3],
            y: e10[0],
            width: this.chart.plotWidth - e10[1] - e10[3],
            height: this.chart.plotHeight - e10[0] - e10[2]
          };
        }
        getGeoMap(t10) {
          if (co(t10)) return ch[t10] && "Topology" === ch[t10].type ? d5(ch[t10]) : ch[t10];
          if (cs(t10, true)) {
            if ("FeatureCollection" === t10.type) return t10;
            if ("Topology" === t10.type) return d5(t10);
          }
        }
        getMapBBox() {
          let t10 = this.getProjectedBounds(), e10 = this.getScale();
          if (t10) {
            let i10 = this.padding, s10 = this.projectedUnitsToPixels({
              x: t10.x1,
              y: t10.y2
            });
            return {
              width: (t10.x2 - t10.x1) * e10 + i10[1] + i10[3],
              height: (t10.y2 - t10.y1) * e10 + i10[0] + i10[2],
              x: s10.x - i10[3],
              y: s10.y - i10[0]
            };
          }
        }
        getProjectedBounds() {
          let t10 = this.projection, e10 = this.chart.series.reduce((t11, e11) => {
            let i11 = e11.getProjectedBounds && e11.getProjectedBounds();
            return i11 && false !== e11.options.affectsMapView && t11.push(i11), t11;
          }, []), i10 = this.options.fitToGeometry;
          if (i10) {
            if (!this.fitToGeometryCache) {
              if ("MultiPoint" === i10.type) {
                let e11 = i10.coordinates.map((e12) => t10.forward(e12)), s10 = e11.map((t11) => t11[0]), o10 = e11.map((t11) => t11[1]);
                this.fitToGeometryCache = {
                  x1: Math.min.apply(0, s10),
                  x2: Math.max.apply(0, s10),
                  y1: Math.min.apply(0, o10),
                  y2: Math.max.apply(0, o10)
                };
              } else this.fitToGeometryCache = d9(t10.path(i10));
            }
            return this.fitToGeometryCache;
          }
          return this.projection.bounds || cp.compositeBounds(e10);
        }
        getScale() {
          return 256 / 400.979322 * Math.pow(2, this.zoom);
        }
        getSVGTransform() {
          let {
            x: t10,
            y: e10,
            width: i10,
            height: s10
          } = this.playingField, o10 = this.projection.forward(this.center), r10 = this.projection.hasCoordinates ? -1 : 1, a10 = this.getScale(), n10 = a10 * r10, l10 = t10 + i10 / 2 - o10[0] * a10, h10 = e10 + s10 / 2 - o10[1] * n10;
          return {
            scaleX: a10,
            scaleY: n10,
            translateX: l10,
            translateY: h10
          };
        }
        lonLatToPixels(t10) {
          let e10 = this.lonLatToProjectedUnits(t10);
          if (e10) return this.projectedUnitsToPixels(e10);
        }
        lonLatToProjectedUnits(t10) {
          let e10 = this.chart, i10 = e10.mapTransforms;
          if (i10) {
            for (let s11 in i10) if (Object.hasOwnProperty.call(i10, s11) && i10[s11].hitZone) {
              let o10 = e10.transformFromLatLon(t10, i10[s11]);
              if (o10 && d6(o10, i10[s11].hitZone.coordinates[0])) return o10;
            }
            return e10.transformFromLatLon(t10, i10.default);
          }
          for (let e11 of this.insets) if (e11.options.geoBounds && d6({
            x: t10.lon,
            y: t10.lat
          }, e11.options.geoBounds.coordinates[0])) {
            let i11 = e11.projection.forward([t10.lon, t10.lat]), s11 = e11.projectedUnitsToPixels({
              x: i11[0],
              y: i11[1]
            });
            return this.pixelsToProjectedUnits(s11);
          }
          let s10 = this.projection.forward([t10.lon, t10.lat]);
          if (!s10.outside) return {
            x: s10[0],
            y: s10[1]
          };
        }
        projectedUnitsToLonLat(t10) {
          let e10 = this.chart, i10 = e10.mapTransforms;
          if (i10) {
            for (let s11 in i10) if (Object.hasOwnProperty.call(i10, s11) && i10[s11].hitZone && d6(t10, i10[s11].hitZone.coordinates[0])) return e10.transformToLatLon(t10, i10[s11]);
            return e10.transformToLatLon(t10, i10.default);
          }
          let s10 = this.projectedUnitsToPixels(t10);
          for (let t11 of this.insets) if (t11.hitZone && d6(s10, t11.hitZone.coordinates[0])) {
            let e11 = t11.pixelsToProjectedUnits(s10), i11 = t11.projection.inverse([e11.x, e11.y]);
            return {
              lon: i11[0],
              lat: i11[1]
            };
          }
          let o10 = this.projection.inverse([t10.x, t10.y]);
          return {
            lon: o10[0],
            lat: o10[1]
          };
        }
        recommendMapView(t10, e10, i10 = false) {
          this.recommendedMapView = {};
          let s10 = e10.map((t11) => this.getGeoMap(t11)), o10 = [];
          s10.forEach((t11) => {
            if (t11 && (Object.keys(this.recommendedMapView).length || (this.recommendedMapView = t11["hc-recommended-mapview"] || {}), t11.bbox)) {
              let [e11, i11, s11, r11] = t11.bbox;
              o10.push({
                x1: e11,
                y1: i11,
                x2: s11,
                y2: r11
              });
            }
          });
          let r10 = o10.length && cp.compositeBounds(o10);
          ct(this, "onRecommendMapView", {
            geoBounds: r10,
            chart: t10
          }, function() {
            if (r10 && this.recommendedMapView) {
              if (!this.recommendedMapView.projection) {
                let {
                  x1: t11,
                  y1: e11,
                  x2: i11,
                  y2: s11
                } = r10;
                this.recommendedMapView.projection = i11 - t11 > 180 && s11 - e11 > 90 ? {
                  name: "EqualEarth",
                  parallels: [0, 0],
                  rotation: [0]
                } : {
                  name: "LambertConformalConic",
                  parallels: [e11, s11],
                  rotation: [-(t11 + i11) / 2]
                };
              }
              this.recommendedMapView.insets || (this.recommendedMapView.insets = void 0);
            }
          }), this.geoMap = s10[0], i10 && t10.hasRendered && !t10.userOptions.mapView?.projection && this.recommendedMapView && this.update(this.recommendedMapView);
        }
        redraw(t10) {
          this.chart.series.forEach((t11) => {
            t11.useMapGeometry && (t11.isDirty = true);
          }), this.chart.redraw(t10);
        }
        setView(t10, e10, i10 = true, s10) {
          t10 && (this.center = t10), "number" == typeof e10 && ("number" == typeof this.minZoom && (e10 = Math.max(e10, this.minZoom)), "number" == typeof this.options.maxZoom && (e10 = Math.min(e10, this.options.maxZoom)), ci(e10) && (this.zoom = e10));
          let o10 = this.getProjectedBounds();
          if (o10) {
            let t11 = this.projection.forward(this.center), {
              x: e11,
              y: i11,
              width: s11,
              height: r10
            } = this.playingField, a10 = this.getScale(), n10 = this.projectedUnitsToPixels({
              x: o10.x1,
              y: o10.y1
            }), l10 = this.projectedUnitsToPixels({
              x: o10.x2,
              y: o10.y2
            }), h10 = [(o10.x1 + o10.x2) / 2, (o10.y1 + o10.y2) / 2];
            if (!this.chart.series.some((t12) => t12.isDrilling)) {
              let o11 = n10.x, d10 = l10.y, c10 = l10.x, p4 = n10.y;
              c10 - o11 < s11 ? t11[0] = h10[0] : o11 < e11 && c10 < e11 + s11 ? t11[0] += Math.max(o11 - e11, c10 - s11 - e11) / a10 : c10 > e11 + s11 && o11 > e11 && (t11[0] += Math.min(c10 - s11 - e11, o11 - e11) / a10), p4 - d10 < r10 ? t11[1] = h10[1] : d10 < i11 && p4 < i11 + r10 ? t11[1] -= Math.max(d10 - i11, p4 - r10 - i11) / a10 : p4 > i11 + r10 && d10 > i11 && (t11[1] -= Math.min(p4 - r10 - i11, d10 - i11) / a10), this.center = this.projection.inverse(t11);
            }
            this.insets.forEach((t12) => {
              t12.options.field && (t12.hitZone = t12.getHitZone(), t12.playingField = t12.getField());
            }), this.render();
          }
          ct(this, "afterSetView"), i10 && this.redraw(s10);
        }
        projectedUnitsToPixels(t10) {
          let e10 = this.getScale(), i10 = this.projection.forward(this.center), s10 = this.playingField, o10 = s10.x + s10.width / 2, r10 = s10.y + s10.height / 2;
          return {
            x: o10 - e10 * (i10[0] - t10.x),
            y: r10 + e10 * (i10[1] - t10.y)
          };
        }
        pixelsToLonLat(t10) {
          return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(t10));
        }
        pixelsToProjectedUnits(t10) {
          let {
            x: e10,
            y: i10
          } = t10, s10 = this.getScale(), o10 = this.projection.forward(this.center), r10 = this.playingField, a10 = r10.x + r10.width / 2, n10 = r10.y + r10.height / 2;
          return {
            x: o10[0] + (e10 - a10) / s10,
            y: o10[1] - (i10 - n10) / s10
          };
        }
        setUpEvents() {
          let t10, e10, i10;
          let {
            chart: s10
          } = this, o10 = (o11) => {
            let {
              lastTouches: r10,
              pinchDown: a10
            } = s10.pointer, n10 = this.projection, l10 = o11.touches, {
              mouseDownX: h10,
              mouseDownY: d10
            } = s10, c10 = 0;
            if (a10?.length === 1 ? (h10 = a10[0].chartX, d10 = a10[0].chartY) : a10?.length === 2 && (h10 = (a10[0].chartX + a10[1].chartX) / 2, d10 = (a10[0].chartY + a10[1].chartY) / 2), l10?.length === 2 && r10 && (c10 = Math.log(Math.sqrt(Math.pow(r10[0].chartX - r10[1].chartX, 2) + Math.pow(r10[0].chartY - r10[1].chartY, 2)) / Math.sqrt(Math.pow(l10[0].chartX - l10[1].chartX, 2) + Math.pow(l10[0].chartY - l10[1].chartY, 2))) / Math.log(0.5)), ci(h10) && ci(d10)) {
              let r11 = `${h10},${d10}`, {
                chartX: a11,
                chartY: p4
              } = o11.originalEvent;
              l10?.length === 2 && (a11 = (l10[0].chartX + l10[1].chartX) / 2, p4 = (l10[0].chartY + l10[1].chartY) / 2), r11 !== e10 && (e10 = r11, t10 = this.projection.forward(this.center), i10 = (this.projection.options.rotation || [0, 0]).slice());
              let u2 = n10.def && n10.def.bounds, g2 = u2 && cd(u2, this.playingField) || -1 / 0;
              if ("Orthographic" === n10.options.name && 2 > (l10?.length || 0) && (this.minZoom || 1 / 0) < 1.3 * g2) {
                let t11 = 440 / (this.getScale() * Math.min(s10.plotWidth, s10.plotHeight));
                if (i10) {
                  let e11 = (h10 - a11) * t11 - i10[0], o12 = d4(-i10[1] - (d10 - p4) * t11, -80, 80), r12 = this.zoom;
                  this.update({
                    projection: {
                      rotation: [-e11, -o12]
                    }
                  }, false), this.fitToBounds(void 0, void 0, false), this.zoom = r12, s10.redraw(false);
                }
              } else if (ci(a11) && ci(p4)) {
                let e11 = this.getScale(), i11 = this.projection.hasCoordinates ? 1 : -1, s11 = this.projection.inverse([t10[0] + (h10 - a11) / e11, t10[1] - (d10 - p4) / e11 * i11]);
                isNaN(s11[0] + s11[1]) || this.zoomBy(c10, s11, void 0, false);
              }
              o11.preventDefault();
            }
          };
          d8(s10, "pan", o10), d8(s10, "touchpan", o10), d8(s10, "selection", (t11) => {
            if (t11.resetSelection) this.zoomBy();
            else {
              let e11 = t11.x - s10.plotLeft, i11 = t11.y - s10.plotTop, {
                y: o11,
                x: r10
              } = this.pixelsToProjectedUnits({
                x: e11,
                y: i11
              }), {
                y: a10,
                x: n10
              } = this.pixelsToProjectedUnits({
                x: e11 + t11.width,
                y: i11 + t11.height
              });
              this.fitToBounds({
                x1: r10,
                y1: o11,
                x2: n10,
                y2: a10
              }, void 0, true, !t11.originalEvent.touches && void 0), /^touch/.test(t11.originalEvent.type) || s10.showResetZoom(), t11.preventDefault();
            }
          });
        }
        render() {
          this.group || (this.group = this.chart.renderer.g("map-view").attr({
            zIndex: 4
          }).add());
        }
        update(t10, e10 = true, i10) {
          let s10 = t10.projection, o10 = s10 && d2.toString(s10) !== d2.toString(this.options.projection), r10 = false;
          cr(true, this.userOptions, t10), cr(true, this.options, t10), "insets" in t10 && (this.insets.forEach((t11) => t11.destroy()), this.insets.length = 0, r10 = true), (o10 || "fitToGeometry" in t10) && delete this.fitToGeometryCache, (o10 || r10) && (this.chart.series.forEach((t11) => {
            let e11 = t11.transformGroups;
            if (t11.clearBounds && t11.clearBounds(), t11.isDirty = true, t11.isDirtyData = true, r10 && e11) for (; e11.length > 1; ) {
              let t12 = e11.pop();
              t12 && t12.destroy();
            }
          }), o10 && (this.projection = new d2(this.options.projection)), r10 && this.createInsets(), !t10.center && Object.hasOwnProperty.call(t10, "zoom") && !ci(t10.zoom) && this.fitToBounds(void 0, void 0, false)), t10.center || ci(t10.zoom) ? this.setView(this.options.center, t10.zoom, false) : "fitToGeometry" in t10 && this.fitToBounds(void 0, void 0, false), e10 && this.chart.redraw(i10);
        }
        zoomBy(t10, e10, i10, s10) {
          let o10 = this.chart, r10 = this.projection.forward(this.center);
          if ("number" == typeof t10) {
            let a10, n10, l10;
            let h10 = this.zoom + t10;
            if (i10) {
              let [t11, e11] = i10, s11 = this.getScale(), a11 = t11 - o10.plotLeft - o10.plotWidth / 2, h11 = e11 - o10.plotTop - o10.plotHeight / 2;
              n10 = r10[0] + a11 / s11, l10 = r10[1] + h11 / s11;
            }
            if ("number" == typeof n10 && "number" == typeof l10) {
              let t11 = 1 - Math.pow(2, this.zoom) / Math.pow(2, h10), e11 = r10[0] - n10, i11 = r10[1] - l10;
              r10[0] -= e11 * t11, r10[1] += i11 * t11, a10 = this.projection.inverse(r10);
            }
            this.setView(e10 || a10, h10, void 0, s10);
          } else this.fitToBounds(void 0, void 0, void 0, s10);
        }
      }
      class cu extends cp {
        constructor(t10, e10) {
          if (super(t10.chart, e10), this.id = e10.id, this.mapView = t10, this.options = cr({
            center: [0, 0]
          }, t10.options.insetOptions, e10), this.allBounds = [], this.options.geoBounds) {
            let e11 = t10.projection.path(this.options.geoBounds);
            this.geoBoundsProjectedBox = d9(e11), this.geoBoundsProjectedPolygon = e11.map((t11) => [t11[1] || 0, t11[2] || 0]);
          }
        }
        getField(t10 = true) {
          let e10 = this.hitZone;
          if (e10) {
            let i10 = t10 ? this.padding : [0, 0, 0, 0], s10 = e10.coordinates[0], o10 = s10.map((t11) => t11[0]), r10 = s10.map((t11) => t11[1]), a10 = Math.min.apply(0, o10) + i10[3], n10 = Math.max.apply(0, o10) - i10[1], l10 = Math.min.apply(0, r10) + i10[0], h10 = Math.max.apply(0, r10) - i10[2];
            if (ci(a10) && ci(l10)) return {
              x: a10,
              y: l10,
              width: n10 - a10,
              height: h10 - l10
            };
          }
          return super.getField.call(this, t10);
        }
        getHitZone() {
          let {
            chart: t10,
            mapView: e10,
            options: i10
          } = this, {
            coordinates: s10
          } = i10.field || {};
          if (s10) {
            let o10 = s10[0];
            if ("percent" === i10.units) {
              let s11 = "mapBoundingBox" === i10.relativeTo && e10.getMapBBox() || cr(t10.plotBox, {
                x: 0,
                y: 0
              });
              o10 = o10.map((t11) => [cl(`${t11[0]}%`, s11.width, s11.x), cl(`${t11[1]}%`, s11.height, s11.y)]);
            }
            return {
              type: "Polygon",
              coordinates: [o10]
            };
          }
        }
        getProjectedBounds() {
          return cp.compositeBounds(this.allBounds);
        }
        isInside(t10) {
          let {
            geoBoundsProjectedBox: e10,
            geoBoundsProjectedPolygon: i10
          } = this;
          return !!(e10 && t10.x >= e10.x1 && t10.x <= e10.x2 && t10.y >= e10.y1 && t10.y <= e10.y2 && i10 && d6(t10, i10));
        }
        render() {
          let {
            chart: t10,
            mapView: e10,
            options: i10
          } = this, s10 = i10.borderPath || i10.field;
          if (s10 && e10.group) {
            let o10 = true;
            this.border || (this.border = t10.renderer.path().addClass("highcharts-mapview-inset-border").add(e10.group), o10 = false), t10.styledMode || this.border.attr({
              stroke: i10.borderColor,
              "stroke-width": i10.borderWidth
            });
            let r10 = this.border.strokeWidth(), a10 = "mapBoundingBox" === i10.relativeTo && e10.getMapBBox() || e10.playingField, n10 = (s10.coordinates || []).reduce((e11, s11) => s11.reduce((e12, s12, o11) => {
              let [n11, l10] = s12;
              return "percent" === i10.units && (n11 = t10.plotLeft + cl(`${n11}%`, a10.width, a10.x), l10 = t10.plotTop + cl(`${l10}%`, a10.height, a10.y)), n11 = d7(n11, r10), l10 = d7(l10, r10), e12.push(0 === o11 ? ["M", n11, l10] : ["L", n11, l10]), e12;
            }, e11), []);
            this.border[o10 ? "animate" : "attr"]({
              d: n10
            });
          }
        }
        destroy() {
          this.border && (this.border = this.border.destroy()), this.eventsToUnbind.forEach((t10) => t10());
        }
        setUpEvents() {
        }
      }
      let {
        animObject: cg,
        stop: cm
      } = tH, {
        noop: cf
      } = A, {
        splitPath: cx
      } = dg, {
        column: cy,
        scatter: cb
      } = rx.seriesTypes, {
        extend: cv,
        find: cM,
        fireEvent: cw,
        getNestedProperty: ck,
        isArray: cS,
        defined: cT,
        isNumber: cC,
        isObject: cA,
        merge: cP,
        objectEach: cL,
        pick: cO,
        splat: cE
      } = J;
      class cI extends cb {
        constructor() {
          super(...arguments), this.processedData = [];
        }
        animate(t10) {
          let {
            chart: e10,
            group: i10
          } = this, s10 = cg(this.options.animation);
          t10 ? i10.attr({
            translateX: e10.plotLeft + e10.plotWidth / 2,
            translateY: e10.plotTop + e10.plotHeight / 2,
            scaleX: 1e-3,
            scaleY: 1e-3
          }) : i10.animate({
            translateX: e10.plotLeft,
            translateY: e10.plotTop,
            scaleX: 1,
            scaleY: 1
          }, s10);
        }
        clearBounds() {
          this.points.forEach((t10) => {
            delete t10.bounds, delete t10.insetIndex, delete t10.projectedPath;
          }), delete this.bounds;
        }
        doFullTranslate() {
          return !!(this.isDirtyData || this.chart.isResizing || !this.hasRendered);
        }
        drawMapDataLabels() {
          super.drawDataLabels(), this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
        }
        drawPoints() {
          let t10 = this, {
            chart: e10,
            group: i10,
            transformGroups: s10 = []
          } = this, {
            mapView: o10,
            renderer: r10
          } = e10;
          if (o10) {
            this.transformGroups = s10, s10[0] || (s10[0] = r10.g().add(i10));
            for (let t11 = 0, e11 = o10.insets.length; t11 < e11; ++t11) s10[t11 + 1] || s10.push(r10.g().add(i10));
            this.doFullTranslate() && (this.points.forEach((t11) => {
              let {
                graphic: e11
              } = t11;
              t11.group = s10["number" == typeof t11.insetIndex ? t11.insetIndex + 1 : 0], e11 && e11.parentGroup !== t11.group && e11.add(t11.group);
            }), cy.prototype.drawPoints.apply(this), this.points.forEach((i11) => {
              let s11 = i11.graphic;
              if (s11) {
                let o11 = s11.animate, r11 = "";
                i11.name && (r11 += "highcharts-name-" + i11.name.replace(/ /g, "-").toLowerCase()), i11.properties && i11.properties["hc-key"] && (r11 += " highcharts-key-" + i11.properties["hc-key"].toString().toLowerCase()), r11 && s11.addClass(r11), e10.styledMode && s11.css(this.pointAttribs(i11, i11.selected && "select" || void 0)), s11.attr({
                  visibility: !i11.visible && (i11.visible || i11.isNull) ? "hidden" : "inherit"
                }), s11.animate = function(i12, r12, a10) {
                  let n10 = cC(i12["stroke-width"]) && !cC(s11["stroke-width"]), l10 = cC(s11["stroke-width"]) && !cC(i12["stroke-width"]);
                  if (n10 || l10) {
                    let o12 = cO(t10.getStrokeWidth(t10.options), 1) / (e10.mapView && e10.mapView.getScale() || 1);
                    n10 && (s11["stroke-width"] = o12), l10 && (i12["stroke-width"] = o12);
                  }
                  return o11.call(s11, i12, r12, l10 ? function() {
                    s11.element.removeAttribute("stroke-width"), delete s11["stroke-width"], a10 && a10.apply(this, arguments);
                  } : a10);
                };
              }
            })), s10.forEach((i11, s11) => {
              let a10 = (0 === s11 ? o10 : o10.insets[s11 - 1]).getSVGTransform(), n10 = cO(this.getStrokeWidth(this.options), 1), l10 = a10.scaleX, h10 = a10.scaleY > 0 ? 1 : -1, d10 = (e11) => {
                (t10.points || []).forEach((t11) => {
                  let i12;
                  let s12 = t11.graphic;
                  s12 && s12["stroke-width"] && (i12 = this.getStrokeWidth(t11.options)) && s12.attr({
                    "stroke-width": i12 / e11
                  });
                });
              };
              if (r10.globalAnimation && e10.hasRendered && o10.allowTransformAnimation) {
                let t11 = Number(i11.attr("translateX")), e11 = Number(i11.attr("translateY")), s12 = Number(i11.attr("scaleX")), o11 = (o12, r11) => {
                  let c11 = s12 + (l10 - s12) * r11.pos;
                  i11.attr({
                    translateX: t11 + (a10.translateX - t11) * r11.pos,
                    translateY: e11 + (a10.translateY - e11) * r11.pos,
                    scaleX: c11,
                    scaleY: c11 * h10,
                    "stroke-width": n10 / c11
                  }), d10(c11);
                }, c10 = cP(cg(r10.globalAnimation)), p4 = c10.step;
                c10.step = function() {
                  p4 && p4.apply(this, arguments), o11.apply(this, arguments);
                }, i11.attr({
                  animator: 0
                }).animate({
                  animator: 1
                }, c10, function() {
                  "boolean" != typeof r10.globalAnimation && r10.globalAnimation.complete && r10.globalAnimation.complete({
                    applyDrilldown: true
                  }), cw(this, "mapZoomComplete");
                }.bind(this));
              } else cm(i11), i11.attr(cP(a10, {
                "stroke-width": n10 / l10
              })), d10(l10);
            }), this.isDrilling || this.drawMapDataLabels();
          }
        }
        getProjectedBounds() {
          if (!this.bounds && this.chart.mapView) {
            let {
              insets: t10,
              projection: e10
            } = this.chart.mapView, i10 = [];
            (this.points || []).forEach((s10) => {
              if (s10.path || s10.geometry) {
                if ("string" == typeof s10.path ? s10.path = cx(s10.path) : cS(s10.path) && "M" === s10.path[0] && (s10.path = this.chart.renderer.pathToSegments(s10.path)), !s10.bounds) {
                  let i11 = s10.getProjectedBounds(e10);
                  if (i11) {
                    s10.labelrank = cO(s10.labelrank, (i11.x2 - i11.x1) * (i11.y2 - i11.y1));
                    let {
                      midX: e11,
                      midY: o10
                    } = i11;
                    if (t10 && cC(e11) && cC(o10)) {
                      let r10 = cM(t10, (t11) => t11.isInside({
                        x: e11,
                        y: o10
                      }));
                      r10 && (delete s10.projectedPath, (i11 = s10.getProjectedBounds(r10.projection)) && r10.allBounds.push(i11), s10.insetIndex = t10.indexOf(r10));
                    }
                    s10.bounds = i11;
                  }
                }
                s10.bounds && void 0 === s10.insetIndex && i10.push(s10.bounds);
              }
            }), this.bounds = cp.compositeBounds(i10);
          }
          return this.bounds;
        }
        getStrokeWidth(t10) {
          let e10 = this.pointAttrToOptions;
          return t10[e10 && e10["stroke-width"] || "borderWidth"];
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        pointAttribs(t10, e10) {
          let {
            mapView: i10,
            styledMode: s10
          } = t10.series.chart, o10 = s10 ? this.colorAttribs(t10) : cy.prototype.pointAttribs.call(this, t10, e10), r10 = this.getStrokeWidth(t10.options);
          if (e10) {
            let i11 = cP(this.options.states && this.options.states[e10], t10.options.states && t10.options.states[e10] || {}), s11 = this.getStrokeWidth(i11);
            cT(s11) && (r10 = s11), o10.stroke = i11.borderColor ?? t10.color;
          }
          r10 && i10 && (r10 /= i10.getScale());
          let a10 = this.getStrokeWidth(this.options);
          return o10.dashstyle && i10 && cC(a10) && (r10 = a10 / i10.getScale()), t10.visible || (o10.fill = this.options.nullColor), cT(r10) ? o10["stroke-width"] = r10 : delete o10["stroke-width"], o10["stroke-linecap"] = o10["stroke-linejoin"] = this.options.linecap, o10;
        }
        updateData() {
          return !this.processedData && super.updateData.apply(this, arguments);
        }
        setData(t10, e10 = true, i10, s10) {
          delete this.bounds, super.setData(t10, false, void 0, s10), this.processData(), this.generatePoints(), e10 && this.chart.redraw(i10);
        }
        dataColumnKeys() {
          return this.pointArrayMap;
        }
        processData() {
          let t10, e10, i10;
          let s10 = this.options, o10 = s10.data, r10 = this.chart, a10 = r10.options.chart, n10 = this.joinBy, l10 = s10.keys || this.pointArrayMap, h10 = [], d10 = {}, c10 = this.chart.mapView, p4 = c10 && (cA(s10.mapData, true) ? c10.getGeoMap(s10.mapData) : c10.geoMap), u2 = r10.mapTransforms = a10.mapTransforms || p4 && p4["hc-transform"] || r10.mapTransforms;
          u2 && cL(u2, (t11) => {
            t11.rotation && (t11.cosAngle = Math.cos(t11.rotation), t11.sinAngle = Math.sin(t11.rotation));
          }), cS(s10.mapData) ? i10 = s10.mapData : p4 && "FeatureCollection" === p4.type && (this.mapTitle = p4.title, i10 = A.geojson(p4, this.type, this)), this.processedData = [];
          let g2 = this.processedData;
          if (o10) {
            let t11;
            for (let e11 = 0, i11 = o10.length; e11 < i11; ++e11) {
              if (cC(t11 = o10[e11])) g2[e11] = {
                value: t11
              };
              else if (cS(t11)) {
                let i12 = 0;
                g2[e11] = {}, !s10.keys && t11.length > l10.length && "string" == typeof t11[0] && (g2[e11]["hc-key"] = t11[0], ++i12);
                for (let s11 = 0; s11 < l10.length; ++s11, ++i12) l10[s11] && void 0 !== t11[i12] && (l10[s11].indexOf(".") > 0 ? dM.prototype.setNestedProperty(g2[e11], t11[i12], l10[s11]) : g2[e11][l10[s11]] = t11[i12]);
              } else g2[e11] = o10[e11];
              n10 && "_i" === n10[0] && (g2[e11]._i = e11);
            }
          }
          if (i10) {
            this.mapData = i10, this.mapMap = {};
            for (let s11 = 0; s11 < i10.length; s11++) e10 = (t10 = i10[s11]).properties, t10._i = s11, n10[0] && e10 && e10[n10[0]] && (t10[n10[0]] = e10[n10[0]]), d10[t10[n10[0]]] = t10;
            if (this.mapMap = d10, n10[1]) {
              let t11 = n10[1];
              g2.forEach((e11) => {
                let i11 = ck(t11, e11);
                d10[i11] && h10.push(d10[i11]);
              });
            }
            if (s10.allAreas) {
              if (n10[1]) {
                let t12 = n10[1];
                g2.forEach((e11) => {
                  h10.push(ck(t12, e11));
                });
              }
              let t11 = "|" + h10.map(function(t12) {
                return t12 && t12[n10[0]];
              }).join("|") + "|";
              i10.forEach((e11) => {
                n10[0] && -1 !== t11.indexOf("|" + e11[n10[0]] + "|") || g2.push(cP(e11, {
                  value: null
                }));
              });
            }
          }
          this.dataTable.rowCount = g2.length;
        }
        setOptions(t10) {
          let e10 = super.setOptions(t10), i10 = e10.joinBy;
          return null === e10.joinBy && (i10 = "_i"), i10 && (this.joinBy = cE(i10), this.joinBy[1] || (this.joinBy[1] = this.joinBy[0])), e10;
        }
        translate() {
          let t10 = this.doFullTranslate(), e10 = this.chart.mapView, i10 = e10 && e10.projection;
          if (this.chart.hasRendered && (this.isDirtyData || !this.hasRendered) && (this.processData(), this.generatePoints(), delete this.bounds, !e10 || e10.userOptions.center || cC(e10.userOptions.zoom) || e10.zoom !== e10.minZoom ? this.getProjectedBounds() : e10.fitToBounds(void 0, void 0, false)), e10) {
            let s10 = e10.getSVGTransform();
            this.points.forEach((o10) => {
              let r10 = cC(o10.insetIndex) && e10.insets[o10.insetIndex].getSVGTransform() || s10;
              r10 && o10.bounds && cC(o10.bounds.midX) && cC(o10.bounds.midY) && (o10.plotX = o10.bounds.midX * r10.scaleX + r10.translateX, o10.plotY = o10.bounds.midY * r10.scaleY + r10.translateY), t10 && (o10.shapeType = "path", o10.shapeArgs = {
                d: dM.getProjectedPath(o10, i10)
              }), o10.hiddenInDataClass || (o10.projectedPath && !o10.projectedPath.length ? o10.setVisible(false) : o10.visible || o10.setVisible(true));
            });
          }
          cw(this, "afterTranslate");
        }
        update(t10) {
          t10.mapData && this.chart.mapView?.recommendMapView(this.chart, [this.chart.options.chart.map, ...(this.chart.options.series || []).map((e10, i10) => i10 === this._i ? t10.mapData : e10.mapData)], true), super.update.apply(this, arguments);
        }
      }
      cI.defaultOptions = cP(cb.defaultOptions, {
        affectsMapView: true,
        animation: false,
        dataLabels: {
          crop: false,
          formatter: function() {
            let {
              numberFormatter: t10
            } = this.series.chart, {
              value: e10
            } = this.point;
            return dw(e10) ? t10(e10, -1) : this.point.name || "";
          },
          inside: true,
          overflow: false,
          padding: 0,
          verticalAlign: "middle"
        },
        linecap: "round",
        marker: null,
        nullColor: "#f7f7f7",
        stickyTracking: false,
        tooltip: {
          followPointer: true,
          pointFormat: "{point.name}: {point.value}<br/>"
        },
        turboThreshold: 0,
        allAreas: true,
        borderColor: "#e6e6e6",
        borderWidth: 1,
        joinBy: "hc-key",
        states: {
          hover: {
            halo: void 0,
            borderColor: "#666666",
            borderWidth: 2
          },
          normal: {
            animation: true
          },
          select: {
            color: "#cccccc"
          }
        },
        legendSymbol: "rectangle"
      }), cv(cI.prototype, {
        type: "map",
        axisTypes: dl.seriesMembers.axisTypes,
        colorAttribs: dl.seriesMembers.colorAttribs,
        colorKey: dl.seriesMembers.colorKey,
        directTouch: true,
        drawDataLabels: cf,
        drawGraph: cf,
        forceDL: true,
        getCenter: lI.getCenter,
        getExtremesFromAll: true,
        getSymbol: cf,
        isCartesian: false,
        parallelArrays: dl.seriesMembers.parallelArrays,
        pointArrayMap: dl.seriesMembers.pointArrayMap,
        pointClass: dM,
        preserveAspectRatio: true,
        searchPoint: cf,
        trackerGroups: dl.seriesMembers.trackerGroups,
        useMapGeometry: true
      }), dl.compose(cI), rx.registerSeriesType("map", cI);
      let cD = cI, {
        extend: cB,
        merge: cz
      } = J;
      class cN extends cD {
        pointAttribs(t10, e10) {
          let i10 = super.pointAttribs(t10, e10);
          return i10.fill = this.options.fillColor, i10;
        }
      }
      cN.defaultOptions = cz(cD.defaultOptions, {
        lineWidth: 1,
        fillColor: "none",
        legendSymbol: "lineMarker"
      }), cB(cN.prototype, {
        type: "mapline",
        colorProp: "stroke",
        pointAttrToOptions: {
          stroke: "color",
          "stroke-width": "lineWidth"
        }
      }), rx.registerSeriesType("mapline", cN);
      let {
        scatter: cR
      } = rx.seriesTypes, {
        isNumber: cW
      } = J;
      class cj extends cR.prototype.pointClass {
        isValid() {
          return !!(this.options.geometry || cW(this.x) && cW(this.y) || cW(this.options.lon) && cW(this.options.lat));
        }
      }
      let {
        noop: cX
      } = A, {
        map: cG,
        scatter: cF
      } = rx.seriesTypes, {
        extend: cH,
        fireEvent: cY,
        isNumber: cV,
        merge: cU
      } = J;
      class cZ extends cF {
        constructor() {
          super(...arguments), this.clearBounds = cG.prototype.clearBounds;
        }
        drawDataLabels() {
          super.drawDataLabels(), this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
        }
        projectPoint(t10) {
          let e10 = this.chart.mapView;
          if (e10) {
            let {
              geometry: i10,
              lon: s10,
              lat: o10
            } = t10, r10 = i10 && "Point" === i10.type && i10.coordinates;
            if (cV(s10) && cV(o10) && (r10 = [s10, o10]), r10) return e10.lonLatToProjectedUnits({
              lon: r10[0],
              lat: r10[1]
            });
          }
        }
        translate() {
          let t10 = this.chart.mapView;
          if (this.generatePoints(), this.getProjectedBounds && this.isDirtyData && (delete this.bounds, this.getProjectedBounds()), t10) {
            let e10 = t10.getSVGTransform(), {
              hasCoordinates: i10
            } = t10.projection;
            this.points.forEach((s10) => {
              let o10, {
                x: r10,
                y: a10
              } = s10, n10 = cV(s10.insetIndex) && t10.insets[s10.insetIndex].getSVGTransform() || e10, l10 = this.projectPoint(s10.options) || s10.properties && this.projectPoint(s10.properties);
              if (l10 ? (r10 = l10.x, a10 = l10.y) : s10.bounds && (r10 = s10.bounds.midX, a10 = s10.bounds.midY, n10 && cV(r10) && cV(a10) && (s10.plotX = r10 * n10.scaleX + n10.translateX, s10.plotY = a10 * n10.scaleY + n10.translateY, o10 = true)), cV(r10) && cV(a10)) {
                if (!o10) {
                  let e11 = t10.projectedUnitsToPixels({
                    x: r10,
                    y: a10
                  });
                  s10.plotX = e11.x, s10.plotY = i10 ? e11.y : this.chart.plotHeight - e11.y;
                }
              } else s10.y = s10.plotX = s10.plotY = void 0;
              s10.isInside = this.isPointInside(s10), s10.zone = this.zones.length ? s10.getZone() : void 0;
            });
          }
          cY(this, "afterTranslate");
        }
      }
      cZ.defaultOptions = cU(cF.defaultOptions, {
        dataLabels: {
          crop: false,
          defer: false,
          enabled: true,
          formatter: function() {
            return this.point.name;
          },
          overflow: false,
          style: {
            color: "#000000"
          }
        },
        legendSymbol: "lineMarker"
      }), iH.prototype.symbols.mapmarker = (t10, e10, i10, s10, o10) => {
        let r10, a10;
        let n10 = o10 && "legend" === o10.context;
        n10 ? (r10 = t10 + i10 / 2, a10 = e10 + s10) : o10 && "number" == typeof o10.anchorX && "number" == typeof o10.anchorY ? (r10 = o10.anchorX, a10 = o10.anchorY) : (r10 = t10 + i10 / 2, a10 = e10 + s10 / 2, e10 -= s10);
        let l10 = n10 ? s10 / 3 : s10 / 2;
        return [["M", r10, a10], ["C", r10, a10, r10 - l10, e10 + 1.5 * l10, r10 - l10, e10 + l10], ["A", l10, l10, 1, 1, 1, r10 + l10, e10 + l10], ["C", r10 + l10, e10 + 1.5 * l10, r10, a10, r10, a10], ["Z"]];
      }, cH(cZ.prototype, {
        type: "mappoint",
        axisTypes: ["colorAxis"],
        forceDL: true,
        isCartesian: false,
        pointClass: cj,
        searchPoint: cX,
        useMapGeometry: true
      }), rx.registerSeriesType("mappoint", cZ);
      let c$ = {
        borderColor: void 0,
        borderWidth: 2,
        className: void 0,
        color: void 0,
        connectorClassName: void 0,
        connectorColor: void 0,
        connectorDistance: 60,
        connectorWidth: 1,
        enabled: false,
        labels: {
          className: void 0,
          allowOverlap: false,
          format: "",
          formatter: void 0,
          align: "right",
          style: {
            fontSize: "0.9em",
            color: "#000000"
          },
          x: 0,
          y: 0
        },
        maxSize: 60,
        minSize: 10,
        legendIndex: 0,
        ranges: {
          value: void 0,
          borderColor: void 0,
          color: void 0,
          connectorColor: void 0
        },
        sizeBy: "area",
        sizeByAbsoluteValue: false,
        zIndex: 1,
        zThreshold: 0
      }, {
        parse: c_
      } = tA, {
        noop: cq
      } = A, {
        arrayMax: cK,
        arrayMin: cJ,
        isNumber: cQ,
        merge: c0,
        pick: c1,
        stableSort: c2
      } = J, c3 = class {
        constructor(t10, e10) {
          this.setState = cq, this.init(t10, e10);
        }
        init(t10, e10) {
          this.options = t10, this.visible = true, this.chart = e10.chart, this.legend = e10;
        }
        addToLegend(t10) {
          t10.splice(this.options.legendIndex, 0, this);
        }
        drawLegendSymbol(t10) {
          let e10;
          let i10 = c1(t10.options.itemDistance, 20), s10 = this.legendItem || {}, o10 = this.options, r10 = o10.ranges, a10 = o10.connectorDistance;
          if (!r10 || !r10.length || !cQ(r10[0].value)) {
            t10.options.bubbleLegend.autoRanges = true;
            return;
          }
          c2(r10, function(t11, e11) {
            return e11.value - t11.value;
          }), this.ranges = r10, this.setOptions(), this.render();
          let n10 = this.getMaxLabelSize(), l10 = this.ranges[0].radius, h10 = 2 * l10;
          e10 = (e10 = a10 - l10 + n10.width) > 0 ? e10 : 0, this.maxLabel = n10, this.movementX = "left" === o10.labels.align ? e10 : 0, s10.labelWidth = h10 + e10 + i10, s10.labelHeight = h10 + n10.height / 2;
        }
        setOptions() {
          let t10 = this.ranges, e10 = this.options, i10 = this.chart.series[e10.seriesIndex], s10 = this.legend.baseline, o10 = {
            zIndex: e10.zIndex,
            "stroke-width": e10.borderWidth
          }, r10 = {
            zIndex: e10.zIndex,
            "stroke-width": e10.connectorWidth
          }, a10 = {
            align: this.legend.options.rtl || "left" === e10.labels.align ? "right" : "left",
            zIndex: e10.zIndex
          }, n10 = i10.options.marker.fillOpacity, l10 = this.chart.styledMode;
          t10.forEach(function(h10, d10) {
            l10 || (o10.stroke = c1(h10.borderColor, e10.borderColor, i10.color), o10.fill = c1(h10.color, e10.color, 1 !== n10 ? c_(i10.color).setOpacity(n10).get("rgba") : i10.color), r10.stroke = c1(h10.connectorColor, e10.connectorColor, i10.color)), t10[d10].radius = this.getRangeRadius(h10.value), t10[d10] = c0(t10[d10], {
              center: t10[0].radius - t10[d10].radius + s10
            }), l10 || c0(true, t10[d10], {
              bubbleAttribs: c0(o10),
              connectorAttribs: c0(r10),
              labelAttribs: a10
            });
          }, this);
        }
        getRangeRadius(t10) {
          let e10 = this.options, i10 = this.options.seriesIndex, s10 = this.chart.series[i10], o10 = e10.ranges[0].value, r10 = e10.ranges[e10.ranges.length - 1].value, a10 = e10.minSize, n10 = e10.maxSize;
          return s10.getRadius.call(this, r10, o10, a10, n10, t10);
        }
        render() {
          let t10 = this.legendItem || {}, e10 = this.chart.renderer, i10 = this.options.zThreshold;
          for (let s10 of (this.symbols || (this.symbols = {
            connectors: [],
            bubbleItems: [],
            labels: []
          }), t10.symbol = e10.g("bubble-legend"), t10.label = e10.g("bubble-legend-item").css(this.legend.itemStyle || {}), t10.symbol.translateX = 0, t10.symbol.translateY = 0, t10.symbol.add(t10.label), t10.label.add(t10.group), this.ranges)) s10.value >= i10 && this.renderRange(s10);
          this.hideOverlappingLabels();
        }
        renderRange(t10) {
          let e10 = this.ranges[0], i10 = this.legend, s10 = this.options, o10 = s10.labels, r10 = this.chart, a10 = r10.series[s10.seriesIndex], n10 = r10.renderer, l10 = this.symbols, h10 = l10.labels, d10 = t10.center, c10 = Math.abs(t10.radius), p4 = s10.connectorDistance || 0, u2 = o10.align, g2 = i10.options.rtl, m2 = s10.borderWidth, f2 = s10.connectorWidth, x2 = e10.radius || 0, y2 = d10 - c10 - m2 / 2 + f2 / 2, b2 = (y2 % 1 ? 1 : 0.5) - (f2 % 2 ? 0 : 0.5), v2 = n10.styledMode, M2 = g2 || "left" === u2 ? -p4 : p4;
          "center" === u2 && (M2 = 0, s10.connectorDistance = 0, t10.labelAttribs.align = "center"), l10.bubbleItems.push(n10.circle(x2, d10 + b2, c10).attr(v2 ? {} : t10.bubbleAttribs).addClass((v2 ? "highcharts-color-" + a10.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (s10.className || "")).add(this.legendItem.symbol)), l10.connectors.push(n10.path(n10.crispLine([["M", x2, y2], ["L", x2 + M2, y2]], s10.connectorWidth)).attr(v2 ? {} : t10.connectorAttribs).addClass((v2 ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (s10.connectorClassName || "")).add(this.legendItem.symbol));
          let w2 = n10.text(this.formatLabel(t10)).attr(v2 ? {} : t10.labelAttribs).css(v2 ? {} : o10.style).addClass("highcharts-bubble-legend-labels " + (s10.labels.className || "")).add(this.legendItem.symbol), k2 = {
            x: x2 + M2 + s10.labels.x,
            y: y2 + s10.labels.y + 0.4 * w2.getBBox().height
          };
          w2.attr(k2), h10.push(w2), w2.placed = true, w2.alignAttr = k2;
        }
        getMaxLabelSize() {
          let t10, e10;
          return this.symbols.labels.forEach(function(i10) {
            e10 = i10.getBBox(true), t10 = t10 ? e10.width > t10.width ? e10 : t10 : e10;
          }), t10 || {};
        }
        formatLabel(t10) {
          let e10 = this.options, i10 = e10.labels.formatter, s10 = e10.labels.format, {
            numberFormatter: o10
          } = this.chart;
          return s10 ? ed.format(s10, t10, this.chart) : i10 ? i10.call(t10) : o10(t10.value, 1);
        }
        hideOverlappingLabels() {
          let t10 = this.chart, e10 = this.options.labels.allowOverlap, i10 = this.symbols;
          !e10 && i10 && (t10.hideOverlappingLabels(i10.labels), i10.labels.forEach(function(t11, e11) {
            t11.newOpacity ? t11.newOpacity !== t11.oldOpacity && i10.connectors[e11].show() : i10.connectors[e11].hide();
          }));
        }
        getRanges() {
          let t10 = this.legend.bubbleLegend, e10 = t10.chart.series, i10 = t10.options.ranges, s10, o10, r10 = Number.MAX_VALUE, a10 = -Number.MAX_VALUE;
          return e10.forEach(function(t11) {
            t11.isBubble && !t11.ignoreSeries && (o10 = t11.getColumn("z").filter(cQ)).length && (r10 = c1(t11.options.zMin, Math.min(r10, Math.max(cJ(o10), false === t11.options.displayNegative ? t11.options.zThreshold : -Number.MAX_VALUE))), a10 = c1(t11.options.zMax, Math.max(a10, cK(o10))));
          }), s10 = r10 === a10 ? [{
            value: a10
          }] : [{
            value: r10
          }, {
            value: (r10 + a10) / 2
          }, {
            value: a10,
            autoRanges: true
          }], i10.length && i10[0].radius && s10.reverse(), s10.forEach(function(t11, e11) {
            i10 && i10[e11] && (s10[e11] = c0(i10[e11], t11));
          }), s10;
        }
        predictBubbleSizes() {
          let t10 = this.chart, e10 = t10.legend.options, i10 = e10.floating, s10 = "horizontal" === e10.layout, o10 = s10 ? t10.legend.lastLineHeight : 0, r10 = t10.plotSizeX, a10 = t10.plotSizeY, n10 = t10.series[this.options.seriesIndex], l10 = n10.getPxExtremes(), h10 = Math.ceil(l10.minPxSize), d10 = Math.ceil(l10.maxPxSize), c10 = Math.min(a10, r10), p4, u2 = n10.options.maxSize;
          return i10 || !/%$/.test(u2) ? p4 = d10 : (p4 = (c10 + o10) * (u2 = parseFloat(u2)) / 100 / (u2 / 100 + 1), (s10 && a10 - p4 >= r10 || !s10 && r10 - p4 >= a10) && (p4 = d10)), [h10, Math.ceil(p4)];
        }
        updateRanges(t10, e10) {
          let i10 = this.legend.options.bubbleLegend;
          i10.minSize = t10, i10.maxSize = e10, i10.ranges = this.getRanges();
        }
        correctSizes() {
          let t10 = this.legend, e10 = this.chart.series[this.options.seriesIndex].getPxExtremes();
          Math.abs(Math.ceil(e10.maxPxSize) - this.options.maxSize) > 1 && (this.updateRanges(this.options.minSize, e10.maxPxSize), t10.render());
        }
      }, {
        setOptions: c6
      } = tw, {
        composed: c5
      } = A, {
        addEvent: c9,
        objectEach: c8,
        pushUnique: c4,
        wrap: c7
      } = J;
      function pt(t10, e10, i10) {
        let s10, o10, r10;
        let a10 = this.legend, n10 = pe(this) >= 0;
        a10 && a10.options.enabled && a10.bubbleLegend && a10.options.bubbleLegend.autoRanges && n10 ? (s10 = a10.bubbleLegend.options, o10 = a10.bubbleLegend.predictBubbleSizes(), a10.bubbleLegend.updateRanges(o10[0], o10[1]), s10.placed || (a10.group.placed = false, a10.allItems.forEach((t11) => {
          (r10 = t11.legendItem || {}).group && (r10.group.translateY = void 0);
        })), a10.render(), s10.placed || (this.getMargins(), this.axes.forEach((t11) => {
          t11.setScale(), t11.updateNames(), c8(t11.ticks, function(t12) {
            t12.isNew = true, t12.isNewLabel = true;
          });
        }), this.getMargins()), s10.placed = true, t10.call(this, e10, i10), a10.bubbleLegend.correctSizes(), pr(a10, pi(a10))) : (t10.call(this, e10, i10), a10 && a10.options.enabled && a10.bubbleLegend && (a10.render(), pr(a10, pi(a10))));
      }
      function pe(t10) {
        let e10 = t10.series, i10 = 0;
        for (; i10 < e10.length; ) {
          if (e10[i10] && e10[i10].isBubble && e10[i10].visible && e10[i10].dataTable.rowCount) return i10;
          i10++;
        }
        return -1;
      }
      function pi(t10) {
        let e10 = t10.allItems, i10 = [], s10 = e10.length, o10, r10, a10, n10 = 0, l10 = 0;
        for (n10 = 0; n10 < s10; n10++) if (r10 = e10[n10].legendItem || {}, a10 = (e10[n10 + 1] || {}).legendItem || {}, r10.labelHeight && (e10[n10].itemHeight = r10.labelHeight), e10[n10] === e10[s10 - 1] || r10.y !== a10.y) {
          for (i10.push({
            height: 0
          }), o10 = i10[i10.length - 1]; l10 <= n10; l10++) e10[l10].itemHeight > o10.height && (o10.height = e10[l10].itemHeight);
          o10.step = n10;
        }
        return i10;
      }
      function ps(t10) {
        let e10 = this.bubbleLegend, i10 = this.options, s10 = i10.bubbleLegend, o10 = pe(this.chart);
        e10 && e10.ranges && e10.ranges.length && (s10.ranges.length && (s10.autoRanges = !!s10.ranges[0].autoRanges), this.destroyItem(e10)), o10 >= 0 && i10.enabled && s10.enabled && (s10.seriesIndex = o10, this.bubbleLegend = new c3(s10, this), this.bubbleLegend.addToLegend(t10.allItems));
      }
      function po(t10) {
        let e10;
        if (t10.defaultPrevented) return false;
        let i10 = t10.legendItem, s10 = this.chart, o10 = i10.visible;
        this && this.bubbleLegend && (i10.visible = !o10, i10.ignoreSeries = o10, e10 = pe(s10) >= 0, this.bubbleLegend.visible !== e10 && (this.update({
          bubbleLegend: {
            enabled: e10
          }
        }), this.bubbleLegend.visible = e10), i10.visible = o10);
      }
      function pr(t10, e10) {
        let i10 = t10.allItems, s10 = t10.options.rtl, o10, r10, a10, n10, l10 = 0;
        i10.forEach((t11, i11) => {
          (n10 = t11.legendItem || {}).group && (o10 = n10.group.translateX || 0, r10 = n10.y || 0, ((a10 = t11.movementX) || s10 && t11.ranges) && (a10 = s10 ? o10 - t11.options.maxSize / 2 : o10 + a10, n10.group.attr({
            translateX: a10
          })), i11 > e10[l10].step && l10++, n10.group.attr({
            translateY: Math.round(r10 + e10[l10].height / 2)
          }), n10.y = r10 + e10[l10].height / 2);
        });
      }
      let pa = {
        compose: function(t10, e10) {
          c4(c5, "Series.BubbleLegend") && (c6({
            legend: {
              bubbleLegend: c$
            }
          }), c7(t10.prototype, "drawChartBox", pt), c9(e10, "afterGetAllItems", ps), c9(e10, "itemClick", po));
        }
      }, {
        seriesTypes: {
          scatter: {
            prototype: {
              pointClass: pn
            }
          }
        }
      } = rx, {
        extend: pl
      } = J;
      class ph extends pn {
        haloPath(t10) {
          let e10 = (t10 && this.marker && this.marker.radius || 0) + t10;
          if (this.series.chart.inverted) {
            let t11 = this.pos() || [0, 0], {
              xAxis: i10,
              yAxis: s10,
              chart: o10
            } = this.series;
            return o10.renderer.symbols.circle(i10.len - t11[1] - e10, s10.len - t11[0] - e10, 2 * e10, 2 * e10);
          }
          return o$.prototype.haloPath.call(this, e10);
        }
      }
      pl(ph.prototype, {
        ttBelow: false
      });
      let pd = ph, {
        parse: pc
      } = tA, {
        composed: pp,
        noop: pu
      } = A, {
        series: pg,
        seriesTypes: {
          column: {
            prototype: pm
          },
          scatter: pf
        }
      } = rx, {
        addEvent: px,
        arrayMax: py,
        arrayMin: pb,
        clamp: pv,
        extend: pM,
        isNumber: pw,
        merge: pk,
        pick: pS,
        pushUnique: pT
      } = J;
      function pC() {
        let t10 = this.len, {
          coll: e10,
          isXAxis: i10,
          min: s10
        } = this, o10 = (this.max || 0) - (s10 || 0), r10 = 0, a10 = t10, n10 = t10 / o10, l10;
        ("xAxis" === e10 || "yAxis" === e10) && (this.series.forEach((t11) => {
          if (t11.bubblePadding && t11.reserveSpace()) {
            this.allowZoomOutside = true, l10 = true;
            let e11 = t11.getColumn(i10 ? "x" : "y");
            if (i10 && ((t11.onPoint || t11).getRadii(0, 0, t11), t11.onPoint && (t11.radii = t11.onPoint.radii)), o10 > 0) {
              let i11 = e11.length;
              for (; i11--; ) if (pw(e11[i11]) && this.dataMin <= e11[i11] && e11[i11] <= this.max) {
                let o11 = t11.radii && t11.radii[i11] || 0;
                r10 = Math.min((e11[i11] - s10) * n10 - o11, r10), a10 = Math.max((e11[i11] - s10) * n10 + o11, a10);
              }
            }
          }
        }), l10 && o10 > 0 && !this.logarithmic && (a10 -= t10, n10 *= (t10 + Math.max(0, r10) - Math.min(a10, t10)) / t10, [["min", "userMin", r10], ["max", "userMax", a10]].forEach((t11) => {
          void 0 === pS(this.options[t11[0]], this[t11[1]]) && (this[t11[0]] += t11[2] / n10);
        })));
      }
      function pA() {
        let {
          ticks: t10,
          tickPositions: e10,
          dataMin: i10 = 0,
          dataMax: s10 = 0,
          categories: o10
        } = this, r10 = this.options.type;
        if ((o10?.length || "category" === r10) && this.series.find((t11) => t11.bubblePadding)) {
          let o11 = e10.length;
          for (; o11--; ) {
            let r11 = t10[e10[o11]], a10 = r11.pos || 0;
            (a10 > s10 || a10 < i10) && r11.label?.hide();
          }
        }
      }
      class pP extends pf {
        static compose(t10, e10, i10) {
          pa.compose(e10, i10), pT(pp, "Series.Bubble") && (px(t10, "foundExtremes", pC), px(t10, "afterRender", pA));
        }
        animate(t10) {
          !t10 && this.points.length < this.options.animationLimit && this.points.forEach(function(t11) {
            let {
              graphic: e10,
              plotX: i10 = 0,
              plotY: s10 = 0
            } = t11;
            e10 && e10.width && (this.hasRendered || e10.attr({
              x: i10,
              y: s10,
              width: 1,
              height: 1
            }), e10.animate(this.markerAttribs(t11), this.options.animation));
          }, this);
        }
        getRadii() {
          let t10 = this.getColumn("z"), e10 = this.getColumn("y"), i10 = [], s10, o10, r10, a10 = this.chart.bubbleZExtremes, {
            minPxSize: n10,
            maxPxSize: l10
          } = this.getPxExtremes();
          if (!a10) {
            let t11, e11 = Number.MAX_VALUE, i11 = -Number.MAX_VALUE;
            this.chart.series.forEach((s11) => {
              if (s11.bubblePadding && s11.reserveSpace()) {
                let o11 = (s11.onPoint || s11).getZExtremes();
                o11 && (e11 = Math.min(pS(e11, o11.zMin), o11.zMin), i11 = Math.max(pS(i11, o11.zMax), o11.zMax), t11 = true);
              }
            }), t11 ? (a10 = {
              zMin: e11,
              zMax: i11
            }, this.chart.bubbleZExtremes = a10) : a10 = {
              zMin: 0,
              zMax: 0
            };
          }
          for (o10 = 0, s10 = t10.length; o10 < s10; o10++) r10 = t10[o10], i10.push(this.getRadius(a10.zMin, a10.zMax, n10, l10, r10, e10 && e10[o10]));
          this.radii = i10;
        }
        getRadius(t10, e10, i10, s10, o10, r10) {
          let a10 = this.options, n10 = "width" !== a10.sizeBy, l10 = a10.zThreshold, h10 = e10 - t10, d10 = 0.5;
          if (null === r10 || null === o10) return null;
          if (pw(o10)) {
            if (a10.sizeByAbsoluteValue && (o10 = Math.abs(o10 - l10), e10 = h10 = Math.max(e10 - l10, Math.abs(t10 - l10)), t10 = 0), o10 < t10) return i10 / 2 - 1;
            h10 > 0 && (d10 = (o10 - t10) / h10);
          }
          return n10 && d10 >= 0 && (d10 = Math.sqrt(d10)), Math.ceil(i10 + d10 * (s10 - i10)) / 2;
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        markerAttribs(t10, e10) {
          let i10 = super.markerAttribs(t10, e10), {
            height: s10 = 0,
            width: o10 = 0
          } = i10;
          return this.chart.inverted ? pM(i10, {
            x: (t10.plotX || 0) - o10 / 2,
            y: (t10.plotY || 0) - s10 / 2
          }) : i10;
        }
        pointAttribs(t10, e10) {
          let i10 = this.options.marker.fillOpacity, s10 = pg.prototype.pointAttribs.call(this, t10, e10);
          return 1 !== i10 && (s10.fill = pc(s10.fill).setOpacity(i10).get("rgba")), s10;
        }
        translate() {
          super.translate.call(this), this.getRadii(), this.translateBubble();
        }
        translateBubble() {
          let {
            data: t10,
            options: e10,
            radii: i10
          } = this, {
            minPxSize: s10
          } = this.getPxExtremes(), o10 = t10.length;
          for (; o10--; ) {
            let r10 = t10[o10], a10 = i10 ? i10[o10] : 0;
            "z" === this.zoneAxis && (r10.negative = (r10.z || 0) < (e10.zThreshold || 0)), pw(a10) && a10 >= s10 / 2 ? (r10.marker = pM(r10.marker, {
              radius: a10,
              width: 2 * a10,
              height: 2 * a10
            }), r10.dlBox = {
              x: r10.plotX - a10,
              y: r10.plotY - a10,
              width: 2 * a10,
              height: 2 * a10
            }) : (r10.shapeArgs = r10.plotY = r10.dlBox = void 0, r10.isInside = false);
          }
        }
        getPxExtremes() {
          let t10 = Math.min(this.chart.plotWidth, this.chart.plotHeight), e10 = (e11) => {
            let i11;
            return "string" == typeof e11 && (i11 = /%$/.test(e11), e11 = parseInt(e11, 10)), i11 ? t10 * e11 / 100 : e11;
          }, i10 = e10(pS(this.options.minSize, 8)), s10 = Math.max(e10(pS(this.options.maxSize, "20%")), i10);
          return {
            minPxSize: i10,
            maxPxSize: s10
          };
        }
        getZExtremes() {
          let t10 = this.options, e10 = this.getColumn("z").filter(pw);
          if (e10.length) {
            let i10 = pS(t10.zMin, pv(pb(e10), false === t10.displayNegative ? t10.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE)), s10 = pS(t10.zMax, py(e10));
            if (pw(i10) && pw(s10)) return {
              zMin: i10,
              zMax: s10
            };
          }
        }
        searchKDTree(t10, e10, i10, s10 = pu, o10 = pu) {
          return s10 = (t11, e11, i11) => {
            let s11 = t11[i11] || 0, o11 = e11[i11] || 0, r10, a10 = false;
            return s11 < 0 && o11 < 0 ? (r10 = s11 - (t11.marker?.radius || 0) >= o11 - (e11.marker?.radius || 0) ? t11 : e11, a10 = true) : r10 = s11 < o11 ? t11 : e11, [r10, a10];
          }, o10 = (t11, e11, i11) => !i11 && t11 > e11 || t11 < e11, super.searchKDTree(t10, e10, i10, s10, o10);
        }
      }
      pP.defaultOptions = pk(pf.defaultOptions, {
        dataLabels: {
          formatter: function() {
            let {
              numberFormatter: t10
            } = this.series.chart, {
              z: e10
            } = this.point;
            return pw(e10) ? t10(e10, -1) : "";
          },
          inside: true,
          verticalAlign: "middle"
        },
        animationLimit: 250,
        marker: {
          lineColor: null,
          lineWidth: 1,
          fillOpacity: 0.5,
          radius: null,
          states: {
            hover: {
              radiusPlus: 0
            }
          },
          symbol: "circle"
        },
        minSize: 8,
        maxSize: "20%",
        softThreshold: false,
        states: {
          hover: {
            halo: {
              size: 5
            }
          }
        },
        tooltip: {
          pointFormat: "({point.x}, {point.y}), Size: {point.z}"
        },
        turboThreshold: 0,
        zThreshold: 0,
        zoneAxis: "z"
      }), pM(pP.prototype, {
        alignDataLabel: pm.alignDataLabel,
        applyZones: pu,
        bubblePadding: true,
        isBubble: true,
        keysAffectYAxis: ["y"],
        pointArrayMap: ["y", "z"],
        pointClass: pd,
        parallelArrays: ["x", "y", "z"],
        trackerGroups: ["group", "dataLabelsGroup"],
        specialGroup: "group",
        zoneAxis: "z"
      }), px(pP, "updatedData", (t10) => {
        delete t10.target.chart.bubbleZExtremes;
      }), px(pP, "remove", (t10) => {
        delete t10.target.chart.bubbleZExtremes;
      }), rx.registerSeriesType("bubble", pP);
      let pL = pP, {
        seriesTypes: {
          map: {
            prototype: {
              pointClass: {
                prototype: pO
              }
            }
          }
        }
      } = rx, {
        extend: pE
      } = J;
      class pI extends pd {
        isValid() {
          return "number" == typeof this.z;
        }
      }
      pE(pI.prototype, {
        applyOptions: pO.applyOptions,
        getProjectedBounds: pO.getProjectedBounds
      });
      let {
        seriesTypes: {
          map: {
            prototype: pD
          },
          mappoint: {
            prototype: pB
          }
        }
      } = rx, {
        extend: pz,
        merge: pN
      } = J;
      class pR extends pL {
        constructor() {
          super(...arguments), this.clearBounds = pD.clearBounds;
        }
        searchPoint(t10, e10) {
          return this.searchKDTree({
            plotX: t10.chartX - this.chart.plotLeft,
            plotY: t10.chartY - this.chart.plotTop
          }, e10, t10);
        }
        translate() {
          pB.translate.call(this), this.getRadii(), this.translateBubble();
        }
      }
      pR.defaultOptions = pN(pL.defaultOptions, {
        lineWidth: 0,
        animationLimit: 500,
        joinBy: "hc-key",
        tooltip: {
          pointFormat: "{point.name}: {point.z}"
        }
      }), pz(pR.prototype, {
        type: "mapbubble",
        axisTypes: ["colorAxis"],
        getProjectedBounds: pD.getProjectedBounds,
        isCartesian: false,
        pointArrayMap: ["z"],
        pointClass: pI,
        processData: pD.processData,
        projectPoint: pB.projectPoint,
        kdAxisArray: ["plotX", "plotY"],
        setData: pD.setData,
        setOptions: pD.setOptions,
        updateData: pD.updateData,
        useMapGeometry: true,
        xyFromShape: true
      }), rx.registerSeriesType("mapbubble", pR);
      let {
        scatter: {
          prototype: {
            pointClass: pW
          }
        }
      } = rx.seriesTypes, {
        clamp: pj,
        defined: pX,
        extend: pG,
        pick: pF
      } = J;
      class pH extends pW {
        applyOptions(t10, e10) {
          return (this.isNull || null === this.value) && delete this.color, super.applyOptions(t10, e10), this.formatPrefix = this.isNull || null === this.value ? "null" : "point", this;
        }
        getCellAttributes() {
          let t10 = this.series, e10 = t10.options, i10 = (e10.colsize || 1) / 2, s10 = (e10.rowsize || 1) / 2, o10 = t10.xAxis, r10 = t10.yAxis, a10 = this.options.marker || t10.options.marker, n10 = t10.pointPlacementToXValue(), l10 = pF(this.pointPadding, e10.pointPadding, 0), h10 = {
            x1: pj(Math.round(o10.len - o10.translate(this.x - i10, false, true, false, true, -n10)), -o10.len, 2 * o10.len),
            x2: pj(Math.round(o10.len - o10.translate(this.x + i10, false, true, false, true, -n10)), -o10.len, 2 * o10.len),
            y1: pj(Math.round(r10.translate(this.y - s10, false, true, false, true)), -r10.len, 2 * r10.len),
            y2: pj(Math.round(r10.translate(this.y + s10, false, true, false, true)), -r10.len, 2 * r10.len)
          };
          for (let t11 of [["width", "x"], ["height", "y"]]) {
            let e11 = t11[0], i11 = t11[1], s11 = i11 + "1", n11 = i11 + "2", d10 = Math.abs(h10[s11] - h10[n11]), c10 = a10 && a10.lineWidth || 0, p4 = Math.abs(h10[s11] + h10[n11]) / 2, u2 = a10 && a10[e11];
            if (pX(u2) && u2 < d10) {
              let t12 = u2 / 2 + c10 / 2;
              h10[s11] = p4 - t12, h10[n11] = p4 + t12;
            }
            l10 && (("x" === i11 && o10.reversed || "y" === i11 && !r10.reversed) && (s11 = n11, n11 = i11 + "1"), h10[s11] += l10, h10[n11] -= l10);
          }
          return h10;
        }
        haloPath(t10) {
          if (!t10) return [];
          let {
            x: e10 = 0,
            y: i10 = 0,
            width: s10 = 0,
            height: o10 = 0
          } = this.shapeArgs || {};
          return [["M", e10 - t10, i10 - t10], ["L", e10 - t10, i10 + o10 + t10], ["L", e10 + s10 + t10, i10 + o10 + t10], ["L", e10 + s10 + t10, i10 - t10], ["Z"]];
        }
        isValid() {
          return this.value !== 1 / 0 && this.value !== -1 / 0;
        }
      }
      pG(pH.prototype, {
        dataLabelOnNull: true,
        moveToTopOnHover: true,
        ttBelow: false
      });
      let {
        isNumber: pY
      } = J, {
        doc: pV
      } = A, {
        defined: pU,
        pick: pZ
      } = J, {
        series: p$,
        seriesTypes: {
          column: p_,
          scatter: pq
        }
      } = rx, {
        prototype: {
          symbols: pK
        }
      } = iH, {
        addEvent: pJ,
        extend: pQ,
        fireEvent: p0,
        isNumber: p1,
        merge: p2,
        pick: p3
      } = J, {
        colorFromPoint: p6,
        getContext: p5
      } = {
        colorFromPoint: function(t10, e10) {
          let i10 = e10.series.colorAxis;
          if (i10) {
            let s10 = i10.toColor(t10 || 0, e10).split(")")[0].split("(")[1].split(",").map((t11) => pZ(parseFloat(t11), parseInt(t11, 10)));
            return s10[3] = 255 * pZ(s10[3], 1), pU(t10) && e10.visible || (s10[3] = 0), s10;
          }
          return [0, 0, 0, 0];
        },
        getContext: function(t10) {
          let {
            canvas: e10,
            context: i10
          } = t10;
          return e10 && i10 ? (i10.clearRect(0, 0, e10.width, e10.height), i10) : (t10.canvas = pV.createElement("canvas"), t10.context = t10.canvas.getContext("2d", {
            willReadFrequently: true
          }) || void 0, t10.context);
        }
      };
      class p9 extends pq {
        constructor() {
          super(...arguments), this.valueMax = NaN, this.valueMin = NaN, this.isDirtyCanvas = true;
        }
        drawPoints() {
          let t10 = this, e10 = t10.options, i10 = e10.interpolation, s10 = e10.marker || {};
          if (i10) {
            let {
              image: e11,
              chart: i11,
              xAxis: s11,
              yAxis: o10
            } = t10, {
              reversed: r10 = false,
              len: a10
            } = s11, {
              reversed: n10 = false,
              len: l10
            } = o10, h10 = {
              width: a10,
              height: l10
            };
            if (!e11 || t10.isDirtyData || t10.isDirtyCanvas) {
              let a11 = p5(t10), {
                canvas: l11,
                options: {
                  colsize: d10 = 1,
                  rowsize: c10 = 1
                },
                points: p4,
                points: {
                  length: u2
                }
              } = t10, g2 = i11.colorAxis && i11.colorAxis[0];
              if (l11 && a11 && g2) {
                let {
                  min: g3,
                  max: m2
                } = s11.getExtremes(), {
                  min: f2,
                  max: x2
                } = o10.getExtremes(), y2 = m2 - g3, b2 = x2 - f2, v2 = Math.round(y2 / d10 / 8 * 8), M2 = Math.round(b2 / c10 / 8 * 8), [w2, k2] = [[v2, v2 / y2, r10, "ceil"], [M2, M2 / b2, !n10, "floor"]].map(([t11, e12, i12, s12]) => i12 ? (i13) => Math[s12](t11 - e12 * i13) : (t12) => Math[s12](e12 * t12)), S2 = l11.width = v2 + 1, T2 = S2 * (l11.height = M2 + 1), C2 = (u2 - 1) / T2, A2 = new Uint8ClampedArray(4 * T2), P2 = (t11, e12) => 4 * Math.ceil(S2 * k2(e12 - f2) + w2(t11 - g3));
                t10.buildKDTree();
                for (let t11 = 0; t11 < T2; t11++) {
                  let e12 = p4[Math.ceil(C2 * t11)], {
                    x: i12,
                    y: s12
                  } = e12;
                  A2.set(p6(e12.value, e12), P2(i12, s12));
                }
                a11.putImageData(new ImageData(A2, S2), 0, 0), e11 ? e11.attr(__spreadProps(__spreadValues({}, h10), {
                  href: l11.toDataURL("image/png", 1)
                })) : (t10.directTouch = false, t10.image = i11.renderer.image(l11.toDataURL("image/png", 1)).attr(h10).add(t10.group));
              }
              t10.isDirtyCanvas = false;
            } else (e11.width !== a10 || e11.height !== l10) && e11.attr(h10);
          } else (s10.enabled || t10._hasPointMarkers) && (p$.prototype.drawPoints.call(t10), t10.points.forEach((e11) => {
            e11.graphic && (e11.graphic[t10.chart.styledMode ? "css" : "animate"](t10.colorAttribs(e11)), null === e11.value && e11.graphic.addClass("highcharts-null-point"));
          }));
        }
        getExtremes() {
          let {
            dataMin: t10,
            dataMax: e10
          } = p$.prototype.getExtremes.call(this, this.getColumn("value"));
          return p1(t10) && (this.valueMin = t10), p1(e10) && (this.valueMax = e10), p$.prototype.getExtremes.call(this);
        }
        getValidPoints(t10, e10) {
          return p$.prototype.getValidPoints.call(this, t10, e10, true);
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        init() {
          super.init.apply(this, arguments);
          let t10 = this.options;
          t10.pointRange = p3(t10.pointRange, t10.colsize || 1), this.yAxis.axisPointRange = t10.rowsize || 1, pK.ellipse = pK.circle, t10.marker && p1(t10.borderRadius) && (t10.marker.r = t10.borderRadius);
        }
        markerAttribs(t10, e10) {
          let i10 = t10.shapeArgs || {};
          if (t10.hasImage) return {
            x: t10.plotX,
            y: t10.plotY
          };
          if (e10 && "normal" !== e10) {
            let s10 = t10.options.marker || {}, o10 = this.options.marker || {}, r10 = o10.states && o10.states[e10] || {}, a10 = s10.states && s10.states[e10] || {}, n10 = (a10.width || r10.width || i10.width || 0) + (a10.widthPlus || r10.widthPlus || 0), l10 = (a10.height || r10.height || i10.height || 0) + (a10.heightPlus || r10.heightPlus || 0);
            return {
              x: (i10.x || 0) + ((i10.width || 0) - n10) / 2,
              y: (i10.y || 0) + ((i10.height || 0) - l10) / 2,
              width: n10,
              height: l10
            };
          }
          return i10;
        }
        pointAttribs(t10, e10) {
          let i10 = p$.prototype.pointAttribs.call(this, t10, e10), s10 = this.options || {}, o10 = this.chart.options.plotOptions || {}, r10 = o10.series || {}, a10 = o10.heatmap || {}, n10 = t10 && t10.options.borderColor || s10.borderColor || a10.borderColor || r10.borderColor, l10 = t10 && t10.options.borderWidth || s10.borderWidth || a10.borderWidth || r10.borderWidth || i10["stroke-width"];
          if (i10.stroke = t10 && t10.marker && t10.marker.lineColor || s10.marker && s10.marker.lineColor || n10 || this.color, i10["stroke-width"] = l10, e10 && "normal" !== e10) {
            let o11 = p2(s10.states && s10.states[e10], s10.marker && s10.marker.states && s10.marker.states[e10], t10 && t10.options.states && t10.options.states[e10] || {});
            i10.fill = o11.color || tA.parse(i10.fill).brighten(o11.brightness || 0).get(), i10.stroke = o11.lineColor || i10.stroke;
          }
          return i10;
        }
        translate() {
          let {
            borderRadius: t10,
            marker: e10
          } = this.options, i10 = e10 && e10.symbol || "rect", s10 = pK[i10] ? i10 : "rect", o10 = -1 !== ["circle", "square"].indexOf(s10);
          for (let e11 of (this.generatePoints(), this.points)) {
            let r10 = e11.getCellAttributes(), a10 = Math.min(r10.x1, r10.x2), n10 = Math.min(r10.y1, r10.y2), l10 = Math.max(Math.abs(r10.x2 - r10.x1), 0), h10 = Math.max(Math.abs(r10.y2 - r10.y1), 0);
            if (e11.hasImage = 0 === (e11.marker && e11.marker.symbol || i10 || "").indexOf("url"), o10) {
              let t11 = Math.abs(l10 - h10);
              a10 = Math.min(r10.x1, r10.x2) + (l10 < h10 ? 0 : t11 / 2), n10 = Math.min(r10.y1, r10.y2) + (l10 < h10 ? t11 / 2 : 0), l10 = h10 = Math.min(l10, h10);
            }
            e11.hasImage && (e11.marker = {
              width: l10,
              height: h10
            }), e11.plotX = e11.clientX = (r10.x1 + r10.x2) / 2, e11.plotY = (r10.y1 + r10.y2) / 2, e11.shapeType = "path", e11.shapeArgs = p2(true, {
              x: a10,
              y: n10,
              width: l10,
              height: h10
            }, {
              d: pK[s10](a10, n10, l10, h10, {
                r: p1(t10) ? t10 : 0
              })
            });
          }
          p0(this, "afterTranslate");
        }
      }
      p9.defaultOptions = p2(pq.defaultOptions, {
        animation: false,
        borderRadius: 0,
        borderWidth: 0,
        interpolation: false,
        nullColor: "#f7f7f7",
        dataLabels: {
          formatter: function() {
            let {
              numberFormatter: t10
            } = this.series.chart, {
              value: e10
            } = this.point;
            return pY(e10) ? t10(e10, -1) : "";
          },
          inside: true,
          verticalAlign: "middle",
          crop: false,
          overflow: "allow",
          padding: 0
        },
        marker: {
          symbol: "rect",
          radius: 0,
          lineColor: void 0,
          states: {
            hover: {
              lineWidthPlus: 0
            },
            select: {}
          }
        },
        clip: true,
        pointRange: null,
        tooltip: {
          pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
        },
        states: {
          hover: {
            halo: false,
            brightness: 0.2
          }
        },
        legendSymbol: "rectangle"
      }), pJ(p9, "afterDataClassLegendClick", function() {
        this.isDirtyCanvas = true, this.drawPoints();
      }), pQ(p9.prototype, {
        axisTypes: dl.seriesMembers.axisTypes,
        colorKey: dl.seriesMembers.colorKey,
        directTouch: true,
        getExtremesFromAll: true,
        keysAffectYAxis: ["y"],
        parallelArrays: dl.seriesMembers.parallelArrays,
        pointArrayMap: ["y", "value"],
        pointClass: pH,
        specialGroup: "group",
        trackerGroups: dl.seriesMembers.trackerGroups,
        alignDataLabel: p_.prototype.alignDataLabel,
        colorAttribs: dl.seriesMembers.colorAttribs,
        getSymbol: p$.prototype.getSymbol
      }), dl.compose(p9), rx.registerSeriesType("heatmap", p9), A.ColorMapComposition = dl, A.MapChart = A.MapChart || dg, A.MapNavigation = A.MapNavigation || ds, A.MapView = A.MapView || cp, A.Projection = A.Projection || d2, A.mapChart = A.Map = A.MapChart.mapChart, A.maps = A.MapChart.maps, A.geojson = dO.geojson, A.topo2geo = dO.topo2geo, dO.compose(A.Chart), pR.compose(A.Axis, A.Chart, A.Legend), ds.compose(dg, A.Pointer, A.SVGRenderer), cp.compose(dg), /**
      * @license Highmaps JS v12.1.2 (2024-12-21)
      * @module highcharts/highmaps
      *
      * (c) 2011-2024 Torstein Honsi
      *
      * License: www.highcharts.com/license
      */
      A.product = "Highmaps";
      let p8 = A;
      return C.default;
    })());
  }
});

// node_modules/highcharts/highstock.js
var require_highstock = __commonJS({
  "node_modules/highcharts/highstock.js"(exports, module) {
    !/**
    * Highcharts JS v12.1.2 (2024-12-21)
    * @module highcharts/highcharts
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? (t._Highcharts = e(), module.exports = t._Highcharts) : "function" == typeof define && define.amd ? define("highcharts/highcharts", [], e) : "object" == typeof exports ? (t._Highcharts = e(), exports.highcharts = t._Highcharts) : (t.Highcharts && t.Highcharts.error(16, true), t.Highcharts = e());
    }("undefined" == typeof window ? exports : window, () => (() => {
      "use strict";
      let t, e, i, s, o, r;
      var a, n, h, l, d, c, p, u, g, f, m, x, y, b, v, k, M, w, S, A, T, C, P, O = {};
      O.d = (t10, e10) => {
        for (var i10 in e10) O.o(e10, i10) && !O.o(t10, i10) && Object.defineProperty(t10, i10, {
          enumerable: true,
          get: e10[i10]
        });
      }, O.o = (t10, e10) => Object.prototype.hasOwnProperty.call(t10, e10);
      var E = {};
      O.d(E, {
        default: () => uH
      }), function(t10) {
        t10.SVG_NS = "http://www.w3.org/2000/svg", t10.product = "Highcharts", t10.version = "12.1.2", t10.win = "undefined" != typeof window ? window : {}, t10.doc = t10.win.document, t10.svg = t10.doc && t10.doc.createElementNS && !!t10.doc.createElementNS(t10.SVG_NS, "svg").createSVGRect, t10.pageLang = t10.doc?.documentElement?.closest("[lang]")?.lang, t10.userAgent = t10.win.navigator && t10.win.navigator.userAgent || "", t10.isChrome = t10.win.chrome, t10.isFirefox = -1 !== t10.userAgent.indexOf("Firefox"), t10.isMS = /(edge|msie|trident)/i.test(t10.userAgent) && !t10.win.opera, t10.isSafari = !t10.isChrome && -1 !== t10.userAgent.indexOf("Safari"), t10.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(t10.userAgent), t10.isWebKit = -1 !== t10.userAgent.indexOf("AppleWebKit"), t10.deg2rad = 2 * Math.PI / 360, t10.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], t10.noop = function() {
        }, t10.supportsPassiveEvents = function() {
          let e10 = false;
          if (!t10.isMS) {
            let i10 = Object.defineProperty({}, "passive", {
              get: function() {
                e10 = true;
              }
            });
            t10.win.addEventListener && t10.win.removeEventListener && (t10.win.addEventListener("testPassive", t10.noop, i10), t10.win.removeEventListener("testPassive", t10.noop, i10));
          }
          return e10;
        }(), t10.charts = [], t10.composed = [], t10.dateFormats = {}, t10.seriesTypes = {}, t10.symbolSizes = {}, t10.chartCount = 0;
      }(a || (a = {}));
      let L = a, {
        charts: D,
        doc: B,
        win: I
      } = L;
      function z(t10, e10, i10, s10) {
        let o10 = e10 ? "Highcharts error" : "Highcharts warning";
        32 === t10 && (t10 = `${o10}: Deprecated member`);
        let r10 = F(t10), a10 = r10 ? `${o10} #${t10}: www.highcharts.com/errors/${t10}/` : t10.toString();
        if (void 0 !== s10) {
          let t11 = "";
          r10 && (a10 += "?"), J(s10, function(e11, i11) {
            t11 += `
 - ${i11}: ${e11}`, r10 && (a10 += encodeURI(i11) + "=" + encodeURI(e11));
          }), a10 += t11;
        }
        tt(L, "displayError", {
          chart: i10,
          code: t10,
          message: a10,
          params: s10
        }, function() {
          if (e10) throw Error(a10);
          I.console && -1 === z.messages.indexOf(a10) && console.warn(a10);
        }), z.messages.push(a10);
      }
      function R(t10, e10) {
        return parseInt(t10, e10 || 10);
      }
      function N(t10) {
        return "string" == typeof t10;
      }
      function W(t10) {
        let e10 = Object.prototype.toString.call(t10);
        return "[object Array]" === e10 || "[object Array Iterator]" === e10;
      }
      function G(t10, e10) {
        return !!t10 && "object" == typeof t10 && (!e10 || !W(t10));
      }
      function X(t10) {
        return G(t10) && "number" == typeof t10.nodeType;
      }
      function H(t10) {
        let e10 = t10 && t10.constructor;
        return !!(G(t10, true) && !X(t10) && e10 && e10.name && "Object" !== e10.name);
      }
      function F(t10) {
        return "number" == typeof t10 && !isNaN(t10) && t10 < 1 / 0 && t10 > -1 / 0;
      }
      function Y(t10) {
        return null != t10;
      }
      function j(t10, e10, i10) {
        let s10;
        let o10 = N(e10) && !Y(i10), r10 = (e11, i11) => {
          Y(e11) ? t10.setAttribute(i11, e11) : o10 ? (s10 = t10.getAttribute(i11)) || "class" !== i11 || (s10 = t10.getAttribute(i11 + "Name")) : t10.removeAttribute(i11);
        };
        return N(e10) ? r10(i10, e10) : J(e10, r10), s10;
      }
      function U(t10) {
        return W(t10) ? t10 : [t10];
      }
      function V(t10, e10) {
        let i10;
        for (i10 in t10 || (t10 = {}), e10) t10[i10] = e10[i10];
        return t10;
      }
      function _() {
        let t10 = arguments, e10 = t10.length;
        for (let i10 = 0; i10 < e10; i10++) {
          let e11 = t10[i10];
          if (null != e11) return e11;
        }
      }
      function $(t10, e10) {
        V(t10.style, e10);
      }
      function Z(t10) {
        return Math.pow(10, Math.floor(Math.log(t10) / Math.LN10));
      }
      function q(t10, e10) {
        return t10 > 1e14 ? t10 : parseFloat(t10.toPrecision(e10 || 14));
      }
      (z || (z = {})).messages = [], Math.easeInOutSine = function(t10) {
        return -0.5 * (Math.cos(Math.PI * t10) - 1);
      };
      let K = Array.prototype.find ? function(t10, e10) {
        return t10.find(e10);
      } : function(t10, e10) {
        let i10;
        let s10 = t10.length;
        for (i10 = 0; i10 < s10; i10++) if (e10(t10[i10], i10)) return t10[i10];
      };
      function J(t10, e10, i10) {
        for (let s10 in t10) Object.hasOwnProperty.call(t10, s10) && e10.call(i10 || t10[s10], t10[s10], s10, t10);
      }
      function Q(t10, e10, i10) {
        function s10(e11, i11) {
          let s11 = t10.removeEventListener;
          s11 && s11.call(t10, e11, i11, false);
        }
        function o10(i11) {
          let o11, r11;
          t10.nodeName && (e10 ? (o11 = {})[e10] = true : o11 = i11, J(o11, function(t11, e11) {
            if (i11[e11]) for (r11 = i11[e11].length; r11--; ) s10(e11, i11[e11][r11].fn);
          }));
        }
        let r10 = "function" == typeof t10 && t10.prototype || t10;
        if (Object.hasOwnProperty.call(r10, "hcEvents")) {
          let t11 = r10.hcEvents;
          if (e10) {
            let r11 = t11[e10] || [];
            i10 ? (t11[e10] = r11.filter(function(t12) {
              return i10 !== t12.fn;
            }), s10(e10, i10)) : (o10(t11), t11[e10] = []);
          } else o10(t11), delete r10.hcEvents;
        }
      }
      function tt(t10, e10, i10, s10) {
        if (i10 = i10 || {}, B.createEvent && (t10.dispatchEvent || t10.fireEvent && t10 !== L)) {
          let s11 = B.createEvent("Events");
          s11.initEvent(e10, true, true), i10 = V(s11, i10), t10.dispatchEvent ? t10.dispatchEvent(i10) : t10.fireEvent(e10, i10);
        } else if (t10.hcEvents) {
          i10.target || V(i10, {
            preventDefault: function() {
              i10.defaultPrevented = true;
            },
            target: t10,
            type: e10
          });
          let s11 = [], o10 = t10, r10 = false;
          for (; o10.hcEvents; ) Object.hasOwnProperty.call(o10, "hcEvents") && o10.hcEvents[e10] && (s11.length && (r10 = true), s11.unshift.apply(s11, o10.hcEvents[e10])), o10 = Object.getPrototypeOf(o10);
          r10 && s11.sort((t11, e11) => t11.order - e11.order), s11.forEach((e11) => {
            false === e11.fn.call(t10, i10) && i10.preventDefault();
          });
        }
        s10 && !i10.defaultPrevented && s10.call(t10, i10);
      }
      let te = function() {
        let e10 = Math.random().toString(36).substring(2, 9) + "-", i10 = 0;
        return function() {
          return "highcharts-" + (t ? "" : e10) + i10++;
        };
      }();
      I.jQuery && (I.jQuery.fn.highcharts = function() {
        let t10 = [].slice.call(arguments);
        if (this[0]) return t10[0] ? (new L[N(t10[0]) ? t10.shift() : "Chart"](this[0], t10[0], t10[1]), this) : D[j(this[0], "data-highcharts-chart")];
      });
      let ti = {
        addEvent: function(t10, e10, i10, s10 = {}) {
          let o10 = "function" == typeof t10 && t10.prototype || t10;
          Object.hasOwnProperty.call(o10, "hcEvents") || (o10.hcEvents = {});
          let r10 = o10.hcEvents;
          L.Point && t10 instanceof L.Point && t10.series && t10.series.chart && (t10.series.chart.runTrackerClick = true);
          let a10 = t10.addEventListener;
          a10 && a10.call(t10, e10, i10, !!L.supportsPassiveEvents && {
            passive: void 0 === s10.passive ? -1 !== e10.indexOf("touch") : s10.passive,
            capture: false
          }), r10[e10] || (r10[e10] = []);
          let n10 = {
            fn: i10,
            order: "number" == typeof s10.order ? s10.order : 1 / 0
          };
          return r10[e10].push(n10), r10[e10].sort((t11, e11) => t11.order - e11.order), function() {
            Q(t10, e10, i10);
          };
        },
        arrayMax: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] > i10 && (i10 = t10[e10]);
          return i10;
        },
        arrayMin: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] < i10 && (i10 = t10[e10]);
          return i10;
        },
        attr: j,
        clamp: function(t10, e10, i10) {
          return t10 > e10 ? t10 < i10 ? t10 : i10 : e10;
        },
        clearTimeout: function(t10) {
          Y(t10) && clearTimeout(t10);
        },
        correctFloat: q,
        createElement: function(t10, e10, i10, s10, o10) {
          let r10 = B.createElement(t10);
          return e10 && V(r10, e10), o10 && $(r10, {
            padding: "0",
            border: "none",
            margin: "0"
          }), i10 && $(r10, i10), s10 && s10.appendChild(r10), r10;
        },
        crisp: function(t10, e10 = 0, i10) {
          let s10 = e10 % 2 / 2, o10 = i10 ? -1 : 1;
          return (Math.round(t10 * o10 - s10) + s10) * o10;
        },
        css: $,
        defined: Y,
        destroyObjectProperties: function(t10, e10, i10) {
          J(t10, function(s10, o10) {
            s10 !== e10 && s10?.destroy && s10.destroy(), (s10?.destroy || !i10) && delete t10[o10];
          });
        },
        diffObjects: function(t10, e10, i10, s10) {
          let o10 = {};
          return !function t11(e11, o11, r10, a10) {
            let n10 = i10 ? o11 : e11;
            J(e11, function(i11, h10) {
              if (!a10 && s10 && s10.indexOf(h10) > -1 && o11[h10]) {
                i11 = U(i11), r10[h10] = [];
                for (let e12 = 0; e12 < Math.max(i11.length, o11[h10].length); e12++) o11[h10][e12] && (void 0 === i11[e12] ? r10[h10][e12] = o11[h10][e12] : (r10[h10][e12] = {}, t11(i11[e12], o11[h10][e12], r10[h10][e12], a10 + 1)));
              } else G(i11, true) && !i11.nodeType ? (r10[h10] = W(i11) ? [] : {}, t11(i11, o11[h10] || {}, r10[h10], a10 + 1), 0 !== Object.keys(r10[h10]).length || "colorAxis" === h10 && 0 === a10 || delete r10[h10]) : (e11[h10] !== o11[h10] || h10 in e11 && !(h10 in o11)) && "__proto__" !== h10 && "constructor" !== h10 && (r10[h10] = n10[h10]);
            });
          }(t10, e10, o10, 0), o10;
        },
        discardElement: function(t10) {
          t10 && t10.parentElement && t10.parentElement.removeChild(t10);
        },
        erase: function(t10, e10) {
          let i10 = t10.length;
          for (; i10--; ) if (t10[i10] === e10) {
            t10.splice(i10, 1);
            break;
          }
        },
        error: z,
        extend: V,
        extendClass: function(t10, e10) {
          let i10 = function() {
          };
          return i10.prototype = new t10(), V(i10.prototype, e10), i10;
        },
        find: K,
        fireEvent: tt,
        getAlignFactor: (t10 = "") => ({
          center: 0.5,
          right: 1,
          middle: 0.5,
          bottom: 1
        })[t10] || 0,
        getClosestDistance: function(t10, e10) {
          let i10, s10, o10, r10;
          let a10 = !e10;
          return t10.forEach((t11) => {
            if (t11.length > 1) for (r10 = s10 = t11.length - 1; r10 > 0; r10--) (o10 = t11[r10] - t11[r10 - 1]) < 0 && !a10 ? (e10?.(), e10 = void 0) : o10 && (void 0 === i10 || o10 < i10) && (i10 = o10);
          }), i10;
        },
        getMagnitude: Z,
        getNestedProperty: function(t10, e10) {
          let i10 = t10.split(".");
          for (; i10.length && Y(e10); ) {
            let t11 = i10.shift();
            if (void 0 === t11 || "__proto__" === t11) return;
            if ("this" === t11) {
              let t12;
              return G(e10) && (t12 = e10["@this"]), t12 ?? e10;
            }
            let s10 = e10[t11.replace(/[\\'"]/g, "")];
            if (!Y(s10) || "function" == typeof s10 || "number" == typeof s10.nodeType || s10 === I) return;
            e10 = s10;
          }
          return e10;
        },
        getStyle: function t10(e10, i10, s10) {
          let o10;
          if ("width" === i10) {
            let i11 = Math.min(e10.offsetWidth, e10.scrollWidth), s11 = e10.getBoundingClientRect && e10.getBoundingClientRect().width;
            return s11 < i11 && s11 >= i11 - 1 && (i11 = Math.floor(s11)), Math.max(0, i11 - (t10(e10, "padding-left", true) || 0) - (t10(e10, "padding-right", true) || 0));
          }
          if ("height" === i10) return Math.max(0, Math.min(e10.offsetHeight, e10.scrollHeight) - (t10(e10, "padding-top", true) || 0) - (t10(e10, "padding-bottom", true) || 0));
          let r10 = I.getComputedStyle(e10, void 0);
          return r10 && (o10 = r10.getPropertyValue(i10), _(s10, "opacity" !== i10) && (o10 = R(o10))), o10;
        },
        insertItem: function(t10, e10) {
          let i10;
          let s10 = t10.options.index, o10 = e10.length;
          for (i10 = t10.options.isInternal ? o10 : 0; i10 < o10 + 1; i10++) if (!e10[i10] || F(s10) && s10 < _(e10[i10].options.index, e10[i10]._i) || e10[i10].options.isInternal) {
            e10.splice(i10, 0, t10);
            break;
          }
          return i10;
        },
        isArray: W,
        isClass: H,
        isDOMElement: X,
        isFunction: function(t10) {
          return "function" == typeof t10;
        },
        isNumber: F,
        isObject: G,
        isString: N,
        merge: function(t10, ...e10) {
          let i10, s10 = [t10, ...e10], o10 = {}, r10 = function(t11, e11) {
            return "object" != typeof t11 && (t11 = {}), J(e11, function(i11, s11) {
              "__proto__" !== s11 && "constructor" !== s11 && (!G(i11, true) || H(i11) || X(i11) ? t11[s11] = e11[s11] : t11[s11] = r10(t11[s11] || {}, i11));
            }), t11;
          };
          true === t10 && (o10 = s10[1], s10 = Array.prototype.slice.call(s10, 2));
          let a10 = s10.length;
          for (i10 = 0; i10 < a10; i10++) o10 = r10(o10, s10[i10]);
          return o10;
        },
        normalizeTickInterval: function(t10, e10, i10, s10, o10) {
          let r10, a10 = t10;
          i10 = _(i10, Z(t10));
          let n10 = t10 / i10;
          for (!e10 && (e10 = o10 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === s10 && (1 === i10 ? e10 = e10.filter(function(t11) {
            return t11 % 1 == 0;
          }) : i10 <= 0.1 && (e10 = [1 / i10]))), r10 = 0; r10 < e10.length && (a10 = e10[r10], (!o10 || !(a10 * i10 >= t10)) && (o10 || !(n10 <= (e10[r10] + (e10[r10 + 1] || e10[r10])) / 2))); r10++) ;
          return q(a10 * i10, -Math.round(Math.log(1e-3) / Math.LN10));
        },
        objectEach: J,
        offset: function(t10) {
          let e10 = B.documentElement, i10 = t10.parentElement || t10.parentNode ? t10.getBoundingClientRect() : {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          };
          return {
            top: i10.top + (I.pageYOffset || e10.scrollTop) - (e10.clientTop || 0),
            left: i10.left + (I.pageXOffset || e10.scrollLeft) - (e10.clientLeft || 0),
            width: i10.width,
            height: i10.height
          };
        },
        pad: function(t10, e10, i10) {
          return Array((e10 || 2) + 1 - String(t10).replace("-", "").length).join(i10 || "0") + t10;
        },
        pick: _,
        pInt: R,
        pushUnique: function(t10, e10) {
          return 0 > t10.indexOf(e10) && !!t10.push(e10);
        },
        relativeLength: function(t10, e10, i10) {
          return /%$/.test(t10) ? e10 * parseFloat(t10) / 100 + (i10 || 0) : parseFloat(t10);
        },
        removeEvent: Q,
        replaceNested: function(t10, ...e10) {
          let i10, s10;
          do
            for (s10 of (i10 = t10, e10)) t10 = t10.replace(s10[0], s10[1]);
          while (t10 !== i10);
          return t10;
        },
        splat: U,
        stableSort: function(t10, e10) {
          let i10, s10;
          let o10 = t10.length;
          for (s10 = 0; s10 < o10; s10++) t10[s10].safeI = s10;
          for (t10.sort(function(t11, s11) {
            return 0 === (i10 = e10(t11, s11)) ? t11.safeI - s11.safeI : i10;
          }), s10 = 0; s10 < o10; s10++) delete t10[s10].safeI;
        },
        syncTimeout: function(t10, e10, i10) {
          return e10 > 0 ? setTimeout(t10, e10, i10) : (t10.call(0, i10), -1);
        },
        timeUnits: {
          millisecond: 1,
          second: 1e3,
          minute: 6e4,
          hour: 36e5,
          day: 864e5,
          week: 6048e5,
          month: 24192e5,
          year: 314496e5
        },
        ucfirst: function(t10) {
          return N(t10) ? t10.substring(0, 1).toUpperCase() + t10.substring(1) : String(t10);
        },
        uniqueKey: te,
        useSerialIds: function(e10) {
          return t = _(e10, t);
        },
        wrap: function(t10, e10, i10) {
          let s10 = t10[e10];
          t10[e10] = function() {
            let t11 = arguments, e11 = this;
            return i10.apply(this, [function() {
              return s10.apply(e11, arguments.length ? arguments : t11);
            }].concat([].slice.call(arguments)));
          };
        }
      }, {
        pageLang: ts,
        win: to
      } = L, {
        defined: tr,
        error: ta,
        extend: tn,
        isNumber: th,
        isObject: tl,
        isString: td,
        merge: tc,
        objectEach: tp,
        pad: tu,
        splat: tg,
        timeUnits: tf,
        ucfirst: tm
      } = ti, tx = L.isSafari && to.Intl && !to.Intl.DateTimeFormat.prototype.formatRange, ty = (t10) => void 0 === t10.main, tb = (t10) => ["D", "L", "M", "X", "J", "V", "S"].indexOf(t10), tv = class {
        constructor(t10) {
          this.options = {
            timezone: "UTC"
          }, this.variableTimezone = false, this.Date = to.Date, this.update(t10);
        }
        update(t10 = {}) {
          this.dTLCache = {}, this.options = t10 = tc(true, this.options, t10);
          let {
            timezoneOffset: e10,
            useUTC: i10
          } = t10;
          this.Date = t10.Date || to.Date || Date;
          let s10 = t10.timezone;
          tr(i10) && (s10 = i10 ? "UTC" : void 0), e10 && e10 % 60 == 0 && (s10 = "Etc/GMT" + (e10 > 0 ? "+" : "") + e10 / 60), this.variableTimezone = "UTC" !== s10 && s10?.indexOf("Etc/GMT") !== 0, this.timezone = s10, ["months", "shortMonths", "weekdays", "shortWeekdays"].forEach((t11) => {
            let e11 = /months/i.test(t11), i11 = /short/.test(t11), s11 = {
              timeZone: "UTC"
            };
            s11[e11 ? "month" : "weekday"] = i11 ? "short" : "long", this[t11] = (e11 ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map((t12) => this.dateFormat(s11, (e11 ? 31 : 1) * 24 * 36e5 * t12));
          });
        }
        toParts(t10) {
          let [e10, i10, s10, o10, r10, a10, n10] = this.dateTimeFormat({
            weekday: "narrow",
            day: "numeric",
            month: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
          }, t10, "es").split(/(?:, |\/|:)/g);
          return [o10, +s10 - 1, i10, r10, a10, n10, Math.floor(Number(t10) || 0) % 1e3, tb(e10)].map(Number);
        }
        dateTimeFormat(t10, e10, i10 = this.options.locale || ts) {
          let s10 = JSON.stringify(t10) + i10;
          td(t10) && (t10 = this.str2dtf(t10));
          let o10 = this.dTLCache[s10];
          if (!o10) {
            t10.timeZone ?? (t10.timeZone = this.timezone);
            try {
              o10 = new Intl.DateTimeFormat(i10, t10);
            } catch (e11) {
              /Invalid time zone/i.test(e11.message) ? (ta(34), t10.timeZone = "UTC", o10 = new Intl.DateTimeFormat(i10, t10)) : ta(e11.message, false);
            }
          }
          return this.dTLCache[s10] = o10, o10?.format(e10) || "";
        }
        str2dtf(t10, e10 = {}) {
          let i10 = {
            L: {
              fractionalSecondDigits: 3
            },
            S: {
              second: "2-digit"
            },
            M: {
              minute: "numeric"
            },
            H: {
              hour: "2-digit"
            },
            k: {
              hour: "numeric"
            },
            E: {
              weekday: "narrow"
            },
            a: {
              weekday: "short"
            },
            A: {
              weekday: "long"
            },
            d: {
              day: "2-digit"
            },
            e: {
              day: "numeric"
            },
            b: {
              month: "short"
            },
            B: {
              month: "long"
            },
            m: {
              month: "2-digit"
            },
            o: {
              month: "numeric"
            },
            y: {
              year: "2-digit"
            },
            Y: {
              year: "numeric"
            }
          };
          return Object.keys(i10).forEach((s10) => {
            -1 !== t10.indexOf(s10) && tn(e10, i10[s10]);
          }), e10;
        }
        makeTime(t10, e10, i10 = 1, s10 = 0, o10, r10, a10) {
          let n10 = this.Date.UTC(t10, e10, i10, s10, o10 || 0, r10 || 0, a10 || 0);
          if ("UTC" !== this.timezone) {
            let t11 = this.getTimezoneOffset(n10);
            if (n10 += t11, -1 !== [2, 3, 8, 9, 10, 11].indexOf(e10) && (s10 < 5 || s10 > 20)) {
              let e11 = this.getTimezoneOffset(n10);
              t11 !== e11 ? n10 += e11 - t11 : t11 - 36e5 !== this.getTimezoneOffset(n10 - 36e5) || tx || (n10 -= 36e5);
            }
          }
          return n10;
        }
        parse(t10) {
          if (!td(t10)) return t10 ?? void 0;
          let e10 = (t10 = t10.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t10), i10 = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(t10);
          e10 || i10 || (t10 += "Z");
          let s10 = Date.parse(t10);
          if (th(s10)) return s10 + (!e10 || i10 ? this.getTimezoneOffset(s10) : 0);
        }
        getTimezoneOffset(t10) {
          if ("UTC" !== this.timezone) {
            let [e10, i10, s10, o10, r10 = 0] = this.dateTimeFormat({
              timeZoneName: "shortOffset"
            }, t10, "en").split(/(GMT|:)/).map(Number), a10 = -(36e5 * (s10 + r10 / 60));
            if (th(a10)) return a10;
          }
          return 0;
        }
        dateFormat(t10, e10, i10) {
          let s10 = L.defaultOptions?.lang;
          if (!tr(e10) || isNaN(e10)) return s10?.invalidDate || "";
          if (td(t10 = t10 ?? "%Y-%m-%d %H:%M:%S")) {
            let i11;
            let s11 = /%\[([a-zA-Z]+)\]/g;
            for (; i11 = s11.exec(t10); ) t10 = t10.replace(i11[0], this.dateTimeFormat(i11[1], e10));
          }
          if (td(t10) && -1 !== t10.indexOf("%")) {
            let i11 = this, [o10, r10, a10, n10, h10, l10, d10, c10] = this.toParts(e10), p10 = s10?.weekdays || this.weekdays, u2 = s10?.shortWeekdays || this.shortWeekdays, g2 = s10?.months || this.months, f2 = s10?.shortMonths || this.shortMonths;
            tp(tn({
              a: u2 ? u2[c10] : p10[c10].substr(0, 3),
              A: p10[c10],
              d: tu(a10),
              e: tu(a10, 2, " "),
              w: c10,
              b: f2[r10],
              B: g2[r10],
              m: tu(r10 + 1),
              o: r10 + 1,
              y: o10.toString().substr(2, 2),
              Y: o10,
              H: tu(n10),
              k: n10,
              I: tu(n10 % 12 || 12),
              l: n10 % 12 || 12,
              M: tu(h10),
              p: n10 < 12 ? "AM" : "PM",
              P: n10 < 12 ? "am" : "pm",
              S: tu(l10),
              L: tu(d10, 3)
            }, L.dateFormats), function(s11, o11) {
              if (td(t10)) for (; -1 !== t10.indexOf("%" + o11); ) t10 = t10.replace("%" + o11, "function" == typeof s11 ? s11.call(i11, e10) : s11);
            });
          } else if (tl(t10)) {
            let i11 = (this.getTimezoneOffset(e10) || 0) / 36e5, s11 = this.timezone || "Etc/GMT" + (i11 >= 0 ? "+" : "") + i11, {
              prefix: o10 = "",
              suffix: r10 = ""
            } = t10;
            t10 = o10 + this.dateTimeFormat(tn({
              timeZone: s11
            }, t10), e10) + r10;
          }
          return i10 ? tm(t10) : t10;
        }
        resolveDTLFormat(t10) {
          return tl(t10, true) ? tl(t10, true) && ty(t10) ? {
            main: t10
          } : t10 : {
            main: (t10 = tg(t10))[0],
            from: t10[1],
            to: t10[2]
          };
        }
        getTimeTicks(t10, e10, i10, s10) {
          let o10 = this, r10 = [], a10 = {}, {
            count: n10 = 1,
            unitRange: h10
          } = t10, [l10, d10, c10, p10, u2, g2] = o10.toParts(e10), f2 = (e10 || 0) % 1e3, m2;
          if (s10 ?? (s10 = 1), tr(e10)) {
            if (f2 = h10 >= tf.second ? 0 : n10 * Math.floor(f2 / n10), h10 >= tf.second && (g2 = h10 >= tf.minute ? 0 : n10 * Math.floor(g2 / n10)), h10 >= tf.minute && (u2 = h10 >= tf.hour ? 0 : n10 * Math.floor(u2 / n10)), h10 >= tf.hour && (p10 = h10 >= tf.day ? 0 : n10 * Math.floor(p10 / n10)), h10 >= tf.day && (c10 = h10 >= tf.month ? 1 : Math.max(1, n10 * Math.floor(c10 / n10))), h10 >= tf.month && (d10 = h10 >= tf.year ? 0 : n10 * Math.floor(d10 / n10)), h10 >= tf.year && (l10 -= l10 % n10), h10 === tf.week) {
              n10 && (e10 = o10.makeTime(l10, d10, c10, p10, u2, g2, f2));
              let t12 = tb(this.dateTimeFormat({
                timeZone: this.timezone,
                weekday: "narrow"
              }, e10, "es"));
              c10 += -t12 + s10 + (t12 < s10 ? -7 : 0);
            }
            e10 = o10.makeTime(l10, d10, c10, p10, u2, g2, f2), o10.variableTimezone && tr(i10) && (m2 = i10 - e10 > 4 * tf.month || o10.getTimezoneOffset(e10) !== o10.getTimezoneOffset(i10));
            let t11 = e10, x2 = 1;
            for (; t11 < i10; ) r10.push(t11), h10 === tf.year ? t11 = o10.makeTime(l10 + x2 * n10, 0) : h10 === tf.month ? t11 = o10.makeTime(l10, d10 + x2 * n10) : m2 && (h10 === tf.day || h10 === tf.week) ? t11 = o10.makeTime(l10, d10, c10 + x2 * n10 * (h10 === tf.day ? 1 : 7)) : m2 && h10 === tf.hour && n10 > 1 ? t11 = o10.makeTime(l10, d10, c10, p10 + x2 * n10) : t11 += h10 * n10, x2++;
            r10.push(t11), h10 <= tf.hour && r10.length < 1e4 && r10.forEach((t12) => {
              t12 % 18e5 == 0 && "000000000" === o10.dateFormat("%H%M%S%L", t12) && (a10[t12] = "day");
            });
          }
          return r10.info = tn(t10, {
            higherRanks: a10,
            totalRange: h10 * n10
          }), r10;
        }
        getDateFormat(t10, e10, i10, s10) {
          let o10 = this.dateFormat("%m-%d %H:%M:%S.%L", e10), r10 = "01-01 00:00:00.000", a10 = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          }, n10 = "millisecond", h10 = n10;
          for (n10 in tf) {
            if (t10 === tf.week && +this.dateFormat("%w", e10) === i10 && o10.substr(6) === r10.substr(6)) {
              n10 = "week";
              break;
            }
            if (tf[n10] > t10) {
              n10 = h10;
              break;
            }
            if (a10[n10] && o10.substr(a10[n10]) !== r10.substr(a10[n10])) break;
            "week" !== n10 && (h10 = n10);
          }
          return this.resolveDTLFormat(s10[n10]).main;
        }
      }, {
        isTouchDevice: tk
      } = L, {
        fireEvent: tM,
        merge: tw
      } = ti, tS = {
        colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"],
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          locale: void 0,
          loading: "Loading...",
          months: void 0,
          shortMonths: void 0,
          weekdays: void 0,
          numericSymbols: ["k", "M", "G", "T", "P", "E"],
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1"
        },
        global: {
          buttonTheme: {
            fill: "#f7f7f7",
            padding: 8,
            r: 2,
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontSize: "0.8em",
              fontWeight: "normal"
            },
            states: {
              hover: {
                fill: "#e6e6e6"
              },
              select: {
                fill: "#e6e9ff",
                style: {
                  color: "#000000",
                  fontWeight: "bold"
                }
              },
              disabled: {
                style: {
                  color: "#cccccc"
                }
              }
            }
          }
        },
        time: {
          Date: void 0,
          timezone: "UTC",
          timezoneOffset: 0,
          useUTC: void 0
        },
        chart: {
          alignThresholds: false,
          panning: {
            enabled: false,
            type: "x"
          },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: {
            theme: {},
            position: {}
          },
          reflow: true,
          type: "line",
          zooming: {
            singleTouch: false,
            resetButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            }
          },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        },
        title: {
          style: {
            color: "#333333",
            fontWeight: "bold"
          },
          text: "Chart title",
          margin: 15,
          minScale: 0.67
        },
        subtitle: {
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: ""
        },
        caption: {
          margin: 15,
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        legend: {
          enabled: true,
          align: "center",
          alignColumns: true,
          className: "highcharts-no-tooltip",
          events: {},
          layout: "horizontal",
          itemMarginBottom: 2,
          itemMarginTop: 2,
          labelFormatter: function() {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            style: {
              fontSize: "0.8em"
            },
            activeColor: "#0022ff",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "0.8em",
            textDecoration: "none",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#666666",
            textDecoration: "line-through"
          },
          shadow: false,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: true,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontSize: "0.8em",
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: 0.5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: true,
          animation: {
            duration: 300,
            easing: (t10) => Math.sqrt(1 - Math.pow(t10 - 1, 2))
          },
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%[AebHMSL]",
            second: "%[AebHMS]",
            minute: "%[AebHM]",
            hour: "%[AebHM]",
            day: "%[AebY]",
            week: "Week from %[AebY]",
            month: "%[BY]",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: false,
          snap: tk ? 25 : 10,
          headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: "#ffffff",
          borderWidth: void 0,
          shadow: true,
          stickOnContact: false,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "0.8em"
          },
          useHTML: false
        },
        credits: {
          enabled: true,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "0.6em"
          },
          text: "Highcharts.com"
        }
      }, tA = new tv(tS.time), tT = {
        defaultOptions: tS,
        defaultTime: tA,
        getOptions: function() {
          return tS;
        },
        setOptions: function(t10) {
          return tM(L, "setOptions", {
            options: t10
          }), tw(true, tS, t10), t10.time && tA.update(tS.time), t10.lang && "locale" in t10.lang && tA.update({
            locale: t10.lang.locale
          }), tS;
        }
      }, {
        isNumber: tC,
        merge: tP,
        pInt: tO,
        defined: tE
      } = ti;
      class tL {
        static parse(t10) {
          return t10 ? new tL(t10) : tL.None;
        }
        constructor(t10) {
          let e10, i10, s10, o10;
          this.rgba = [NaN, NaN, NaN, NaN], this.input = t10;
          let r10 = L.Color;
          if (r10 && r10 !== tL) return new r10(t10);
          if ("object" == typeof t10 && void 0 !== t10.stops) this.stops = t10.stops.map((t11) => new tL(t11[1]));
          else if ("string" == typeof t10) for (this.input = t10 = tL.names[t10.toLowerCase()] || t10, s10 = tL.parsers.length; s10-- && !i10; ) (e10 = (o10 = tL.parsers[s10]).regex.exec(t10)) && (i10 = o10.parse(e10));
          i10 && (this.rgba = i10);
        }
        get(t10) {
          let e10 = this.input, i10 = this.rgba;
          if ("object" == typeof e10 && void 0 !== this.stops) {
            let i11 = tP(e10);
            return i11.stops = [].slice.call(i11.stops), this.stops.forEach((e11, s10) => {
              i11.stops[s10] = [i11.stops[s10][0], e11.get(t10)];
            }), i11;
          }
          return i10 && tC(i10[0]) ? "rgb" !== t10 && (t10 || 1 !== i10[3]) ? "a" === t10 ? `${i10[3]}` : "rgba(" + i10.join(",") + ")" : "rgb(" + i10[0] + "," + i10[1] + "," + i10[2] + ")" : e10;
        }
        brighten(t10) {
          let e10 = this.rgba;
          if (this.stops) this.stops.forEach(function(e11) {
            e11.brighten(t10);
          });
          else if (tC(t10) && 0 !== t10) for (let i10 = 0; i10 < 3; i10++) e10[i10] += tO(255 * t10), e10[i10] < 0 && (e10[i10] = 0), e10[i10] > 255 && (e10[i10] = 255);
          return this;
        }
        setOpacity(t10) {
          return this.rgba[3] = t10, this;
        }
        tweenTo(t10, e10) {
          let i10 = this.rgba, s10 = t10.rgba;
          if (!tC(i10[0]) || !tC(s10[0])) return t10.input || "none";
          let o10 = 1 !== s10[3] || 1 !== i10[3], r10 = (t11, s11) => t11 + (i10[s11] - t11) * (1 - e10), a10 = s10.slice(0, 3).map(r10).map(Math.round);
          return o10 && a10.push(r10(s10[3], 3)), (o10 ? "rgba(" : "rgb(") + a10.join(",") + ")";
        }
      }
      tL.names = {
        white: "#ffffff",
        black: "#000000"
      }, tL.parsers = [{
        regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
        parse: function(t10) {
          return [tO(t10[1]), tO(t10[2]), tO(t10[3]), parseFloat(t10[4], 10)];
        }
      }, {
        regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
        parse: function(t10) {
          return [tO(t10[1]), tO(t10[2]), tO(t10[3]), 1];
        }
      }, {
        regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
        parse: function(t10) {
          return [tO(t10[1] + t10[1], 16), tO(t10[2] + t10[2], 16), tO(t10[3] + t10[3], 16), tE(t10[4]) ? tO(t10[4] + t10[4], 16) / 255 : 1];
        }
      }, {
        regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
        parse: function(t10) {
          return [tO(t10[1], 16), tO(t10[2], 16), tO(t10[3], 16), tE(t10[4]) ? tO(t10[4], 16) / 255 : 1];
        }
      }], tL.None = new tL("");
      let {
        parse: tD
      } = tL, {
        win: tB
      } = L, {
        isNumber: tI,
        objectEach: tz
      } = ti;
      class tR {
        constructor(t10, e10, i10) {
          this.pos = NaN, this.options = e10, this.elem = t10, this.prop = i10;
        }
        dSetter() {
          let t10 = this.paths, e10 = t10 && t10[0], i10 = t10 && t10[1], s10 = this.now || 0, o10 = [];
          if (1 !== s10 && e10 && i10) {
            if (e10.length === i10.length && s10 < 1) for (let t11 = 0; t11 < i10.length; t11++) {
              let r10 = e10[t11], a10 = i10[t11], n10 = [];
              for (let t12 = 0; t12 < a10.length; t12++) {
                let e11 = r10[t12], i11 = a10[t12];
                tI(e11) && tI(i11) && !("A" === a10[0] && (4 === t12 || 5 === t12)) ? n10[t12] = e11 + s10 * (i11 - e11) : n10[t12] = i11;
              }
              o10.push(n10);
            }
            else o10 = i10;
          } else o10 = this.toD || [];
          this.elem.attr("d", o10, void 0, true);
        }
        update() {
          let t10 = this.elem, e10 = this.prop, i10 = this.now, s10 = this.options.step;
          this[e10 + "Setter"] ? this[e10 + "Setter"]() : t10.attr ? t10.element && t10.attr(e10, i10, null, true) : t10.style[e10] = i10 + this.unit, s10 && s10.call(t10, i10, this);
        }
        run(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = function(t11) {
            return !r10.stopped && s10.step(t11);
          }, a10 = tB.requestAnimationFrame || function(t11) {
            setTimeout(t11, 13);
          }, n10 = function() {
            for (let t11 = 0; t11 < tR.timers.length; t11++) tR.timers[t11]() || tR.timers.splice(t11--, 1);
            tR.timers.length && a10(n10);
          };
          t10 !== e10 || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = t10, this.end = e10, this.unit = i10, this.now = this.start, this.pos = 0, r10.elem = this.elem, r10.prop = this.prop, r10() && 1 === tR.timers.push(r10) && a10(n10)) : (delete o10.curAnim[this.prop], o10.complete && 0 === Object.keys(o10.curAnim).length && o10.complete.call(this.elem));
        }
        step(t10) {
          let e10, i10;
          let s10 = +/* @__PURE__ */ new Date(), o10 = this.options, r10 = this.elem, a10 = o10.complete, n10 = o10.duration, h10 = o10.curAnim;
          return r10.attr && !r10.element ? e10 = false : t10 || s10 >= n10 + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h10[this.prop] = true, i10 = true, tz(h10, function(t11) {
            true !== t11 && (i10 = false);
          }), i10 && a10 && a10.call(r10), e10 = false) : (this.pos = o10.easing((s10 - this.startTime) / n10), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e10 = true), e10;
        }
        initPath(t10, e10, i10) {
          let s10 = t10.startX, o10 = t10.endX, r10 = i10.slice(), a10 = t10.isArea, n10 = a10 ? 2 : 1, h10 = e10 && i10.length > e10.length && i10.hasStackedCliffs, l10, d10, c10, p10, u2 = e10 && e10.slice();
          if (!u2 || h10) return [r10, r10];
          function g2(t11, e11) {
            for (; t11.length < d10; ) {
              let i11 = t11[0], s11 = e11[d10 - t11.length];
              if (s11 && "M" === i11[0] && ("C" === s11[0] ? t11[0] = ["C", i11[1], i11[2], i11[1], i11[2], i11[1], i11[2]] : t11[0] = ["L", i11[1], i11[2]]), t11.unshift(i11), a10) {
                let e12 = t11.pop();
                t11.push(t11[t11.length - 1], e12);
              }
            }
          }
          function f2(t11) {
            for (; t11.length < d10; ) {
              let e11 = t11[Math.floor(t11.length / n10) - 1].slice();
              if ("C" === e11[0] && (e11[1] = e11[5], e11[2] = e11[6]), a10) {
                let i11 = t11[Math.floor(t11.length / n10)].slice();
                t11.splice(t11.length / 2, 0, e11, i11);
              } else t11.push(e11);
            }
          }
          if (s10 && o10 && o10.length) {
            for (c10 = 0; c10 < s10.length; c10++) {
              if (s10[c10] === o10[0]) {
                l10 = c10;
                break;
              }
              if (s10[0] === o10[o10.length - s10.length + c10]) {
                l10 = c10, p10 = true;
                break;
              }
              if (s10[s10.length - 1] === o10[o10.length - s10.length + c10]) {
                l10 = s10.length - c10;
                break;
              }
            }
            void 0 === l10 && (u2 = []);
          }
          return u2.length && tI(l10) && (d10 = r10.length + l10 * n10, p10 ? (g2(u2, r10), f2(r10)) : (g2(r10, u2), f2(u2))), [u2, r10];
        }
        fillSetter() {
          tR.prototype.strokeSetter.apply(this, arguments);
        }
        strokeSetter() {
          this.elem.attr(this.prop, tD(this.start).tweenTo(tD(this.end), this.pos), void 0, true);
        }
      }
      tR.timers = [];
      let {
        defined: tN,
        getStyle: tW,
        isArray: tG,
        isNumber: tX,
        isObject: tH,
        merge: tF,
        objectEach: tY,
        pick: tj
      } = ti;
      function tU(t10) {
        return tH(t10) ? tF({
          duration: 500,
          defer: 0
        }, t10) : {
          duration: t10 ? 500 : 0,
          defer: 0
        };
      }
      function tV(t10, e10) {
        let i10 = tR.timers.length;
        for (; i10--; ) tR.timers[i10].elem !== t10 || e10 && e10 !== tR.timers[i10].prop || (tR.timers[i10].stopped = true);
      }
      let t_ = {
        animate: function(t10, e10, i10) {
          let s10, o10 = "", r10, a10, n10;
          tH(i10) || (n10 = arguments, i10 = {
            duration: n10[2],
            easing: n10[3],
            complete: n10[4]
          }), tX(i10.duration) || (i10.duration = 400), i10.easing = "function" == typeof i10.easing ? i10.easing : Math[i10.easing] || Math.easeInOutSine, i10.curAnim = tF(e10), tY(e10, function(n11, h10) {
            tV(t10, h10), a10 = new tR(t10, i10, h10), r10 = void 0, "d" === h10 && tG(e10.d) ? (a10.paths = a10.initPath(t10, t10.pathArray, e10.d), a10.toD = e10.d, s10 = 0, r10 = 1) : t10.attr ? s10 = t10.attr(h10) : (s10 = parseFloat(tW(t10, h10)) || 0, "opacity" !== h10 && (o10 = "px")), r10 || (r10 = n11), "string" == typeof r10 && r10.match("px") && (r10 = r10.replace(/px/g, "")), a10.run(s10, r10, o10);
          });
        },
        animObject: tU,
        getDeferredAnimation: function(t10, e10, i10) {
          let s10 = tU(e10), o10 = i10 ? [i10] : t10.series, r10 = 0, a10 = 0;
          return o10.forEach((t11) => {
            let i11 = tU(t11.options.animation);
            r10 = tH(e10) && tN(e10.defer) ? s10.defer : Math.max(r10, i11.duration + i11.defer), a10 = Math.min(s10.duration, i11.duration);
          }), t10.renderer.forExport && (r10 = 0), {
            defer: Math.max(0, r10 - a10),
            duration: Math.min(r10, a10)
          };
        },
        setAnimation: function(t10, e10) {
          e10.renderer.globalAnimation = tj(t10, e10.options.chart.animation, true);
        },
        stop: tV
      }, {
        SVG_NS: t$,
        win: tZ
      } = L, {
        attr: tq,
        createElement: tK,
        css: tJ,
        error: tQ,
        isFunction: t0,
        isString: t1,
        objectEach: t2,
        splat: t3
      } = ti, {
        trustedTypes: t5
      } = tZ, t6 = t5 && t0(t5.createPolicy) && t5.createPolicy("highcharts", {
        createHTML: (t10) => t10
      }), t9 = t6 ? t6.createHTML("") : "";
      class t4 {
        static filterUserAttributes(t10) {
          return t2(t10, (e10, i10) => {
            let s10 = true;
            -1 === t4.allowedAttributes.indexOf(i10) && (s10 = false), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i10) && (s10 = t1(e10) && t4.allowedReferences.some((t11) => 0 === e10.indexOf(t11))), s10 || (tQ(33, false, void 0, {
              "Invalid attribute in config": `${i10}`
            }), delete t10[i10]), t1(e10) && t10[i10] && (t10[i10] = e10.replace(/</g, "&lt;"));
          }), t10;
        }
        static parseStyle(t10) {
          return t10.split(";").reduce((t11, e10) => {
            let i10 = e10.split(":").map((t12) => t12.trim()), s10 = i10.shift();
            return s10 && i10.length && (t11[s10.replace(/-([a-z])/g, (t12) => t12[1].toUpperCase())] = i10.join(":")), t11;
          }, {});
        }
        static setElementHTML(t10, e10) {
          t10.innerHTML = t4.emptyHTML, e10 && new t4(e10).addToDOM(t10);
        }
        constructor(t10) {
          this.nodes = "string" == typeof t10 ? this.parseMarkup(t10) : t10;
        }
        addToDOM(t10) {
          return function t11(e10, i10) {
            let s10;
            return t3(e10).forEach(function(e11) {
              let o10;
              let r10 = e11.tagName, a10 = e11.textContent ? L.doc.createTextNode(e11.textContent) : void 0, n10 = t4.bypassHTMLFiltering;
              if (r10) {
                if ("#text" === r10) o10 = a10;
                else if (-1 !== t4.allowedTags.indexOf(r10) || n10) {
                  let s11 = "svg" === r10 ? t$ : i10.namespaceURI || t$, h10 = L.doc.createElementNS(s11, r10), l10 = e11.attributes || {};
                  t2(e11, function(t12, e12) {
                    "tagName" !== e12 && "attributes" !== e12 && "children" !== e12 && "style" !== e12 && "textContent" !== e12 && (l10[e12] = t12);
                  }), tq(h10, n10 ? l10 : t4.filterUserAttributes(l10)), e11.style && tJ(h10, e11.style), a10 && h10.appendChild(a10), t11(e11.children || [], h10), o10 = h10;
                } else tQ(33, false, void 0, {
                  "Invalid tagName in config": r10
                });
              }
              o10 && i10.appendChild(o10), s10 = o10;
            }), s10;
          }(this.nodes, t10);
        }
        parseMarkup(t10) {
          let e10;
          let i10 = [];
          t10 = t10.trim().replace(/ style=(["'])/g, " data-style=$1");
          try {
            e10 = new DOMParser().parseFromString(t6 ? t6.createHTML(t10) : t10, "text/html");
          } catch (t11) {
          }
          if (!e10) {
            let i11 = tK("div");
            i11.innerHTML = t10, e10 = {
              body: i11
            };
          }
          let s10 = (t11, e11) => {
            let i11 = t11.nodeName.toLowerCase(), o10 = {
              tagName: i11
            };
            "#text" === i11 && (o10.textContent = t11.textContent || "");
            let r10 = t11.attributes;
            if (r10) {
              let t12 = {};
              [].forEach.call(r10, (e12) => {
                "data-style" === e12.name ? o10.style = t4.parseStyle(e12.value) : t12[e12.name] = e12.value;
              }), o10.attributes = t12;
            }
            if (t11.childNodes.length) {
              let e12 = [];
              [].forEach.call(t11.childNodes, (t12) => {
                s10(t12, e12);
              }), e12.length && (o10.children = e12);
            }
            e11.push(o10);
          };
          return [].forEach.call(e10.body.childNodes, (t11) => s10(t11, i10)), i10;
        }
      }
      t4.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "in2", "markerHeight", "markerWidth", "offset", "opacity", "operator", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "radius", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], t4.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], t4.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feComposite", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMorphology", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], t4.emptyHTML = t9, t4.bypassHTMLFiltering = false;
      let {
        defaultOptions: t8,
        defaultTime: t7
      } = tT, {
        pageLang: et
      } = L, {
        extend: ee,
        getNestedProperty: ei,
        isArray: es,
        isNumber: eo,
        isObject: er,
        isString: ea,
        pick: en,
        ucfirst: eh
      } = ti, el = {
        add: (t10, e10) => t10 + e10,
        divide: (t10, e10) => 0 !== e10 ? t10 / e10 : "",
        eq: (t10, e10) => t10 == e10,
        each: function(t10) {
          let e10 = arguments[arguments.length - 1];
          return !!es(t10) && t10.map((i10, s10) => ep(e10.body, ee(er(i10) ? i10 : {
            "@this": i10
          }, {
            "@index": s10,
            "@first": 0 === s10,
            "@last": s10 === t10.length - 1
          }))).join("");
        },
        ge: (t10, e10) => t10 >= e10,
        gt: (t10, e10) => t10 > e10,
        if: (t10) => !!t10,
        le: (t10, e10) => t10 <= e10,
        lt: (t10, e10) => t10 < e10,
        multiply: (t10, e10) => t10 * e10,
        ne: (t10, e10) => t10 != e10,
        subtract: (t10, e10) => t10 - e10,
        ucfirst: eh,
        unless: (t10) => !t10
      }, ed = {}, ec = (t10) => /^["'].+["']$/.test(t10);
      function ep(t10 = "", e10, i10) {
        let s10 = /\{([\p{L}\d:\.,;\-\/<>\[\]%_@+"'’= #\(\)]+)\}/gu, o10 = /\(([\p{L}\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/gu, r10 = [], a10 = /f$/, n10 = /\.(\d)/, h10 = i10?.options.lang || t8.lang, l10 = i10 && i10.time || t7, d10 = i10 && i10.numberFormatter || eu, c10 = (t11 = "") => {
          let i11;
          return "true" === t11 || "false" !== t11 && ((i11 = Number(t11)).toString() === t11 ? i11 : ec(t11) ? t11.slice(1, -1) : ei(t11, e10));
        }, p10, u2, g2 = 0, f2;
        for (; null !== (p10 = s10.exec(t10)); ) {
          let i11 = p10, s11 = o10.exec(p10[1]);
          s11 && (p10 = s11, f2 = true), u2 && u2.isBlock || (u2 = {
            ctx: e10,
            expression: p10[1],
            find: p10[0],
            isBlock: "#" === p10[1].charAt(0),
            start: p10.index,
            startInner: p10.index + p10[0].length,
            length: p10[0].length
          });
          let a11 = (u2.isBlock ? i11 : p10)[1].split(" ")[0].replace("#", "");
          el[a11] && (u2.isBlock && a11 === u2.fn && g2++, u2.fn || (u2.fn = a11));
          let n11 = "else" === p10[1];
          if (u2.isBlock && u2.fn && (p10[1] === `/${u2.fn}` || n11)) {
            if (g2) !n11 && g2--;
            else {
              let e11 = u2.startInner, i12 = t10.substr(e11, p10.index - e11);
              void 0 === u2.body ? (u2.body = i12, u2.startInner = p10.index + p10[0].length) : u2.elseBody = i12, u2.find += i12 + p10[0], n11 || (r10.push(u2), u2 = void 0);
            }
          } else u2.isBlock || r10.push(u2);
          if (s11 && !u2?.isBlock) break;
        }
        return r10.forEach((s11) => {
          let r11, p11;
          let {
            body: u3,
            elseBody: g3,
            expression: f3,
            fn: m2
          } = s11;
          if (m2) {
            let t11 = [s11], o11 = [], a11 = f3.length, n11 = 0, h11;
            for (p11 = 0; p11 <= a11; p11++) {
              let t12 = f3.charAt(p11);
              h11 || '"' !== t12 && "'" !== t12 ? h11 === t12 && (h11 = "") : h11 = t12, h11 || " " !== t12 && p11 !== a11 || (o11.push(f3.substr(n11, p11 - n11)), n11 = p11 + 1);
            }
            for (p11 = el[m2].length; p11--; ) t11.unshift(c10(o11[p11 + 1]));
            r11 = el[m2].apply(e10, t11), s11.isBlock && "boolean" == typeof r11 && (r11 = ep(r11 ? u3 : g3, e10, i10));
          } else {
            let t11 = ec(f3) ? [f3] : f3.split(":");
            if (r11 = c10(t11.shift() || ""), t11.length && "number" == typeof r11) {
              let e11 = t11.join(":");
              if (a10.test(e11)) {
                let t12 = parseInt((e11.match(n10) || ["", "-1"])[1], 10);
                null !== r11 && (r11 = d10(r11, t12, h10.decimalPoint, e11.indexOf(",") > -1 ? h10.thousandsSep : ""));
              } else r11 = l10.dateFormat(e11, r11);
            }
            o10.lastIndex = 0, o10.test(s11.find) && ea(r11) && (r11 = `"${r11}"`);
          }
          t10 = t10.replace(s11.find, en(r11, ""));
        }), f2 ? ep(t10, e10, i10) : t10;
      }
      function eu(t10, e10, i10, s10) {
        e10 = +e10;
        let o10, r10, [a10, n10] = (t10 = +t10 || 0).toString().split("e").map(Number), h10 = this?.options?.lang || t8.lang, l10 = (t10.toString().split(".")[1] || "").split("e")[0].length, d10 = e10, c10 = {};
        i10 ?? (i10 = h10.decimalPoint), s10 ?? (s10 = h10.thousandsSep), -1 === e10 ? e10 = Math.min(l10, 20) : eo(e10) ? e10 && n10 < 0 && ((r10 = e10 + n10) >= 0 ? (a10 = +a10.toExponential(r10).split("e")[0], e10 = r10) : (a10 = Math.floor(a10), t10 = e10 < 20 ? +(a10 * Math.pow(10, n10)).toFixed(e10) : 0, n10 = 0)) : e10 = 2, n10 && (e10 ?? (e10 = 2), t10 = a10), eo(e10) && e10 >= 0 && (c10.minimumFractionDigits = e10, c10.maximumFractionDigits = e10), "" === s10 && (c10.useGrouping = false);
        let p10 = s10 || i10, u2 = p10 ? "en" : this?.locale || h10.locale || et, g2 = JSON.stringify(c10) + u2;
        return o10 = (ed[g2] ?? (ed[g2] = new Intl.NumberFormat(u2, c10))).format(t10), p10 && (o10 = o10.replace(/([,\.])/g, "_$1").replace(/_\,/g, s10 ?? ",").replace("_.", i10 ?? ".")), (e10 || 0 != +o10) && (!(n10 < 0) || d10) || (o10 = "0"), n10 && 0 != +o10 && (o10 += "e" + (n10 < 0 ? "" : "+") + n10), o10;
      }
      let eg = {
        dateFormat: function(t10, e10, i10) {
          return t7.dateFormat(t10, e10, i10);
        },
        format: ep,
        helpers: el,
        numberFormat: eu
      };
      !function(t10) {
        let e10;
        t10.rendererTypes = {}, t10.getRendererType = function(i10 = e10) {
          return t10.rendererTypes[i10] || t10.rendererTypes[e10];
        }, t10.registerRendererType = function(i10, s10, o10) {
          t10.rendererTypes[i10] = s10, (!e10 || o10) && (e10 = i10, L.Renderer = s10);
        };
      }(n || (n = {}));
      let ef = n, {
        clamp: em,
        pick: ex,
        pushUnique: ey,
        stableSort: eb
      } = ti;
      (h || (h = {})).distribute = function t10(e10, i10, s10) {
        let o10 = e10, r10 = o10.reducedLen || i10, a10 = (t11, e11) => t11.target - e11.target, n10 = [], h10 = e10.length, l10 = [], d10 = n10.push, c10, p10, u2, g2 = true, f2, m2, x2 = 0, y2;
        for (c10 = h10; c10--; ) x2 += e10[c10].size;
        if (x2 > r10) {
          for (eb(e10, (t11, e11) => (e11.rank || 0) - (t11.rank || 0)), u2 = (y2 = e10[0].rank === e10[e10.length - 1].rank) ? h10 / 2 : -1, p10 = y2 ? u2 : h10 - 1; u2 && x2 > r10; ) f2 = e10[c10 = Math.floor(p10)], ey(l10, c10) && (x2 -= f2.size), p10 += u2, y2 && p10 >= e10.length && (u2 /= 2, p10 = u2);
          l10.sort((t11, e11) => e11 - t11).forEach((t11) => d10.apply(n10, e10.splice(t11, 1)));
        }
        for (eb(e10, a10), e10 = e10.map((t11) => ({
          size: t11.size,
          targets: [t11.target],
          align: ex(t11.align, 0.5)
        })); g2; ) {
          for (c10 = e10.length; c10--; ) f2 = e10[c10], m2 = (Math.min.apply(0, f2.targets) + Math.max.apply(0, f2.targets)) / 2, f2.pos = em(m2 - f2.size * f2.align, 0, i10 - f2.size);
          for (c10 = e10.length, g2 = false; c10--; ) c10 > 0 && e10[c10 - 1].pos + e10[c10 - 1].size > e10[c10].pos && (e10[c10 - 1].size += e10[c10].size, e10[c10 - 1].targets = e10[c10 - 1].targets.concat(e10[c10].targets), e10[c10 - 1].align = 0.5, e10[c10 - 1].pos + e10[c10 - 1].size > i10 && (e10[c10 - 1].pos = i10 - e10[c10 - 1].size), e10.splice(c10, 1), g2 = true);
        }
        return d10.apply(o10, n10), c10 = 0, e10.some((e11) => {
          let r11 = 0;
          return (e11.targets || []).some(() => (o10[c10].pos = e11.pos + r11, void 0 !== s10 && Math.abs(o10[c10].pos - o10[c10].target) > s10) ? (o10.slice(0, c10 + 1).forEach((t11) => delete t11.pos), o10.reducedLen = (o10.reducedLen || i10) - 0.1 * i10, o10.reducedLen > 0.1 * i10 && t10(o10, i10, s10), true) : (r11 += o10[c10].size, c10++, false));
        }), eb(o10, a10), o10;
      };
      let ev = h, {
        animate: ek,
        animObject: eM,
        stop: ew
      } = t_, {
        deg2rad: eS,
        doc: eA,
        svg: eT,
        SVG_NS: eC,
        win: eP,
        isFirefox: eO
      } = L, {
        addEvent: eE,
        attr: eL,
        createElement: eD,
        crisp: eB,
        css: eI,
        defined: ez,
        erase: eR,
        extend: eN,
        fireEvent: eW,
        getAlignFactor: eG,
        isArray: eX,
        isFunction: eH,
        isNumber: eF,
        isObject: eY,
        isString: ej,
        merge: eU,
        objectEach: eV,
        pick: e_,
        pInt: e$,
        pushUnique: eZ,
        replaceNested: eq,
        syncTimeout: eK,
        uniqueKey: eJ
      } = ti;
      class eQ {
        _defaultGetter(t10) {
          let e10 = e_(this[t10 + "Value"], this[t10], this.element ? this.element.getAttribute(t10) : null, 0);
          return /^-?[\d\.]+$/.test(e10) && (e10 = parseFloat(e10)), e10;
        }
        _defaultSetter(t10, e10, i10) {
          i10.setAttribute(e10, t10);
        }
        add(t10) {
          let e10;
          let i10 = this.renderer, s10 = this.element;
          return t10 && (this.parentGroup = t10), void 0 !== this.textStr && "text" === this.element.nodeName && i10.buildText(this), this.added = true, (!t10 || t10.handleZ || this.zIndex) && (e10 = this.zIndexSetter()), e10 || (t10 ? t10.element : i10.box).appendChild(s10), this.onAdd && this.onAdd(), this;
        }
        addClass(t10, e10) {
          let i10 = e10 ? "" : this.attr("class") || "";
          return (t10 = (t10 || "").split(/ /g).reduce(function(t11, e11) {
            return -1 === i10.indexOf(e11) && t11.push(e11), t11;
          }, i10 ? [i10] : []).join(" ")) !== i10 && this.attr("class", t10), this;
        }
        afterSetters() {
          this.doTransform && (this.updateTransform(), this.doTransform = false);
        }
        align(t10, e10, i10, s10 = true) {
          let o10 = this.renderer, r10 = o10.alignedObjects, a10 = !!t10;
          t10 ? (this.alignOptions = t10, this.alignByTranslate = e10, this.alignTo = i10) : (t10 = this.alignOptions || {}, e10 = this.alignByTranslate, i10 = this.alignTo);
          let n10 = !i10 || ej(i10) ? i10 || "renderer" : void 0;
          n10 && (a10 && eZ(r10, this), i10 = void 0);
          let h10 = e_(i10, o10[n10], o10), l10 = (h10.x || 0) + (t10.x || 0) + ((h10.width || 0) - (t10.width || 0)) * eG(t10.align), d10 = (h10.y || 0) + (t10.y || 0) + ((h10.height || 0) - (t10.height || 0)) * eG(t10.verticalAlign), c10 = {
            "text-align": t10?.align
          };
          return c10[e10 ? "translateX" : "x"] = Math.round(l10), c10[e10 ? "translateY" : "y"] = Math.round(d10), s10 && (this[this.placed ? "animate" : "attr"](c10), this.placed = true), this.alignAttr = c10, this;
        }
        alignSetter(t10) {
          let e10 = {
            left: "start",
            center: "middle",
            right: "end"
          };
          e10[t10] && (this.alignValue = t10, this.element.setAttribute("text-anchor", e10[t10]));
        }
        animate(t10, e10, i10) {
          let s10 = eM(e_(e10, this.renderer.globalAnimation, true)), o10 = s10.defer;
          return eA.hidden && (s10.duration = 0), 0 !== s10.duration ? (i10 && (s10.complete = i10), eK(() => {
            this.element && ek(this, t10, s10);
          }, o10)) : (this.attr(t10, void 0, i10 || s10.complete), eV(t10, function(t11, e11) {
            s10.step && s10.step.call(this, t11, {
              prop: e11,
              pos: 1,
              elem: this
            });
          }, this)), this;
        }
        applyTextOutline(t10) {
          let e10 = this.element;
          -1 !== t10.indexOf("contrast") && (t10 = t10.replace(/contrast/g, this.renderer.getContrast(e10.style.fill)));
          let i10 = t10.split(" "), s10 = i10[i10.length - 1], o10 = i10[0];
          if (o10 && "none" !== o10 && L.svg) {
            this.fakeTS = true, o10 = o10.replace(/(^[\d\.]+)(.*?)$/g, function(t12, e11, i12) {
              return 2 * Number(e11) + i12;
            }), this.removeTextOutline();
            let t11 = eA.createElementNS(eC, "tspan");
            eL(t11, {
              class: "highcharts-text-outline",
              fill: s10,
              stroke: s10,
              "stroke-width": o10,
              "stroke-linejoin": "round"
            });
            let i11 = e10.querySelector("textPath") || e10;
            [].forEach.call(i11.childNodes, (e11) => {
              let i12 = e11.cloneNode(true);
              i12.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((t12) => i12.removeAttribute(t12)), t11.appendChild(i12);
            });
            let r10 = 0;
            [].forEach.call(i11.querySelectorAll("text tspan"), (t12) => {
              r10 += Number(t12.getAttribute("dy"));
            });
            let a10 = eA.createElementNS(eC, "tspan");
            a10.textContent = "​", eL(a10, {
              x: Number(e10.getAttribute("x")),
              dy: -r10
            }), t11.appendChild(a10), i11.insertBefore(t11, i11.firstChild);
          }
        }
        attr(t10, e10, i10, s10) {
          let {
            element: o10
          } = this, r10 = eQ.symbolCustomAttribs, a10, n10, h10 = this, l10;
          return "string" == typeof t10 && void 0 !== e10 && (a10 = t10, (t10 = {})[a10] = e10), "string" == typeof t10 ? h10 = (this[t10 + "Getter"] || this._defaultGetter).call(this, t10, o10) : (eV(t10, function(e11, i11) {
            l10 = false, s10 || ew(this, i11), this.symbolName && -1 !== r10.indexOf(i11) && (n10 || (this.symbolAttr(t10), n10 = true), l10 = true), this.rotation && ("x" === i11 || "y" === i11) && (this.doTransform = true), l10 || (this[i11 + "Setter"] || this._defaultSetter).call(this, e11, i11, o10);
          }, this), this.afterSetters()), i10 && i10.call(this), h10;
        }
        clip(t10) {
          if (t10 && !t10.clipPath) {
            let e10 = eJ() + "-", i10 = this.renderer.createElement("clipPath").attr({
              id: e10
            }).add(this.renderer.defs);
            eN(t10, {
              clipPath: i10,
              id: e10,
              count: 0
            }), t10.add(i10);
          }
          return this.attr("clip-path", t10 ? `url(${this.renderer.url}#${t10.id})` : "none");
        }
        crisp(t10, e10) {
          e10 = Math.round(e10 || t10.strokeWidth || 0);
          let i10 = t10.x || this.x || 0, s10 = t10.y || this.y || 0, o10 = (t10.width || this.width || 0) + i10, r10 = (t10.height || this.height || 0) + s10, a10 = eB(i10, e10), n10 = eB(s10, e10);
          return eN(t10, {
            x: a10,
            y: n10,
            width: eB(o10, e10) - a10,
            height: eB(r10, e10) - n10
          }), ez(t10.strokeWidth) && (t10.strokeWidth = e10), t10;
        }
        complexColor(t10, e10, i10) {
          let s10 = this.renderer, o10, r10, a10, n10, h10, l10, d10, c10, p10, u2, g2 = [], f2;
          eW(this.renderer, "complexColor", {
            args: arguments
          }, function() {
            if (t10.radialGradient ? r10 = "radialGradient" : t10.linearGradient && (r10 = "linearGradient"), r10) {
              if (a10 = t10[r10], h10 = s10.gradients, l10 = t10.stops, p10 = i10.radialReference, eX(a10) && (t10[r10] = a10 = {
                x1: a10[0],
                y1: a10[1],
                x2: a10[2],
                y2: a10[3],
                gradientUnits: "userSpaceOnUse"
              }), "radialGradient" === r10 && p10 && !ez(a10.gradientUnits) && (n10 = a10, a10 = eU(a10, s10.getRadialAttr(p10, n10), {
                gradientUnits: "userSpaceOnUse"
              })), eV(a10, function(t11, e11) {
                "id" !== e11 && g2.push(e11, t11);
              }), eV(l10, function(t11) {
                g2.push(t11);
              }), h10[g2 = g2.join(",")]) u2 = h10[g2].attr("id");
              else {
                a10.id = u2 = eJ();
                let t11 = h10[g2] = s10.createElement(r10).attr(a10).add(s10.defs);
                t11.radAttr = n10, t11.stops = [], l10.forEach(function(e11) {
                  0 === e11[1].indexOf("rgba") ? (d10 = (o10 = tL.parse(e11[1])).get("rgb"), c10 = o10.get("a")) : (d10 = e11[1], c10 = 1);
                  let i11 = s10.createElement("stop").attr({
                    offset: e11[0],
                    "stop-color": d10,
                    "stop-opacity": c10
                  }).add(t11);
                  t11.stops.push(i11);
                });
              }
              f2 = "url(" + s10.url + "#" + u2 + ")", i10.setAttribute(e10, f2), i10.gradient = g2, t10.toString = function() {
                return f2;
              };
            }
          });
        }
        css(t10) {
          let e10 = this.styles, i10 = {}, s10 = this.element, o10, r10 = !e10;
          if (e10 && eV(t10, function(t11, s11) {
            e10 && e10[s11] !== t11 && (i10[s11] = t11, r10 = true);
          }), r10) {
            e10 && (t10 = eN(e10, i10)), null === t10.width || "auto" === t10.width ? delete this.textWidth : "text" === s10.nodeName.toLowerCase() && t10.width && (o10 = this.textWidth = e$(t10.width)), eN(this.styles, t10), o10 && !eT && this.renderer.forExport && delete t10.width;
            let r11 = eO && t10.fontSize || null;
            r11 && (eF(r11) || /^\d+$/.test(r11)) && (t10.fontSize += "px");
            let a10 = eU(t10);
            s10.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "whiteSpace", "width"].forEach((t11) => a10 && delete a10[t11]), a10.color && (a10.fill = a10.color)), eI(s10, a10);
          }
          return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t10.textOutline && this.applyTextOutline(t10.textOutline)), this;
        }
        dashstyleSetter(t10) {
          let e10, i10 = this["stroke-width"];
          if ("inherit" === i10 && (i10 = 1), t10 = t10 && t10.toLowerCase()) {
            let s10 = t10.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            for (e10 = s10.length; e10--; ) s10[e10] = "" + e$(s10[e10]) * e_(i10, NaN);
            t10 = s10.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t10);
          }
        }
        destroy() {
          let t10 = this, e10 = t10.element || {}, i10 = t10.renderer, s10 = e10.ownerSVGElement, o10 = "SPAN" === e10.nodeName && t10.parentGroup || void 0, r10, a10;
          if (e10.onclick = e10.onmouseout = e10.onmouseover = e10.onmousemove = e10.point = null, ew(t10), t10.clipPath && s10) {
            let e11 = t10.clipPath;
            [].forEach.call(s10.querySelectorAll("[clip-path],[CLIP-PATH]"), function(t11) {
              t11.getAttribute("clip-path").indexOf(e11.element.id) > -1 && t11.removeAttribute("clip-path");
            }), t10.clipPath = e11.destroy();
          }
          if (t10.connector = t10.connector?.destroy(), t10.stops) {
            for (a10 = 0; a10 < t10.stops.length; a10++) t10.stops[a10].destroy();
            t10.stops.length = 0, t10.stops = void 0;
          }
          for (t10.safeRemoveChild(e10); o10 && o10.div && 0 === o10.div.childNodes.length; ) r10 = o10.parentGroup, t10.safeRemoveChild(o10.div), delete o10.div, o10 = r10;
          t10.alignOptions && eR(i10.alignedObjects, t10), eV(t10, function(e11, i11) {
            t10[i11] && t10[i11].parentGroup === t10 && t10[i11].destroy && t10[i11].destroy(), delete t10[i11];
          });
        }
        dSetter(t10, e10, i10) {
          eX(t10) && ("string" == typeof t10[0] && (t10 = this.renderer.pathToSegments(t10)), this.pathArray = t10, t10 = t10.reduce((t11, e11, i11) => e11 && e11.join ? (i11 ? t11 + " " : "") + e11.join(" ") : (e11 || "").toString(), "")), /(NaN| {2}|^$)/.test(t10) && (t10 = "M 0 0"), this[e10] !== t10 && (i10.setAttribute(e10, t10), this[e10] = t10);
        }
        fillSetter(t10, e10, i10) {
          "string" == typeof t10 ? i10.setAttribute(e10, t10) : t10 && this.complexColor(t10, e10, i10);
        }
        hrefSetter(t10, e10, i10) {
          i10.setAttributeNS("http://www.w3.org/1999/xlink", e10, t10);
        }
        getBBox(t10, e10) {
          let i10, s10, o10, r10;
          let {
            alignValue: a10,
            element: n10,
            renderer: h10,
            styles: l10,
            textStr: d10
          } = this, {
            cache: c10,
            cacheKeys: p10
          } = h10, u2 = n10.namespaceURI === this.SVG_NS, g2 = e_(e10, this.rotation, 0), f2 = h10.styledMode ? n10 && eQ.prototype.getStyle.call(n10, "font-size") : l10.fontSize;
          if (ez(d10) && (-1 === (r10 = d10.toString()).indexOf("<") && (r10 = r10.replace(/\d/g, "0")), r10 += ["", h10.rootFontSize, f2, g2, this.textWidth, a10, l10.lineClamp, l10.textOverflow, l10.fontWeight].join(",")), r10 && !t10 && (i10 = c10[r10]), !i10 || i10.polygon) {
            if (u2 || h10.forExport) {
              try {
                o10 = this.fakeTS && function(t12) {
                  let e11 = n10.querySelector(".highcharts-text-outline");
                  e11 && eI(e11, {
                    display: t12
                  });
                }, eH(o10) && o10("none"), i10 = n10.getBBox ? eN({}, n10.getBBox()) : {
                  width: n10.offsetWidth,
                  height: n10.offsetHeight,
                  x: 0,
                  y: 0
                }, eH(o10) && o10("");
              } catch (t12) {
              }
              (!i10 || i10.width < 0) && (i10 = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              });
            } else i10 = this.htmlGetBBox();
            s10 = i10.height, u2 && (i10.height = s10 = {
              "11px,17": 14,
              "13px,20": 16
            }[`${f2 || ""},${Math.round(s10)}`] || s10), g2 && (i10 = this.getRotatedBox(i10, g2));
            let t11 = {
              bBox: i10
            };
            eW(this, "afterGetBBox", t11), i10 = t11.bBox;
          }
          if (r10 && ("" === d10 || i10.height > 0)) {
            for (; p10.length > 250; ) delete c10[p10.shift()];
            c10[r10] || p10.push(r10), c10[r10] = i10;
          }
          return i10;
        }
        getRotatedBox(t10, e10) {
          let {
            x: i10,
            y: s10,
            width: o10,
            height: r10
          } = t10, {
            alignValue: a10,
            translateY: n10,
            rotationOriginX: h10 = 0,
            rotationOriginY: l10 = 0
          } = this, d10 = eG(a10), c10 = Number(this.element.getAttribute("y") || 0) - (n10 ? 0 : s10), p10 = e10 * eS, u2 = (e10 - 90) * eS, g2 = Math.cos(p10), f2 = Math.sin(p10), m2 = o10 * g2, x2 = o10 * f2, y2 = Math.cos(u2), b2 = Math.sin(u2), [[v2, k2], [M2, w2]] = [h10, l10].map((t11) => [t11 - t11 * g2, t11 * f2]), S2 = i10 + d10 * (o10 - m2) + v2 + w2 + c10 * y2, A2 = S2 + m2, T2 = A2 - r10 * y2, C2 = T2 - m2, P2 = s10 + c10 - d10 * x2 - k2 + M2 + c10 * b2, O2 = P2 + x2, E2 = O2 - r10 * b2, L2 = E2 - x2, D2 = Math.min(S2, A2, T2, C2), B2 = Math.min(P2, O2, E2, L2), I2 = Math.max(S2, A2, T2, C2) - D2, z2 = Math.max(P2, O2, E2, L2) - B2;
          return {
            x: D2,
            y: B2,
            width: I2,
            height: z2,
            polygon: [[S2, P2], [A2, O2], [T2, E2], [C2, L2]]
          };
        }
        getStyle(t10) {
          return eP.getComputedStyle(this.element || this, "").getPropertyValue(t10);
        }
        hasClass(t10) {
          return -1 !== ("" + this.attr("class")).split(" ").indexOf(t10);
        }
        hide() {
          return this.attr({
            visibility: "hidden"
          });
        }
        htmlGetBBox() {
          return {
            height: 0,
            width: 0,
            x: 0,
            y: 0
          };
        }
        constructor(t10, e10) {
          this.onEvents = {}, this.opacity = 1, this.SVG_NS = eC, this.element = "span" === e10 || "body" === e10 ? eD(e10) : eA.createElementNS(this.SVG_NS, e10), this.renderer = t10, this.styles = {}, eW(this, "afterInit");
        }
        on(t10, e10) {
          let {
            onEvents: i10
          } = this;
          return i10[t10] && i10[t10](), i10[t10] = eE(this.element, t10, e10), this;
        }
        opacitySetter(t10, e10, i10) {
          let s10 = Number(Number(t10).toFixed(3));
          this.opacity = s10, i10.setAttribute(e10, s10);
        }
        reAlign() {
          this.alignOptions?.width && "left" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = false, this.align());
        }
        removeClass(t10) {
          return this.attr("class", ("" + this.attr("class")).replace(ej(t10) ? RegExp(`(^| )${t10}( |$)`) : t10, " ").replace(/ +/g, " ").trim());
        }
        removeTextOutline() {
          let t10 = this.element.querySelector("tspan.highcharts-text-outline");
          t10 && this.safeRemoveChild(t10);
        }
        safeRemoveChild(t10) {
          let e10 = t10.parentNode;
          e10 && e10.removeChild(t10);
        }
        setRadialReference(t10) {
          let e10 = this.element.gradient && this.renderer.gradients[this.element.gradient];
          return this.element.radialReference = t10, e10 && e10.radAttr && e10.animate(this.renderer.getRadialAttr(t10, e10.radAttr)), this;
        }
        shadow(t10) {
          let {
            renderer: e10
          } = this, i10 = eU(this.parentGroup?.rotation === 90 ? {
            offsetX: -1,
            offsetY: -1
          } : {}, eY(t10) ? t10 : {}), s10 = e10.shadowDefinition(i10);
          return this.attr({
            filter: t10 ? `url(${e10.url}#${s10})` : "none"
          });
        }
        show(t10 = true) {
          return this.attr({
            visibility: t10 ? "inherit" : "visible"
          });
        }
        "stroke-widthSetter"(t10, e10, i10) {
          this[e10] = t10, i10.setAttribute(e10, t10);
        }
        strokeWidth() {
          if (!this.renderer.styledMode) return this["stroke-width"] || 0;
          let t10 = this.getStyle("stroke-width"), e10 = 0, i10;
          return /px$/.test(t10) ? e10 = e$(t10) : "" !== t10 && (eL(i10 = eA.createElementNS(eC, "rect"), {
            width: t10,
            "stroke-width": 0
          }), this.element.parentNode.appendChild(i10), e10 = i10.getBBox().width, i10.parentNode.removeChild(i10)), e10;
        }
        symbolAttr(t10) {
          let e10 = this;
          eQ.symbolCustomAttribs.forEach(function(i10) {
            e10[i10] = e_(t10[i10], e10[i10]);
          }), e10.attr({
            d: e10.renderer.symbols[e10.symbolName](e10.x, e10.y, e10.width, e10.height, e10)
          });
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.textPxLength, this.textStr = t10, this.added && this.renderer.buildText(this), this.reAlign());
        }
        titleSetter(t10) {
          let e10 = this.element, i10 = e10.getElementsByTagName("title")[0] || eA.createElementNS(this.SVG_NS, "title");
          e10.insertBefore ? e10.insertBefore(i10, e10.firstChild) : e10.appendChild(i10), i10.textContent = eq(e_(t10, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        }
        toFront() {
          let t10 = this.element;
          return t10.parentNode.appendChild(t10), this;
        }
        translate(t10, e10) {
          return this.attr({
            translateX: t10,
            translateY: e10
          });
        }
        updateTransform(t10 = "transform") {
          let {
            element: e10,
            matrix: i10,
            rotation: s10 = 0,
            rotationOriginX: o10,
            rotationOriginY: r10,
            scaleX: a10,
            scaleY: n10,
            translateX: h10 = 0,
            translateY: l10 = 0
          } = this, d10 = ["translate(" + h10 + "," + l10 + ")"];
          ez(i10) && d10.push("matrix(" + i10.join(",") + ")"), s10 && (d10.push("rotate(" + s10 + " " + e_(o10, e10.getAttribute("x"), 0) + " " + e_(r10, e10.getAttribute("y") || 0) + ")"), this.text?.element.tagName === "SPAN" && this.text.attr({
            rotation: s10,
            rotationOriginX: (o10 || 0) - this.padding,
            rotationOriginY: (r10 || 0) - this.padding
          })), (ez(a10) || ez(n10)) && d10.push("scale(" + e_(a10, 1) + " " + e_(n10, 1) + ")"), d10.length && !(this.text || this).textPath && e10.setAttribute(t10, d10.join(" "));
        }
        visibilitySetter(t10, e10, i10) {
          "inherit" === t10 ? i10.removeAttribute(e10) : this[e10] !== t10 && i10.setAttribute(e10, t10), this[e10] = t10;
        }
        xGetter(t10) {
          return "circle" === this.element.nodeName && ("x" === t10 ? t10 = "cx" : "y" === t10 && (t10 = "cy")), this._defaultGetter(t10);
        }
        zIndexSetter(t10, e10) {
          let i10 = this.renderer, s10 = this.parentGroup, o10 = (s10 || i10).element || i10.box, r10 = this.element, a10 = o10 === i10.box, n10, h10, l10, d10 = false, c10, p10 = this.added, u2;
          if (ez(t10) ? (r10.setAttribute("data-z-index", t10), t10 = +t10, this[e10] === t10 && (p10 = false)) : ez(this[e10]) && r10.removeAttribute("data-z-index"), this[e10] = t10, p10) {
            for ((t10 = this.zIndex) && s10 && (s10.handleZ = true), u2 = (n10 = o10.childNodes).length - 1; u2 >= 0 && !d10; u2--) c10 = !ez(l10 = (h10 = n10[u2]).getAttribute("data-z-index")), h10 !== r10 && (t10 < 0 && c10 && !a10 && !u2 ? (o10.insertBefore(r10, n10[u2]), d10 = true) : (e$(l10) <= t10 || c10 && (!ez(t10) || t10 >= 0)) && (o10.insertBefore(r10, n10[u2 + 1]), d10 = true));
            d10 || (o10.insertBefore(r10, n10[a10 ? 3 : 0]), d10 = true);
          }
          return d10;
        }
      }
      eQ.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], eQ.prototype.strokeSetter = eQ.prototype.fillSetter, eQ.prototype.yGetter = eQ.prototype.xGetter, eQ.prototype.matrixSetter = eQ.prototype.rotationOriginXSetter = eQ.prototype.rotationOriginYSetter = eQ.prototype.rotationSetter = eQ.prototype.scaleXSetter = eQ.prototype.scaleYSetter = eQ.prototype.translateXSetter = eQ.prototype.translateYSetter = eQ.prototype.verticalAlignSetter = function(t10, e10) {
        this[e10] = t10, this.doTransform = true;
      };
      let e0 = eQ, {
        defined: e1,
        extend: e2,
        getAlignFactor: e3,
        isNumber: e5,
        merge: e6,
        pick: e9,
        removeEvent: e4
      } = ti;
      class e8 extends e0 {
        constructor(t10, e10, i10, s10, o10, r10, a10, n10, h10, l10) {
          let d10;
          super(t10, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = false, this.textStr = e10, this.x = i10, this.y = s10, this.anchorX = r10, this.anchorY = a10, this.baseline = h10, this.className = l10, this.addClass("button" === l10 ? "highcharts-no-tooltip" : "highcharts-label"), l10 && this.addClass("highcharts-" + l10), this.text = t10.text(void 0, 0, 0, n10).attr({
            zIndex: 1
          }), "string" == typeof o10 && ((d10 = /^url\((.*?)\)$/.test(o10)) || this.renderer.symbols[o10]) && (this.symbolKey = o10), this.bBox = e8.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t10.styledMode || d10, this.deferredAttr = {}, this.alignFactor = 0;
        }
        alignSetter(t10) {
          let e10 = e3(t10);
          this.textAlign = t10, e10 !== this.alignFactor && (this.alignFactor = e10, this.bBox && e5(this.xSetting) && this.attr({
            x: this.xSetting
          }));
        }
        anchorXSetter(t10, e10) {
          this.anchorX = t10, this.boxAttr(e10, Math.round(t10) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(t10, e10) {
          this.anchorY = t10, this.boxAttr(e10, t10 - this.ySetting);
        }
        boxAttr(t10, e10) {
          this.box ? this.box.attr(t10, e10) : this.deferredAttr[t10] = e10;
        }
        css(t10) {
          if (t10) {
            let e10 = {};
            t10 = e6(t10), e8.textProps.forEach((i10) => {
              void 0 !== t10[i10] && (e10[i10] = t10[i10], delete t10[i10]);
            }), this.text.css(e10), "fontSize" in e10 || "fontWeight" in e10 ? this.updateTextPadding() : ("width" in e10 || "textOverflow" in e10) && this.updateBoxSize();
          }
          return e0.prototype.css.call(this, t10);
        }
        destroy() {
          e4(this.element, "mouseenter"), e4(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), e0.prototype.destroy.call(this);
        }
        fillSetter(t10, e10) {
          t10 && (this.needsBox = true), this.fill = t10, this.boxAttr(e10, t10);
        }
        getBBox(t10, e10) {
          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
          let {
            padding: i10,
            height: s10 = 0,
            translateX: o10 = 0,
            translateY: r10 = 0,
            width: a10 = 0
          } = this, n10 = e9(this.paddingLeft, i10), h10 = e10 ?? (this.rotation || 0), l10 = {
            width: a10,
            height: s10,
            x: o10 + this.bBox.x - n10,
            y: r10 + this.bBox.y - i10 + this.baselineOffset
          };
          return h10 && (l10 = this.getRotatedBox(l10, h10)), l10;
        }
        getCrispAdjust() {
          return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        }
        heightSetter(t10) {
          this.heightSetting = t10, this.doUpdate = true;
        }
        afterSetters() {
          super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = false);
        }
        onAdd() {
          this.text.add(this), this.attr({
            text: e9(this.textStr, ""),
            x: this.x || 0,
            y: this.y || 0
          }), this.box && e1(this.anchorX) && this.attr({
            anchorX: this.anchorX,
            anchorY: this.anchorY
          });
        }
        paddingSetter(t10, e10) {
          e5(t10) ? t10 !== this[e10] && (this[e10] = t10, this.updateTextPadding()) : this[e10] = void 0;
        }
        rSetter(t10, e10) {
          this.boxAttr(e10, t10);
        }
        strokeSetter(t10, e10) {
          this.stroke = t10, this.boxAttr(e10, t10);
        }
        "stroke-widthSetter"(t10, e10) {
          t10 && (this.needsBox = true), this["stroke-width"] = t10, this.boxAttr(e10, t10);
        }
        "text-alignSetter"(t10) {
          this.textAlign = this["text-align"] = t10, this.updateTextPadding();
        }
        textSetter(t10) {
          void 0 !== t10 && this.text.attr({
            text: t10
          }), this.updateTextPadding(), this.reAlign();
        }
        updateBoxSize() {
          let t10;
          let e10 = this.text, i10 = {}, s10 = this.padding, o10 = this.bBox = (!e5(this.widthSetting) || !e5(this.heightSetting) || this.textAlign) && e1(e10.textStr) ? e10.getBBox(void 0, 0) : e8.emptyBBox;
          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o10.height || 0) + 2 * s10;
          let r10 = this.renderer.fontMetrics(e10);
          if (this.baselineOffset = s10 + Math.min((this.text.firstLineMetrics || r10).b, o10.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r10.h) / 2), this.needsBox && !e10.textPath) {
            if (!this.box) {
              let t11 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
              t11.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t11.add(this);
            }
            t10 = this.getCrispAdjust(), i10.x = t10, i10.y = (this.baseline ? -this.baselineOffset : 0) + t10, i10.width = Math.round(this.width), i10.height = Math.round(this.height), this.box.attr(e2(i10, this.deferredAttr)), this.deferredAttr = {};
          }
        }
        updateTextPadding() {
          let t10 = this.text, e10 = t10.styles.textAlign || this.textAlign;
          if (!t10.textPath) {
            this.updateBoxSize();
            let i10 = this.baseline ? 0 : this.baselineOffset, s10 = (this.paddingLeft ?? this.padding) + e3(e10) * (this.widthSetting ?? this.bBox.width);
            (s10 !== t10.x || i10 !== t10.y) && (t10.attr({
              align: e10,
              x: s10
            }), void 0 !== i10 && t10.attr("y", i10)), t10.x = s10, t10.y = i10;
          }
        }
        widthSetter(t10) {
          this.widthSetting = e5(t10) ? t10 : void 0, this.doUpdate = true;
        }
        getPaddedWidth() {
          let t10 = this.padding, e10 = e9(this.paddingLeft, t10), i10 = e9(this.paddingRight, t10);
          return (this.widthSetting || this.bBox.width || 0) + e10 + i10;
        }
        xSetter(t10) {
          this.x = t10, this.alignFactor && (t10 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true), this.xSetting = Math.round(t10), this.attr("translateX", this.xSetting);
        }
        ySetter(t10) {
          this.ySetting = this.y = Math.round(t10), this.attr("translateY", this.ySetting);
        }
      }
      e8.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }, e8.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineClamp", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"];
      let {
        defined: e7,
        isNumber: it,
        pick: ie
      } = ti;
      function ii(t10, e10, i10, s10, o10) {
        let r10 = [];
        if (o10) {
          let a10 = o10.start || 0, n10 = ie(o10.r, i10), h10 = ie(o10.r, s10 || i10), l10 = 2e-4 / (o10.borderRadius ? 1 : Math.max(n10, 1)), d10 = Math.abs((o10.end || 0) - a10 - 2 * Math.PI) < l10, c10 = (o10.end || 0) - (d10 ? l10 : 0), p10 = o10.innerR, u2 = ie(o10.open, d10), g2 = Math.cos(a10), f2 = Math.sin(a10), m2 = Math.cos(c10), x2 = Math.sin(c10), y2 = ie(o10.longArc, c10 - a10 - Math.PI < l10 ? 0 : 1), b2 = ["A", n10, h10, 0, y2, ie(o10.clockwise, 1), t10 + n10 * m2, e10 + h10 * x2];
          b2.params = {
            start: a10,
            end: c10,
            cx: t10,
            cy: e10
          }, r10.push(["M", t10 + n10 * g2, e10 + h10 * f2], b2), e7(p10) && ((b2 = ["A", p10, p10, 0, y2, e7(o10.clockwise) ? 1 - o10.clockwise : 0, t10 + p10 * g2, e10 + p10 * f2]).params = {
            start: c10,
            end: a10,
            cx: t10,
            cy: e10
          }, r10.push(u2 ? ["M", t10 + p10 * m2, e10 + p10 * x2] : ["L", t10 + p10 * m2, e10 + p10 * x2], b2)), u2 || r10.push(["Z"]);
        }
        return r10;
      }
      function is(t10, e10, i10, s10, o10) {
        return o10 && o10.r ? io(t10, e10, i10, s10, o10) : [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
      }
      function io(t10, e10, i10, s10, o10) {
        let r10 = o10?.r || 0;
        return [["M", t10 + r10, e10], ["L", t10 + i10 - r10, e10], ["A", r10, r10, 0, 0, 1, t10 + i10, e10 + r10], ["L", t10 + i10, e10 + s10 - r10], ["A", r10, r10, 0, 0, 1, t10 + i10 - r10, e10 + s10], ["L", t10 + r10, e10 + s10], ["A", r10, r10, 0, 0, 1, t10, e10 + s10 - r10], ["L", t10, e10 + r10], ["A", r10, r10, 0, 0, 1, t10 + r10, e10], ["Z"]];
      }
      let ir = {
        arc: ii,
        callout: function(t10, e10, i10, s10, o10) {
          let r10 = Math.min(o10 && o10.r || 0, i10, s10), a10 = r10 + 6, n10 = o10 && o10.anchorX, h10 = o10 && o10.anchorY || 0, l10 = io(t10, e10, i10, s10, {
            r: r10
          });
          if (!it(n10) || n10 < i10 && n10 > 0 && h10 < s10 && h10 > 0) return l10;
          if (t10 + n10 > i10 - a10) {
            if (h10 > e10 + a10 && h10 < e10 + s10 - a10) l10.splice(3, 1, ["L", t10 + i10, h10 - 6], ["L", t10 + i10 + 6, h10], ["L", t10 + i10, h10 + 6], ["L", t10 + i10, e10 + s10 - r10]);
            else if (n10 < i10) {
              let o11 = h10 < e10 + a10, d10 = o11 ? e10 : e10 + s10;
              l10.splice(o11 ? 2 : 5, 0, ["L", n10, h10], ["L", t10 + i10 - r10, d10]);
            } else l10.splice(3, 1, ["L", t10 + i10, s10 / 2], ["L", n10, h10], ["L", t10 + i10, s10 / 2], ["L", t10 + i10, e10 + s10 - r10]);
          } else if (t10 + n10 < a10) {
            if (h10 > e10 + a10 && h10 < e10 + s10 - a10) l10.splice(7, 1, ["L", t10, h10 + 6], ["L", t10 - 6, h10], ["L", t10, h10 - 6], ["L", t10, e10 + r10]);
            else if (n10 > 0) {
              let i11 = h10 < e10 + a10, o11 = i11 ? e10 : e10 + s10;
              l10.splice(i11 ? 1 : 6, 0, ["L", n10, h10], ["L", t10 + r10, o11]);
            } else l10.splice(7, 1, ["L", t10, s10 / 2], ["L", n10, h10], ["L", t10, s10 / 2], ["L", t10, e10 + r10]);
          } else h10 > s10 && n10 < i10 - a10 ? l10.splice(5, 1, ["L", n10 + 6, e10 + s10], ["L", n10, e10 + s10 + 6], ["L", n10 - 6, e10 + s10], ["L", t10 + r10, e10 + s10]) : h10 < 0 && n10 > a10 && l10.splice(1, 1, ["L", n10 - 6, e10], ["L", n10, e10 - 6], ["L", n10 + 6, e10], ["L", i10 - r10, e10]);
          return l10;
        },
        circle: function(t10, e10, i10, s10) {
          return ii(t10 + i10 / 2, e10 + s10 / 2, i10 / 2, s10 / 2, {
            start: 0.5 * Math.PI,
            end: 2.5 * Math.PI,
            open: false
          });
        },
        diamond: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10 / 2], ["L", t10 + i10 / 2, e10 + s10], ["L", t10, e10 + s10 / 2], ["Z"]];
        },
        rect: is,
        roundedRect: io,
        square: is,
        triangle: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
        },
        "triangle-down": function(t10, e10, i10, s10) {
          return [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10 / 2, e10 + s10], ["Z"]];
        }
      }, {
        doc: ia,
        SVG_NS: ih,
        win: il
      } = L, {
        attr: id,
        extend: ic,
        fireEvent: ip,
        isString: iu,
        objectEach: ig,
        pick: im
      } = ti, ix = (t10, e10) => t10.substring(0, e10) + "…", iy = class {
        constructor(t10) {
          let e10 = t10.styles;
          this.renderer = t10.renderer, this.svgElement = t10, this.width = t10.textWidth, this.textLineHeight = e10 && e10.lineHeight, this.textOutline = e10 && e10.textOutline, this.ellipsis = !!(e10 && "ellipsis" === e10.textOverflow), this.lineClamp = e10?.lineClamp, this.noWrap = !!(e10 && "nowrap" === e10.whiteSpace);
        }
        buildSVG() {
          let t10 = this.svgElement, e10 = t10.element, i10 = t10.renderer, s10 = im(t10.textStr, "").toString(), o10 = -1 !== s10.indexOf("<"), r10 = e10.childNodes, a10 = !t10.added && i10.box, n10 = [s10, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, t10.getStyle("font-size"), t10.styles.lineClamp, this.width].join(",");
          if (n10 !== t10.textCache) {
            t10.textCache = n10, delete t10.actualWidth;
            for (let t11 = r10.length; t11--; ) e10.removeChild(r10[t11]);
            if (o10 || this.ellipsis || this.width || t10.textPath || -1 !== s10.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(s10))) {
              if ("" !== s10) {
                a10 && a10.appendChild(e10);
                let i11 = new t4(s10);
                this.modifyTree(i11.nodes), i11.addToDOM(e10), this.modifyDOM(), this.ellipsis && -1 !== (e10.textContent || "").indexOf("…") && t10.attr("title", this.unescapeEntities(t10.textStr || "", ["&lt;", "&gt;"])), a10 && a10.removeChild(e10);
              }
            } else e10.appendChild(ia.createTextNode(this.unescapeEntities(s10)));
            iu(this.textOutline) && t10.applyTextOutline && t10.applyTextOutline(this.textOutline);
          }
        }
        modifyDOM() {
          let t10;
          let e10 = this.svgElement, i10 = id(e10.element, "x");
          for (e10.firstLineMetrics = void 0; t10 = e10.element.firstChild; ) if (/^[\s\u200B]*$/.test(t10.textContent || " ")) e10.element.removeChild(t10);
          else break;
          [].forEach.call(e10.element.querySelectorAll("tspan.highcharts-br"), (t11, s11) => {
            t11.nextSibling && t11.previousSibling && (0 === s11 && 1 === t11.previousSibling.nodeType && (e10.firstLineMetrics = e10.renderer.fontMetrics(t11.previousSibling)), id(t11, {
              dy: this.getLineHeight(t11.nextSibling),
              x: i10
            }));
          });
          let s10 = this.width || 0;
          if (!s10) return;
          let o10 = (t11, o11) => {
            let r11 = t11.textContent || "", a10 = r11.replace(/([^\^])-/g, "$1- ").split(" "), n10 = !this.noWrap && (a10.length > 1 || e10.element.childNodes.length > 1), h10 = this.getLineHeight(o11), l10 = Math.max(0, s10 - 0.8 * h10), d10 = 0, c10 = e10.actualWidth;
            if (n10) {
              let r12 = [], n11 = [];
              for (; o11.firstChild && o11.firstChild !== t11; ) n11.push(o11.firstChild), o11.removeChild(o11.firstChild);
              for (; a10.length; ) if (a10.length && !this.noWrap && d10 > 0 && (r12.push(t11.textContent || ""), t11.textContent = a10.join(" ").replace(/- /g, "-")), this.truncate(t11, void 0, a10, 0 === d10 && c10 || 0, s10, l10, (t12, e11) => a10.slice(0, e11).join(" ").replace(/- /g, "-")), c10 = e10.actualWidth, d10++, this.lineClamp && d10 >= this.lineClamp) {
                a10.length && (this.truncate(t11, t11.textContent || "", void 0, 0, s10, l10, ix), t11.textContent = t11.textContent?.replace("…", "") + "…");
                break;
              }
              n11.forEach((e11) => {
                o11.insertBefore(e11, t11);
              }), r12.forEach((e11) => {
                o11.insertBefore(ia.createTextNode(e11), t11);
                let s11 = ia.createElementNS(ih, "tspan");
                s11.textContent = "​", id(s11, {
                  dy: h10,
                  x: i10
                }), o11.insertBefore(s11, t11);
              });
            } else this.ellipsis && r11 && this.truncate(t11, r11, void 0, 0, s10, l10, ix);
          }, r10 = (t11) => {
            [].slice.call(t11.childNodes).forEach((i11) => {
              i11.nodeType === il.Node.TEXT_NODE ? o10(i11, t11) : (-1 !== i11.className.baseVal.indexOf("highcharts-br") && (e10.actualWidth = 0), r10(i11));
            });
          };
          r10(e10.element);
        }
        getLineHeight(t10) {
          let e10 = t10.nodeType === il.Node.TEXT_NODE ? t10.parentElement : t10;
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e10 || this.svgElement.element).h;
        }
        modifyTree(t10) {
          let e10 = (i10, s10) => {
            let {
              attributes: o10 = {},
              children: r10,
              style: a10 = {},
              tagName: n10
            } = i10, h10 = this.renderer.styledMode;
            if ("b" === n10 || "strong" === n10 ? h10 ? o10.class = "highcharts-strong" : a10.fontWeight = "bold" : ("i" === n10 || "em" === n10) && (h10 ? o10.class = "highcharts-emphasized" : a10.fontStyle = "italic"), a10 && a10.color && (a10.fill = a10.color), "br" === n10) {
              o10.class = "highcharts-br", i10.textContent = "​";
              let e11 = t10[s10 + 1];
              e11 && e11.textContent && (e11.textContent = e11.textContent.replace(/^ +/gm, ""));
            } else "a" === n10 && r10 && r10.some((t11) => "#text" === t11.tagName) && (i10.children = [{
              children: r10,
              tagName: "tspan"
            }]);
            "#text" !== n10 && "a" !== n10 && (i10.tagName = "tspan"), ic(i10, {
              attributes: o10,
              style: a10
            }), r10 && r10.filter((t11) => "#text" !== t11.tagName).forEach(e10);
          };
          t10.forEach(e10), ip(this.svgElement, "afterModifyTree", {
            nodes: t10
          });
        }
        truncate(t10, e10, i10, s10, o10, r10, a10) {
          let n10, h10;
          let l10 = this.svgElement, {
            rotation: d10
          } = l10, c10 = [], p10 = i10 && !s10 ? 1 : 0, u2 = (e10 || i10 || "").length, g2 = u2;
          i10 || (o10 = r10);
          let f2 = function(e11, o11) {
            let r11 = o11 || e11, a11 = t10.parentNode;
            if (a11 && void 0 === c10[r11] && a11.getSubStringLength) try {
              c10[r11] = s10 + a11.getSubStringLength(0, i10 ? r11 + 1 : r11);
            } catch (t11) {
            }
            return c10[r11];
          };
          if (l10.rotation = 0, s10 + (h10 = f2(t10.textContent.length)) > o10) {
            for (; p10 <= u2; ) g2 = Math.ceil((p10 + u2) / 2), i10 && (n10 = a10(i10, g2)), h10 = f2(g2, n10 && n10.length - 1), p10 === u2 ? p10 = u2 + 1 : h10 > o10 ? u2 = g2 - 1 : p10 = g2;
            0 === u2 ? t10.textContent = "" : e10 && u2 === e10.length - 1 || (t10.textContent = n10 || a10(e10 || i10, g2)), this.ellipsis && h10 > o10 && this.truncate(t10, t10.textContent || "", void 0, 0, o10, r10, ix);
          }
          i10 && i10.splice(0, g2), l10.actualWidth = h10, l10.rotation = d10;
        }
        unescapeEntities(t10, e10) {
          return ig(this.renderer.escapes, function(i10, s10) {
            e10 && -1 !== e10.indexOf(i10) || (t10 = t10.toString().replace(RegExp(i10, "g"), s10));
          }), t10;
        }
      }, {
        defaultOptions: ib
      } = tT, {
        charts: iv,
        deg2rad: ik,
        doc: iM,
        isFirefox: iw,
        isMS: iS,
        isWebKit: iA,
        noop: iT,
        SVG_NS: iC,
        symbolSizes: iP,
        win: iO
      } = L, {
        addEvent: iE,
        attr: iL,
        createElement: iD,
        crisp: iB,
        css: iI,
        defined: iz,
        destroyObjectProperties: iR,
        extend: iN,
        isArray: iW,
        isNumber: iG,
        isObject: iX,
        isString: iH,
        merge: iF,
        pick: iY,
        pInt: ij,
        replaceNested: iU,
        uniqueKey: iV
      } = ti;
      class i_ {
        constructor(t10, e10, i10, s10, o10, r10, a10) {
          let n10, h10;
          let l10 = this.createElement("svg").attr({
            version: "1.1",
            class: "highcharts-root"
          }), d10 = l10.element;
          a10 || l10.css(this.getStyle(s10 || {})), t10.appendChild(d10), iL(t10, "dir", "ltr"), -1 === t10.innerHTML.indexOf("xmlns") && iL(d10, "xmlns", this.SVG_NS), this.box = d10, this.boxWrapper = l10, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(iM.createTextNode("Created with Highcharts 12.1.2")), this.defs = this.createElement("defs").add(), this.allowHTML = r10, this.forExport = o10, this.styledMode = a10, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l10.getStyle("font-size"), this.setSize(e10, i10, false), iw && t10.getBoundingClientRect && ((n10 = function() {
            iI(t10, {
              left: 0,
              top: 0
            }), h10 = t10.getBoundingClientRect(), iI(t10, {
              left: Math.ceil(h10.left) - h10.left + "px",
              top: Math.ceil(h10.top) - h10.top + "px"
            });
          })(), this.unSubPixelFix = iE(iO, "resize", n10));
        }
        definition(t10) {
          return new t4([t10]).addToDOM(this.defs.element);
        }
        getReferenceURL() {
          if ((iw || iA) && iM.getElementsByTagName("base").length) {
            if (!iz(e)) {
              let t10 = iV(), i10 = new t4([{
                tagName: "svg",
                attributes: {
                  width: 8,
                  height: 8
                },
                children: [{
                  tagName: "defs",
                  children: [{
                    tagName: "clipPath",
                    attributes: {
                      id: t10
                    },
                    children: [{
                      tagName: "rect",
                      attributes: {
                        width: 4,
                        height: 4
                      }
                    }]
                  }]
                }, {
                  tagName: "rect",
                  attributes: {
                    id: "hitme",
                    width: 8,
                    height: 8,
                    "clip-path": `url(#${t10})`,
                    fill: "rgba(0,0,0,0.001)"
                  }
                }]
              }]).addToDOM(iM.body);
              iI(i10, {
                position: "fixed",
                top: 0,
                left: 0,
                zIndex: 9e5
              });
              let s10 = iM.elementFromPoint(6, 6);
              e = "hitme" === (s10 && s10.id), iM.body.removeChild(i10);
            }
            if (e) return iU(iO.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
          }
          return "";
        }
        getStyle(t10) {
          return this.style = iN({
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
            fontSize: "1rem"
          }, t10), this.style;
        }
        setStyle(t10) {
          this.boxWrapper.css(this.getStyle(t10));
        }
        isHidden() {
          return !this.boxWrapper.getBBox().width;
        }
        destroy() {
          let t10 = this.defs;
          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), iR(this.gradients || {}), this.gradients = null, this.defs = t10.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
        }
        createElement(t10) {
          return new this.Element(this, t10);
        }
        getRadialAttr(t10, e10) {
          return {
            cx: t10[0] - t10[2] / 2 + (e10.cx || 0) * t10[2],
            cy: t10[1] - t10[2] / 2 + (e10.cy || 0) * t10[2],
            r: (e10.r || 0) * t10[2]
          };
        }
        shadowDefinition(t10) {
          let e10 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t10).map((e11) => `${e11}-${t10[e11]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i10 = iF({
            color: "#000000",
            offsetX: 1,
            offsetY: 1,
            opacity: 0.15,
            width: 5
          }, t10);
          return this.defs.element.querySelector(`#${e10}`) || this.definition({
            tagName: "filter",
            attributes: {
              id: e10,
              filterUnits: i10.filterUnits
            },
            children: this.getShadowFilterContent(i10)
          }), e10;
        }
        getShadowFilterContent(t10) {
          return [{
            tagName: "feDropShadow",
            attributes: {
              dx: t10.offsetX,
              dy: t10.offsetY,
              "flood-color": t10.color,
              "flood-opacity": Math.min(5 * t10.opacity, 1),
              stdDeviation: t10.width / 2
            }
          }];
        }
        buildText(t10) {
          new iy(t10).buildSVG();
        }
        getContrast(t10) {
          let e10 = tL.parse(t10).rgba.map((t11) => {
            let e11 = t11 / 255;
            return e11 <= 0.03928 ? e11 / 12.92 : Math.pow((e11 + 0.055) / 1.055, 2.4);
          }), i10 = 0.2126 * e10[0] + 0.7152 * e10[1] + 0.0722 * e10[2];
          return 1.05 / (i10 + 0.05) > (i10 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
        }
        button(t10, e10, i10, s10, o10 = {}, r10, a10, n10, h10, l10) {
          let d10 = this.label(t10, e10, i10, h10, void 0, void 0, l10, void 0, "button"), c10 = this.styledMode, p10 = arguments, u2 = 0;
          o10 = iF(ib.global.buttonTheme, o10), c10 && (delete o10.fill, delete o10.stroke, delete o10["stroke-width"]);
          let g2 = o10.states || {}, f2 = o10.style || {};
          delete o10.states, delete o10.style;
          let m2 = [t4.filterUserAttributes(o10)], x2 = [f2];
          return c10 || ["hover", "select", "disabled"].forEach((t11, e11) => {
            m2.push(iF(m2[0], t4.filterUserAttributes(p10[e11 + 5] || g2[t11] || {}))), x2.push(m2[e11 + 1].style), delete m2[e11 + 1].style;
          }), iE(d10.element, iS ? "mouseover" : "mouseenter", function() {
            3 !== u2 && d10.setState(1);
          }), iE(d10.element, iS ? "mouseout" : "mouseleave", function() {
            3 !== u2 && d10.setState(u2);
          }), d10.setState = (t11 = 0) => {
            if (1 !== t11 && (d10.state = u2 = t11), d10.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t11]), !c10) {
              d10.attr(m2[t11]);
              let e11 = x2[t11];
              iX(e11) && d10.css(e11);
            }
          }, d10.attr(m2[0]), !c10 && (d10.css(iN({
            cursor: "default"
          }, f2)), l10 && d10.text.css({
            pointerEvents: "none"
          })), d10.on("touchstart", (t11) => t11.stopPropagation()).on("click", function(t11) {
            3 !== u2 && s10.call(d10, t11);
          });
        }
        crispLine(t10, e10) {
          let [i10, s10] = t10;
          return iz(i10[1]) && i10[1] === s10[1] && (i10[1] = s10[1] = iB(i10[1], e10)), iz(i10[2]) && i10[2] === s10[2] && (i10[2] = s10[2] = iB(i10[2], e10)), t10;
        }
        path(t10) {
          let e10 = this.styledMode ? {} : {
            fill: "none"
          };
          return iW(t10) ? e10.d = t10 : iX(t10) && iN(e10, t10), this.createElement("path").attr(e10);
        }
        circle(t10, e10, i10) {
          let s10 = iX(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: i10
          }, o10 = this.createElement("circle");
          return o10.xSetter = o10.ySetter = function(t11, e11, i11) {
            i11.setAttribute("c" + e11, t11);
          }, o10.attr(s10);
        }
        arc(t10, e10, i10, s10, o10, r10) {
          let a10;
          iX(t10) ? (e10 = (a10 = t10).y, i10 = a10.r, s10 = a10.innerR, o10 = a10.start, r10 = a10.end, t10 = a10.x) : a10 = {
            innerR: s10,
            start: o10,
            end: r10
          };
          let n10 = this.symbol("arc", t10, e10, i10, i10, a10);
          return n10.r = i10, n10;
        }
        rect(t10, e10, i10, s10, o10, r10) {
          let a10 = iX(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: o10,
            width: Math.max(i10 || 0, 0),
            height: Math.max(s10 || 0, 0)
          }, n10 = this.createElement("rect");
          return this.styledMode || (void 0 !== r10 && (a10["stroke-width"] = r10, iN(a10, n10.crisp(a10))), a10.fill = "none"), n10.rSetter = function(t11, e11, i11) {
            n10.r = t11, iL(i11, {
              rx: t11,
              ry: t11
            });
          }, n10.rGetter = function() {
            return n10.r || 0;
          }, n10.attr(a10);
        }
        roundedRect(t10) {
          return this.symbol("roundedRect").attr(t10);
        }
        setSize(t10, e10, i10) {
          this.width = t10, this.height = e10, this.boxWrapper.animate({
            width: t10,
            height: e10
          }, {
            step: function() {
              this.attr({
                viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
              });
            },
            duration: iY(i10, true) ? void 0 : 0
          }), this.alignElements();
        }
        g(t10) {
          let e10 = this.createElement("g");
          return t10 ? e10.attr({
            class: "highcharts-" + t10
          }) : e10;
        }
        image(t10, e10, i10, s10, o10, r10) {
          let a10 = {
            preserveAspectRatio: "none"
          };
          iG(e10) && (a10.x = e10), iG(i10) && (a10.y = i10), iG(s10) && (a10.width = s10), iG(o10) && (a10.height = o10);
          let n10 = this.createElement("image").attr(a10), h10 = function(e11) {
            n10.attr({
              href: t10
            }), r10.call(n10, e11);
          };
          if (r10) {
            n10.attr({
              href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
            });
            let e11 = new iO.Image();
            iE(e11, "load", h10), e11.src = t10, e11.complete && h10({});
          } else n10.attr({
            href: t10
          });
          return n10;
        }
        symbol(t10, e10, i10, s10, o10, r10) {
          let a10, n10, h10, l10;
          let d10 = this, c10 = /^url\((.*?)\)$/, p10 = c10.test(t10), u2 = !p10 && (this.symbols[t10] ? t10 : "circle"), g2 = u2 && this.symbols[u2];
          if (g2) "number" == typeof e10 && (n10 = g2.call(this.symbols, e10 || 0, i10 || 0, s10 || 0, o10 || 0, r10)), a10 = this.path(n10), d10.styledMode || a10.attr("fill", "none"), iN(a10, {
            symbolName: u2 || void 0,
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }), r10 && iN(a10, r10);
          else if (p10) {
            h10 = t10.match(c10)[1];
            let s11 = a10 = this.image(h10);
            s11.imgwidth = iY(r10 && r10.width, iP[h10] && iP[h10].width), s11.imgheight = iY(r10 && r10.height, iP[h10] && iP[h10].height), l10 = (t11) => t11.attr({
              width: t11.width,
              height: t11.height
            }), ["width", "height"].forEach((t11) => {
              s11[`${t11}Setter`] = function(t12, e11) {
                this[e11] = t12;
                let {
                  alignByTranslate: i11,
                  element: s12,
                  width: o11,
                  height: a11,
                  imgwidth: n11,
                  imgheight: h11
                } = this, l11 = "width" === e11 ? n11 : h11, d11 = 1;
                r10 && "within" === r10.backgroundSize && o11 && a11 && n11 && h11 ? (d11 = Math.min(o11 / n11, a11 / h11), iL(s12, {
                  width: Math.round(n11 * d11),
                  height: Math.round(h11 * d11)
                })) : s12 && l11 && s12.setAttribute(e11, l11), !i11 && n11 && h11 && this.translate(((o11 || 0) - n11 * d11) / 2, ((a11 || 0) - h11 * d11) / 2);
              };
            }), iz(e10) && s11.attr({
              x: e10,
              y: i10
            }), s11.isImg = true, s11.symbolUrl = t10, iz(s11.imgwidth) && iz(s11.imgheight) ? l10(s11) : (s11.attr({
              width: 0,
              height: 0
            }), iD("img", {
              onload: function() {
                let t11 = iv[d10.chartIndex];
                0 === this.width && (iI(this, {
                  position: "absolute",
                  top: "-999em"
                }), iM.body.appendChild(this)), iP[h10] = {
                  width: this.width,
                  height: this.height
                }, s11.imgwidth = this.width, s11.imgheight = this.height, s11.element && l10(s11), this.parentNode && this.parentNode.removeChild(this), d10.imgCount--, d10.imgCount || !t11 || t11.hasLoaded || t11.onload();
              },
              src: h10
            }), this.imgCount++);
          }
          return a10;
        }
        clipRect(t10, e10, i10, s10) {
          return this.rect(t10, e10, i10, s10, 0);
        }
        text(t10, e10, i10, s10) {
          let o10 = {};
          if (s10 && (this.allowHTML || !this.forExport)) return this.html(t10, e10, i10);
          o10.x = Math.round(e10 || 0), i10 && (o10.y = Math.round(i10)), iz(t10) && (o10.text = t10);
          let r10 = this.createElement("text").attr(o10);
          return s10 && (!this.forExport || this.allowHTML) || (r10.xSetter = function(t11, e11, i11) {
            let s11 = i11.getElementsByTagName("tspan"), o11 = i11.getAttribute(e11);
            for (let i12 = 0, r11; i12 < s11.length; i12++) (r11 = s11[i12]).getAttribute(e11) === o11 && r11.setAttribute(e11, t11);
            i11.setAttribute(e11, t11);
          }), r10;
        }
        fontMetrics(t10) {
          let e10 = ij(e0.prototype.getStyle.call(t10, "font-size") || 0), i10 = e10 < 24 ? e10 + 3 : Math.round(1.2 * e10), s10 = Math.round(0.8 * i10);
          return {
            h: i10,
            b: s10,
            f: e10
          };
        }
        rotCorr(t10, e10, i10) {
          let s10 = t10;
          return e10 && i10 && (s10 = Math.max(s10 * Math.cos(e10 * ik), 4)), {
            x: -t10 / 3 * Math.sin(e10 * ik),
            y: s10
          };
        }
        pathToSegments(t10) {
          let e10 = [], i10 = [], s10 = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          };
          for (let o10 = 0; o10 < t10.length; o10++) iH(i10[0]) && iG(t10[o10]) && i10.length === s10[i10[0].toUpperCase()] && t10.splice(o10, 0, i10[0].replace("M", "L").replace("m", "l")), "string" == typeof t10[o10] && (i10.length && e10.push(i10.slice(0)), i10.length = 0), i10.push(t10[o10]);
          return e10.push(i10.slice(0)), e10;
        }
        label(t10, e10, i10, s10, o10, r10, a10, n10, h10) {
          return new e8(this, t10, e10, i10, s10, o10, r10, a10, n10, h10);
        }
        alignElements() {
          this.alignedObjects.forEach((t10) => t10.align());
        }
      }
      iN(i_.prototype, {
        Element: e0,
        SVG_NS: iC,
        escapes: {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "'": "&#39;",
          '"': "&quot;"
        },
        symbols: ir,
        draw: iT
      }), ef.registerRendererType("svg", i_, true);
      let {
        composed: i$
      } = L, {
        attr: iZ,
        css: iq,
        createElement: iK,
        defined: iJ,
        extend: iQ,
        getAlignFactor: i0,
        isNumber: i1,
        pInt: i2,
        pushUnique: i3
      } = ti;
      function i5(t10, e10, i10) {
        let s10 = this.div?.style || i10.style;
        e0.prototype[`${e10}Setter`].call(this, t10, e10, i10), s10 && (s10[e10] = t10);
      }
      let i6 = (t10, e10) => {
        if (!t10.div) {
          let i10 = iZ(t10.element, "class"), s10 = t10.css, o10 = iK("div", i10 ? {
            className: i10
          } : void 0, __spreadProps(__spreadValues({
            position: "absolute",
            left: `${t10.translateX || 0}px`,
            top: `${t10.translateY || 0}px`
          }, t10.styles), {
            display: t10.display,
            opacity: t10.opacity,
            visibility: t10.visibility
          }), t10.parentGroup?.div || e10);
          t10.classSetter = (t11, e11, i11) => {
            i11.setAttribute("class", t11), o10.className = t11;
          }, t10.translateXSetter = t10.translateYSetter = (e11, i11) => {
            t10[i11] = e11, o10.style["translateX" === i11 ? "left" : "top"] = `${e11}px`, t10.doTransform = true;
          }, t10.opacitySetter = t10.visibilitySetter = i5, t10.css = (e11) => (s10.call(t10, e11), e11.cursor && (o10.style.cursor = e11.cursor), e11.pointerEvents && (o10.style.pointerEvents = e11.pointerEvents), t10), t10.on = function() {
            return e0.prototype.on.apply({
              element: o10,
              onEvents: t10.onEvents
            }, arguments), t10;
          }, t10.div = o10;
        }
        return t10.div;
      };
      class i9 extends e0 {
        static compose(t10) {
          i3(i$, this.compose) && (t10.prototype.html = function(t11, e10, i10) {
            return new i9(this, "span").attr({
              text: t11,
              x: Math.round(e10),
              y: Math.round(i10)
            });
          });
        }
        constructor(t10, e10) {
          super(t10, e10), this.css(__spreadValues({
            position: "absolute"
          }, t10.styledMode ? {} : {
            fontFamily: t10.style.fontFamily,
            fontSize: t10.style.fontSize
          }));
        }
        getSpanCorrection(t10, e10, i10) {
          this.xCorr = -t10 * i10, this.yCorr = -e10;
        }
        css(t10) {
          let e10;
          let {
            element: i10
          } = this, s10 = "SPAN" === i10.tagName && t10 && "width" in t10, o10 = s10 && t10.width;
          return s10 && (delete t10.width, this.textWidth = i2(o10) || void 0, e10 = true), t10?.textOverflow === "ellipsis" && (t10.overflow = "hidden"), t10?.lineClamp && (t10.display = "-webkit-box", t10.WebkitLineClamp = t10.lineClamp, t10.WebkitBoxOrient = "vertical", t10.overflow = "hidden"), i1(Number(t10?.fontSize)) && (t10.fontSize = t10.fontSize + "px"), iQ(this.styles, t10), iq(i10, t10), e10 && this.updateTransform(), this;
        }
        htmlGetBBox() {
          let {
            element: t10
          } = this;
          return {
            x: t10.offsetLeft,
            y: t10.offsetTop,
            width: t10.offsetWidth,
            height: t10.offsetHeight
          };
        }
        updateTransform() {
          if (!this.added) {
            this.alignOnAdd = true;
            return;
          }
          let {
            element: t10,
            renderer: e10,
            rotation: i10,
            rotationOriginX: s10,
            rotationOriginY: o10,
            scaleX: r10,
            scaleY: a10,
            styles: n10,
            textAlign: h10 = "left",
            textWidth: l10,
            translateX: d10 = 0,
            translateY: c10 = 0,
            x: p10 = 0,
            y: u2 = 0
          } = this, {
            display: g2 = "block",
            whiteSpace: f2
          } = n10;
          if (iq(t10, {
            marginLeft: `${d10}px`,
            marginTop: `${c10}px`
          }), "SPAN" === t10.tagName) {
            let n11;
            let d11 = [i10, h10, t10.innerHTML, l10, this.textAlign].join(","), c11 = -(this.parentGroup?.padding * 1) || 0;
            if (l10 !== this.oldTextWidth) {
              let e11 = this.textPxLength ? this.textPxLength : (iq(t10, {
                width: "",
                whiteSpace: f2 || "nowrap"
              }), t10.offsetWidth), s11 = l10 || 0;
              (s11 > this.oldTextWidth || e11 > s11) && (/[ \-]/.test(t10.textContent || t10.innerText) || "ellipsis" === t10.style.textOverflow) && (iq(t10, {
                width: e11 > s11 || i10 || r10 ? l10 + "px" : "auto",
                display: g2,
                whiteSpace: f2 || "normal"
              }), this.oldTextWidth = l10);
            }
            d11 !== this.cTT && (n11 = e10.fontMetrics(t10).b, iJ(i10) && (i10 !== (this.oldRotation || 0) || h10 !== this.oldAlign) && this.setSpanRotation(i10, c11, c11), this.getSpanCorrection(!iJ(i10) && !this.textWidth && this.textPxLength || t10.offsetWidth, n11, i0(h10)));
            let {
              xCorr: m2 = 0,
              yCorr: x2 = 0
            } = this, y2 = {
              left: `${p10 + m2}px`,
              top: `${u2 + x2}px`,
              textAlign: h10,
              transformOrigin: `${(s10 ?? p10) - m2 - p10 - c11}px ${(o10 ?? u2) - x2 - u2 - c11}px`
            };
            (r10 || a10) && (y2.transform = `scale(${r10 ?? 1},${a10 ?? 1})`), iq(t10, y2), this.cTT = d11, this.oldRotation = i10, this.oldAlign = h10;
          }
        }
        setSpanRotation(t10, e10, i10) {
          iq(this.element, {
            transform: `rotate(${t10}deg)`,
            transformOrigin: `${e10}% ${i10}px`
          });
        }
        add(t10) {
          let e10;
          let i10 = this.renderer.box.parentNode, s10 = [];
          if (this.parentGroup = t10, t10 && !(e10 = t10.div)) {
            let o10 = t10;
            for (; o10; ) s10.push(o10), o10 = o10.parentGroup;
            for (let t11 of s10.reverse()) e10 = i6(t11, i10);
          }
          return (e10 || i10).appendChild(this.element), this.added = true, this.alignOnAdd && this.updateTransform(), this;
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t4.setElementHTML(this.element, t10 ?? ""), this.textStr = t10, this.doTransform = true);
        }
        alignSetter(t10) {
          this.alignValue = this.textAlign = t10, this.doTransform = true;
        }
        xSetter(t10, e10) {
          this[e10] = t10, this.doTransform = true;
        }
      }
      let i4 = i9.prototype;
      i4.visibilitySetter = i4.opacitySetter = i5, i4.ySetter = i4.rotationSetter = i4.rotationOriginXSetter = i4.rotationOriginYSetter = i4.xSetter, function(t10) {
        t10.xAxis = {
          alignTicks: true,
          allowDecimals: void 0,
          panningEnabled: true,
          zIndex: 2,
          zoomEnabled: true,
          dateTimeLabelFormats: {
            millisecond: {
              main: "%[HMSL]",
              range: false
            },
            second: {
              main: "%[HMS]",
              range: false
            },
            minute: {
              main: "%[HM]",
              range: false
            },
            hour: {
              main: "%[HM]",
              range: false
            },
            day: {
              main: "%[eb]"
            },
            week: {
              main: "%[eb]"
            },
            month: {
              main: "%[bY]"
            },
            year: {
              main: "%Y"
            }
          },
          endOnTick: false,
          gridLineDashStyle: "Solid",
          gridZIndex: 1,
          labels: {
            autoRotationLimit: 80,
            distance: 15,
            enabled: true,
            indentation: 10,
            overflow: "justify",
            reserveSpace: void 0,
            rotation: void 0,
            staggerLines: 0,
            step: 0,
            useHTML: false,
            zIndex: 7,
            style: {
              color: "#333333",
              cursor: "default",
              fontSize: "0.8em",
              textOverflow: "ellipsis"
            }
          },
          maxPadding: 0.01,
          minorGridLineDashStyle: "Solid",
          minorTickLength: 2,
          minorTickPosition: "outside",
          minorTicksPerMajor: 5,
          minPadding: 0.01,
          offset: void 0,
          reversed: void 0,
          reversedStacks: false,
          showEmpty: true,
          showFirstLabel: true,
          showLastLabel: true,
          startOfWeek: 1,
          startOnTick: false,
          tickLength: 10,
          tickPixelInterval: 100,
          tickmarkPlacement: "between",
          tickPosition: "outside",
          title: {
            align: "middle",
            useHTML: false,
            x: 0,
            y: 0,
            style: {
              color: "#666666",
              fontSize: "0.8em"
            }
          },
          visible: true,
          minorGridLineColor: "#f2f2f2",
          minorGridLineWidth: 1,
          minorTickColor: "#999999",
          lineColor: "#333333",
          lineWidth: 1,
          gridLineColor: "#e6e6e6",
          gridLineWidth: void 0,
          tickColor: "#333333"
        }, t10.yAxis = {
          reversedStacks: true,
          endOnTick: true,
          maxPadding: 0.05,
          minPadding: 0.05,
          tickPixelInterval: 72,
          showLastLabel: true,
          labels: {
            x: void 0
          },
          startOnTick: true,
          title: {
            text: "Values"
          },
          stackLabels: {
            animation: {},
            allowOverlap: false,
            enabled: false,
            crop: true,
            overflow: "justify",
            formatter: function() {
              let {
                numberFormatter: t11
              } = this.axis.chart;
              return t11(this.total || 0, -1);
            },
            style: {
              color: "#000000",
              fontSize: "0.7em",
              fontWeight: "bold",
              textOutline: "1px contrast"
            }
          },
          gridLineWidth: 1,
          lineWidth: 0
        };
      }(l || (l = {}));
      let i8 = l, {
        addEvent: i7,
        isFunction: st,
        objectEach: se,
        removeEvent: si
      } = ti;
      (d || (d = {})).registerEventOptions = function(t10, e10) {
        t10.eventOptions = t10.eventOptions || {}, se(e10.events, function(e11, i10) {
          t10.eventOptions[i10] !== e11 && (t10.eventOptions[i10] && (si(t10, i10, t10.eventOptions[i10]), delete t10.eventOptions[i10]), st(e11) && (t10.eventOptions[i10] = e11, i7(t10, i10, e11, {
            order: 0
          })));
        });
      };
      let ss = d, {
        deg2rad: so
      } = L, {
        clamp: sr,
        correctFloat: sa,
        defined: sn,
        destroyObjectProperties: sh,
        extend: sl,
        fireEvent: sd,
        getAlignFactor: sc,
        isNumber: sp,
        merge: su,
        objectEach: sg,
        pick: sf
      } = ti, sm = class {
        constructor(t10, e10, i10, s10, o10) {
          this.isNew = true, this.isNewLabel = true, this.axis = t10, this.pos = e10, this.type = i10 || "", this.parameters = o10 || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, sd(this, "init"), i10 || s10 || this.addLabel();
        }
        addLabel() {
          let t10 = this, e10 = t10.axis, i10 = e10.options, s10 = e10.chart, o10 = e10.categories, r10 = e10.logarithmic, a10 = e10.names, n10 = t10.pos, h10 = sf(t10.options && t10.options.labels, i10.labels), l10 = e10.tickPositions, d10 = n10 === l10[0], c10 = n10 === l10[l10.length - 1], p10 = (!h10.step || 1 === h10.step) && 1 === e10.tickInterval, u2 = l10.info, g2 = t10.label, f2, m2, x2, y2 = this.parameters.category || (o10 ? sf(o10[n10], a10[n10], n10) : n10);
          r10 && sp(y2) && (y2 = sa(r10.lin2log(y2))), e10.dateTime && (u2 ? f2 = (m2 = s10.time.resolveDTLFormat(i10.dateTimeLabelFormats[!i10.grid && u2.higherRanks[n10] || u2.unitName])).main : sp(y2) && (f2 = e10.dateTime.getXDateFormat(y2, i10.dateTimeLabelFormats || {}))), t10.isFirst = d10, t10.isLast = c10;
          let b2 = {
            axis: e10,
            chart: s10,
            dateTimeLabelFormat: f2,
            isFirst: d10,
            isLast: c10,
            pos: n10,
            tick: t10,
            tickPositionInfo: u2,
            value: y2
          };
          sd(this, "labelFormat", b2);
          let v2 = (t11) => h10.formatter ? h10.formatter.call(t11, t11) : h10.format ? (t11.text = e10.defaultLabelFormatter.call(t11), eg.format(h10.format, t11, s10)) : e10.defaultLabelFormatter.call(t11), k2 = v2.call(b2, b2), M2 = m2 && m2.list;
          M2 ? t10.shortenLabel = function() {
            for (x2 = 0; x2 < M2.length; x2++) if (sl(b2, {
              dateTimeLabelFormat: M2[x2]
            }), g2.attr({
              text: v2.call(b2, b2)
            }), g2.getBBox().width < e10.getSlotWidth(t10) - 2 * (h10.padding || 0)) return;
            g2.attr({
              text: ""
            });
          } : t10.shortenLabel = void 0, p10 && e10._addedPlotLB && t10.moveLabel(k2, h10), sn(g2) || t10.movedLabel ? g2 && g2.textStr !== k2 && !p10 && (!g2.textWidth || h10.style.width || g2.styles.width || g2.css({
            width: null
          }), g2.attr({
            text: k2
          }), g2.textPxLength = g2.getBBox().width) : (t10.label = g2 = t10.createLabel(k2, h10), t10.rotation = 0);
        }
        createLabel(t10, e10, i10) {
          let s10 = this.axis, {
            renderer: o10,
            styledMode: r10
          } = s10.chart, a10 = sn(t10) && e10.enabled ? o10.text(t10, i10?.x, i10?.y, e10.useHTML).add(s10.labelGroup) : void 0;
          if (a10) {
            let t11 = e10.style.whiteSpace || "normal";
            r10 || a10.css(su(e10.style, {
              whiteSpace: "nowrap"
            })), a10.textPxLength = a10.getBBox().width, r10 || a10.css({
              whiteSpace: t11
            });
          }
          return a10;
        }
        destroy() {
          sh(this, this.axis);
        }
        getPosition(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart, a10 = s10 && r10.oldChartHeight || r10.chartHeight, n10 = {
            x: t10 ? sa(o10.translate(e10 + i10, void 0, void 0, s10) + o10.transB) : o10.left + o10.offset + (o10.opposite ? (s10 && r10.oldChartWidth || r10.chartWidth) - o10.right - o10.left : 0),
            y: t10 ? a10 - o10.bottom + o10.offset - (o10.opposite ? o10.height : 0) : sa(a10 - o10.translate(e10 + i10, void 0, void 0, s10) - o10.transB)
          };
          return n10.y = sr(n10.y, -1e9, 1e9), sd(this, "afterGetPosition", {
            pos: n10
          }), n10;
        }
        getLabelPosition(t10, e10, i10, s10, o10, r10, a10, n10) {
          let h10, l10;
          let d10 = this.axis, c10 = d10.transA, p10 = d10.isLinked && d10.linkedParent ? d10.linkedParent.reversed : d10.reversed, u2 = d10.staggerLines, g2 = d10.tickRotCorr || {
            x: 0,
            y: 0
          }, f2 = s10 || d10.reserveSpaceDefault ? 0 : -d10.labelOffset * ("center" === d10.labelAlign ? 0.5 : 1), m2 = o10.distance, x2 = {};
          return h10 = 0 === d10.side ? i10.rotation ? -m2 : -i10.getBBox().height : 2 === d10.side ? g2.y + m2 : Math.cos(i10.rotation * so) * (g2.y - i10.getBBox(false, 0).height / 2), sn(o10.y) && (h10 = 0 === d10.side && d10.horiz ? o10.y + h10 : o10.y), t10 = t10 + sf(o10.x, [0, 1, 0, -1][d10.side] * m2) + f2 + g2.x - (r10 && s10 ? r10 * c10 * (p10 ? -1 : 1) : 0), e10 = e10 + h10 - (r10 && !s10 ? r10 * c10 * (p10 ? 1 : -1) : 0), u2 && (l10 = a10 / (n10 || 1) % u2, d10.opposite && (l10 = u2 - l10 - 1), e10 += l10 * (d10.labelOffset / u2)), x2.x = t10, x2.y = Math.round(e10), sd(this, "afterGetLabelPosition", {
            pos: x2,
            tickmarkOffset: r10,
            index: a10
          }), x2;
        }
        getLabelSize() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        }
        getMarkPath(t10, e10, i10, s10, o10 = false, r10) {
          return r10.crispLine([["M", t10, e10], ["L", t10 + (o10 ? 0 : -i10), e10 + (o10 ? i10 : 0)]], s10);
        }
        handleOverflow(t10) {
          let e10 = this.axis, i10 = e10.options.labels, s10 = t10.x, o10 = e10.chart.chartWidth, r10 = e10.chart.spacing, a10 = sf(e10.labelLeft, Math.min(e10.pos, r10[3])), n10 = sf(e10.labelRight, Math.max(e10.isRadial ? 0 : e10.pos + e10.len, o10 - r10[1])), h10 = this.label, l10 = this.rotation, d10 = sc(e10.labelAlign || h10.attr("align")), c10 = h10.getBBox().width, p10 = e10.getSlotWidth(this), u2 = p10, g2 = 1, f2, m2, x2;
          l10 || "justify" !== i10.overflow ? l10 < 0 && s10 - d10 * c10 < a10 ? x2 = Math.round(s10 / Math.cos(l10 * so) - a10) : l10 > 0 && s10 + d10 * c10 > n10 && (x2 = Math.round((o10 - s10) / Math.cos(l10 * so))) : (f2 = s10 - d10 * c10, m2 = s10 + (1 - d10) * c10, f2 < a10 ? u2 = t10.x + u2 * (1 - d10) - a10 : m2 > n10 && (u2 = n10 - t10.x + u2 * d10, g2 = -1), (u2 = Math.min(p10, u2)) < p10 && "center" === e10.labelAlign && (t10.x += g2 * (p10 - u2 - d10 * (p10 - Math.min(c10, u2)))), (c10 > u2 || e10.autoRotation && (h10.styles || {}).width) && (x2 = u2)), x2 && h10 && (this.shortenLabel ? this.shortenLabel() : h10.css(sl({}, {
            width: Math.floor(x2) + "px",
            lineClamp: e10.isRadial ? 0 : 1
          })));
        }
        moveLabel(t10, e10) {
          let i10 = this, s10 = i10.label, o10 = i10.axis, r10 = false, a10;
          s10 && s10.textStr === t10 ? (i10.movedLabel = s10, r10 = true, delete i10.label) : sg(o10.ticks, function(e11) {
            r10 || e11.isNew || e11 === i10 || !e11.label || e11.label.textStr !== t10 || (i10.movedLabel = e11.label, r10 = true, e11.labelPos = i10.movedLabel.xy, delete e11.label);
          }), !r10 && (i10.labelPos || s10) && (a10 = i10.labelPos || s10.xy, i10.movedLabel = i10.createLabel(t10, e10, a10), i10.movedLabel && i10.movedLabel.attr({
            opacity: 0
          }));
        }
        render(t10, e10, i10) {
          let s10 = this.axis, o10 = s10.horiz, r10 = this.pos, a10 = sf(this.tickmarkOffset, s10.tickmarkOffset), n10 = this.getPosition(o10, r10, a10, e10), h10 = n10.x, l10 = n10.y, d10 = s10.pos, c10 = d10 + s10.len, p10 = o10 ? h10 : l10;
          !s10.chart.polar && this.isNew && (sa(p10) < d10 || p10 > c10) && (i10 = 0);
          let u2 = sf(i10, this.label && this.label.newOpacity, 1);
          i10 = sf(i10, 1), this.isActive = true, this.renderGridLine(e10, i10), this.renderMark(n10, i10), this.renderLabel(n10, e10, u2, t10), this.isNew = false, sd(this, "afterRender");
        }
        renderGridLine(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = {}, r10 = this.pos, a10 = this.type, n10 = sf(this.tickmarkOffset, i10.tickmarkOffset), h10 = i10.chart.renderer, l10 = this.gridLine, d10, c10 = s10.gridLineWidth, p10 = s10.gridLineColor, u2 = s10.gridLineDashStyle;
          "minor" === this.type && (c10 = s10.minorGridLineWidth, p10 = s10.minorGridLineColor, u2 = s10.minorGridLineDashStyle), l10 || (i10.chart.styledMode || (o10.stroke = p10, o10["stroke-width"] = c10 || 0, o10.dashstyle = u2), a10 || (o10.zIndex = 1), t10 && (e10 = 0), this.gridLine = l10 = h10.path().attr(o10).addClass("highcharts-" + (a10 ? a10 + "-" : "") + "grid-line").add(i10.gridGroup)), l10 && (d10 = i10.getPlotLinePath({
            value: r10 + n10,
            lineWidth: l10.strokeWidth(),
            force: "pass",
            old: t10,
            acrossPanes: false
          })) && l10[t10 || this.isNew ? "attr" : "animate"]({
            d: d10,
            opacity: e10
          });
        }
        renderMark(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = i10.chart.renderer, r10 = this.type, a10 = i10.tickSize(r10 ? r10 + "Tick" : "tick"), n10 = t10.x, h10 = t10.y, l10 = sf(s10["minor" !== r10 ? "tickWidth" : "minorTickWidth"], !r10 && i10.isXAxis ? 1 : 0), d10 = s10["minor" !== r10 ? "tickColor" : "minorTickColor"], c10 = this.mark, p10 = !c10;
          a10 && (i10.opposite && (a10[0] = -a10[0]), c10 || (this.mark = c10 = o10.path().addClass("highcharts-" + (r10 ? r10 + "-" : "") + "tick").add(i10.axisGroup), i10.chart.styledMode || c10.attr({
            stroke: d10,
            "stroke-width": l10
          })), c10[p10 ? "attr" : "animate"]({
            d: this.getMarkPath(n10, h10, a10[0], c10.strokeWidth(), i10.horiz, o10),
            opacity: e10
          }));
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.horiz, a10 = o10.options, n10 = this.label, h10 = a10.labels, l10 = h10.step, d10 = sf(this.tickmarkOffset, o10.tickmarkOffset), c10 = t10.x, p10 = t10.y, u2 = true;
          n10 && sp(c10) && (n10.xy = t10 = this.getLabelPosition(c10, p10, n10, r10, h10, d10, s10, l10), (!this.isFirst || this.isLast || a10.showFirstLabel) && (!this.isLast || this.isFirst || a10.showLastLabel) ? !r10 || h10.step || h10.rotation || e10 || 0 === i10 || this.handleOverflow(t10) : u2 = false, l10 && s10 % l10 && (u2 = false), u2 && sp(t10.y) ? (t10.opacity = i10, n10[this.isNewLabel ? "attr" : "animate"](t10).show(true), this.isNewLabel = false) : (n10.hide(), this.isNewLabel = true));
        }
        replaceMovedLabel() {
          let t10 = this.label, e10 = this.axis;
          t10 && !this.isNew && (t10.animate({
            opacity: 0
          }, void 0, t10.destroy), delete this.label), e10.isDirty = true, this.label = this.movedLabel, delete this.movedLabel;
        }
      }, {
        animObject: sx
      } = t_, {
        xAxis: sy,
        yAxis: sb
      } = i8, {
        defaultOptions: sv
      } = tT, {
        registerEventOptions: sk
      } = ss, {
        deg2rad: sM
      } = L, {
        arrayMax: sw,
        arrayMin: sS,
        clamp: sA,
        correctFloat: sT,
        defined: sC,
        destroyObjectProperties: sP,
        erase: sO,
        error: sE,
        extend: sL,
        fireEvent: sD,
        getClosestDistance: sB,
        insertItem: sI,
        isArray: sz,
        isNumber: sR,
        isString: sN,
        merge: sW,
        normalizeTickInterval: sG,
        objectEach: sX,
        pick: sH,
        relativeLength: sF,
        removeEvent: sY,
        splat: sj,
        syncTimeout: sU
      } = ti, sV = (t10, e10) => sG(e10, void 0, void 0, sH(t10.options.allowDecimals, e10 < 0.5 || void 0 !== t10.tickAmount), !!t10.tickAmount);
      sL(sv, {
        xAxis: sy,
        yAxis: sW(sy, sb)
      });
      class s_ {
        constructor(t10, e10, i10) {
          this.init(t10, e10, i10);
        }
        init(t10, e10, i10 = this.coll) {
          let s10 = "xAxis" === i10, o10 = this.isZAxis || (t10.inverted ? !s10 : s10);
          this.chart = t10, this.horiz = o10, this.isXAxis = s10, this.coll = i10, sD(this, "init", {
            userOptions: e10
          }), this.opposite = sH(e10.opposite, this.opposite), this.side = sH(e10.side, this.side, o10 ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e10);
          let r10 = this.options, a10 = r10.labels;
          this.type ?? (this.type = r10.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r10.uniqueNames ?? true), sD(this, "afterSetType"), this.userOptions = e10, this.minPixelPadding = 0, this.reversed = sH(r10.reversed, this.reversed), this.visible = r10.visible, this.zoomEnabled = r10.zoomEnabled, this.hasNames = "category" === this.type || true === r10.categories, this.categories = sz(r10.categories) && r10.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = sC(r10.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r10.minRange || r10.maxZoom, this.range = r10.range, this.offset = r10.offset || 0, this.max = void 0, this.min = void 0;
          let n10 = sH(r10.crosshair, sj(t10.options.tooltip.crosshairs)[s10 ? 0 : 1]);
          this.crosshair = true === n10 ? {} : n10, -1 === t10.axes.indexOf(this) && (s10 ? t10.axes.splice(t10.xAxis.length, 0, this) : t10.axes.push(this), sI(this, t10[this.coll])), t10.orderItems(this.coll), this.series = this.series || [], t10.inverted && !this.isZAxis && s10 && !sC(this.reversed) && (this.reversed = true), this.labelRotation = sR(a10.rotation) ? a10.rotation : void 0, sk(this, r10), sD(this, "afterInit");
        }
        setOptions(t10) {
          let e10 = this.horiz ? {
            labels: {
              autoRotation: [-45],
              padding: 3
            },
            margin: 15
          } : {
            labels: {
              padding: 1
            },
            title: {
              rotation: 90 * this.side
            }
          };
          this.options = sW(e10, sv[this.coll], t10), sD(this, "afterSetOptions", {
            userOptions: t10
          });
        }
        defaultLabelFormatter() {
          let t10 = this.axis, {
            numberFormatter: e10
          } = this.chart, i10 = sR(this.value) ? this.value : NaN, s10 = t10.chart.time, o10 = t10.categories, r10 = this.dateTimeLabelFormat, a10 = sv.lang, n10 = a10.numericSymbols, h10 = a10.numericSymbolMagnitude || 1e3, l10 = t10.logarithmic ? Math.abs(i10) : t10.tickInterval, d10 = n10 && n10.length, c10, p10;
          if (o10) p10 = `${this.value}`;
          else if (r10) p10 = s10.dateFormat(r10, i10, true);
          else if (d10 && n10 && l10 >= 1e3) for (; d10-- && void 0 === p10; ) l10 >= (c10 = Math.pow(h10, d10 + 1)) && 10 * i10 % c10 == 0 && null !== n10[d10] && 0 !== i10 && (p10 = e10(i10 / c10, -1) + n10[d10]);
          return void 0 === p10 && (p10 = Math.abs(i10) >= 1e4 ? e10(i10, -1) : e10(i10, -1, void 0, "")), p10;
        }
        getSeriesExtremes() {
          let t10;
          let e10 = this;
          sD(this, "getSeriesExtremes", null, function() {
            e10.hasVisibleSeries = false, e10.dataMin = e10.dataMax = e10.threshold = void 0, e10.softThreshold = !e10.isXAxis, e10.series.forEach((i10) => {
              if (i10.reserveSpace()) {
                let s10 = i10.options, o10, r10 = s10.threshold, a10, n10;
                if (e10.hasVisibleSeries = true, e10.positiveValuesOnly && 0 >= (r10 || 0) && (r10 = void 0), e10.isXAxis) (o10 = i10.getColumn("x")).length && (o10 = e10.logarithmic ? o10.filter((t11) => t11 > 0) : o10, a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max, sR(a10) || a10 instanceof Date || (o10 = o10.filter(sR), a10 = (t10 = i10.getXExtremes(o10)).min, n10 = t10.max), o10.length && (e10.dataMin = Math.min(sH(e10.dataMin, a10), a10), e10.dataMax = Math.max(sH(e10.dataMax, n10), n10)));
                else {
                  let t11 = i10.applyExtremes();
                  sR(t11.dataMin) && (a10 = t11.dataMin, e10.dataMin = Math.min(sH(e10.dataMin, a10), a10)), sR(t11.dataMax) && (n10 = t11.dataMax, e10.dataMax = Math.max(sH(e10.dataMax, n10), n10)), sC(r10) && (e10.threshold = r10), (!s10.softThreshold || e10.positiveValuesOnly) && (e10.softThreshold = false);
                }
              }
            });
          }), sD(this, "afterGetSeriesExtremes");
        }
        translate(t10, e10, i10, s10, o10, r10) {
          let a10 = this.linkedParent || this, n10 = s10 && a10.old ? a10.old.min : a10.min;
          if (!sR(n10)) return NaN;
          let h10 = a10.minPixelPadding, l10 = (a10.isOrdinal || a10.brokenAxis?.hasBreaks || a10.logarithmic && o10) && a10.lin2val, d10 = 1, c10 = 0, p10 = s10 && a10.old ? a10.old.transA : a10.transA, u2 = 0;
          return p10 || (p10 = a10.transA), i10 && (d10 *= -1, c10 = a10.len), a10.reversed && (d10 *= -1, c10 -= d10 * (a10.sector || a10.len)), e10 ? (u2 = (t10 = t10 * d10 + c10 - h10) / p10 + n10, l10 && (u2 = a10.lin2val(u2))) : (l10 && (t10 = a10.val2lin(t10)), u2 = d10 * (t10 - n10) * p10 + c10 + d10 * h10 + (sR(r10) ? p10 * r10 : 0), a10.isRadial || (u2 = sT(u2))), u2;
        }
        toPixels(t10, e10) {
          return this.translate(this.chart?.time.parse(t10) ?? NaN, false, !this.horiz, void 0, true) + (e10 ? 0 : this.pos);
        }
        toValue(t10, e10) {
          return this.translate(t10 - (e10 ? 0 : this.pos), true, !this.horiz, void 0, true);
        }
        getPlotLinePath(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.left, o10 = e10.top, r10 = t10.old, a10 = t10.value, n10 = t10.lineWidth, h10 = r10 && i10.oldChartHeight || i10.chartHeight, l10 = r10 && i10.oldChartWidth || i10.chartWidth, d10 = e10.transB, c10 = t10.translatedValue, p10 = t10.force, u2, g2, f2, m2, x2;
          function y2(t11, e11, i11) {
            return "pass" !== p10 && (t11 < e11 || t11 > i11) && (p10 ? t11 = sA(t11, e11, i11) : x2 = true), t11;
          }
          let b2 = {
            value: a10,
            lineWidth: n10,
            old: r10,
            force: p10,
            acrossPanes: t10.acrossPanes,
            translatedValue: c10
          };
          return sD(this, "getPlotLinePath", b2, function(t11) {
            u2 = f2 = (c10 = sA(c10 = sH(c10, e10.translate(a10, void 0, void 0, r10)), -1e9, 1e9)) + d10, g2 = m2 = h10 - c10 - d10, sR(c10) ? e10.horiz ? (g2 = o10, m2 = h10 - e10.bottom + (e10.options.isInternal ? 0 : i10.scrollablePixelsY || 0), u2 = f2 = y2(u2, s10, s10 + e10.width)) : (u2 = s10, f2 = l10 - e10.right + (i10.scrollablePixelsX || 0), g2 = m2 = y2(g2, o10, o10 + e10.height)) : (x2 = true, p10 = false), t11.path = x2 && !p10 ? void 0 : i10.renderer.crispLine([["M", u2, g2], ["L", f2, m2]], n10 || 1);
          }), b2.path;
        }
        getLinearTickPositions(t10, e10, i10) {
          let s10, o10, r10;
          let a10 = sT(Math.floor(e10 / t10) * t10), n10 = sT(Math.ceil(i10 / t10) * t10), h10 = [];
          if (sT(a10 + t10) === a10 && (r10 = 20), this.single) return [e10];
          for (s10 = a10; s10 <= n10 && (h10.push(s10), (s10 = sT(s10 + t10, r10)) !== o10); ) o10 = s10;
          return h10;
        }
        getMinorTickInterval() {
          let {
            minorTicks: t10,
            minorTickInterval: e10
          } = this.options;
          return true === t10 ? sH(e10, "auto") : false !== t10 ? e10 : void 0;
        }
        getMinorTickPositions() {
          let t10 = this.options, e10 = this.tickPositions, i10 = this.minorTickInterval, s10 = this.pointRangePadding || 0, o10 = (this.min || 0) - s10, r10 = (this.max || 0) + s10, a10 = this.brokenAxis?.hasBreaks ? this.brokenAxis.unitLength : r10 - o10, n10 = [], h10;
          if (a10 && a10 / i10 < this.len / 3) {
            let s11 = this.logarithmic;
            if (s11) this.paddedTicks.forEach(function(t11, e11, o11) {
              e11 && n10.push.apply(n10, s11.getLogTickPositions(i10, o11[e11 - 1], o11[e11], true));
            });
            else if (this.dateTime && "auto" === this.getMinorTickInterval()) n10 = n10.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i10), o10, r10, t10.startOfWeek));
            else for (h10 = o10 + (e10[0] - o10) % i10; h10 <= r10 && h10 !== n10[0]; h10 += i10) n10.push(h10);
          }
          return 0 !== n10.length && this.trimTicks(n10), n10;
        }
        adjustForMinRange() {
          let t10 = this.options, e10 = this.logarithmic, i10 = this.chart.time, {
            max: s10,
            min: o10,
            minRange: r10
          } = this, a10, n10, h10, l10;
          this.isXAxis && void 0 === r10 && !e10 && (r10 = sC(t10.min) || sC(t10.max) || sC(t10.floor) || sC(t10.ceiling) ? null : Math.min(5 * (sB(this.series.map((t11) => {
            let e11 = t11.getColumn("x");
            return t11.xIncrement ? e11.slice(0, 2) : e11;
          })) || 0), this.dataMax - this.dataMin)), sR(s10) && sR(o10) && sR(r10) && s10 - o10 < r10 && (n10 = this.dataMax - this.dataMin >= r10, a10 = (r10 - s10 + o10) / 2, h10 = [o10 - a10, i10.parse(t10.min) ?? o10 - a10], n10 && (h10[2] = e10 ? e10.log2lin(this.dataMin) : this.dataMin), l10 = [(o10 = sw(h10)) + r10, i10.parse(t10.max) ?? o10 + r10], n10 && (l10[2] = e10 ? e10.log2lin(this.dataMax) : this.dataMax), (s10 = sS(l10)) - o10 < r10 && (h10[0] = s10 - r10, h10[1] = i10.parse(t10.min) ?? s10 - r10, o10 = sw(h10))), this.minRange = r10, this.min = o10, this.max = s10;
        }
        getClosest() {
          let t10, e10;
          if (this.categories) e10 = 1;
          else {
            let i10 = [];
            this.series.forEach(function(t11) {
              let s10 = t11.closestPointRange, o10 = t11.getColumn("x");
              1 === o10.length ? i10.push(o10[0]) : t11.sorted && sC(s10) && t11.reserveSpace() && (e10 = sC(e10) ? Math.min(e10, s10) : s10);
            }), i10.length && (i10.sort((t11, e11) => t11 - e11), t10 = sB([i10]));
          }
          return t10 && e10 ? Math.min(t10, e10) : t10 || e10;
        }
        nameToX(t10) {
          let e10 = sz(this.options.categories), i10 = e10 ? this.categories : this.names, s10 = t10.options.x, o10;
          return t10.series.requireSorting = false, sC(s10) || (s10 = this.uniqueNames && i10 ? e10 ? i10.indexOf(t10.name) : sH(i10.keys[t10.name], -1) : t10.series.autoIncrement()), -1 === s10 ? !e10 && i10 && (o10 = i10.length) : sR(s10) && (o10 = s10), void 0 !== o10 ? (this.names[o10] = t10.name, this.names.keys[t10.name] = o10) : t10.x && (o10 = t10.x), o10;
        }
        updateNames() {
          let t10 = this, e10 = this.names;
          e10.length > 0 && (Object.keys(e10.keys).forEach(function(t11) {
            delete e10.keys[t11];
          }), e10.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e11) => {
            e11.xIncrement = null, (!e11.points || e11.isDirtyData) && (t10.max = Math.max(t10.max || 0, e11.dataTable.rowCount - 1), e11.processData(), e11.generatePoints());
            let i10 = e11.getColumn("x").slice();
            e11.data.forEach((e12, s10) => {
              let o10 = i10[s10];
              e12?.options && void 0 !== e12.name && void 0 !== (o10 = t10.nameToX(e12)) && o10 !== e12.x && (i10[s10] = e12.x = o10);
            }), e11.dataTable.setColumn("x", i10);
          }));
        }
        setAxisTranslation() {
          let t10 = this, e10 = t10.max - t10.min, i10 = t10.linkedParent, s10 = !!t10.categories, o10 = t10.isXAxis, r10 = t10.axisPointRange || 0, a10, n10 = 0, h10 = 0, l10, d10 = t10.transA;
          (o10 || s10 || r10) && (a10 = t10.getClosest(), i10 ? (n10 = i10.minPointOffset, h10 = i10.pointRangePadding) : t10.series.forEach(function(e11) {
            let i11 = s10 ? 1 : o10 ? sH(e11.options.pointRange, a10, 0) : t10.axisPointRange || 0, l11 = e11.options.pointPlacement;
            if (r10 = Math.max(r10, i11), !t10.single || s10) {
              let t11 = e11.is("xrange") ? !o10 : o10;
              n10 = Math.max(n10, t11 && sN(l11) ? 0 : i11 / 2), h10 = Math.max(h10, t11 && "on" === l11 ? 0 : i11);
            }
          }), l10 = t10.ordinal && t10.ordinal.slope && a10 ? t10.ordinal.slope / a10 : 1, t10.minPointOffset = n10 *= l10, t10.pointRangePadding = h10 *= l10, t10.pointRange = Math.min(r10, t10.single && s10 ? 1 : e10), o10 && a10 && (t10.closestPointRange = a10)), t10.translationSlope = t10.transA = d10 = t10.staticScale || t10.len / (e10 + h10 || 1), t10.transB = t10.horiz ? t10.left : t10.bottom, t10.minPixelPadding = d10 * n10, sD(this, "afterSetAxisTranslation");
        }
        minFromRange() {
          let {
            max: t10,
            min: e10
          } = this;
          return sR(t10) && sR(e10) && t10 - e10 || void 0;
        }
        setTickInterval(t10) {
          let {
            categories: e10,
            chart: i10,
            dataMax: s10,
            dataMin: o10,
            dateTime: r10,
            isXAxis: a10,
            logarithmic: n10,
            options: h10,
            softThreshold: l10
          } = this, d10 = i10.time, c10 = sR(this.threshold) ? this.threshold : void 0, p10 = this.minRange || 0, {
            ceiling: u2,
            floor: g2,
            linkedTo: f2,
            softMax: m2,
            softMin: x2
          } = h10, y2 = sR(f2) && i10[this.coll]?.[f2], b2 = h10.tickPixelInterval, v2 = h10.maxPadding, k2 = h10.minPadding, M2 = 0, w2, S2 = sR(h10.tickInterval) && h10.tickInterval >= 0 ? h10.tickInterval : void 0, A2, T2, C2, P2;
          if (r10 || e10 || y2 || this.getTickAmount(), C2 = sH(this.userMin, d10.parse(h10.min)), P2 = sH(this.userMax, d10.parse(h10.max)), y2 ? (this.linkedParent = y2, w2 = y2.getExtremes(), this.min = sH(w2.min, w2.dataMin), this.max = sH(w2.max, w2.dataMax), this.type !== y2.type && sE(11, true, i10)) : (l10 && sC(c10) && sR(s10) && sR(o10) && (o10 >= c10 ? (A2 = c10, k2 = 0) : s10 <= c10 && (T2 = c10, v2 = 0)), this.min = sH(C2, A2, o10), this.max = sH(P2, T2, s10)), sR(this.max) && sR(this.min) && (n10 && (this.positiveValuesOnly && !t10 && 0 >= Math.min(this.min, sH(o10, this.min)) && sE(10, true, i10), this.min = sT(n10.log2lin(this.min), 16), this.max = sT(n10.log2lin(this.max), 16)), this.range && sR(o10) && (this.userMin = this.min = C2 = Math.max(o10, this.minFromRange() || 0), this.userMax = P2 = this.max, this.range = void 0)), sD(this, "foundExtremes"), this.adjustForMinRange(), sR(this.min) && sR(this.max)) {
            if (!sR(this.userMin) && sR(x2) && x2 < this.min && (this.min = C2 = x2), !sR(this.userMax) && sR(m2) && m2 > this.max && (this.max = P2 = m2), e10 || this.axisPointRange || this.stacking?.usePercentage || y2 || !(M2 = this.max - this.min) || (!sC(C2) && k2 && (this.min -= M2 * k2), sC(P2) || !v2 || (this.max += M2 * v2)), !sR(this.userMin) && sR(g2) && (this.min = Math.max(this.min, g2)), !sR(this.userMax) && sR(u2) && (this.max = Math.min(this.max, u2)), l10 && sR(o10) && sR(s10)) {
              let t11 = c10 || 0;
              !sC(C2) && this.min < t11 && o10 >= t11 ? this.min = h10.minRange ? Math.min(t11, this.max - p10) : t11 : !sC(P2) && this.max > t11 && s10 <= t11 && (this.max = h10.minRange ? Math.max(t11, this.min + p10) : t11);
            }
            !i10.polar && this.min > this.max && (sC(h10.min) ? this.max = this.min : sC(h10.max) && (this.min = this.max)), M2 = this.max - this.min;
          }
          if (this.min !== this.max && sR(this.min) && sR(this.max) ? y2 && !S2 && b2 === y2.options.tickPixelInterval ? this.tickInterval = S2 = y2.tickInterval : this.tickInterval = sH(S2, this.tickAmount ? M2 / Math.max(this.tickAmount - 1, 1) : void 0, e10 ? 1 : M2 * b2 / Math.max(this.len, b2)) : this.tickInterval = 1, a10 && !t10) {
            let t11 = this.min !== this.old?.min || this.max !== this.old?.max;
            this.series.forEach(function(e11) {
              e11.forceCrop = e11.forceCropping?.(), e11.processData(t11);
            }), sD(this, "postProcessData", {
              hasExtremesChanged: t11
            });
          }
          this.setAxisTranslation(), sD(this, "initialAxisTranslation"), this.pointRange && !S2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
          let O2 = sH(h10.minTickInterval, r10 && !this.series.some((t11) => !t11.sorted) ? this.closestPointRange : 0);
          !S2 && this.tickInterval < O2 && (this.tickInterval = O2), r10 || n10 || S2 || (this.tickInterval = sV(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
        }
        setTickPositions() {
          let t10 = this.options, e10 = t10.tickPositions, i10 = t10.tickPositioner, s10 = this.getMinorTickInterval(), o10 = !this.isPanning, r10 = o10 && t10.startOnTick, a10 = o10 && t10.endOnTick, n10 = [], h10;
          if (this.tickmarkOffset = this.categories && "between" === t10.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0, this.single = this.min === this.max && sC(this.min) && !this.tickAmount && (this.min % 1 == 0 || false !== t10.allowDecimals), e10) n10 = e10.slice();
          else if (sR(this.min) && sR(this.max)) {
            if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) n10 = [this.min, this.max], sE(19, false, this.chart);
            else if (this.dateTime) n10 = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t10.units), this.min, this.max, t10.startOfWeek, this.ordinal?.positions, this.closestPointRange, true);
            else if (this.logarithmic) n10 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
            else {
              let t11 = this.tickInterval, e11 = t11;
              for (; e11 <= 2 * t11; ) if (n10 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && n10.length > this.tickAmount) this.tickInterval = sV(this, e11 *= 1.1);
              else break;
            }
            n10.length > this.len && (n10 = [n10[0], n10[n10.length - 1]])[0] === n10[1] && (n10.length = 1), i10 && (this.tickPositions = n10, (h10 = i10.apply(this, [this.min, this.max])) && (n10 = h10));
          }
          this.tickPositions = n10, this.minorTickInterval = "auto" === s10 && this.tickInterval ? this.tickInterval / t10.minorTicksPerMajor : s10, this.paddedTicks = n10.slice(0), this.trimTicks(n10, r10, a10), !this.isLinked && sR(this.min) && sR(this.max) && (this.single && n10.length < 2 && !this.categories && !this.series.some((t11) => t11.is("heatmap") && "between" === t11.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), e10 || h10 || this.adjustTickAmount()), sD(this, "afterSetTickPositions");
        }
        trimTicks(t10, e10, i10) {
          let s10 = t10[0], o10 = t10[t10.length - 1], r10 = !this.isOrdinal && this.minPointOffset || 0;
          if (sD(this, "trimTicks"), !this.isLinked) {
            if (e10 && s10 !== -1 / 0) this.min = s10;
            else for (; this.min - r10 > t10[0]; ) t10.shift();
            if (i10) this.max = o10;
            else for (; this.max + r10 < t10[t10.length - 1]; ) t10.pop();
            0 === t10.length && sC(s10) && !this.options.tickPositions && t10.push((o10 + s10) / 2);
          }
        }
        alignToOthers() {
          let t10;
          let e10 = this, i10 = e10.chart, s10 = [this], o10 = e10.options, r10 = i10.options.chart, a10 = "yAxis" === this.coll && r10.alignThresholds, n10 = [];
          if (e10.thresholdAlignment = void 0, (false !== r10.alignTicks && o10.alignTicks || a10) && false !== o10.startOnTick && false !== o10.endOnTick && !e10.logarithmic) {
            let o11 = (t11) => {
              let {
                horiz: e11,
                options: i11
              } = t11;
              return [e11 ? i11.left : i11.top, i11.width, i11.height, i11.pane].join(",");
            }, r11 = o11(this);
            i10[this.coll].forEach(function(i11) {
              let {
                series: a11
              } = i11;
              a11.length && a11.some((t11) => t11.visible) && i11 !== e10 && o11(i11) === r11 && (t10 = true, s10.push(i11));
            });
          }
          if (t10 && a10) {
            s10.forEach((t12) => {
              let i11 = t12.getThresholdAlignment(e10);
              sR(i11) && n10.push(i11);
            });
            let t11 = n10.length > 1 ? n10.reduce((t12, e11) => t12 += e11, 0) / n10.length : void 0;
            s10.forEach((e11) => {
              e11.thresholdAlignment = t11;
            });
          }
          return t10;
        }
        getThresholdAlignment(t10) {
          if ((!sR(this.dataMin) || this !== t10 && this.series.some((t11) => t11.isDirty || t11.isDirtyData)) && this.getSeriesExtremes(), sR(this.threshold)) {
            let t11 = sA((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
            return this.options.reversed && (t11 = 1 - t11), t11;
          }
        }
        getTickAmount() {
          let t10 = this.options, e10 = t10.tickPixelInterval, i10 = t10.tickAmount;
          sC(t10.tickInterval) || i10 || !(this.len < e10) || this.isRadial || this.logarithmic || !t10.startOnTick || !t10.endOnTick || (i10 = 2), !i10 && this.alignToOthers() && (i10 = Math.ceil(this.len / e10) + 1), i10 < 4 && (this.finalTickAmt = i10, i10 = 5), this.tickAmount = i10;
        }
        adjustTickAmount() {
          let t10 = this, {
            finalTickAmt: e10,
            max: i10,
            min: s10,
            options: o10,
            tickPositions: r10,
            tickAmount: a10,
            thresholdAlignment: n10
          } = t10, h10 = r10?.length, l10 = sH(t10.threshold, t10.softThreshold ? 0 : null), d10, c10, p10 = t10.tickInterval, u2, g2 = () => r10.push(sT(r10[r10.length - 1] + p10)), f2 = () => r10.unshift(sT(r10[0] - p10));
          if (sR(n10) && (u2 = n10 < 0.5 ? Math.ceil(n10 * (a10 - 1)) : Math.floor(n10 * (a10 - 1)), o10.reversed && (u2 = a10 - 1 - u2)), t10.hasData() && sR(s10) && sR(i10)) {
            let n11 = () => {
              t10.transA *= (h10 - 1) / (a10 - 1), t10.min = o10.startOnTick ? r10[0] : Math.min(s10, r10[0]), t10.max = o10.endOnTick ? r10[r10.length - 1] : Math.max(i10, r10[r10.length - 1]);
            };
            if (sR(u2) && sR(t10.threshold)) {
              for (; r10[u2] !== l10 || r10.length !== a10 || r10[0] > s10 || r10[r10.length - 1] < i10; ) {
                for (r10.length = 0, r10.push(t10.threshold); r10.length < a10; ) void 0 === r10[u2] || r10[u2] > t10.threshold ? f2() : g2();
                if (p10 > 8 * t10.tickInterval) break;
                p10 *= 2;
              }
              n11();
            } else if (h10 < a10) {
              for (; r10.length < a10; ) r10.length % 2 || s10 === l10 ? g2() : f2();
              n11();
            }
            if (sC(e10)) {
              for (c10 = d10 = r10.length; c10--; ) (3 === e10 && c10 % 2 == 1 || e10 <= 2 && c10 > 0 && c10 < d10 - 1) && r10.splice(c10, 1);
              t10.finalTickAmt = void 0;
            }
          }
        }
        setScale() {
          let {
            coll: t10,
            stacking: e10
          } = this, i10 = false, s10 = false;
          this.series.forEach((t11) => {
            i10 = i10 || t11.isDirtyData || t11.isDirty, s10 = s10 || t11.xAxis && t11.xAxis.isDirty || false;
          }), this.setAxisSize();
          let o10 = this.len !== (this.old && this.old.len);
          o10 || i10 || s10 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e10 && "yAxis" === t10 && e10.buildStacks(), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e10 && "xAxis" === t10 && e10.buildStacks(), this.isDirty || (this.isDirty = o10 || this.min !== this.old?.min || this.max !== this.old?.max)) : e10 && e10.cleanStacks(), i10 && delete this.allExtremes, sD(this, "afterSetScale");
        }
        setExtremes(t10, e10, i10 = true, s10, o10) {
          let r10 = this.chart;
          this.series.forEach((t11) => {
            delete t11.kdTree;
          }), t10 = r10.time.parse(t10), e10 = r10.time.parse(e10), sD(this, "setExtremes", o10 = sL(o10, {
            min: t10,
            max: e10
          }), (t11) => {
            this.userMin = t11.min, this.userMax = t11.max, this.eventArgs = t11, i10 && r10.redraw(s10);
          });
        }
        setAxisSize() {
          let t10 = this.chart, e10 = this.options, i10 = e10.offsets || [0, 0, 0, 0], s10 = this.horiz, o10 = this.width = Math.round(sF(sH(e10.width, t10.plotWidth - i10[3] + i10[1]), t10.plotWidth)), r10 = this.height = Math.round(sF(sH(e10.height, t10.plotHeight - i10[0] + i10[2]), t10.plotHeight)), a10 = this.top = Math.round(sF(sH(e10.top, t10.plotTop + i10[0]), t10.plotHeight, t10.plotTop)), n10 = this.left = Math.round(sF(sH(e10.left, t10.plotLeft + i10[3]), t10.plotWidth, t10.plotLeft));
          this.bottom = t10.chartHeight - r10 - a10, this.right = t10.chartWidth - o10 - n10, this.len = Math.max(s10 ? o10 : r10, 0), this.pos = s10 ? n10 : a10;
        }
        getExtremes() {
          let t10 = this.logarithmic;
          return {
            min: t10 ? sT(t10.lin2log(this.min)) : this.min,
            max: t10 ? sT(t10.lin2log(this.max)) : this.max,
            dataMin: this.dataMin,
            dataMax: this.dataMax,
            userMin: this.userMin,
            userMax: this.userMax
          };
        }
        getThreshold(t10) {
          let e10 = this.logarithmic, i10 = e10 ? e10.lin2log(this.min) : this.min, s10 = e10 ? e10.lin2log(this.max) : this.max;
          return null === t10 || t10 === -1 / 0 ? t10 = i10 : t10 === 1 / 0 ? t10 = s10 : i10 > t10 ? t10 = i10 : s10 < t10 && (t10 = s10), this.translate(t10, 0, 1, 0, 1);
        }
        autoLabelAlign(t10) {
          let e10 = (sH(t10, 0) - 90 * this.side + 720) % 360, i10 = {
            align: "center"
          };
          return sD(this, "autoLabelAlign", i10, function(t11) {
            e10 > 15 && e10 < 165 ? t11.align = "right" : e10 > 195 && e10 < 345 && (t11.align = "left");
          }), i10.align;
        }
        tickSize(t10) {
          let e10 = this.options, i10 = sH(e10["tick" === t10 ? "tickWidth" : "minorTickWidth"], "tick" === t10 && this.isXAxis && !this.categories ? 1 : 0), s10 = e10["tick" === t10 ? "tickLength" : "minorTickLength"], o10;
          i10 && s10 && ("inside" === e10[t10 + "Position"] && (s10 = -s10), o10 = [s10, i10]);
          let r10 = {
            tickSize: o10
          };
          return sD(this, "afterTickSize", r10), r10.tickSize;
        }
        labelMetrics() {
          let t10 = this.chart.renderer, e10 = this.ticks, i10 = e10[Object.keys(e10)[0]] || {};
          return this.chart.renderer.fontMetrics(i10.label || i10.movedLabel || t10.box);
        }
        unsquish() {
          let t10 = this.options.labels, e10 = t10.padding || 0, i10 = this.horiz, s10 = this.tickInterval, o10 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s10), r10 = t10.rotation, a10 = sT(0.8 * this.labelMetrics().h), n10 = Math.max(this.max - this.min, 0), h10 = function(t11) {
            let i11 = (t11 + 2 * e10) / (o10 || 1);
            return (i11 = i11 > 1 ? Math.ceil(i11) : 1) * s10 > n10 && t11 !== 1 / 0 && o10 !== 1 / 0 && n10 && (i11 = Math.ceil(n10 / s10)), sT(i11 * s10);
          }, l10 = s10, d10, c10 = Number.MAX_VALUE, p10;
          if (i10) {
            if (!t10.staggerLines && (sR(r10) ? p10 = [r10] : o10 < t10.autoRotationLimit && (p10 = t10.autoRotation)), p10) {
              let t11, e11;
              for (let i11 of p10) (i11 === r10 || i11 && i11 >= -90 && i11 <= 90) && (e11 = (t11 = h10(Math.abs(a10 / Math.sin(sM * i11)))) + Math.abs(i11 / 360)) < c10 && (c10 = e11, d10 = i11, l10 = t11);
            }
          } else l10 = h10(0.75 * a10);
          return this.autoRotation = p10, this.labelRotation = sH(d10, sR(r10) ? r10 : 0), t10.step ? s10 : l10;
        }
        getSlotWidth(t10) {
          let e10 = this.chart, i10 = this.horiz, s10 = this.options.labels, o10 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), r10 = e10.margin[3];
          if (t10 && sR(t10.slotWidth)) return t10.slotWidth;
          if (i10 && s10.step < 2 && !this.isRadial) return s10.rotation ? 0 : (this.staggerLines || 1) * this.len / o10;
          if (!i10) {
            let t11 = s10.style.width;
            if (void 0 !== t11) return parseInt(String(t11), 10);
            if (r10) return r10 - e10.spacing[3];
          }
          return 0.33 * e10.chartWidth;
        }
        renderUnsquish() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.tickPositions, s10 = this.ticks, o10 = this.options.labels, r10 = o10.style, a10 = this.horiz, n10 = this.getSlotWidth(), h10 = Math.max(1, Math.round(n10 - (a10 ? 2 * (o10.padding || 0) : o10.distance || 0))), l10 = {}, d10 = this.labelMetrics(), c10 = r10.lineClamp, p10, u2 = c10 ?? (Math.floor(this.len / (i10.length * d10.h)) || 1), g2 = 0;
          sN(o10.rotation) || (l10.rotation = o10.rotation || 0), i10.forEach(function(t11) {
            let e11 = s10[t11];
            e11.movedLabel && e11.replaceMovedLabel();
            let i11 = e11.label?.textPxLength || 0;
            i11 > g2 && (g2 = i11);
          }), this.maxLabelLength = g2, this.autoRotation ? g2 > h10 && g2 > d10.h ? l10.rotation = this.labelRotation : this.labelRotation = 0 : n10 && (p10 = h10), l10.rotation && (p10 = g2 > 0.5 * t10.chartHeight ? 0.33 * t10.chartHeight : g2, c10 || (u2 = 1)), this.labelAlign = o10.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l10.align = this.labelAlign), i10.forEach(function(t11) {
            let e11 = s10[t11], i11 = e11 && e11.label, o11 = r10.width, a11 = {};
            i11 && (i11.attr(l10), e11.shortenLabel ? e11.shortenLabel() : p10 && !o11 && "nowrap" !== r10.whiteSpace && (p10 < (i11.textPxLength || 0) || "SPAN" === i11.element.tagName) ? i11.css(sL(a11, {
              width: `${p10}px`,
              lineClamp: u2
            })) : !i11.styles.width || a11.width || o11 || i11.css({
              width: "auto"
            }), e11.rotation = l10.rotation);
          }, this), this.tickRotCorr = e10.rotCorr(d10.b, this.labelRotation || 0, 0 !== this.side);
        }
        hasData() {
          return this.series.some(function(t10) {
            return t10.hasData();
          }) || this.options.showEmpty && sC(this.min) && sC(this.max);
        }
        addTitle(t10) {
          let e10;
          let i10 = this.chart.renderer, s10 = this.horiz, o10 = this.opposite, r10 = this.options.title, a10 = this.chart.styledMode;
          this.axisTitle || ((e10 = r10.textAlign) || (e10 = (s10 ? {
            low: "left",
            middle: "center",
            high: "right"
          } : {
            low: o10 ? "right" : "left",
            middle: "center",
            high: o10 ? "left" : "right"
          })[r10.align]), this.axisTitle = i10.text(r10.text || "", 0, 0, r10.useHTML).attr({
            zIndex: 7,
            rotation: r10.rotation || 0,
            align: e10
          }).addClass("highcharts-axis-title"), a10 || this.axisTitle.css(sW(r10.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true), a10 || r10.style.width || this.isRadial || this.axisTitle.css({
            width: this.len + "px"
          }), this.axisTitle[t10 ? "show" : "hide"](t10);
        }
        generateTick(t10) {
          let e10 = this.ticks;
          e10[t10] ? e10[t10].addLabel() : e10[t10] = new sm(this, t10);
        }
        createGroups() {
          let {
            axisParent: t10,
            chart: e10,
            coll: i10,
            options: s10
          } = this, o10 = e10.renderer, r10 = (e11, r11, a10) => o10.g(e11).attr({
            zIndex: a10
          }).addClass(`highcharts-${i10.toLowerCase()}${r11} ` + (this.isRadial ? `highcharts-radial-axis${r11} ` : "") + (s10.className || "")).add(t10);
          this.axisGroup || (this.gridGroup = r10("grid", "-grid", s10.gridZIndex), this.axisGroup = r10("axis", "", s10.zIndex), this.labelGroup = r10("axis-labels", "-labels", s10.labels.zIndex));
        }
        getOffset() {
          let t10 = this, {
            chart: e10,
            horiz: i10,
            options: s10,
            side: o10,
            ticks: r10,
            tickPositions: a10,
            coll: n10
          } = t10, h10 = e10.inverted && !t10.isZAxis ? [1, 0, 3, 2][o10] : o10, l10 = t10.hasData(), d10 = s10.title, c10 = s10.labels, p10 = sR(s10.crossing), u2 = e10.axisOffset, g2 = e10.clipOffset, f2 = [-1, 1, 1, -1][o10], m2, x2 = 0, y2, b2 = 0, v2 = 0, k2, M2;
          if (t10.showAxis = m2 = l10 || s10.showEmpty, t10.staggerLines = t10.horiz && c10.staggerLines || void 0, t10.createGroups(), l10 || t10.isLinked ? (a10.forEach(function(e11) {
            t10.generateTick(e11);
          }), t10.renderUnsquish(), t10.reserveSpaceDefault = 0 === o10 || 2 === o10 || {
            1: "left",
            3: "right"
          }[o10] === t10.labelAlign, sH(c10.reserveSpace, !p10 && null, "center" === t10.labelAlign || null, t10.reserveSpaceDefault) && a10.forEach(function(t11) {
            v2 = Math.max(r10[t11].getLabelSize(), v2);
          }), t10.staggerLines && (v2 *= t10.staggerLines), t10.labelOffset = v2 * (t10.opposite ? -1 : 1)) : sX(r10, function(t11, e11) {
            t11.destroy(), delete r10[e11];
          }), d10?.text && false !== d10.enabled && (t10.addTitle(m2), m2 && !p10 && false !== d10.reserveSpace && (t10.titleOffset = x2 = t10.axisTitle.getBBox()[i10 ? "height" : "width"], b2 = sC(y2 = d10.offset) ? 0 : sH(d10.margin, i10 ? 5 : 10))), t10.renderLine(), t10.offset = f2 * sH(s10.offset, u2[o10] ? u2[o10] + (s10.margin || 0) : 0), t10.tickRotCorr = t10.tickRotCorr || {
            x: 0,
            y: 0
          }, M2 = 0 === o10 ? -t10.labelMetrics().h : 2 === o10 ? t10.tickRotCorr.y : 0, k2 = Math.abs(v2) + b2, v2 && (k2 -= M2, k2 += f2 * (i10 ? sH(c10.y, t10.tickRotCorr.y + f2 * c10.distance) : sH(c10.x, f2 * c10.distance))), t10.axisTitleMargin = sH(y2, k2), t10.getMaxLabelDimensions && (t10.maxLabelDimensions = t10.getMaxLabelDimensions(r10, a10)), "colorAxis" !== n10 && g2) {
            let e11 = this.tickSize("tick");
            u2[o10] = Math.max(u2[o10], (t10.axisTitleMargin || 0) + x2 + f2 * t10.offset, k2, a10 && a10.length && e11 ? e11[0] + f2 * t10.offset : 0);
            let i11 = !t10.axisLine || s10.offset ? 0 : t10.axisLine.strokeWidth() / 2;
            g2[h10] = Math.max(g2[h10], i11);
          }
          sD(this, "afterGetOffset");
        }
        getLinePath(t10) {
          let e10 = this.chart, i10 = this.opposite, s10 = this.offset, o10 = this.horiz, r10 = this.left + (i10 ? this.width : 0) + s10, a10 = e10.chartHeight - this.bottom - (i10 ? this.height : 0) + s10;
          return i10 && (t10 *= -1), e10.renderer.crispLine([["M", o10 ? this.left : r10, o10 ? a10 : this.top], ["L", o10 ? e10.chartWidth - this.right : r10, o10 ? a10 : e10.chartHeight - this.bottom]], t10);
        }
        renderLine() {
          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
            stroke: this.options.lineColor,
            "stroke-width": this.options.lineWidth,
            zIndex: 7
          }));
        }
        getTitlePosition(t10) {
          let e10 = this.horiz, i10 = this.left, s10 = this.top, o10 = this.len, r10 = this.options.title, a10 = e10 ? i10 : s10, n10 = this.opposite, h10 = this.offset, l10 = r10.x, d10 = r10.y, c10 = this.chart.renderer.fontMetrics(t10), p10 = t10 ? Math.max(t10.getBBox(false, 0).height - c10.h - 1, 0) : 0, u2 = {
            low: a10 + (e10 ? 0 : o10),
            middle: a10 + o10 / 2,
            high: a10 + (e10 ? o10 : 0)
          }[r10.align], g2 = (e10 ? s10 + this.height : i10) + (e10 ? 1 : -1) * (n10 ? -1 : 1) * (this.axisTitleMargin || 0) + [-p10, p10, c10.f, -p10][this.side], f2 = {
            x: e10 ? u2 + l10 : g2 + (n10 ? this.width : 0) + h10 + l10,
            y: e10 ? g2 + d10 - (n10 ? this.height : 0) + h10 : u2 + d10
          };
          return sD(this, "afterGetTitlePosition", {
            titlePosition: f2
          }), f2;
        }
        renderMinorTick(t10, e10) {
          let i10 = this.minorTicks;
          i10[t10] || (i10[t10] = new sm(this, t10, "minor")), e10 && i10[t10].isNew && i10[t10].render(null, true), i10[t10].render(null, false, 1);
        }
        renderTick(t10, e10, i10) {
          let s10 = this.isLinked, o10 = this.ticks;
          (!s10 || t10 >= this.min && t10 <= this.max || this.grid && this.grid.isColumn) && (o10[t10] || (o10[t10] = new sm(this, t10)), i10 && o10[t10].isNew && o10[t10].render(e10, true, -1), o10[t10].render(e10));
        }
        render() {
          let t10, e10;
          let i10 = this, s10 = i10.chart, o10 = i10.logarithmic, r10 = s10.renderer, a10 = i10.options, n10 = i10.isLinked, h10 = i10.tickPositions, l10 = i10.axisTitle, d10 = i10.ticks, c10 = i10.minorTicks, p10 = i10.alternateBands, u2 = a10.stackLabels, g2 = a10.alternateGridColor, f2 = a10.crossing, m2 = i10.tickmarkOffset, x2 = i10.axisLine, y2 = i10.showAxis, b2 = sx(r10.globalAnimation);
          if (i10.labelEdge.length = 0, i10.overlap = false, [d10, c10, p10].forEach(function(t11) {
            sX(t11, function(t12) {
              t12.isActive = false;
            });
          }), sR(f2)) {
            let t11 = this.isXAxis ? s10.yAxis[0] : s10.xAxis[0], e11 = [1, -1, -1, 1][this.side];
            if (t11) {
              let s11 = t11.toPixels(f2, true);
              i10.horiz && (s11 = t11.len - s11), i10.offset = e11 * s11;
            }
          }
          if (i10.hasData() || n10) {
            let r11 = i10.chart.hasRendered && i10.old && sR(i10.old.min);
            i10.minorTickInterval && !i10.categories && i10.getMinorTickPositions().forEach(function(t11) {
              i10.renderMinorTick(t11, r11);
            }), h10.length && (h10.forEach(function(t11, e11) {
              i10.renderTick(t11, e11, r11);
            }), m2 && (0 === i10.min || i10.single) && (d10[-1] || (d10[-1] = new sm(i10, -1, null, true)), d10[-1].render(-1))), g2 && h10.forEach(function(r12, a11) {
              e10 = void 0 !== h10[a11 + 1] ? h10[a11 + 1] + m2 : i10.max - m2, a11 % 2 == 0 && r12 < i10.max && e10 <= i10.max + (s10.polar ? -m2 : m2) && (p10[r12] || (p10[r12] = new L.PlotLineOrBand(i10, {})), t10 = r12 + m2, p10[r12].options = {
                from: o10 ? o10.lin2log(t10) : t10,
                to: o10 ? o10.lin2log(e10) : e10,
                color: g2,
                className: "highcharts-alternate-grid"
              }, p10[r12].render(), p10[r12].isActive = true);
            }), i10._addedPlotLB || (i10._addedPlotLB = true, (a10.plotLines || []).concat(a10.plotBands || []).forEach(function(t11) {
              i10.addPlotBandOrLine(t11);
            }));
          }
          [d10, c10, p10].forEach(function(t11) {
            let e11 = [], i11 = b2.duration;
            sX(t11, function(t12, i12) {
              t12.isActive || (t12.render(i12, false, 0), t12.isActive = false, e11.push(i12));
            }), sU(function() {
              let i12 = e11.length;
              for (; i12--; ) t11[e11[i12]] && !t11[e11[i12]].isActive && (t11[e11[i12]].destroy(), delete t11[e11[i12]]);
            }, t11 !== p10 && s10.hasRendered && i11 ? i11 : 0);
          }), x2 && (x2[x2.isPlaced ? "animate" : "attr"]({
            d: this.getLinePath(x2.strokeWidth())
          }), x2.isPlaced = true, x2[y2 ? "show" : "hide"](y2)), l10 && y2 && (l10[l10.isNew ? "attr" : "animate"](i10.getTitlePosition(l10)), l10.isNew = false), u2 && u2.enabled && i10.stacking && i10.stacking.renderStackTotals(), i10.old = {
            len: i10.len,
            max: i10.max,
            min: i10.min,
            transA: i10.transA,
            userMax: i10.userMax,
            userMin: i10.userMin
          }, i10.isDirty = false, sD(this, "afterRender");
        }
        redraw() {
          this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t10) {
            t10.render();
          })), this.series.forEach(function(t10) {
            t10.isDirty = true;
          });
        }
        getKeepProps() {
          return this.keepProps || s_.keepProps;
        }
        destroy(t10) {
          let e10 = this, i10 = e10.plotLinesAndBands, s10 = this.eventOptions;
          if (sD(this, "destroy", {
            keepEvents: t10
          }), t10 || sY(e10), [e10.ticks, e10.minorTicks, e10.alternateBands].forEach(function(t11) {
            sP(t11);
          }), i10) {
            let t11 = i10.length;
            for (; t11--; ) i10[t11].destroy();
          }
          for (let t11 in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(t12) {
            e10[t12] && (e10[t12] = e10[t12].destroy());
          }), e10.plotLinesAndBandsGroups) e10.plotLinesAndBandsGroups[t11] = e10.plotLinesAndBandsGroups[t11].destroy();
          sX(e10, function(t11, i11) {
            -1 === e10.getKeepProps().indexOf(i11) && delete e10[i11];
          }), this.eventOptions = s10;
        }
        drawCrosshair(t10, e10) {
          let i10 = this.crosshair, s10 = sH(i10 && i10.snap, true), o10 = this.chart, r10, a10, n10, h10 = this.cross, l10;
          if (sD(this, "drawCrosshair", {
            e: t10,
            point: e10
          }), t10 || (t10 = this.cross && this.cross.e), i10 && false !== (sC(e10) || !s10)) {
            if (s10 ? sC(e10) && (a10 = sH("colorAxis" !== this.coll ? e10.crosshairPos : null, this.isXAxis ? e10.plotX : this.len - e10.plotY)) : a10 = t10 && (this.horiz ? t10.chartX - this.pos : this.len - t10.chartY + this.pos), sC(a10) && (l10 = {
              value: e10 && (this.isXAxis ? e10.x : sH(e10.stackY, e10.y)),
              translatedValue: a10
            }, o10.polar && sL(l10, {
              isCrosshair: true,
              chartX: t10 && t10.chartX,
              chartY: t10 && t10.chartY,
              point: e10
            }), r10 = this.getPlotLinePath(l10) || null), !sC(r10)) {
              this.hideCrosshair();
              return;
            }
            n10 = this.categories && !this.isRadial, h10 || (this.cross = h10 = o10.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (n10 ? "category " : "thin ") + (i10.className || "")).attr({
              zIndex: sH(i10.zIndex, 2)
            }).add(), !o10.styledMode && (h10.attr({
              stroke: i10.color || (n10 ? tL.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"),
              "stroke-width": sH(i10.width, 1)
            }).css({
              "pointer-events": "none"
            }), i10.dashStyle && h10.attr({
              dashstyle: i10.dashStyle
            }))), h10.show().attr({
              d: r10
            }), n10 && !i10.width && h10.attr({
              "stroke-width": this.transA
            }), this.cross.e = t10;
          } else this.hideCrosshair();
          sD(this, "afterDrawCrosshair", {
            e: t10,
            point: e10
          });
        }
        hideCrosshair() {
          this.cross && this.cross.hide(), sD(this, "afterHideCrosshair");
        }
        update(t10, e10) {
          let i10 = this.chart;
          t10 = sW(this.userOptions, t10), this.destroy(true), this.init(i10, t10), i10.isDirtyBox = true, sH(e10, true) && i10.redraw();
        }
        remove(t10) {
          let e10 = this.chart, i10 = this.coll, s10 = this.series, o10 = s10.length;
          for (; o10--; ) s10[o10] && s10[o10].remove(false);
          sO(e10.axes, this), sO(e10[i10] || [], this), e10.orderItems(i10), this.destroy(), e10.isDirtyBox = true, sH(t10, true) && e10.redraw();
        }
        setTitle(t10, e10) {
          this.update({
            title: t10
          }, e10);
        }
        setCategories(t10, e10) {
          this.update({
            categories: t10
          }, e10);
        }
      }
      s_.keepProps = ["coll", "extKey", "hcEvents", "len", "names", "series", "userMax", "userMin"];
      let {
        addEvent: s$,
        getMagnitude: sZ,
        normalizeTickInterval: sq,
        timeUnits: sK
      } = ti;
      !function(t10) {
        function e10() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function i10() {
          if ("datetime" !== this.type) {
            this.dateTime = void 0;
            return;
          }
          this.dateTime || (this.dateTime = new s10(this));
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("dateTime") || (t11.keepProps.push("dateTime"), t11.prototype.getTimeTicks = e10, s$(t11, "afterSetType", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          normalizeTimeTickInterval(t11, e11) {
            let i11 = e11 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], s11 = i11[i11.length - 1], o10 = sK[s11[0]], r10 = s11[1], a10;
            for (a10 = 0; a10 < i11.length && (o10 = sK[(s11 = i11[a10])[0]], r10 = s11[1], !i11[a10 + 1] || !(t11 <= (o10 * r10[r10.length - 1] + sK[i11[a10 + 1][0]]) / 2)); a10++) ;
            o10 === sK.year && t11 < 5 * o10 && (r10 = [1, 2, 5]);
            let n10 = sq(t11 / o10, r10, "year" === s11[0] ? Math.max(sZ(t11 / o10), 1) : 1);
            return {
              unitRange: o10,
              count: n10,
              unitName: s11[0]
            };
          }
          getXDateFormat(t11, e11) {
            let {
              axis: i11
            } = this, s11 = i11.chart.time;
            return i11.closestPointRange ? s11.getDateFormat(i11.closestPointRange, t11, i11.options.startOfWeek, e11) || s11.resolveDTLFormat(e11.year).main : s11.resolveDTLFormat(e11.day).main;
          }
        }
        t10.Additions = s10;
      }(c || (c = {}));
      let sJ = c, {
        addEvent: sQ,
        normalizeTickInterval: s0,
        pick: s1
      } = ti;
      !function(t10) {
        function e10() {
          "logarithmic" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s10(this));
        }
        function i10() {
          let t11 = this.logarithmic;
          t11 && (this.lin2val = function(e11) {
            return t11.lin2log(e11);
          }, this.val2lin = function(e11) {
            return t11.log2lin(e11);
          });
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("logarithmic") || (t11.keepProps.push("logarithmic"), sQ(t11, "afterSetType", e10), sQ(t11, "afterInit", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          getLogTickPositions(t11, e11, i11, s11) {
            let o10 = this.axis, r10 = o10.len, a10 = o10.options, n10 = [];
            if (s11 || (this.minorAutoInterval = void 0), t11 >= 0.5) t11 = Math.round(t11), n10 = o10.getLinearTickPositions(t11, e11, i11);
            else if (t11 >= 0.08) {
              let o11, r11, a11, h10, l10, d10, c10;
              let p10 = Math.floor(e11);
              for (o11 = t11 > 0.3 ? [1, 2, 4] : t11 > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r11 = p10; r11 < i11 + 1 && !c10; r11++) for (a11 = 0, h10 = o11.length; a11 < h10 && !c10; a11++) (l10 = this.log2lin(this.lin2log(r11) * o11[a11])) > e11 && (!s11 || d10 <= i11) && void 0 !== d10 && n10.push(d10), d10 > i11 && (c10 = true), d10 = l10;
            } else {
              let h10 = this.lin2log(e11), l10 = this.lin2log(i11), d10 = s11 ? o10.getMinorTickInterval() : a10.tickInterval, c10 = a10.tickPixelInterval / (s11 ? 5 : 1), p10 = s11 ? r10 / o10.tickPositions.length : r10;
              t11 = s0(t11 = s1("auto" === d10 ? null : d10, this.minorAutoInterval, (l10 - h10) * c10 / (p10 || 1))), n10 = o10.getLinearTickPositions(t11, h10, l10).map(this.log2lin), s11 || (this.minorAutoInterval = t11 / 5);
            }
            return s11 || (o10.tickInterval = t11), n10;
          }
          lin2log(t11) {
            return Math.pow(10, t11);
          }
          log2lin(t11) {
            return Math.log(t11) / Math.LN10;
          }
        }
        t10.Additions = s10;
      }(p || (p = {}));
      let s2 = p, {
        erase: s3,
        extend: s5,
        isNumber: s6
      } = ti;
      !function(t10) {
        let e10;
        function i10(t11) {
          return this.addPlotBandOrLine(t11, "plotBands");
        }
        function s10(t11, i11) {
          let s11 = this.userOptions, o11 = new e10(this, t11);
          if (this.visible && (o11 = o11.render()), o11) {
            if (this._addedPlotLB || (this._addedPlotLB = true, (s11.plotLines || []).concat(s11.plotBands || []).forEach((t12) => {
              this.addPlotBandOrLine(t12);
            })), i11) {
              let e11 = s11[i11] || [];
              e11.push(t11), s11[i11] = e11;
            }
            this.plotLinesAndBands.push(o11);
          }
          return o11;
        }
        function o10(t11) {
          return this.addPlotBandOrLine(t11, "plotLines");
        }
        function r10(t11, e11, i11) {
          i11 = i11 || this.options;
          let s11 = this.getPlotLinePath({
            value: e11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), o11 = [], r11 = this.horiz, a11 = !s6(this.min) || !s6(this.max) || t11 < this.min && e11 < this.min || t11 > this.max && e11 > this.max, n11 = this.getPlotLinePath({
            value: t11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), h11, l10 = 1, d10;
          if (n11 && s11) for (a11 && (d10 = n11.toString() === s11.toString(), l10 = 0), h11 = 0; h11 < n11.length; h11 += 2) {
            let t12 = n11[h11], e12 = n11[h11 + 1], i12 = s11[h11], a12 = s11[h11 + 1];
            ("M" === t12[0] || "L" === t12[0]) && ("M" === e12[0] || "L" === e12[0]) && ("M" === i12[0] || "L" === i12[0]) && ("M" === a12[0] || "L" === a12[0]) && (r11 && i12[1] === t12[1] ? (i12[1] += l10, a12[1] += l10) : r11 || i12[2] !== t12[2] || (i12[2] += l10, a12[2] += l10), o11.push(["M", t12[1], t12[2]], ["L", e12[1], e12[2]], ["L", a12[1], a12[2]], ["L", i12[1], i12[2]], ["Z"])), o11.isFlat = d10;
          }
          return o11;
        }
        function a10(t11) {
          this.removePlotBandOrLine(t11);
        }
        function n10(t11) {
          let e11 = this.plotLinesAndBands, i11 = this.options, s11 = this.userOptions;
          if (e11) {
            let o11 = e11.length;
            for (; o11--; ) e11[o11].id === t11 && e11[o11].destroy();
            [i11.plotLines || [], s11.plotLines || [], i11.plotBands || [], s11.plotBands || []].forEach(function(e12) {
              for (o11 = e12.length; o11--; ) (e12[o11] || {}).id === t11 && s3(e12, e12[o11]);
            });
          }
        }
        function h10(t11) {
          this.removePlotBandOrLine(t11);
        }
        t10.compose = function(t11, l10) {
          let d10 = l10.prototype;
          return d10.addPlotBand || (e10 = t11, s5(d10, {
            addPlotBand: i10,
            addPlotLine: o10,
            addPlotBandOrLine: s10,
            getPlotBandPath: r10,
            removePlotBand: a10,
            removePlotLine: h10,
            removePlotBandOrLine: n10
          })), l10;
        };
      }(u || (u = {}));
      let s9 = u, {
        addEvent: s4,
        arrayMax: s8,
        arrayMin: s7,
        defined: ot,
        destroyObjectProperties: oe,
        erase: oi,
        fireEvent: os,
        merge: oo,
        objectEach: or,
        pick: oa
      } = ti;
      class on {
        static compose(t10, e10) {
          return s4(t10, "afterInit", function() {
            this.labelCollectors.push(() => {
              let t11 = [];
              for (let e11 of this.axes) for (let {
                label: i10,
                options: s10
              } of e11.plotLinesAndBands) i10 && !s10?.label?.allowOverlap && t11.push(i10);
              return t11;
            });
          }), s9.compose(on, e10);
        }
        constructor(t10, e10) {
          this.axis = t10, this.options = e10, this.id = e10.id;
        }
        render() {
          os(this, "render");
          let {
            axis: t10,
            options: e10
          } = this, {
            horiz: i10,
            logarithmic: s10
          } = t10, {
            color: o10,
            events: r10,
            zIndex: a10 = 0
          } = e10, {
            renderer: n10,
            time: h10
          } = t10.chart, l10 = {}, d10 = h10.parse(e10.to), c10 = h10.parse(e10.from), p10 = h10.parse(e10.value), u2 = e10.borderWidth, g2 = e10.label, {
            label: f2,
            svgElem: m2
          } = this, x2 = [], y2, b2 = ot(c10) && ot(d10), v2 = ot(p10), k2 = !m2, M2 = {
            class: "highcharts-plot-" + (b2 ? "band " : "line ") + (e10.className || "")
          }, w2 = b2 ? "bands" : "lines";
          if (!t10.chart.styledMode && (v2 ? (M2.stroke = o10 || "#999999", M2["stroke-width"] = oa(e10.width, 1), e10.dashStyle && (M2.dashstyle = e10.dashStyle)) : b2 && (M2.fill = o10 || "#e6e9ff", u2 && (M2.stroke = e10.borderColor, M2["stroke-width"] = u2))), l10.zIndex = a10, w2 += "-" + a10, (y2 = t10.plotLinesAndBandsGroups[w2]) || (t10.plotLinesAndBandsGroups[w2] = y2 = n10.g("plot-" + w2).attr(l10).add()), m2 || (this.svgElem = m2 = n10.path().attr(M2).add(y2)), ot(p10)) x2 = t10.getPlotLinePath({
            value: s10?.log2lin(p10) ?? p10,
            lineWidth: m2.strokeWidth(),
            acrossPanes: e10.acrossPanes
          });
          else {
            if (!(ot(c10) && ot(d10))) return;
            x2 = t10.getPlotBandPath(s10?.log2lin(c10) ?? c10, s10?.log2lin(d10) ?? d10, e10);
          }
          return !this.eventsAdded && r10 && (or(r10, (t11, e11) => {
            m2?.on(e11, (t12) => {
              r10[e11].apply(this, [t12]);
            });
          }), this.eventsAdded = true), (k2 || !m2.d) && x2?.length ? m2.attr({
            d: x2
          }) : m2 && (x2 ? (m2.show(), m2.animate({
            d: x2
          })) : m2.d && (m2.hide(), f2 && (this.label = f2 = f2.destroy()))), g2 && (ot(g2.text) || ot(g2.formatter)) && x2?.length && t10.width > 0 && t10.height > 0 && !x2.isFlat ? (g2 = oo(__spreadValues({
            align: i10 && b2 ? "center" : void 0,
            x: i10 ? !b2 && 4 : 10,
            verticalAlign: !i10 && b2 ? "middle" : void 0,
            y: i10 ? b2 ? 16 : 10 : b2 ? 6 : -4,
            rotation: i10 && !b2 ? 90 : 0
          }, b2 ? {
            inside: true
          } : {}), g2), this.renderLabel(g2, x2, b2, a10)) : f2 && f2.hide(), this;
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart.renderer, a10 = t10.inside, n10 = this.label;
          n10 || (this.label = n10 = r10.text(this.getLabelText(t10), 0, 0, t10.useHTML).attr({
            align: t10.textAlign || t10.align,
            rotation: t10.rotation,
            class: "highcharts-plot-" + (i10 ? "band" : "line") + "-label " + (t10.className || ""),
            zIndex: s10
          }), o10.chart.styledMode || n10.css(oo({
            fontSize: "0.8em",
            textOverflow: i10 && !a10 ? "" : "ellipsis"
          }, t10.style)), n10.add());
          let h10 = e10.xBounds || [e10[0][1], e10[1][1], i10 ? e10[2][1] : e10[0][1]], l10 = e10.yBounds || [e10[0][2], e10[1][2], i10 ? e10[2][2] : e10[0][2]], d10 = s7(h10), c10 = s7(l10), p10 = s8(h10) - d10;
          n10.align(t10, false, {
            x: d10,
            y: c10,
            width: p10,
            height: s8(l10) - c10
          }), (!n10.alignValue || "left" === n10.alignValue || ot(a10)) && n10.css({
            width: (t10.style?.width || (i10 && a10 ? p10 : 90 === n10.rotation ? o10.height - (n10.alignAttr.y - o10.top) : (t10.clip ? o10.width : o10.chart.chartWidth) - (n10.alignAttr.x - o10.left))) + "px"
          }), n10.show(true);
        }
        getLabelText(t10) {
          return ot(t10.formatter) ? t10.formatter.call(this) : t10.text;
        }
        destroy() {
          oi(this.axis.plotLinesAndBands, this), delete this.axis, oe(this);
        }
      }
      let {
        animObject: oh
      } = t_, {
        format: ol
      } = eg, {
        composed: od,
        dateFormats: oc,
        doc: op,
        isSafari: ou
      } = L, {
        distribute: og
      } = ev, {
        addEvent: of,
        clamp: om,
        css: ox,
        discardElement: oy,
        extend: ob,
        fireEvent: ov,
        isArray: ok,
        isNumber: oM,
        isObject: ow,
        isString: oS,
        merge: oA,
        pick: oT,
        pushUnique: oC,
        splat: oP,
        syncTimeout: oO
      } = ti;
      class oE {
        constructor(t10, e10, i10) {
          this.allowShared = true, this.crosshairs = [], this.distance = 0, this.isHidden = true, this.isSticky = false, this.options = {}, this.outside = false, this.chart = t10, this.init(t10, e10), this.pointer = i10;
        }
        bodyFormatter(t10) {
          return t10.map((t11) => {
            let e10 = t11.series.tooltipOptions, i10 = t11.formatPrefix || "point";
            return (e10[i10 + "Formatter"] || t11.tooltipFormatter).call(t11, e10[i10 + "Format"] || "");
          });
        }
        cleanSplit(t10) {
          this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.tt;
            i10 && (!i10.isActive || t10 ? e10.tt = i10.destroy() : i10.isActive = false);
          });
        }
        defaultFormatter(t10) {
          let e10;
          let i10 = this.points || oP(this);
          return (e10 = (e10 = [t10.headerFooterFormatter(i10[0])]).concat(t10.bodyFormatter(i10))).push(t10.headerFooterFormatter(i10[0], true)), e10;
        }
        destroy() {
          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), oy(this.container)), ti.clearTimeout(this.hideTimer);
        }
        getAnchor(t10, e10) {
          let i10;
          let {
            chart: s10,
            pointer: o10
          } = this, r10 = s10.inverted, a10 = s10.plotTop, n10 = s10.plotLeft;
          if ((t10 = oP(t10))[0].series && t10[0].series.yAxis && !t10[0].series.yAxis.options.reversedStacks && (t10 = t10.slice().reverse()), this.followPointer && e10) void 0 === e10.chartX && (e10 = o10.normalize(e10)), i10 = [e10.chartX - n10, e10.chartY - a10];
          else if (t10[0].tooltipPos) i10 = t10[0].tooltipPos;
          else {
            let s11 = 0, o11 = 0;
            t10.forEach(function(t11) {
              let e11 = t11.pos(true);
              e11 && (s11 += e11[0], o11 += e11[1]);
            }), s11 /= t10.length, o11 /= t10.length, this.shared && t10.length > 1 && e10 && (r10 ? s11 = e10.chartX : o11 = e10.chartY), i10 = [s11 - n10, o11 - a10];
          }
          return i10.map(Math.round);
        }
        getClassName(t10, e10, i10) {
          let s10 = this.options, o10 = t10.series, r10 = o10.options;
          return [s10.className, "highcharts-label", i10 && "highcharts-tooltip-header", e10 ? "highcharts-tooltip-box" : "highcharts-tooltip", !i10 && "highcharts-color-" + oT(t10.colorIndex, o10.colorIndex), r10 && r10.className].filter(oS).join(" ");
        }
        getLabel({
          anchorX: t10,
          anchorY: e10
        } = {
          anchorX: 0,
          anchorY: 0
        }) {
          let i10 = this, s10 = this.chart.styledMode, o10 = this.options, r10 = this.split && this.allowShared, a10 = this.container, n10 = this.chart.renderer;
          if (this.label) {
            let t11 = !this.label.hasClass("highcharts-label");
            (!r10 && t11 || r10 && !t11) && this.destroy();
          }
          if (!this.label) {
            if (this.outside) {
              let t11 = this.chart, e11 = t11.options.chart.style, i11 = ef.getRendererType();
              this.container = a10 = L.doc.createElement("div"), a10.className = "highcharts-tooltip-container " + (t11.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), ox(a10, {
                position: "absolute",
                top: "1px",
                pointerEvents: "none",
                zIndex: Math.max(this.options.style.zIndex || 0, (e11 && e11.zIndex || 0) + 3)
              }), this.renderer = n10 = new i11(a10, 0, 0, e11, void 0, void 0, n10.styledMode);
            }
            if (r10 ? this.label = n10.g("tooltip") : (this.label = n10.label("", t10, e10, o10.shape, void 0, void 0, o10.useHTML, void 0, "tooltip").attr({
              padding: o10.padding,
              r: o10.borderRadius
            }), s10 || this.label.attr({
              fill: o10.backgroundColor,
              "stroke-width": o10.borderWidth || 0
            }).css(o10.style).css({
              pointerEvents: o10.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
            })), i10.outside) {
              let t11 = this.label;
              [t11.xSetter, t11.ySetter].forEach((e11, s11) => {
                t11[s11 ? "ySetter" : "xSetter"] = (o11) => {
                  e11.call(t11, i10.distance), t11[s11 ? "y" : "x"] = o11, a10 && (a10.style[s11 ? "top" : "left"] = `${o11}px`);
                };
              });
            }
            this.label.attr({
              zIndex: 8
            }).shadow(o10.shadow).add();
          }
          return a10 && !a10.parentElement && L.doc.body.appendChild(a10), this.label;
        }
        getPlayingField() {
          let {
            body: t10,
            documentElement: e10
          } = op, {
            chart: i10,
            distance: s10,
            outside: o10
          } = this;
          return {
            width: o10 ? Math.max(t10.scrollWidth, e10.scrollWidth, t10.offsetWidth, e10.offsetWidth, e10.clientWidth) - 2 * s10 - 2 : i10.chartWidth,
            height: o10 ? Math.max(t10.scrollHeight, e10.scrollHeight, t10.offsetHeight, e10.offsetHeight, e10.clientHeight) : i10.chartHeight
          };
        }
        getPosition(t10, e10, i10) {
          let {
            distance: s10,
            chart: o10,
            outside: r10,
            pointer: a10
          } = this, {
            inverted: n10,
            plotLeft: h10,
            plotTop: l10,
            polar: d10
          } = o10, {
            plotX: c10 = 0,
            plotY: p10 = 0
          } = i10, u2 = {}, g2 = n10 && i10.h || 0, {
            height: f2,
            width: m2
          } = this.getPlayingField(), x2 = a10.getChartPosition(), y2 = (t11) => t11 * x2.scaleX, b2 = (t11) => t11 * x2.scaleY, v2 = (i11) => {
            let a11 = "x" === i11;
            return [i11, a11 ? m2 : f2, a11 ? t10 : e10].concat(r10 ? [a11 ? y2(t10) : b2(e10), a11 ? x2.left - s10 + y2(c10 + h10) : x2.top - s10 + b2(p10 + l10), 0, a11 ? m2 : f2] : [a11 ? t10 : e10, a11 ? c10 + h10 : p10 + l10, a11 ? h10 : l10, a11 ? h10 + o10.plotWidth : l10 + o10.plotHeight]);
          }, k2 = v2("y"), M2 = v2("x"), w2, S2 = !!i10.negative;
          !d10 && o10.hoverSeries?.yAxis?.reversed && (S2 = !S2);
          let A2 = !this.followPointer && oT(i10.ttBelow, !d10 && !n10 === S2), T2 = function(t11, e11, i11, o11, a11, n11, h11) {
            let l11 = r10 ? "y" === t11 ? b2(s10) : y2(s10) : s10, d11 = (i11 - o11) / 2, c11 = o11 < a11 - s10, p11 = a11 + s10 + o11 < e11, f3 = a11 - l11 - i11 + d11, m3 = a11 + l11 - d11;
            if (A2 && p11) u2[t11] = m3;
            else if (!A2 && c11) u2[t11] = f3;
            else if (c11) u2[t11] = Math.min(h11 - o11, f3 - g2 < 0 ? f3 : f3 - g2);
            else {
              if (!p11) return false;
              u2[t11] = Math.max(n11, m3 + g2 + i11 > e11 ? m3 : m3 + g2);
            }
          }, C2 = function(t11, e11, i11, o11, r11) {
            if (r11 < s10 || r11 > e11 - s10) return false;
            r11 < i11 / 2 ? u2[t11] = 1 : r11 > e11 - o11 / 2 ? u2[t11] = e11 - o11 - 2 : u2[t11] = r11 - i11 / 2;
          }, P2 = function(t11) {
            [k2, M2] = [M2, k2], w2 = t11;
          }, O2 = () => {
            false !== T2.apply(0, k2) ? false !== C2.apply(0, M2) || w2 || (P2(true), O2()) : w2 ? u2.x = u2.y = 0 : (P2(true), O2());
          };
          return (n10 && !d10 || this.len > 1) && P2(), O2(), u2;
        }
        hide(t10) {
          let e10 = this;
          ti.clearTimeout(this.hideTimer), t10 = oT(t10, this.options.hideDelay), this.isHidden || (this.hideTimer = oO(function() {
            let i10 = e10.getLabel();
            e10.getLabel().animate({
              opacity: 0
            }, {
              duration: t10 ? 150 : t10,
              complete: () => {
                i10.hide(), e10.container && e10.container.remove();
              }
            }), e10.isHidden = true;
          }, t10));
        }
        init(t10, e10) {
          this.chart = t10, this.options = e10, this.crosshairs = [], this.isHidden = true, this.split = e10.split && !t10.inverted && !t10.polar, this.shared = e10.shared || this.split, this.outside = oT(e10.outside, !!(t10.scrollablePixelsX || t10.scrollablePixelsY));
        }
        shouldStickOnContact(t10) {
          return !!(!this.followPointer && this.options.stickOnContact && (!t10 || this.pointer.inClass(t10.target, "highcharts-tooltip")));
        }
        move(t10, e10, i10, s10) {
          let o10 = this, r10 = oh(!o10.isHidden && o10.options.animation), a10 = o10.followPointer || (o10.len || 0) > 1, n10 = {
            x: t10,
            y: e10
          };
          a10 || (n10.anchorX = i10, n10.anchorY = s10), r10.step = () => o10.drawTracker(), o10.getLabel().animate(n10, r10);
        }
        refresh(t10, e10) {
          let {
            chart: i10,
            options: s10,
            pointer: o10,
            shared: r10
          } = this, a10 = oP(t10), n10 = a10[0], h10 = s10.format, l10 = s10.formatter || this.defaultFormatter, d10 = i10.styledMode, c10 = this.allowShared;
          if (!s10.enabled || !n10.series) return;
          ti.clearTimeout(this.hideTimer), this.allowShared = !(!ok(t10) && t10.series && t10.series.noSharedTooltip), c10 = c10 && !this.allowShared, this.followPointer = !this.split && n10.series.tooltipOptions.followPointer;
          let p10 = this.getAnchor(t10, e10), u2 = p10[0], g2 = p10[1];
          r10 && this.allowShared && (o10.applyInactiveState(a10), a10.forEach((t11) => t11.setState("hover")), n10.points = a10), this.len = a10.length;
          let f2 = oS(h10) ? ol(h10, n10, i10) : l10.call(n10, this);
          n10.points = void 0;
          let m2 = n10.series;
          if (this.distance = oT(m2.tooltipOptions.distance, 16), false === f2) this.hide();
          else {
            if (this.split && this.allowShared) this.renderSplit(f2, a10);
            else {
              let t11 = u2, r11 = g2;
              if (e10 && o10.isDirectTouch && (t11 = e10.chartX - i10.plotLeft, r11 = e10.chartY - i10.plotTop), i10.polar || false === m2.options.clip || a10.some((e11) => o10.isDirectTouch || e11.series.shouldShowTooltip(t11, r11))) {
                let t12 = this.getLabel(c10 && this.tt || {});
                (!s10.style.width || d10) && t12.css({
                  width: (this.outside ? this.getPlayingField() : i10.spacingBox).width + "px"
                }), t12.attr({
                  class: this.getClassName(n10),
                  text: f2 && f2.join ? f2.join("") : f2
                }), this.outside && t12.attr({
                  x: om(t12.x || 0, 0, this.getPlayingField().width - (t12.width || 0) - 1)
                }), d10 || t12.attr({
                  stroke: s10.borderColor || n10.color || m2.color || "#666666"
                }), this.updatePosition({
                  plotX: u2,
                  plotY: g2,
                  negative: n10.negative,
                  ttBelow: n10.ttBelow,
                  h: p10[2] || 0
                });
              } else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show(), this.isHidden = false;
          }
          ov(this, "refresh");
        }
        renderSplit(t10, e10) {
          let i10 = this, {
            chart: s10,
            chart: {
              chartWidth: o10,
              chartHeight: r10,
              plotHeight: a10,
              plotLeft: n10,
              plotTop: h10,
              scrollablePixelsY: l10 = 0,
              scrollablePixelsX: d10,
              styledMode: c10
            },
            distance: p10,
            options: u2,
            options: {
              positioner: g2
            },
            pointer: f2
          } = i10, {
            scrollLeft: m2 = 0,
            scrollTop: x2 = 0
          } = s10.scrollablePlotArea?.scrollingContainer || {}, y2 = i10.outside && "number" != typeof d10 ? op.documentElement.getBoundingClientRect() : {
            left: m2,
            right: m2 + o10,
            top: x2,
            bottom: x2 + r10
          }, b2 = i10.getLabel(), v2 = this.renderer || s10.renderer, k2 = !!(s10.xAxis[0] && s10.xAxis[0].opposite), {
            left: M2,
            top: w2
          } = f2.getChartPosition(), S2 = h10 + x2, A2 = 0, T2 = a10 - l10;
          function C2(t11, e11, s11, o11, r11 = true) {
            let a11, n11;
            return s11 ? (a11 = k2 ? 0 : T2, n11 = om(t11 - o11 / 2, y2.left, y2.right - o11 - (i10.outside ? M2 : 0))) : (a11 = e11 - S2, n11 = om(n11 = r11 ? t11 - o11 - p10 : t11 + p10, r11 ? n11 : y2.left, y2.right)), {
              x: n11,
              y: a11
            };
          }
          oS(t10) && (t10 = [false, t10]);
          let P2 = t10.slice(0, e10.length + 1).reduce(function(t11, s11, o11) {
            if (false !== s11 && "" !== s11) {
              let r11 = e10[o11 - 1] || {
                isHeader: true,
                plotX: e10[0].plotX,
                plotY: a10,
                series: {}
              }, l11 = r11.isHeader, d11 = l11 ? i10 : r11.series, f3 = d11.tt = function(t12, e11, s12) {
                let o12 = t12, {
                  isHeader: r12,
                  series: a11
                } = e11;
                if (!o12) {
                  let t13 = {
                    padding: u2.padding,
                    r: u2.borderRadius
                  };
                  c10 || (t13.fill = u2.backgroundColor, t13["stroke-width"] = u2.borderWidth ?? 1), o12 = v2.label("", 0, 0, u2[r12 ? "headerShape" : "shape"], void 0, void 0, u2.useHTML).addClass(i10.getClassName(e11, true, r12)).attr(t13).add(b2);
                }
                return o12.isActive = true, o12.attr({
                  text: s12
                }), c10 || o12.css(u2.style).attr({
                  stroke: u2.borderColor || e11.color || a11.color || "#333333"
                }), o12;
              }(d11.tt, r11, s11.toString()), m3 = f3.getBBox(), x3 = m3.width + f3.strokeWidth();
              l11 && (A2 = m3.height, T2 += A2, k2 && (S2 -= A2));
              let {
                anchorX: M3,
                anchorY: w3
              } = function(t12) {
                let e11, i11;
                let {
                  isHeader: s12,
                  plotX: o12 = 0,
                  plotY: r12 = 0,
                  series: l12
                } = t12;
                if (s12) e11 = Math.max(n10 + o12, n10), i11 = h10 + a10 / 2;
                else {
                  let {
                    xAxis: t13,
                    yAxis: s13
                  } = l12;
                  e11 = t13.pos + om(o12, -p10, t13.len + p10), l12.shouldShowTooltip(0, s13.pos - h10 + r12, {
                    ignoreX: true
                  }) && (i11 = s13.pos + r12);
                }
                return {
                  anchorX: e11 = om(e11, y2.left - p10, y2.right + p10),
                  anchorY: i11
                };
              }(r11);
              if ("number" == typeof w3) {
                let e11 = m3.height + 1, s12 = g2 ? g2.call(i10, x3, e11, r11) : C2(M3, w3, l11, x3);
                t11.push({
                  align: g2 ? 0 : void 0,
                  anchorX: M3,
                  anchorY: w3,
                  boxWidth: x3,
                  point: r11,
                  rank: oT(s12.rank, l11 ? 1 : 0),
                  size: e11,
                  target: s12.y,
                  tt: f3,
                  x: s12.x
                });
              } else f3.isActive = false;
            }
            return t11;
          }, []);
          !g2 && P2.some((t11) => {
            let {
              outside: e11
            } = i10, s11 = (e11 ? M2 : 0) + t11.anchorX;
            return s11 < y2.left && s11 + t11.boxWidth < y2.right || s11 < M2 - y2.left + t11.boxWidth && y2.right - s11 > s11;
          }) && (P2 = P2.map((t11) => {
            let {
              x: e11,
              y: i11
            } = C2(t11.anchorX, t11.anchorY, t11.point.isHeader, t11.boxWidth, false);
            return ob(t11, {
              target: i11,
              x: e11
            });
          })), i10.cleanSplit(), og(P2, T2);
          let O2 = {
            left: M2,
            right: M2
          };
          P2.forEach(function(t11) {
            let {
              x: e11,
              boxWidth: s11,
              isHeader: o11
            } = t11;
            !o11 && (i10.outside && M2 + e11 < O2.left && (O2.left = M2 + e11), !o11 && i10.outside && O2.left + s11 > O2.right && (O2.right = M2 + e11));
          }), P2.forEach(function(t11) {
            let {
              x: e11,
              anchorX: s11,
              anchorY: o11,
              pos: r11,
              point: {
                isHeader: a11
              }
            } = t11, n11 = {
              visibility: void 0 === r11 ? "hidden" : "inherit",
              x: e11,
              y: (r11 || 0) + S2,
              anchorX: s11,
              anchorY: o11
            };
            if (i10.outside && e11 < s11) {
              let t12 = M2 - O2.left;
              t12 > 0 && (a11 || (n11.x = e11 + t12, n11.anchorX = s11 + t12), a11 && (n11.x = (O2.right - O2.left) / 2, n11.anchorX = s11 + t12));
            }
            t11.tt.attr(n11);
          });
          let {
            container: E2,
            outside: L2,
            renderer: D2
          } = i10;
          if (L2 && E2 && D2) {
            let {
              width: t11,
              height: e11,
              x: i11,
              y: s11
            } = b2.getBBox();
            D2.setSize(t11 + i11, e11 + s11, false), E2.style.left = O2.left + "px", E2.style.top = w2 + "px";
          }
          ou && b2.attr({
            opacity: 1 === b2.opacity ? 0.999 : 1
          });
        }
        drawTracker() {
          if (!this.shouldStickOnContact()) {
            this.tracker && (this.tracker = this.tracker.destroy());
            return;
          }
          let t10 = this.chart, e10 = this.label, i10 = this.shared ? t10.hoverPoints : t10.hoverPoint;
          if (!e10 || !i10) return;
          let s10 = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }, o10 = this.getAnchor(i10), r10 = e10.getBBox();
          o10[0] += t10.plotLeft - (e10.translateX || 0), o10[1] += t10.plotTop - (e10.translateY || 0), s10.x = Math.min(0, o10[0]), s10.y = Math.min(0, o10[1]), s10.width = o10[0] < 0 ? Math.max(Math.abs(o10[0]), r10.width - o10[0]) : Math.max(Math.abs(o10[0]), r10.width), s10.height = o10[1] < 0 ? Math.max(Math.abs(o10[1]), r10.height - Math.abs(o10[1])) : Math.max(Math.abs(o10[1]), r10.height), this.tracker ? this.tracker.attr(s10) : (this.tracker = e10.renderer.rect(s10).addClass("highcharts-tracker").add(e10), t10.styledMode || this.tracker.attr({
            fill: "rgba(0,0,0,0)"
          }));
        }
        styledModeFormat(t10) {
          return t10.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
        }
        headerFooterFormatter(t10, e10) {
          let i10 = t10.series, s10 = i10.tooltipOptions, o10 = i10.xAxis, r10 = o10 && o10.dateTime, a10 = {
            isFooter: e10,
            point: t10
          }, n10 = s10.xDateFormat || "", h10 = s10[e10 ? "footerFormat" : "headerFormat"];
          return ov(this, "headerFormatter", a10, function(e11) {
            if (r10 && !n10 && oM(t10.key) && (n10 = r10.getXDateFormat(t10.key, s10.dateTimeLabelFormats)), r10 && n10) {
              if (ow(n10)) {
                let t11 = n10;
                oc[0] = (e12) => i10.chart.time.dateFormat(t11, e12), n10 = "%0";
              }
              (t10.tooltipDateKeys || ["key"]).forEach((t11) => {
                h10 = h10.replace(RegExp("point\\." + t11 + "([ \\)}])", ""), `(point.${t11}:${n10})$1`);
              });
            }
            i10.chart.styledMode && (h10 = this.styledModeFormat(h10)), e11.text = ol(h10, t10, this.chart);
          }), a10.text || "";
        }
        update(t10) {
          this.destroy(), this.init(this.chart, oA(true, this.options, t10));
        }
        updatePosition(t10) {
          let {
            chart: e10,
            container: i10,
            distance: s10,
            options: o10,
            pointer: r10,
            renderer: a10
          } = this, {
            height: n10 = 0,
            width: h10 = 0
          } = this.getLabel(), {
            left: l10,
            top: d10,
            scaleX: c10,
            scaleY: p10
          } = r10.getChartPosition(), u2 = (o10.positioner || this.getPosition).call(this, h10, n10, t10), g2 = L.doc, f2 = (t10.plotX || 0) + e10.plotLeft, m2 = (t10.plotY || 0) + e10.plotTop, x2;
          a10 && i10 && (o10.positioner && (u2.x += l10 - s10, u2.y += d10 - s10), x2 = (o10.borderWidth || 0) + 2 * s10 + 2, a10.setSize(om(h10 + x2, 0, g2.documentElement.clientWidth) - 1, n10 + x2, false), (1 !== c10 || 1 !== p10) && (ox(i10, {
            transform: `scale(${c10}, ${p10})`
          }), f2 *= c10, m2 *= p10), f2 += l10 - u2.x, m2 += d10 - u2.y), this.move(Math.round(u2.x), Math.round(u2.y || 0), f2, m2);
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          oC(od, "Core.Tooltip") && of(e10, "afterInit", function() {
            let e11 = this.chart;
            e11.options.tooltip && (e11.tooltip = new t10(e11, e11.options.tooltip, this));
          });
        };
      }(oE || (oE = {}));
      let oL = oE, {
        animObject: oD
      } = t_, {
        defaultOptions: oB
      } = tT, {
        format: oI
      } = eg, {
        addEvent: oz,
        crisp: oR,
        erase: oN,
        extend: oW,
        fireEvent: oG,
        getNestedProperty: oX,
        isArray: oH,
        isFunction: oF,
        isNumber: oY,
        isObject: oj,
        merge: oU,
        pick: oV,
        syncTimeout: o_,
        removeEvent: o$,
        uniqueKey: oZ
      } = ti;
      class oq {
        animateBeforeDestroy() {
          let t10 = this, e10 = {
            x: t10.startXPos,
            opacity: 0
          }, i10 = t10.getGraphicalProps();
          i10.singular.forEach(function(i11) {
            t10[i11] = t10[i11].animate("dataLabel" === i11 ? {
              x: t10[i11].startXPos,
              y: t10[i11].startYPos,
              opacity: 0
            } : e10);
          }), i10.plural.forEach(function(e11) {
            t10[e11].forEach(function(e12) {
              e12.element && e12.animate(oW({
                x: t10.startXPos
              }, e12.startYPos ? {
                x: e12.startXPos,
                y: e12.startYPos
              } : {}));
            });
          });
        }
        applyOptions(t10, e10) {
          let i10 = this.series, s10 = i10.options.pointValKey || i10.pointValKey;
          return oW(this, t10 = oq.prototype.optionsToObject.call(this, t10)), this.options = this.options ? oW(this.options, t10) : t10, t10.group && delete this.group, t10.dataLabels && delete this.dataLabels, s10 && (this.y = oq.prototype.getNestedProperty.call(this, s10)), this.selected && (this.state = "select"), "name" in this && void 0 === e10 && i10.xAxis && i10.xAxis.hasNames && (this.x = i10.xAxis.nameToX(this)), void 0 === this.x && i10 ? this.x = e10 ?? i10.autoIncrement() : oY(t10.x) && i10.options.relativeXValue ? this.x = i10.autoIncrement(t10.x) : "string" == typeof this.x && (e10 ?? (e10 = i10.chart.time.parse(this.x)), oY(e10) && (this.x = e10)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
        }
        destroy() {
          if (!this.destroyed) {
            let t10 = this, e10 = t10.series, i10 = e10.chart, s10 = e10.options.dataSorting, o10 = i10.hoverPoints, r10 = oD(t10.series.chart.renderer.globalAnimation), a10 = () => {
              for (let e11 in (t10.graphic || t10.graphics || t10.dataLabel || t10.dataLabels) && (o$(t10), t10.destroyElements()), t10) delete t10[e11];
            };
            t10.legendItem && i10.legend.destroyItem(t10), o10 && (t10.setState(), oN(o10, t10), o10.length || (i10.hoverPoints = null)), t10 === i10.hoverPoint && t10.onMouseOut(), s10 && s10.enabled ? (this.animateBeforeDestroy(), o_(a10, r10.duration)) : a10(), i10.pointCount--;
          }
          this.destroyed = true;
        }
        destroyElements(t10) {
          let e10 = this, i10 = e10.getGraphicalProps(t10);
          i10.singular.forEach(function(t11) {
            e10[t11] = e10[t11].destroy();
          }), i10.plural.forEach(function(t11) {
            e10[t11].forEach(function(t12) {
              t12 && t12.element && t12.destroy();
            }), delete e10[t11];
          });
        }
        firePointEvent(t10, e10, i10) {
          let s10 = this, o10 = this.series.options;
          s10.manageEvent(t10), "click" === t10 && o10.allowPointSelect && (i10 = function(t11) {
            !s10.destroyed && s10.select && s10.select(null, t11.ctrlKey || t11.metaKey || t11.shiftKey);
          }), oG(s10, t10, e10, i10);
        }
        getClassName() {
          return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
        }
        getGraphicalProps(t10) {
          let e10, i10;
          let s10 = this, o10 = [], r10 = {
            singular: [],
            plural: []
          };
          for ((t10 = t10 || {
            graphic: 1,
            dataLabel: 1
          }).graphic && o10.push("graphic", "connector"), t10.dataLabel && o10.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i10 = o10.length; i10--; ) s10[e10 = o10[i10]] && r10.singular.push(e10);
          return ["graphic", "dataLabel"].forEach(function(e11) {
            let i11 = e11 + "s";
            t10[e11] && s10[i11] && r10.plural.push(i11);
          }), r10;
        }
        getNestedProperty(t10) {
          return t10 ? 0 === t10.indexOf("custom.") ? oX(t10, this.options) : this[t10] : void 0;
        }
        getZone() {
          let t10 = this.series, e10 = t10.zones, i10 = t10.zoneAxis || "y", s10, o10 = 0;
          for (s10 = e10[0]; this[i10] >= s10.value; ) s10 = e10[++o10];
          return this.nonZonedColor || (this.nonZonedColor = this.color), s10 && s10.color && !this.options.color ? this.color = s10.color : this.color = this.nonZonedColor, s10;
        }
        hasNewShapeType() {
          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
        }
        constructor(t10, e10, i10) {
          this.formatPrefix = "point", this.visible = true, this.point = this, this.series = t10, this.applyOptions(e10, i10), this.id ?? (this.id = oZ()), this.resolveColor(), t10.chart.pointCount++, oG(this, "afterInit");
        }
        isValid() {
          return (oY(this.x) || this.x instanceof Date) && oY(this.y);
        }
        optionsToObject(t10) {
          let e10 = this.series, i10 = e10.options.keys, s10 = i10 || e10.pointArrayMap || ["y"], o10 = s10.length, r10 = {}, a10, n10 = 0, h10 = 0;
          if (oY(t10) || null === t10) r10[s10[0]] = t10;
          else if (oH(t10)) for (!i10 && t10.length > o10 && ("string" == (a10 = typeof t10[0]) ? e10.xAxis?.dateTime ? r10.x = e10.chart.time.parse(t10[0]) : r10.name = t10[0] : "number" === a10 && (r10.x = t10[0]), n10++); h10 < o10; ) i10 && void 0 === t10[n10] || (s10[h10].indexOf(".") > 0 ? oq.prototype.setNestedProperty(r10, t10[n10], s10[h10]) : r10[s10[h10]] = t10[n10]), n10++, h10++;
          else "object" == typeof t10 && (r10 = t10, t10.dataLabels && (e10.hasDataLabels = () => true), t10.marker && (e10._hasPointMarkers = true));
          return r10;
        }
        pos(t10, e10 = this.plotY) {
          if (!this.destroyed) {
            let {
              plotX: i10,
              series: s10
            } = this, {
              chart: o10,
              xAxis: r10,
              yAxis: a10
            } = s10, n10 = 0, h10 = 0;
            if (oY(i10) && oY(e10)) return t10 && (n10 = r10 ? r10.pos : o10.plotLeft, h10 = a10 ? a10.pos : o10.plotTop), o10.inverted && r10 && a10 ? [a10.len - e10 + h10, r10.len - i10 + n10] : [i10 + n10, e10 + h10];
          }
        }
        resolveColor() {
          let t10 = this.series, e10 = t10.chart.options.chart, i10 = t10.chart.styledMode, s10, o10, r10 = e10.colorCount, a10;
          delete this.nonZonedColor, t10.options.colorByPoint ? (i10 || (s10 = (o10 = t10.options.colors || t10.chart.options.colors)[t10.colorCounter], r10 = o10.length), a10 = t10.colorCounter, t10.colorCounter++, t10.colorCounter === r10 && (t10.colorCounter = 0)) : (i10 || (s10 = t10.color), a10 = t10.colorIndex), this.colorIndex = oV(this.options.colorIndex, a10), this.color = oV(this.options.color, s10);
        }
        setNestedProperty(t10, e10, i10) {
          return i10.split(".").reduce(function(t11, i11, s10, o10) {
            let r10 = o10.length - 1 === s10;
            return t11[i11] = r10 ? e10 : oj(t11[i11], true) ? t11[i11] : {}, t11[i11];
          }, t10), t10;
        }
        shouldDraw() {
          return !this.isNull;
        }
        tooltipFormatter(t10) {
          let {
            chart: e10,
            pointArrayMap: i10 = ["y"],
            tooltipOptions: s10
          } = this.series, {
            valueDecimals: o10 = "",
            valuePrefix: r10 = "",
            valueSuffix: a10 = ""
          } = s10;
          return e10.styledMode && (t10 = e10.tooltip?.styledModeFormat(t10) || t10), i10.forEach((e11) => {
            e11 = "{point." + e11, (r10 || a10) && (t10 = t10.replace(RegExp(e11 + "}", "g"), r10 + e11 + "}" + a10)), t10 = t10.replace(RegExp(e11 + "}", "g"), e11 + ":,." + o10 + "f}");
          }), oI(t10, this, e10);
        }
        update(t10, e10, i10, s10) {
          let o10;
          let r10 = this, a10 = r10.series, n10 = r10.graphic, h10 = a10.chart, l10 = a10.options;
          function d10() {
            r10.applyOptions(t10);
            let s11 = n10 && r10.hasMockGraphic, d11 = null === r10.y ? !s11 : s11;
            n10 && d11 && (r10.graphic = n10.destroy(), delete r10.hasMockGraphic), oj(t10, true) && (n10 && n10.element && t10 && t10.marker && void 0 !== t10.marker.symbol && (r10.graphic = n10.destroy()), t10?.dataLabels && r10.dataLabel && (r10.dataLabel = r10.dataLabel.destroy())), o10 = r10.index;
            let c10 = {};
            for (let t11 of a10.dataColumnKeys()) c10[t11] = r10[t11];
            a10.dataTable.setRow(c10, o10), l10.data[o10] = oj(l10.data[o10], true) || oj(t10, true) ? r10.options : oV(t10, l10.data[o10]), a10.isDirty = a10.isDirtyData = true, !a10.fixedBox && a10.hasCartesianSeries && (h10.isDirtyBox = true), "point" === l10.legendType && (h10.isDirtyLegend = true), e10 && h10.redraw(i10);
          }
          e10 = oV(e10, true), false === s10 ? d10() : r10.firePointEvent("update", {
            options: t10
          }, d10);
        }
        remove(t10, e10) {
          this.series.removePoint(this.series.data.indexOf(this), t10, e10);
        }
        select(t10, e10) {
          let i10 = this, s10 = i10.series, o10 = s10.chart;
          t10 = oV(t10, !i10.selected), this.selectedStaging = t10, i10.firePointEvent(t10 ? "select" : "unselect", {
            accumulate: e10
          }, function() {
            i10.selected = i10.options.selected = t10, s10.options.data[s10.data.indexOf(i10)] = i10.options, i10.setState(t10 && "select"), e10 || o10.getSelectedPoints().forEach(function(t11) {
              let e11 = t11.series;
              t11.selected && t11 !== i10 && (t11.selected = t11.options.selected = false, e11.options.data[e11.data.indexOf(t11)] = t11.options, t11.setState(o10.hoverPoints && e11.options.inactiveOtherPoints ? "inactive" : ""), t11.firePointEvent("unselect"));
            });
          }), delete this.selectedStaging;
        }
        onMouseOver(t10) {
          let {
            inverted: e10,
            pointer: i10
          } = this.series.chart;
          i10 && (t10 = t10 ? i10.normalize(t10) : i10.getChartCoordinatesFromPoint(this, e10), i10.runPointActions(t10, this));
        }
        onMouseOut() {
          let t10 = this.series.chart;
          this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t10.hoverPoints || []).forEach(function(t11) {
            t11.setState();
          }), t10.hoverPoints = t10.hoverPoint = null;
        }
        manageEvent(t10) {
          let e10 = oU(this.series.options.point, this.options), i10 = e10.events?.[t10];
          oF(i10) && (!this.hcEvents?.[t10] || this.hcEvents?.[t10]?.map((t11) => t11.fn).indexOf(i10) === -1) ? (this.importedUserEvent?.(), this.importedUserEvent = oz(this, t10, i10), this.hcEvents && (this.hcEvents[t10].userEvent = true)) : this.importedUserEvent && !i10 && this.hcEvents?.[t10] && this.hcEvents?.[t10].userEvent && (o$(this, t10), delete this.hcEvents[t10], Object.keys(this.hcEvents) || delete this.importedUserEvent);
        }
        setState(t10, e10) {
          let i10 = this.series, s10 = this.state, o10 = i10.options.states[t10 || "normal"] || {}, r10 = oB.plotOptions[i10.type].marker && i10.options.marker, a10 = r10 && false === r10.enabled, n10 = r10 && r10.states && r10.states[t10 || "normal"] || {}, h10 = false === n10.enabled, l10 = this.marker || {}, d10 = i10.chart, c10 = r10 && i10.markerAttribs, p10 = i10.halo, u2, g2, f2, m2 = i10.stateMarkerGraphic, x2;
          if ((t10 = t10 || "") === this.state && !e10 || this.selected && "select" !== t10 || false === o10.enabled || t10 && (h10 || a10 && false === n10.enabled) || t10 && l10.states && l10.states[t10] && false === l10.states[t10].enabled) return;
          if (this.state = t10, c10 && (u2 = i10.markerAttribs(this, t10)), this.graphic && !this.hasMockGraphic) {
            if (s10 && this.graphic.removeClass("highcharts-point-" + s10), t10 && this.graphic.addClass("highcharts-point-" + t10), !d10.styledMode) {
              g2 = i10.pointAttribs(this, t10), f2 = oV(d10.options.chart.animation, o10.animation);
              let e11 = g2.opacity;
              i10.options.inactiveOtherPoints && oY(e11) && (this.dataLabels || []).forEach(function(t11) {
                t11 && !t11.hasClass("highcharts-data-label-hidden") && (t11.animate({
                  opacity: e11
                }, f2), t11.connector && t11.connector.animate({
                  opacity: e11
                }, f2));
              }), this.graphic.animate(g2, f2);
            }
            u2 && this.graphic.animate(u2, oV(d10.options.chart.animation, n10.animation, r10.animation)), m2 && m2.hide();
          } else t10 && n10 && (x2 = l10.symbol || i10.symbol, m2 && m2.currentSymbol !== x2 && (m2 = m2.destroy()), u2 && (m2 ? m2[e10 ? "animate" : "attr"]({
            x: u2.x,
            y: u2.y
          }) : x2 && (i10.stateMarkerGraphic = m2 = d10.renderer.symbol(x2, u2.x, u2.y, u2.width, u2.height, oU(r10, n10)).add(i10.markerGroup), m2.currentSymbol = x2)), !d10.styledMode && m2 && "inactive" !== this.state && m2.attr(i10.pointAttribs(this, t10))), m2 && (m2[t10 && this.isInside ? "show" : "hide"](), m2.element.point = this, m2.addClass(this.getClassName(), true));
          let y2 = o10.halo, b2 = this.graphic || m2, v2 = b2 && b2.visibility || "inherit";
          y2 && y2.size && b2 && "hidden" !== v2 && !this.isCluster ? (p10 || (i10.halo = p10 = d10.renderer.path().add(b2.parentGroup)), p10.show()[e10 ? "animate" : "attr"]({
            d: this.haloPath(y2.size)
          }), p10.attr({
            class: "highcharts-halo highcharts-color-" + oV(this.colorIndex, i10.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: v2,
            zIndex: -1
          }), p10.point = this, d10.styledMode || p10.attr(oW({
            fill: this.color || i10.color,
            "fill-opacity": y2.opacity
          }, t4.filterUserAttributes(y2.attributes || {})))) : p10?.point?.haloPath && !p10.point.destroyed && p10.animate({
            d: p10.point.haloPath(0)
          }, null, p10.hide), oG(this, "afterSetState", {
            state: t10
          });
        }
        haloPath(t10) {
          let e10 = this.pos();
          return e10 ? this.series.chart.renderer.symbols.circle(oR(e10[0], 1) - t10, e10[1] - t10, 2 * t10, 2 * t10) : [];
        }
      }
      let oK = oq, {
        parse: oJ
      } = tL, {
        charts: oQ,
        composed: o0,
        isTouchDevice: o1
      } = L, {
        addEvent: o2,
        attr: o3,
        css: o5,
        extend: o6,
        find: o9,
        fireEvent: o4,
        isNumber: o8,
        isObject: o7,
        objectEach: rt,
        offset: re,
        pick: ri,
        pushUnique: rs,
        splat: ro
      } = ti;
      class rr {
        applyInactiveState(t10) {
          let e10 = [], i10;
          (t10 || []).forEach(function(t11) {
            i10 = t11.series, e10.push(i10), i10.linkedParent && e10.push(i10.linkedParent), i10.linkedSeries && (e10 = e10.concat(i10.linkedSeries)), i10.navigatorSeries && e10.push(i10.navigatorSeries);
          }), this.chart.series.forEach(function(t11) {
            -1 === e10.indexOf(t11) ? t11.setState("inactive", true) : t11.options.inactiveOtherPoints && t11.setAllPointsToState("inactive");
          });
        }
        destroy() {
          let t10 = this;
          this.eventsToUnbind.forEach((t11) => t11()), this.eventsToUnbind = [], !L.chartCount && (rr.unbindDocumentMouseUp.forEach((t11) => t11.unbind()), rr.unbindDocumentMouseUp.length = 0, rr.unbindDocumentTouchEnd && (rr.unbindDocumentTouchEnd = rr.unbindDocumentTouchEnd())), clearInterval(t10.tooltipTimeout), rt(t10, function(e10, i10) {
            t10[i10] = void 0;
          });
        }
        getSelectionMarkerAttrs(t10, e10) {
          let i10 = {
            args: {
              chartX: t10,
              chartY: e10
            },
            attrs: {},
            shapeType: "rect"
          };
          return o4(this, "getSelectionMarkerAttrs", i10, (i11) => {
            let s10;
            let {
              chart: o10,
              zoomHor: r10,
              zoomVert: a10
            } = this, {
              mouseDownX: n10 = 0,
              mouseDownY: h10 = 0
            } = o10, l10 = i11.attrs;
            l10.x = o10.plotLeft, l10.y = o10.plotTop, l10.width = r10 ? 1 : o10.plotWidth, l10.height = a10 ? 1 : o10.plotHeight, r10 && (s10 = t10 - n10, l10.width = Math.max(1, Math.abs(s10)), l10.x = (s10 > 0 ? 0 : s10) + n10), a10 && (s10 = e10 - h10, l10.height = Math.max(1, Math.abs(s10)), l10.y = (s10 > 0 ? 0 : s10) + h10);
          }), i10;
        }
        drag(t10) {
          let {
            chart: e10
          } = this, {
            mouseDownX: i10 = 0,
            mouseDownY: s10 = 0
          } = e10, {
            panning: o10,
            panKey: r10,
            selectionMarkerFill: a10
          } = e10.options.chart, n10 = e10.plotLeft, h10 = e10.plotTop, l10 = e10.plotWidth, d10 = e10.plotHeight, c10 = o7(o10) ? o10.enabled : o10, p10 = r10 && t10[`${r10}Key`], u2 = t10.chartX, g2 = t10.chartY, f2, m2 = this.selectionMarker;
          if ((!m2 || !m2.touch) && (u2 < n10 ? u2 = n10 : u2 > n10 + l10 && (u2 = n10 + l10), g2 < h10 ? g2 = h10 : g2 > h10 + d10 && (g2 = h10 + d10), this.hasDragged = Math.sqrt(Math.pow(i10 - u2, 2) + Math.pow(s10 - g2, 2)), this.hasDragged > 10)) {
            f2 = e10.isInsidePlot(i10 - n10, s10 - h10, {
              visiblePlotOnly: true
            });
            let {
              shapeType: r11,
              attrs: l11
            } = this.getSelectionMarkerAttrs(u2, g2);
            (e10.hasCartesianSeries || e10.mapView) && this.hasZoom && f2 && !p10 && !m2 && (this.selectionMarker = m2 = e10.renderer[r11](), m2.attr({
              class: "highcharts-selection-marker",
              zIndex: 7
            }).add(), e10.styledMode || m2.attr({
              fill: a10 || oJ("#334eff").setOpacity(0.25).get()
            })), m2 && m2.attr(l11), f2 && !m2 && c10 && e10.pan(t10, o10);
          }
        }
        dragStart(t10) {
          let e10 = this.chart;
          e10.mouseIsDown = t10.type, e10.cancelClick = false, e10.mouseDownX = t10.chartX, e10.mouseDownY = t10.chartY;
        }
        getSelectionBox(t10) {
          let e10 = {
            args: {
              marker: t10
            },
            result: t10.getBBox()
          };
          return o4(this, "getSelectionBox", e10), e10.result;
        }
        drop(t10) {
          let e10;
          let {
            chart: i10,
            selectionMarker: s10
          } = this;
          for (let t11 of i10.axes) t11.isPanning && (t11.isPanning = false, (t11.options.startOnTick || t11.options.endOnTick || t11.series.some((t12) => t12.boosted)) && (t11.forceRedraw = true, t11.setExtremes(t11.userMin, t11.userMax, false), e10 = true));
          if (e10 && i10.redraw(), s10 && t10) {
            if (this.hasDragged) {
              let e11 = this.getSelectionBox(s10);
              i10.transform({
                axes: i10.axes.filter((t11) => t11.zoomEnabled && ("xAxis" === t11.coll && this.zoomX || "yAxis" === t11.coll && this.zoomY)),
                selection: __spreadValues({
                  originalEvent: t10,
                  xAxis: [],
                  yAxis: []
                }, e11),
                from: e11
              });
            }
            o8(i10.index) && (this.selectionMarker = s10.destroy());
          }
          i10 && o8(i10.index) && (o5(i10.container, {
            cursor: i10._cursor
          }), i10.cancelClick = this.hasDragged > 10, i10.mouseIsDown = false, this.hasDragged = 0, this.pinchDown = []);
        }
        findNearestKDPoint(t10, e10, i10) {
          let s10;
          return t10.forEach(function(t11) {
            let o10 = !(t11.noSharedTooltip && e10) && 0 > t11.options.findNearestPointBy.indexOf("y"), r10 = t11.searchPoint(i10, o10);
            o7(r10, true) && r10.series && (!o7(s10, true) || function(t12, i11) {
              let s11 = t12.distX - i11.distX, o11 = t12.dist - i11.dist, r11 = i11.series.group?.zIndex - t12.series.group?.zIndex;
              return 0 !== s11 && e10 ? s11 : 0 !== o11 ? o11 : 0 !== r11 ? r11 : t12.series.index > i11.series.index ? -1 : 1;
            }(s10, r10) > 0) && (s10 = r10);
          }), s10;
        }
        getChartCoordinatesFromPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = t10.series, o10 = t10.shapeArgs;
          if (i10 && s10) {
            let r10 = t10.clientX ?? t10.plotX ?? 0, a10 = t10.plotY || 0;
            return t10.isNode && o10 && o8(o10.x) && o8(o10.y) && (r10 = o10.x, a10 = o10.y), e10 ? {
              chartX: s10.len + s10.pos - a10,
              chartY: i10.len + i10.pos - r10
            } : {
              chartX: r10 + i10.pos,
              chartY: a10 + s10.pos
            };
          }
          if (o10 && o10.x && o10.y) return {
            chartX: o10.x,
            chartY: o10.y
          };
        }
        getChartPosition() {
          if (this.chartPosition) return this.chartPosition;
          let {
            container: t10
          } = this.chart, e10 = re(t10);
          this.chartPosition = {
            left: e10.left,
            top: e10.top,
            scaleX: 1,
            scaleY: 1
          };
          let {
            offsetHeight: i10,
            offsetWidth: s10
          } = t10;
          return s10 > 2 && i10 > 2 && (this.chartPosition.scaleX = e10.width / s10, this.chartPosition.scaleY = e10.height / i10), this.chartPosition;
        }
        getCoordinates(t10) {
          let e10 = {
            xAxis: [],
            yAxis: []
          };
          for (let i10 of this.chart.axes) e10[i10.isXAxis ? "xAxis" : "yAxis"].push({
            axis: i10,
            value: i10.toValue(t10[i10.horiz ? "chartX" : "chartY"])
          });
          return e10;
        }
        getHoverData(t10, e10, i10, s10, o10, r10) {
          let a10 = [], n10 = function(t11) {
            return t11.visible && !(!o10 && t11.directTouch) && ri(t11.options.enableMouseTracking, true);
          }, h10 = e10, l10, d10 = {
            chartX: r10 ? r10.chartX : void 0,
            chartY: r10 ? r10.chartY : void 0,
            shared: o10
          };
          o4(this, "beforeGetHoverData", d10), l10 = h10 && !h10.stickyTracking ? [h10] : i10.filter((t11) => t11.stickyTracking && (d10.filter || n10)(t11));
          let c10 = s10 && t10 || !r10 ? t10 : this.findNearestKDPoint(l10, o10, r10);
          return h10 = c10 && c10.series, c10 && (o10 && !h10.noSharedTooltip ? (l10 = i10.filter(function(t11) {
            return d10.filter ? d10.filter(t11) : n10(t11) && !t11.noSharedTooltip;
          })).forEach(function(t11) {
            let e11 = o9(t11.points, function(t12) {
              return t12.x === c10.x && !t12.isNull;
            });
            o7(e11) && (t11.boosted && t11.boost && (e11 = t11.boost.getPoint(e11)), a10.push(e11));
          }) : a10.push(c10)), o4(this, "afterGetHoverData", d10 = {
            hoverPoint: c10
          }), {
            hoverPoint: d10.hoverPoint,
            hoverSeries: h10,
            hoverPoints: a10
          };
        }
        getPointFromEvent(t10) {
          let e10 = t10.target, i10;
          for (; e10 && !i10; ) i10 = e10.point, e10 = e10.parentNode;
          return i10;
        }
        onTrackerMouseOut(t10) {
          let e10 = this.chart, i10 = t10.relatedTarget, s10 = e10.hoverSeries;
          this.isDirectTouch = false, !s10 || !i10 || s10.stickyTracking || this.inClass(i10, "highcharts-tooltip") || this.inClass(i10, "highcharts-series-" + s10.index) && this.inClass(i10, "highcharts-tracker") || s10.onMouseOut();
        }
        inClass(t10, e10) {
          let i10 = t10, s10;
          for (; i10; ) {
            if (s10 = o3(i10, "class")) {
              if (-1 !== s10.indexOf(e10)) return true;
              if (-1 !== s10.indexOf("highcharts-container")) return false;
            }
            i10 = i10.parentElement;
          }
        }
        constructor(t10, e10) {
          this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e10, this.chart = t10, this.runChartClick = !!e10.chart.events?.click, this.pinchDown = [], this.setDOMEvents(), o4(this, "afterInit");
        }
        normalize(t10, e10) {
          let i10 = t10.touches, s10 = i10 ? i10.length ? i10.item(0) : ri(i10.changedTouches, t10.changedTouches)[0] : t10;
          e10 || (e10 = this.getChartPosition());
          let o10 = s10.pageX - e10.left, r10 = s10.pageY - e10.top;
          return o6(t10, {
            chartX: Math.round(o10 /= e10.scaleX),
            chartY: Math.round(r10 /= e10.scaleY)
          });
        }
        onContainerClick(t10) {
          let e10 = this.chart, i10 = e10.hoverPoint, s10 = this.normalize(t10), o10 = e10.plotLeft, r10 = e10.plotTop;
          !e10.cancelClick && (i10 && this.inClass(s10.target, "highcharts-tracker") ? (o4(i10.series, "click", o6(s10, {
            point: i10
          })), e10.hoverPoint && i10.firePointEvent("click", s10)) : (o6(s10, this.getCoordinates(s10)), e10.isInsidePlot(s10.chartX - o10, s10.chartY - r10, {
            visiblePlotOnly: true
          }) && o4(e10, "click", s10)));
        }
        onContainerMouseDown(t10) {
          let e10 = (1 & (t10.buttons || t10.button)) == 1;
          t10 = this.normalize(t10), L.isFirefox && 0 !== t10.button && this.onContainerMouseMove(t10), (void 0 === t10.button || e10) && (this.zoomOption(t10), e10 && t10.preventDefault?.(), this.dragStart(t10));
        }
        onContainerMouseLeave(t10) {
          let {
            pointer: e10
          } = oQ[ri(rr.hoverChartIndex, -1)] || {};
          t10 = this.normalize(t10), this.onContainerMouseMove(t10), e10 && !this.inClass(t10.relatedTarget, "highcharts-tooltip") && (e10.reset(), e10.chartPosition = void 0);
        }
        onContainerMouseEnter() {
          delete this.chartPosition;
        }
        onContainerMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.normalize(t10);
          this.setHoverChartIndex(t10), ("mousedown" === e10.mouseIsDown || this.touchSelect(s10)) && this.drag(s10), !e10.openMenu && (this.inClass(s10.target, "highcharts-tracker") || e10.isInsidePlot(s10.chartX - e10.plotLeft, s10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          })) && !(i10 && i10.shouldStickOnContact(s10)) && (this.inClass(s10.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(s10));
        }
        onDocumentTouchEnd(t10) {
          this.onDocumentMouseUp(t10);
        }
        onContainerTouchMove(t10) {
          this.touchSelect(t10) ? this.onContainerMouseMove(t10) : this.touch(t10);
        }
        onContainerTouchStart(t10) {
          this.touchSelect(t10) ? this.onContainerMouseDown(t10) : (this.zoomOption(t10), this.touch(t10, true));
        }
        onDocumentMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.chartPosition, o10 = this.normalize(t10, s10);
          !s10 || e10.isInsidePlot(o10.chartX - e10.plotLeft, o10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          }) || i10 && i10.shouldStickOnContact(o10) || o10.target !== e10.container.ownerDocument && this.inClass(o10.target, "highcharts-tracker") || this.reset();
        }
        onDocumentMouseUp(t10) {
          oQ[ri(rr.hoverChartIndex, -1)]?.pointer?.drop(t10);
        }
        pinch(t10) {
          let e10 = this, {
            chart: i10,
            hasZoom: s10,
            lastTouches: o10
          } = e10, r10 = [].map.call(t10.touches || [], (t11) => e10.normalize(t11)), a10 = r10.length, n10 = 1 === a10 && (e10.inClass(t10.target, "highcharts-tracker") && i10.runTrackerClick || e10.runChartClick), h10 = i10.tooltip, l10 = 1 === a10 && ri(h10?.options.followTouchMove, true);
          a10 > 1 ? e10.initiated = true : l10 && (e10.initiated = false), s10 && e10.initiated && !n10 && false !== t10.cancelable && t10.preventDefault(), "touchstart" === t10.type ? (e10.pinchDown = r10, e10.res = true, i10.mouseDownX = t10.chartX) : l10 ? this.runPointActions(e10.normalize(t10)) : o10 && (o4(i10, "touchpan", {
            originalEvent: t10,
            touches: r10
          }, () => {
            let e11 = (t11) => {
              let e12 = t11[0], i11 = t11[1] || e12;
              return {
                x: e12.chartX,
                y: e12.chartY,
                width: i11.chartX - e12.chartX,
                height: i11.chartY - e12.chartY
              };
            };
            i10.transform({
              axes: i10.axes.filter((t11) => t11.zoomEnabled && (this.zoomHor && t11.horiz || this.zoomVert && !t11.horiz)),
              to: e11(r10),
              from: e11(o10),
              trigger: t10.type
            });
          }), e10.res && (e10.res = false, this.reset(false, 0))), e10.lastTouches = r10;
        }
        reset(t10, e10) {
          let i10 = this.chart, s10 = i10.hoverSeries, o10 = i10.hoverPoint, r10 = i10.hoverPoints, a10 = i10.tooltip, n10 = a10 && a10.shared ? r10 : o10;
          t10 && n10 && ro(n10).forEach(function(e11) {
            e11.series.isCartesian && void 0 === e11.plotX && (t10 = false);
          }), t10 ? a10 && n10 && ro(n10).length && (a10.refresh(n10), a10.shared && r10 ? r10.forEach(function(t11) {
            t11.setState(t11.state, true), t11.series.isCartesian && (t11.series.xAxis.crosshair && t11.series.xAxis.drawCrosshair(null, t11), t11.series.yAxis.crosshair && t11.series.yAxis.drawCrosshair(null, t11));
          }) : o10 && (o10.setState(o10.state, true), i10.axes.forEach(function(t11) {
            t11.crosshair && o10.series[t11.coll] === t11 && t11.drawCrosshair(null, o10);
          }))) : (o10 && o10.onMouseOut(), r10 && r10.forEach(function(t11) {
            t11.setState();
          }), s10 && s10.onMouseOut(), a10 && a10.hide(e10), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i10.axes.forEach(function(t11) {
            t11.hideCrosshair();
          }), i10.hoverPoints = i10.hoverPoint = void 0);
        }
        runPointActions(t10, e10, i10) {
          let s10 = this.chart, o10 = s10.series, r10 = s10.tooltip && s10.tooltip.options.enabled ? s10.tooltip : void 0, a10 = !!r10 && r10.shared, n10 = e10 || s10.hoverPoint, h10 = n10 && n10.series || s10.hoverSeries, l10 = (!t10 || "touchmove" !== t10.type) && (!!e10 || h10 && h10.directTouch && this.isDirectTouch), d10 = this.getHoverData(n10, h10, o10, l10, a10, t10);
          n10 = d10.hoverPoint, h10 = d10.hoverSeries;
          let c10 = d10.hoverPoints, p10 = h10 && h10.tooltipOptions.followPointer && !h10.tooltipOptions.split, u2 = a10 && h10 && !h10.noSharedTooltip;
          if (n10 && (i10 || n10 !== s10.hoverPoint || r10 && r10.isHidden)) {
            if ((s10.hoverPoints || []).forEach(function(t11) {
              -1 === c10.indexOf(t11) && t11.setState();
            }), s10.hoverSeries !== h10 && h10.onMouseOver(), this.applyInactiveState(c10), (c10 || []).forEach(function(t11) {
              t11.setState("hover");
            }), s10.hoverPoint && s10.hoverPoint.firePointEvent("mouseOut"), !n10.series) return;
            s10.hoverPoints = c10, s10.hoverPoint = n10, n10.firePointEvent("mouseOver", void 0, () => {
              r10 && n10 && r10.refresh(u2 ? c10 : n10, t10);
            });
          } else if (p10 && r10 && !r10.isHidden) {
            let e11 = r10.getAnchor([{}], t10);
            s10.isInsidePlot(e11[0], e11[1], {
              visiblePlotOnly: true
            }) && r10.updatePosition({
              plotX: e11[0],
              plotY: e11[1]
            });
          }
          this.unDocMouseMove || (this.unDocMouseMove = o2(s10.container.ownerDocument, "mousemove", (t11) => oQ[rr.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(t11)), this.eventsToUnbind.push(this.unDocMouseMove)), s10.axes.forEach(function(e11) {
            let i11;
            let o11 = ri((e11.crosshair || {}).snap, true);
            !o11 || (i11 = s10.hoverPoint) && i11.series[e11.coll] === e11 || (i11 = o9(c10, (t11) => t11.series && t11.series[e11.coll] === e11)), i11 || !o11 ? e11.drawCrosshair(t10, i11) : e11.hideCrosshair();
          });
        }
        setDOMEvents() {
          let t10 = this.chart.container, e10 = t10.ownerDocument;
          t10.onmousedown = this.onContainerMouseDown.bind(this), t10.onmousemove = this.onContainerMouseMove.bind(this), t10.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(o2(t10, "mouseenter", this.onContainerMouseEnter.bind(this)), o2(t10, "mouseleave", this.onContainerMouseLeave.bind(this))), rr.unbindDocumentMouseUp.some((t11) => t11.doc === e10) || rr.unbindDocumentMouseUp.push({
            doc: e10,
            unbind: o2(e10, "mouseup", this.onDocumentMouseUp.bind(this))
          });
          let i10 = this.chart.renderTo.parentElement;
          for (; i10 && "BODY" !== i10.tagName; ) this.eventsToUnbind.push(o2(i10, "scroll", () => {
            delete this.chartPosition;
          })), i10 = i10.parentElement;
          this.eventsToUnbind.push(o2(t10, "touchstart", this.onContainerTouchStart.bind(this), {
            passive: false
          }), o2(t10, "touchmove", this.onContainerTouchMove.bind(this), {
            passive: false
          })), rr.unbindDocumentTouchEnd || (rr.unbindDocumentTouchEnd = o2(e10, "touchend", this.onDocumentTouchEnd.bind(this), {
            passive: false
          })), this.setPointerCapture(), o2(this.chart, "redraw", this.setPointerCapture.bind(this));
        }
        setPointerCapture() {
          if (!o1) return;
          let t10 = this.pointerCaptureEventsToUnbind, e10 = this.chart, i10 = e10.container, s10 = ri(e10.options.tooltip?.followTouchMove, true) && e10.series.some((t11) => t11.options.findNearestPointBy.indexOf("y") > -1);
          !this.hasPointerCapture && s10 ? (t10.push(o2(i10, "pointerdown", (t11) => {
            t11.target?.hasPointerCapture(t11.pointerId) && t11.target?.releasePointerCapture(t11.pointerId);
          }), o2(i10, "pointermove", (t11) => {
            e10.pointer?.getPointFromEvent(t11)?.onMouseOver(t11);
          })), e10.styledMode || o5(i10, {
            "touch-action": "none"
          }), i10.className += " highcharts-no-touch-action", this.hasPointerCapture = true) : this.hasPointerCapture && !s10 && (t10.forEach((t11) => t11()), t10.length = 0, e10.styledMode || o5(i10, {
            "touch-action": ri(e10.options.chart.style?.["touch-action"], "manipulation")
          }), i10.className = i10.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = false);
        }
        setHoverChartIndex(t10) {
          let e10 = this.chart, i10 = L.charts[ri(rr.hoverChartIndex, -1)];
          if (i10 && i10 !== e10) {
            let s10 = {
              relatedTarget: e10.container
            };
            t10 && !t10?.relatedTarget && Object.assign({}, t10, s10), i10.pointer?.onContainerMouseLeave(t10 || s10);
          }
          i10 && i10.mouseIsDown || (rr.hoverChartIndex = e10.index);
        }
        touch(t10, e10) {
          let i10;
          let {
            chart: s10,
            pinchDown: o10 = []
          } = this;
          this.setHoverChartIndex(), 1 === (t10 = this.normalize(t10)).touches.length ? s10.isInsidePlot(t10.chartX - s10.plotLeft, t10.chartY - s10.plotTop, {
            visiblePlotOnly: true
          }) && !s10.openMenu ? (e10 && this.runPointActions(t10), "touchmove" === t10.type && (i10 = !!o10[0] && Math.pow(o10[0].chartX - t10.chartX, 2) + Math.pow(o10[0].chartY - t10.chartY, 2) >= 16), ri(i10, true) && this.pinch(t10)) : e10 && this.reset() : 2 === t10.touches.length && this.pinch(t10);
        }
        touchSelect(t10) {
          return !!(this.chart.zooming.singleTouch && t10.touches && 1 === t10.touches.length);
        }
        zoomOption(t10) {
          let e10 = this.chart, i10 = e10.inverted, s10 = e10.zooming.type || "", o10, r10;
          /touch/.test(t10.type) && (s10 = ri(e10.zooming.pinchType, s10)), this.zoomX = o10 = /x/.test(s10), this.zoomY = r10 = /y/.test(s10), this.zoomHor = o10 && !i10 || r10 && i10, this.zoomVert = r10 && !i10 || o10 && i10, this.hasZoom = o10 || r10;
        }
      }
      rr.unbindDocumentMouseUp = [], function(t10) {
        t10.compose = function(e10) {
          rs(o0, "Core.Pointer") && o2(e10, "beforeRender", function() {
            this.pointer = new t10(this, this.options);
          });
        };
      }(rr || (rr = {}));
      let ra = rr, {
        fireEvent: rn,
        isArray: rh,
        objectEach: rl,
        uniqueKey: rd
      } = ti, rc = class {
        constructor(t10 = {}) {
          this.autoId = !t10.id, this.columns = {}, this.id = t10.id || rd(), this.modified = this, this.rowCount = 0, this.versionTag = rd();
          let e10 = 0;
          rl(t10.columns || {}, (t11, i10) => {
            this.columns[i10] = t11.slice(), e10 = Math.max(e10, t11.length);
          }), this.applyRowCount(e10);
        }
        applyRowCount(t10) {
          this.rowCount = t10, rl(this.columns, (e10) => {
            rh(e10) && (e10.length = t10);
          });
        }
        getColumn(t10, e10) {
          return this.columns[t10];
        }
        getColumns(t10, e10) {
          return (t10 || Object.keys(this.columns)).reduce((t11, e11) => (t11[e11] = this.columns[e11], t11), {});
        }
        getRow(t10, e10) {
          return (e10 || Object.keys(this.columns)).map((e11) => this.columns[e11]?.[t10]);
        }
        setColumn(t10, e10 = [], i10 = 0, s10) {
          this.setColumns({
            [t10]: e10
          }, i10, s10);
        }
        setColumns(t10, e10, i10) {
          let s10 = this.rowCount;
          rl(t10, (t11, e11) => {
            this.columns[e11] = t11.slice(), s10 = t11.length;
          }), this.applyRowCount(s10), i10?.silent || (rn(this, "afterSetColumns"), this.versionTag = rd());
        }
        setRow(t10, e10 = this.rowCount, i10, s10) {
          let {
            columns: o10
          } = this, r10 = i10 ? this.rowCount + 1 : e10 + 1;
          rl(t10, (t11, a10) => {
            let n10 = o10[a10] || s10?.addColumns !== false && Array(r10);
            n10 && (i10 ? n10.splice(e10, 0, t11) : n10[e10] = t11, o10[a10] = n10);
          }), r10 > this.rowCount && this.applyRowCount(r10), s10?.silent || (rn(this, "afterSetRows"), this.versionTag = rd());
        }
      }, {
        extend: rp,
        merge: ru,
        pick: rg
      } = ti;
      !function(t10) {
        function e10(t11, e11, i10) {
          let s10 = this.legendItem = this.legendItem || {}, {
            chart: o10,
            options: r10
          } = this, {
            baseline: a10 = 0,
            symbolWidth: n10,
            symbolHeight: h10
          } = t11, l10 = this.symbol || "circle", d10 = h10 / 2, c10 = o10.renderer, p10 = s10.group, u2 = a10 - Math.round((t11.fontMetrics?.b || h10) * (i10 ? 0.4 : 0.3)), g2 = {}, f2, m2 = r10.marker, x2 = 0;
          if (o10.styledMode || (g2["stroke-width"] = Math.min(r10.lineWidth || 0, 24), r10.dashStyle ? g2.dashstyle = r10.dashStyle : "square" === r10.linecap || (g2["stroke-linecap"] = "round")), s10.line = c10.path().addClass("highcharts-graph").attr(g2).add(p10), i10 && (s10.area = c10.path().addClass("highcharts-area").add(p10)), g2["stroke-linecap"] && (x2 = Math.min(s10.line.strokeWidth(), n10) / 2), n10) {
            let t12 = [["M", x2, u2], ["L", n10 - x2, u2]];
            s10.line.attr({
              d: t12
            }), s10.area?.attr({
              d: [...t12, ["L", n10 - x2, a10], ["L", x2, a10]]
            });
          }
          if (m2 && false !== m2.enabled && n10) {
            let t12 = Math.min(rg(m2.radius, d10), d10);
            0 === l10.indexOf("url") && (m2 = ru(m2, {
              width: h10,
              height: h10
            }), t12 = 0), s10.symbol = f2 = c10.symbol(l10, n10 / 2 - t12, u2 - t12, 2 * t12, 2 * t12, rp({
              context: "legend"
            }, m2)).addClass("highcharts-point").add(p10), f2.isMarker = true;
          }
        }
        t10.areaMarker = function(t11, i10) {
          e10.call(this, t11, i10, true);
        }, t10.lineMarker = e10, t10.rectangle = function(t11, e11) {
          let i10 = e11.legendItem || {}, s10 = t11.options, o10 = t11.symbolHeight, r10 = s10.squareSymbol, a10 = r10 ? o10 : t11.symbolWidth;
          i10.symbol = this.chart.renderer.rect(r10 ? (t11.symbolWidth - o10) / 2 : 0, t11.baseline - o10 + 1, a10, o10, rg(t11.options.symbolRadius, o10 / 2)).addClass("highcharts-point").attr({
            zIndex: 3
          }).add(i10.group);
        };
      }(g || (g = {}));
      let rf = g, {
        defaultOptions: rm
      } = tT, {
        extend: rx,
        extendClass: ry,
        merge: rb
      } = ti;
      !function(t10) {
        function e10(e11, i10) {
          let s10 = rm.plotOptions || {}, o10 = i10.defaultOptions, r10 = i10.prototype;
          return r10.type = e11, r10.pointClass || (r10.pointClass = oK), !t10.seriesTypes[e11] && (o10 && (s10[e11] = o10), t10.seriesTypes[e11] = i10, true);
        }
        t10.seriesTypes = L.seriesTypes, t10.registerSeriesType = e10, t10.seriesType = function(i10, s10, o10, r10, a10) {
          let n10 = rm.plotOptions || {};
          if (s10 = s10 || "", n10[i10] = rb(n10[s10], o10), delete t10.seriesTypes[i10], e10(i10, ry(t10.seriesTypes[s10] || function() {
          }, r10)), t10.seriesTypes[i10].prototype.type = i10, a10) {
            class e11 extends oK {
            }
            rx(e11.prototype, a10), t10.seriesTypes[i10].prototype.pointClass = e11;
          }
          return t10.seriesTypes[i10];
        };
      }(f || (f = {}));
      let rv = f, {
        animObject: rk,
        setAnimation: rM
      } = t_, {
        defaultOptions: rw
      } = tT, {
        registerEventOptions: rS
      } = ss, {
        svg: rA,
        win: rT
      } = L, {
        seriesTypes: rC
      } = rv, {
        arrayMax: rP,
        arrayMin: rO,
        clamp: rE,
        correctFloat: rL,
        crisp: rD,
        defined: rB,
        destroyObjectProperties: rI,
        diffObjects: rz,
        erase: rR,
        error: rN,
        extend: rW,
        find: rG,
        fireEvent: rX,
        getClosestDistance: rH,
        getNestedProperty: rF,
        insertItem: rY,
        isArray: rj,
        isNumber: rU,
        isString: rV,
        merge: r_,
        objectEach: r$,
        pick: rZ,
        removeEvent: rq,
        syncTimeout: rK
      } = ti;
      class rJ {
        constructor() {
          this.zoneAxis = "y";
        }
        init(t10, e10) {
          let i10;
          rX(this, "init", {
            options: e10
          }), this.dataTable ?? (this.dataTable = new rc());
          let s10 = t10.series;
          this.eventsToUnbind = [], this.chart = t10, this.options = this.setOptions(e10);
          let o10 = this.options, r10 = false !== o10.visible;
          this.linkedSeries = [], this.bindAxes(), rW(this, {
            name: o10.name,
            state: "",
            visible: r10,
            selected: true === o10.selected
          }), rS(this, o10);
          let a10 = o10.events;
          (a10 && a10.click || o10.point && o10.point.events && o10.point.events.click || o10.allowPointSelect) && (t10.runTrackerClick = true), this.getColor(), this.getSymbol(), this.isCartesian && (t10.hasCartesianSeries = true), s10.length && (i10 = s10[s10.length - 1]), this._i = rZ(i10 && i10._i, -1) + 1, this.opacity = this.options.opacity, t10.orderItems("series", rY(this, s10)), o10.dataSorting && o10.dataSorting.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o10.data, false), rX(this, "afterInit");
        }
        is(t10) {
          return rC[t10] && this instanceof rC[t10];
        }
        bindAxes() {
          let t10;
          let e10 = this, i10 = e10.options, s10 = e10.chart;
          rX(this, "bindAxes", null, function() {
            (e10.axisTypes || []).forEach(function(o10) {
              (s10[o10] || []).forEach(function(s11) {
                t10 = s11.options, (rZ(i10[o10], 0) === s11.index || void 0 !== i10[o10] && i10[o10] === t10.id) && (rY(e10, s11.series), e10[o10] = s11, s11.isDirty = true);
              }), e10[o10] || e10.optionalAxis === o10 || rN(18, true, s10);
            });
          }), rX(this, "afterBindAxes");
        }
        hasData() {
          return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;
        }
        hasMarkerChanged(t10, e10) {
          let i10 = t10.marker, s10 = e10.marker || {};
          return i10 && (s10.enabled && !i10.enabled || s10.symbol !== i10.symbol || s10.height !== i10.height || s10.width !== i10.width);
        }
        autoIncrement(t10) {
          let e10;
          let i10 = this.options, {
            pointIntervalUnit: s10,
            relativeXValue: o10
          } = this.options, r10 = this.chart.time, a10 = this.xIncrement ?? r10.parse(i10.pointStart) ?? 0;
          if (this.pointInterval = e10 = rZ(this.pointInterval, i10.pointInterval, 1), o10 && rU(t10) && (e10 *= t10), s10) {
            let t11 = r10.toParts(a10);
            "day" === s10 ? t11[2] += e10 : "month" === s10 ? t11[1] += e10 : "year" === s10 && (t11[0] += e10), e10 = r10.makeTime.apply(r10, t11) - a10;
          }
          return o10 && rU(t10) ? a10 + e10 : (this.xIncrement = a10 + e10, a10);
        }
        setDataSortingOptions() {
          let t10 = this.options;
          rW(this, {
            requireSorting: false,
            sorted: false,
            enabledDataSorting: true,
            allowDG: false
          }), rB(t10.pointRange) || (t10.pointRange = 1);
        }
        setOptions(t10) {
          let e10;
          let i10 = this.chart, s10 = i10.options.plotOptions, o10 = i10.userOptions || {}, r10 = r_(t10), a10 = i10.styledMode, n10 = {
            plotOptions: s10,
            userOptions: r10
          };
          rX(this, "setOptions", n10);
          let h10 = n10.plotOptions[this.type], l10 = o10.plotOptions || {}, d10 = l10.series || {}, c10 = rw.plotOptions[this.type] || {}, p10 = l10[this.type] || {};
          this.userOptions = n10.userOptions;
          let u2 = r_(h10, s10.series, p10, r10);
          this.tooltipOptions = r_(rw.tooltip, rw.plotOptions.series?.tooltip, c10?.tooltip, i10.userOptions.tooltip, l10.series?.tooltip, p10.tooltip, r10.tooltip), this.stickyTracking = rZ(r10.stickyTracking, p10.stickyTracking, d10.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || u2.stickyTracking), null === h10.marker && delete u2.marker, this.zoneAxis = u2.zoneAxis || "y";
          let g2 = this.zones = (u2.zones || []).map((t11) => __spreadValues({}, t11));
          return (u2.negativeColor || u2.negativeFillColor) && !u2.zones && (e10 = {
            value: u2[this.zoneAxis + "Threshold"] || u2.threshold || 0,
            className: "highcharts-negative"
          }, a10 || (e10.color = u2.negativeColor, e10.fillColor = u2.negativeFillColor), g2.push(e10)), g2.length && rB(g2[g2.length - 1].value) && g2.push(a10 ? {} : {
            color: this.color,
            fillColor: this.fillColor
          }), rX(this, "afterSetOptions", {
            options: u2
          }), u2;
        }
        getName() {
          return rZ(this.options.name, "Series " + (this.index + 1));
        }
        getCyclic(t10, e10, i10) {
          let s10, o10;
          let r10 = this.chart, a10 = `${t10}Index`, n10 = `${t10}Counter`, h10 = i10?.length || r10.options.chart.colorCount;
          !e10 && (rB(o10 = rZ("color" === t10 ? this.options.colorIndex : void 0, this[a10])) ? s10 = o10 : (r10.series.length || (r10[n10] = 0), s10 = r10[n10] % h10, r10[n10] += 1), i10 && (e10 = i10[s10])), void 0 !== s10 && (this[a10] = s10), this[t10] = e10;
        }
        getColor() {
          this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || rw.plotOptions[this.type].color, this.chart.options.colors);
        }
        getPointsCollection() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        }
        getSymbol() {
          let t10 = this.options.marker;
          this.getCyclic("symbol", t10.symbol, this.chart.options.symbols);
        }
        getColumn(t10, e10) {
          return (e10 ? this.dataTable.modified : this.dataTable).getColumn(t10, true) || [];
        }
        findPointIndex(t10, e10) {
          let i10, s10, o10;
          let r10 = t10.id, a10 = t10.x, n10 = this.points, h10 = this.options.dataSorting;
          if (r10) {
            let t11 = this.chart.get(r10);
            t11 instanceof oK && (i10 = t11);
          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            let e11 = (e12) => !e12.touched && e12.index === t10.index;
            if (h10 && h10.matchByName ? e11 = (e12) => !e12.touched && e12.name === t10.name : this.options.relativeXValue && (e11 = (e12) => !e12.touched && e12.options.x === t10.x), !(i10 = rG(n10, e11))) return;
          }
          return i10 && void 0 !== (o10 = i10 && i10.index) && (s10 = true), void 0 === o10 && rU(a10) && (o10 = this.getColumn("x").indexOf(a10, e10)), -1 !== o10 && void 0 !== o10 && this.cropped && (o10 = o10 >= this.cropStart ? o10 - this.cropStart : o10), !s10 && rU(o10) && n10[o10] && n10[o10].touched && (o10 = void 0), o10;
        }
        updateData(t10, e10) {
          let i10 = this.options, s10 = i10.dataSorting, o10 = this.points, r10 = [], a10 = this.requireSorting, n10 = t10.length === o10.length, h10, l10, d10, c10, p10 = true;
          if (this.xIncrement = null, t10.forEach(function(t11, e11) {
            let l11;
            let d11 = rB(t11) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, t11) || {}, p11 = d11.x;
            d11.id || rU(p11) ? (-1 === (l11 = this.findPointIndex(d11, c10)) || void 0 === l11 ? r10.push(t11) : o10[l11] && t11 !== i10.data[l11] ? (o10[l11].update(t11, false, null, false), o10[l11].touched = true, a10 && (c10 = l11 + 1)) : o10[l11] && (o10[l11].touched = true), (!n10 || e11 !== l11 || s10 && s10.enabled || this.hasDerivedData) && (h10 = true)) : r10.push(t11);
          }, this), h10) for (l10 = o10.length; l10--; ) (d10 = o10[l10]) && !d10.touched && d10.remove && d10.remove(false, e10);
          else !n10 || s10 && s10.enabled ? p10 = false : (t10.forEach(function(t11, e11) {
            t11 === o10[e11].y || o10[e11].destroyed || o10[e11].update(t11, false, null, false);
          }), r10.length = 0);
          if (o10.forEach(function(t11) {
            t11 && (t11.touched = false);
          }), !p10) return false;
          r10.forEach(function(t11) {
            this.addPoint(t11, false, null, null, false);
          }, this);
          let u2 = this.getColumn("x");
          return null === this.xIncrement && u2.length && (this.xIncrement = rP(u2), this.autoIncrement()), true;
        }
        dataColumnKeys() {
          return ["x", ...this.pointArrayMap || ["y"]];
        }
        setData(t10, e10 = true, i10, s10) {
          let o10 = this.points, r10 = o10 && o10.length || 0, a10 = this.options, n10 = this.chart, h10 = a10.dataSorting, l10 = this.xAxis, d10 = a10.turboThreshold, c10 = this.dataTable, p10 = this.dataColumnKeys(), u2 = this.pointValKey || "y", g2 = (this.pointArrayMap || []).length, f2 = a10.keys, m2, x2, y2 = 0, b2 = 1, v2;
          n10.options.chart.allowMutatingData || (a10.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v2 = r_(true, t10));
          let k2 = (t10 = v2 || t10 || []).length;
          if (h10 && h10.enabled && (t10 = this.sortData(t10)), n10.options.chart.allowMutatingData && false !== s10 && k2 && r10 && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x2 = this.updateData(t10, i10)), !x2) {
            this.xIncrement = null, this.colorCounter = 0;
            let e11 = d10 && k2 > d10;
            if (e11) {
              let i11 = this.getFirstValidPoint(t10), s11 = this.getFirstValidPoint(t10, k2 - 1, -1), o11 = (t11) => !!(rj(t11) && (f2 || rU(t11[0])));
              if (rU(i11) && rU(s11)) {
                let e12 = [], i12 = [];
                for (let s12 of t10) e12.push(this.autoIncrement()), i12.push(s12);
                c10.setColumns({
                  x: e12,
                  [u2]: i12
                });
              } else if (o11(i11) && o11(s11)) {
                if (g2) {
                  let e12 = i11.length === g2 ? 1 : 0, s12 = Array(p10.length).fill(0).map(() => []);
                  for (let i12 of t10) {
                    e12 && s12[0].push(this.autoIncrement());
                    for (let t11 = e12; t11 <= g2; t11++) s12[t11]?.push(i12[t11 - e12]);
                  }
                  c10.setColumns(p10.reduce((t11, e13, i12) => (t11[e13] = s12[i12], t11), {}));
                } else {
                  f2 && (y2 = f2.indexOf("x"), b2 = f2.indexOf("y"), y2 = y2 >= 0 ? y2 : 0, b2 = b2 >= 0 ? b2 : 1), 1 === i11.length && (b2 = 0);
                  let e12 = [], s12 = [];
                  if (y2 === b2) for (let i12 of t10) e12.push(this.autoIncrement()), s12.push(i12[b2]);
                  else for (let i12 of t10) e12.push(i12[y2]), s12.push(i12[b2]);
                  c10.setColumns({
                    x: e12,
                    [u2]: s12
                  });
                }
              } else e11 = false;
            }
            if (!e11) {
              let e12 = p10.reduce((t11, e13) => (t11[e13] = [], t11), {});
              for (m2 = 0; m2 < k2; m2++) {
                let i11 = this.pointClass.prototype.applyOptions.apply({
                  series: this
                }, [t10[m2]]);
                for (let t11 of p10) e12[t11][m2] = i11[t11];
              }
              c10.setColumns(e12);
            }
            for (rV(this.getColumn("y")[0]) && rN(14, true, n10), this.data = [], this.options.data = this.userOptions.data = t10, m2 = r10; m2--; ) o10[m2]?.destroy();
            l10 && (l10.minRange = l10.userMinRange), this.isDirty = n10.isDirtyBox = true, this.isDirtyData = !!o10, i10 = false;
          }
          "point" === a10.legendType && (this.processData(), this.generatePoints()), e10 && n10.redraw(i10);
        }
        sortData(t10) {
          let e10 = this, i10 = e10.options.dataSorting.sortKey || "y", s10 = function(t11, e11) {
            return rB(e11) && t11.pointClass.prototype.optionsToObject.call({
              series: t11
            }, e11) || {};
          };
          return t10.forEach(function(i11, o10) {
            t10[o10] = s10(e10, i11), t10[o10].index = o10;
          }, this), t10.concat().sort((t11, e11) => {
            let s11 = rF(i10, t11), o10 = rF(i10, e11);
            return o10 < s11 ? -1 : o10 > s11 ? 1 : 0;
          }).forEach(function(t11, e11) {
            t11.x = e11;
          }, this), e10.linkedSeries && e10.linkedSeries.forEach(function(e11) {
            let i11 = e11.options, o10 = i11.data;
            i11.dataSorting && i11.dataSorting.enabled || !o10 || (o10.forEach(function(i12, r10) {
              o10[r10] = s10(e11, i12), t10[r10] && (o10[r10].x = t10[r10].x, o10[r10].index = r10);
            }), e11.setData(o10, false));
          }), t10;
        }
        getProcessedData(t10) {
          let e10 = this, {
            dataTable: i10,
            isCartesian: s10,
            options: o10,
            xAxis: r10
          } = e10, a10 = o10.cropThreshold, n10 = t10 || e10.getExtremesFromAll, h10 = r10?.logarithmic, l10 = i10.rowCount, d10, c10, p10 = 0, u2, g2, f2, m2 = e10.getColumn("x"), x2 = i10, y2 = false;
          return r10 && (g2 = (u2 = r10.getExtremes()).min, f2 = u2.max, y2 = !!(r10.categories && !r10.names.length), s10 && e10.sorted && !n10 && (!a10 || l10 > a10 || e10.forceCrop) && (m2[l10 - 1] < g2 || m2[0] > f2 ? x2 = new rc() : e10.getColumn(e10.pointValKey || "y").length && (m2[0] < g2 || m2[l10 - 1] > f2) && (x2 = (d10 = this.cropData(i10, g2, f2)).modified, p10 = d10.start, c10 = true))), m2 = x2.getColumn("x") || [], {
            modified: x2,
            cropped: c10,
            cropStart: p10,
            closestPointRange: rH([h10 ? m2.map(h10.log2lin) : m2], () => e10.requireSorting && !y2 && rN(15, false, e10.chart))
          };
        }
        processData(t10) {
          let e10 = this.xAxis, i10 = this.dataTable;
          if (this.isCartesian && !this.isDirty && !e10.isDirty && !this.yAxis.isDirty && !t10) return false;
          let s10 = this.getProcessedData();
          i10.modified = s10.modified, this.cropped = s10.cropped, this.cropStart = s10.cropStart, this.closestPointRange = this.basePointRange = s10.closestPointRange, rX(this, "afterProcessData");
        }
        cropData(t10, e10, i10) {
          let s10 = t10.getColumn("x", true) || [], o10 = s10.length, r10 = {}, a10, n10, h10 = 0, l10 = o10;
          for (a10 = 0; a10 < o10; a10++) if (s10[a10] >= e10) {
            h10 = Math.max(0, a10 - 1);
            break;
          }
          for (n10 = a10; n10 < o10; n10++) if (s10[n10] > i10) {
            l10 = n10 + 1;
            break;
          }
          for (let e11 of this.dataColumnKeys()) {
            let i11 = t10.getColumn(e11, true);
            i11 && (r10[e11] = i11.slice(h10, l10));
          }
          return {
            modified: new rc({
              columns: r10
            }),
            start: h10,
            end: l10
          };
        }
        generatePoints() {
          let t10 = this.options, e10 = this.processedData || t10.data, i10 = this.dataTable.modified, s10 = this.getColumn("x", true), o10 = this.pointClass, r10 = i10.rowCount, a10 = this.cropStart || 0, n10 = this.hasGroupedData, h10 = t10.keys, l10 = [], d10 = t10.dataGrouping && t10.dataGrouping.groupAll ? a10 : 0, c10 = this.xAxis?.categories, p10 = this.pointArrayMap || ["y"], u2 = this.dataColumnKeys(), g2, f2, m2, x2, y2 = this.data, b2;
          if (!y2 && !n10) {
            let t11 = [];
            t11.length = e10?.length || 0, y2 = this.data = t11;
          }
          for (h10 && n10 && (this.options.keys = false), x2 = 0; x2 < r10; x2++) f2 = a10 + x2, n10 ? ((m2 = new o10(this, i10.getRow(x2, u2) || [])).dataGroup = this.groupMap[d10 + x2], m2.dataGroup?.options && (m2.options = m2.dataGroup.options, rW(m2, m2.dataGroup.options), delete m2.dataLabels)) : (m2 = y2[f2], b2 = e10 ? e10[f2] : i10.getRow(x2, p10), m2 || void 0 === b2 || (y2[f2] = m2 = new o10(this, b2, s10[x2]))), m2 && (m2.index = n10 ? d10 + x2 : f2, l10[x2] = m2, m2.category = c10?.[m2.x] ?? m2.x, m2.key = m2.name ?? m2.category);
          if (this.options.keys = h10, y2 && (r10 !== (g2 = y2.length) || n10)) for (x2 = 0; x2 < g2; x2++) x2 !== a10 || n10 || (x2 += r10), y2[x2] && (y2[x2].destroyElements(), y2[x2].plotX = void 0);
          this.data = y2, this.points = l10, rX(this, "afterGeneratePoints");
        }
        getXExtremes(t10) {
          return {
            min: rO(t10),
            max: rP(t10)
          };
        }
        getExtremes(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = e10 || this.getExtremesFromAll || this.options.getExtremesFromAll, r10 = o10 && this.cropped ? this.dataTable : this.dataTable.modified, a10 = r10.rowCount, n10 = t10 || this.stackedYData, h10 = n10 ? [n10] : (this.keysAffectYAxis || this.pointArrayMap || ["y"])?.map((t11) => r10.getColumn(t11, true) || []) || [], l10 = this.getColumn("x", true), d10 = [], c10 = this.requireSorting && !this.is("column") ? 1 : 0, p10 = !!s10 && s10.positiveValuesOnly, u2 = o10 || this.cropped || !i10, g2, f2, m2, x2 = 0, y2 = 0;
          for (i10 && (x2 = (g2 = i10.getExtremes()).min, y2 = g2.max), m2 = 0; m2 < a10; m2++) if (f2 = l10[m2], u2 || (l10[m2 + c10] || f2) >= x2 && (l10[m2 - c10] || f2) <= y2) for (let t11 of h10) {
            let e11 = t11[m2];
            rU(e11) && (e11 > 0 || !p10) && d10.push(e11);
          }
          let b2 = {
            activeYData: d10,
            dataMin: rO(d10),
            dataMax: rP(d10)
          };
          return rX(this, "afterGetExtremes", {
            dataExtremes: b2
          }), b2;
        }
        applyExtremes() {
          let t10 = this.getExtremes();
          return this.dataMin = t10.dataMin, this.dataMax = t10.dataMax, t10;
        }
        getFirstValidPoint(t10, e10 = 0, i10 = 1) {
          let s10 = t10.length, o10 = e10;
          for (; o10 >= 0 && o10 < s10; ) {
            if (rB(t10[o10])) return t10[o10];
            o10 += i10;
          }
        }
        translate() {
          this.generatePoints();
          let t10 = this.options, e10 = t10.stacking, i10 = this.xAxis, s10 = this.enabledDataSorting, o10 = this.yAxis, r10 = this.points, a10 = r10.length, n10 = this.pointPlacementToXValue(), h10 = !!n10, l10 = t10.threshold, d10 = t10.startFromThreshold ? l10 : 0, c10, p10, u2, g2, f2 = Number.MAX_VALUE;
          function m2(t11) {
            return rE(t11, -1e9, 1e9);
          }
          for (c10 = 0; c10 < a10; c10++) {
            let t11;
            let a11 = r10[c10], x2 = a11.x, y2, b2, v2 = a11.y, k2 = a11.low, M2 = e10 && o10.stacking?.stacks[(this.negStacks && v2 < (d10 ? 0 : l10) ? "-" : "") + this.stackKey];
            p10 = i10.translate(x2, false, false, false, true, n10), a11.plotX = rU(p10) ? rL(m2(p10)) : void 0, e10 && this.visible && M2 && M2[x2] && (g2 = this.getStackIndicator(g2, x2, this.index), !a11.isNull && g2.key && (b2 = (y2 = M2[x2]).points[g2.key]), y2 && rj(b2) && (k2 = b2[0], v2 = b2[1], k2 === d10 && g2.key === M2[x2].base && (k2 = rZ(rU(l10) ? l10 : o10.min)), o10.positiveValuesOnly && rB(k2) && k2 <= 0 && (k2 = void 0), a11.total = a11.stackTotal = rZ(y2.total), a11.percentage = rB(a11.y) && y2.total ? a11.y / y2.total * 100 : void 0, a11.stackY = v2, this.irregularWidths || y2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a11.yBottom = rB(k2) ? m2(o10.translate(k2, false, true, false, true)) : void 0, this.dataModify && (v2 = this.dataModify.modifyValue(v2, c10)), rU(v2) && void 0 !== a11.plotX && (t11 = rU(t11 = o10.translate(v2, false, true, false, true)) ? m2(t11) : void 0), a11.plotY = t11, a11.isInside = this.isPointInside(a11), a11.clientX = h10 ? rL(i10.translate(x2, false, false, false, true, n10)) : p10, a11.negative = (a11.y || 0) < (l10 || 0), a11.isNull || false === a11.visible || (void 0 !== u2 && (f2 = Math.min(f2, Math.abs(p10 - u2))), u2 = p10), a11.zone = this.zones.length ? a11.getZone() : void 0, !a11.graphic && this.group && s10 && (a11.isNew = true);
          }
          this.closestPointRangePx = f2, rX(this, "afterTranslate");
        }
        getValidPoints(t10, e10, i10) {
          let s10 = this.chart;
          return (t10 || this.points || []).filter(function(t11) {
            let {
              plotX: o10,
              plotY: r10
            } = t11;
            return !!((i10 || !t11.isNull && rU(r10)) && (!e10 || s10.isInsidePlot(o10, r10, {
              inverted: s10.inverted
            }))) && false !== t11.visible;
          });
        }
        getClipBox() {
          let {
            chart: t10,
            xAxis: e10,
            yAxis: i10
          } = this, {
            x: s10,
            y: o10,
            width: r10,
            height: a10
          } = r_(t10.clipBox);
          return e10 && e10.len !== t10.plotSizeX && (r10 = e10.len), i10 && i10.len !== t10.plotSizeY && (a10 = i10.len), t10.inverted && !this.invertible && ([r10, a10] = [a10, r10]), {
            x: s10,
            y: o10,
            width: r10,
            height: a10
          };
        }
        getSharedClipKey() {
          return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
        }
        setClip() {
          let {
            chart: t10,
            group: e10,
            markerGroup: i10
          } = this, s10 = t10.sharedClips, o10 = t10.renderer, r10 = this.getClipBox(), a10 = this.getSharedClipKey(), n10 = s10[a10];
          n10 ? n10.animate(r10) : s10[a10] = n10 = o10.clipRect(r10), e10 && e10.clip(false === this.options.clip ? void 0 : n10), i10 && i10.clip();
        }
        animate(t10) {
          let {
            chart: e10,
            group: i10,
            markerGroup: s10
          } = this, o10 = e10.inverted, r10 = rk(this.options.animation), a10 = [this.getSharedClipKey(), r10.duration, r10.easing, r10.defer].join(","), n10 = e10.sharedClips[a10], h10 = e10.sharedClips[a10 + "m"];
          if (t10 && i10) {
            let t11 = this.getClipBox();
            if (n10) n10.attr("height", t11.height);
            else {
              t11.width = 0, o10 && (t11.x = e10.plotHeight), n10 = e10.renderer.clipRect(t11), e10.sharedClips[a10] = n10;
              let i11 = {
                x: -99,
                y: -99,
                width: o10 ? e10.plotWidth + 199 : 99,
                height: o10 ? 99 : e10.plotHeight + 199
              };
              h10 = e10.renderer.clipRect(i11), e10.sharedClips[a10 + "m"] = h10;
            }
            i10.clip(n10), s10?.clip(h10);
          } else if (n10 && !n10.hasClass("highcharts-animating")) {
            let t11 = this.getClipBox(), i11 = r10.step;
            (s10?.element.childNodes.length || e10.series.length > 1) && (r10.step = function(t12, e11) {
              i11 && i11.apply(e11, arguments), "width" === e11.prop && h10?.element && h10.attr(o10 ? "height" : "width", t12 + 99);
            }), n10.addClass("highcharts-animating").animate(t11, r10);
          }
        }
        afterAnimate() {
          this.setClip(), r$(this.chart.sharedClips, (t10, e10, i10) => {
            t10 && !this.chart.container.querySelector(`[clip-path="url(#${t10.id})"]`) && (t10.destroy(), delete i10[e10]);
          }), this.finishedAnimating = true, rX(this, "afterAnimate");
        }
        drawPoints(t10 = this.points) {
          let e10, i10, s10, o10, r10, a10, n10;
          let h10 = this.chart, l10 = h10.styledMode, {
            colorAxis: d10,
            options: c10
          } = this, p10 = c10.marker, u2 = this[this.specialGroup || "markerGroup"], g2 = this.xAxis, f2 = rZ(p10.enabled, !g2 || !!g2.isRadial || null, this.closestPointRangePx >= p10.enabledThreshold * p10.radius);
          if (false !== p10.enabled || this._hasPointMarkers) for (e10 = 0; e10 < t10.length; e10++) if (o10 = (s10 = (i10 = t10[e10]).graphic) ? "animate" : "attr", r10 = i10.marker || {}, a10 = !!i10.marker, (f2 && void 0 === r10.enabled || r10.enabled) && !i10.isNull && false !== i10.visible) {
            let t11 = rZ(r10.symbol, this.symbol, "rect");
            n10 = this.markerAttribs(i10, i10.selected && "select"), this.enabledDataSorting && (i10.startXPos = g2.reversed ? -(n10.width || 0) : g2.width);
            let e11 = false !== i10.isInside;
            if (!s10 && e11 && ((n10.width || 0) > 0 || i10.hasImage) && (i10.graphic = s10 = h10.renderer.symbol(t11, n10.x, n10.y, n10.width, n10.height, a10 ? r10 : p10).add(u2), this.enabledDataSorting && h10.hasRendered && (s10.attr({
              x: i10.startXPos
            }), o10 = "animate")), s10 && "animate" === o10 && s10[e11 ? "show" : "hide"](e11).animate(n10), s10) {
              let t12 = this.pointAttribs(i10, l10 || !i10.selected ? void 0 : "select");
              l10 ? d10 && s10.css({
                fill: t12.fill
              }) : s10[o10](t12);
            }
            s10 && s10.addClass(i10.getClassName(), true);
          } else s10 && (i10.graphic = s10.destroy());
        }
        markerAttribs(t10, e10) {
          let i10 = this.options, s10 = i10.marker, o10 = t10.marker || {}, r10 = o10.symbol || s10.symbol, a10 = {}, n10, h10, l10 = rZ(o10.radius, s10 && s10.radius);
          e10 && (n10 = s10.states[e10], l10 = rZ((h10 = o10.states && o10.states[e10]) && h10.radius, n10 && n10.radius, l10 && l10 + (n10 && n10.radiusPlus || 0))), t10.hasImage = r10 && 0 === r10.indexOf("url"), t10.hasImage && (l10 = 0);
          let d10 = t10.pos();
          return rU(l10) && d10 && (i10.crisp && (d10[0] = rD(d10[0], t10.hasImage ? 0 : "rect" === r10 ? s10?.lineWidth || 0 : 1)), a10.x = d10[0] - l10, a10.y = d10[1] - l10), l10 && (a10.width = a10.height = 2 * l10), a10;
        }
        pointAttribs(t10, e10) {
          let i10 = this.options.marker, s10 = t10 && t10.options, o10 = s10 && s10.marker || {}, r10 = s10 && s10.color, a10 = t10 && t10.color, n10 = t10 && t10.zone && t10.zone.color, h10, l10, d10 = this.color, c10, p10, u2 = rZ(o10.lineWidth, i10.lineWidth), g2 = 1;
          return d10 = r10 || n10 || a10 || d10, c10 = o10.fillColor || i10.fillColor || d10, p10 = o10.lineColor || i10.lineColor || d10, e10 = e10 || "normal", h10 = i10.states[e10] || {}, u2 = rZ((l10 = o10.states && o10.states[e10] || {}).lineWidth, h10.lineWidth, u2 + rZ(l10.lineWidthPlus, h10.lineWidthPlus, 0)), c10 = l10.fillColor || h10.fillColor || c10, {
            stroke: p10 = l10.lineColor || h10.lineColor || p10,
            "stroke-width": u2,
            fill: c10,
            opacity: g2 = rZ(l10.opacity, h10.opacity, g2)
          };
        }
        destroy(t10) {
          let e10, i10, s10;
          let o10 = this, r10 = o10.chart, a10 = /AppleWebKit\/533/.test(rT.navigator.userAgent), n10 = o10.data || [];
          for (rX(o10, "destroy", {
            keepEventsForUpdate: t10
          }), this.removeEvents(t10), (o10.axisTypes || []).forEach(function(t11) {
            (s10 = o10[t11]) && s10.series && (rR(s10.series, o10), s10.isDirty = s10.forceRedraw = true);
          }), o10.legendItem && o10.chart.legend.destroyItem(o10), e10 = n10.length; e10--; ) (i10 = n10[e10]) && i10.destroy && i10.destroy();
          for (let t11 of o10.zones) rI(t11, void 0, true);
          ti.clearTimeout(o10.animationTimeout), r$(o10, function(t11, e11) {
            t11 instanceof e0 && !t11.survive && t11[a10 && "group" === e11 ? "hide" : "destroy"]();
          }), r10.hoverSeries === o10 && (r10.hoverSeries = void 0), rR(r10.series, o10), r10.orderItems("series"), r$(o10, function(e11, i11) {
            t10 && "hcEvents" === i11 || delete o10[i11];
          });
        }
        applyZones() {
          let {
            area: t10,
            chart: e10,
            graph: i10,
            zones: s10,
            points: o10,
            xAxis: r10,
            yAxis: a10,
            zoneAxis: n10
          } = this, {
            inverted: h10,
            renderer: l10
          } = e10, d10 = this[`${n10}Axis`], {
            isXAxis: c10,
            len: p10 = 0,
            minPointOffset: u2 = 0
          } = d10 || {}, g2 = (i10?.strokeWidth() || 0) / 2 + 1, f2 = (t11, e11 = 0, i11 = 0) => {
            h10 && (i11 = p10 - i11);
            let {
              translated: s11 = 0,
              lineClip: o11
            } = t11, r11 = i11 - s11;
            o11?.push(["L", e11, Math.abs(r11) < g2 ? i11 - g2 * (r11 <= 0 ? -1 : 1) : s11]);
          };
          if (s10.length && (i10 || t10) && d10 && rU(d10.min)) {
            let e11 = d10.getExtremes().max + u2, g3 = (t11) => {
              t11.forEach((e12, i11) => {
                ("M" === e12[0] || "L" === e12[0]) && (t11[i11] = [e12[0], c10 ? p10 - e12[1] : e12[1], c10 ? e12[2] : p10 - e12[2]]);
              });
            };
            if (s10.forEach((t11) => {
              t11.lineClip = [], t11.translated = rE(d10.toPixels(rZ(t11.value, e11), true) || 0, 0, p10);
            }), i10 && !this.showLine && i10.hide(), t10 && t10.hide(), "y" === n10 && o10.length < r10.len) for (let t11 of o10) {
              let {
                plotX: e12,
                plotY: i11,
                zone: o11
              } = t11, r11 = o11 && s10[s10.indexOf(o11) - 1];
              o11 && f2(o11, e12, i11), r11 && f2(r11, e12, i11);
            }
            let m2 = [], x2 = d10.toPixels(d10.getExtremes().min - u2, true);
            s10.forEach((e12) => {
              let s11 = e12.lineClip || [], o11 = Math.round(e12.translated || 0);
              r10.reversed && s11.reverse();
              let {
                clip: n11,
                simpleClip: d11
              } = e12, p11 = 0, u3 = 0, f3 = r10.len, y2 = a10.len;
              c10 ? (p11 = o11, f3 = x2) : (u3 = o11, y2 = x2);
              let b2 = [["M", p11, u3], ["L", f3, u3], ["L", f3, y2], ["L", p11, y2], ["Z"]], v2 = [b2[0], ...s11, b2[1], b2[2], ...m2, b2[3], b2[4]];
              m2 = s11.reverse(), x2 = o11, h10 && (g3(v2), t10 && g3(b2)), n11 ? (n11.animate({
                d: v2
              }), d11?.animate({
                d: b2
              })) : (n11 = e12.clip = l10.path(v2), t10 && (d11 = e12.simpleClip = l10.path(b2))), i10 && e12.graph?.clip(n11), t10 && e12.area?.clip(d11);
            });
          } else this.visible && (i10 && i10.show(), t10 && t10.show());
        }
        plotGroup(t10, e10, i10, s10, o10) {
          let r10 = this[t10], a10 = !r10, n10 = {
            visibility: i10,
            zIndex: s10 || 0.1
          };
          return rB(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n10.opacity = this.opacity), r10 || (this[t10] = r10 = this.chart.renderer.g().add(o10)), r10.addClass("highcharts-" + e10 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (rB(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r10.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true), r10.attr(n10)[a10 ? "attr" : "animate"](this.getPlotBox(e10)), r10;
        }
        getPlotBox(t10) {
          let e10 = this.xAxis, i10 = this.yAxis, s10 = this.chart, o10 = s10.inverted && !s10.polar && e10 && this.invertible && "series" === t10;
          return s10.inverted && (e10 = i10, i10 = this.xAxis), {
            translateX: e10 ? e10.left : s10.plotLeft,
            translateY: i10 ? i10.top : s10.plotTop,
            rotation: o10 ? 90 : 0,
            rotationOriginX: o10 ? (e10.len - i10.len) / 2 : 0,
            rotationOriginY: o10 ? (e10.len + i10.len) / 2 : 0,
            scaleX: o10 ? -1 : 1,
            scaleY: 1
          };
        }
        removeEvents(t10) {
          let {
            eventsToUnbind: e10
          } = this;
          t10 || rq(this), e10.length && (e10.forEach((t11) => {
            t11();
          }), e10.length = 0);
        }
        render() {
          let t10 = this, {
            chart: e10,
            options: i10,
            hasRendered: s10
          } = t10, o10 = rk(i10.animation), r10 = t10.visible ? "inherit" : "hidden", a10 = i10.zIndex, n10 = e10.seriesGroup, h10 = t10.finishedAnimating ? 0 : o10.duration;
          rX(this, "render"), t10.plotGroup("group", "series", r10, a10, n10), t10.markerGroup = t10.plotGroup("markerGroup", "markers", r10, a10, n10), false !== i10.clip && t10.setClip(), h10 && t10.animate?.(true), t10.drawGraph && (t10.drawGraph(), t10.applyZones()), t10.visible && t10.drawPoints(), t10.drawDataLabels?.(), t10.redrawPoints?.(), i10.enableMouseTracking && t10.drawTracker?.(), h10 && t10.animate?.(), s10 || (h10 && o10.defer && (h10 += o10.defer), t10.animationTimeout = rK(() => {
            t10.afterAnimate();
          }, h10 || 0)), t10.isDirty = false, t10.hasRendered = true, rX(t10, "afterRender");
        }
        redraw() {
          let t10 = this.isDirty || this.isDirtyData;
          this.translate(), this.render(), t10 && delete this.kdTree;
        }
        reserveSpace() {
          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
        }
        searchPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = this.chart.inverted;
          return this.searchKDTree({
            clientX: o10 ? i10.len - t10.chartY + i10.pos : t10.chartX - i10.pos,
            plotY: o10 ? s10.len - t10.chartX + s10.pos : t10.chartY - s10.pos
          }, e10, t10);
        }
        buildKDTree(t10) {
          this.buildingKdTree = true;
          let e10 = this, i10 = e10.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          delete e10.kdTree, rK(function() {
            e10.kdTree = function t11(i11, s10, o10) {
              let r10, a10;
              let n10 = i11?.length;
              if (n10) return r10 = e10.kdAxisArray[s10 % o10], i11.sort((t12, e11) => (t12[r10] || 0) - (e11[r10] || 0)), {
                point: i11[a10 = Math.floor(n10 / 2)],
                left: t11(i11.slice(0, a10), s10 + 1, o10),
                right: t11(i11.slice(a10 + 1), s10 + 1, o10)
              };
            }(e10.getValidPoints(void 0, !e10.directTouch), i10, i10), e10.buildingKdTree = false;
          }, e10.options.kdNow || t10?.type === "touchstart" ? 0 : 1);
        }
        searchKDTree(t10, e10, i10, s10, o10) {
          let r10 = this, [a10, n10] = this.kdAxisArray, h10 = e10 ? "distX" : "dist", l10 = (r10.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d10 = !!r10.isBubble, c10 = s10 || ((t11, e11, i11) => [(t11[i11] || 0) < (e11[i11] || 0) ? t11 : e11, false]), p10 = o10 || ((t11, e11) => t11 < e11);
          if (this.kdTree || this.buildingKdTree || this.buildKDTree(i10), this.kdTree) return function t11(e11, i11, s11, o11) {
            let l11 = i11.point, u2 = r10.kdAxisArray[s11 % o11], g2 = l11, f2 = false;
            !function(t12, e12) {
              let i12 = t12[a10], s12 = e12[a10], o12 = rB(i12) && rB(s12) ? i12 - s12 : null, r11 = t12[n10], h11 = e12[n10], l12 = rB(r11) && rB(h11) ? r11 - h11 : 0, c11 = d10 && e12.marker?.radius || 0;
              e12.dist = Math.sqrt((o12 && o12 * o12 || 0) + l12 * l12) - c11, e12.distX = rB(o12) ? Math.abs(o12) - c11 : Number.MAX_VALUE;
            }(e11, l11);
            let m2 = (e11[u2] || 0) - (l11[u2] || 0) + (d10 && l11.marker?.radius || 0), x2 = m2 < 0 ? "left" : "right", y2 = m2 < 0 ? "right" : "left";
            return i11[x2] && ([g2, f2] = c10(l11, t11(e11, i11[x2], s11 + 1, o11), h10)), i11[y2] && p10(Math.sqrt(m2 * m2), g2[h10], f2) && (g2 = c10(g2, t11(e11, i11[y2], s11 + 1, o11), h10)[0]), g2;
          }(t10, this.kdTree, l10, l10);
        }
        pointPlacementToXValue() {
          let {
            options: t10,
            xAxis: e10
          } = this, i10 = t10.pointPlacement;
          return "between" === i10 && (i10 = e10.reversed ? -0.5 : 0.5), rU(i10) ? i10 * (t10.pointRange || e10.pointRange) : 0;
        }
        isPointInside(t10) {
          let {
            chart: e10,
            xAxis: i10,
            yAxis: s10
          } = this, {
            plotX: o10 = -1,
            plotY: r10 = -1
          } = t10;
          return r10 >= 0 && r10 <= (s10 ? s10.len : e10.plotHeight) && o10 >= 0 && o10 <= (i10 ? i10.len : e10.plotWidth);
        }
        drawTracker() {
          let t10 = this, e10 = t10.options, i10 = e10.trackByArea, s10 = [].concat((i10 ? t10.areaPath : t10.graphPath) || []), o10 = t10.chart, r10 = o10.pointer, a10 = o10.renderer, n10 = o10.options.tooltip?.snap || 0, h10 = () => {
            e10.enableMouseTracking && o10.hoverSeries !== t10 && t10.onMouseOver();
          }, l10 = "rgba(192,192,192," + (rA ? 1e-4 : 2e-3) + ")", d10 = t10.tracker;
          d10 ? d10.attr({
            d: s10
          }) : t10.graph && (t10.tracker = d10 = a10.path(s10).attr({
            visibility: t10.visible ? "inherit" : "hidden",
            zIndex: 2
          }).addClass(i10 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t10.group), o10.styledMode || d10.attr({
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            stroke: l10,
            fill: i10 ? l10 : "none",
            "stroke-width": t10.graph.strokeWidth() + (i10 ? 0 : 2 * n10)
          }), [t10.tracker, t10.markerGroup, t10.dataLabelsGroup].forEach((t11) => {
            t11 && (t11.addClass("highcharts-tracker").on("mouseover", h10).on("mouseout", (t12) => {
              r10?.onTrackerMouseOut(t12);
            }), e10.cursor && !o10.styledMode && t11.css({
              cursor: e10.cursor
            }), t11.on("touchstart", h10));
          })), rX(this, "afterDrawTracker");
        }
        addPoint(t10, e10, i10, s10, o10) {
          let r10, a10;
          let n10 = this.options, {
            chart: h10,
            data: l10,
            dataTable: d10,
            xAxis: c10
          } = this, p10 = c10 && c10.hasNames && c10.names, u2 = n10.data, g2 = this.getColumn("x");
          e10 = rZ(e10, true);
          let f2 = {
            series: this
          };
          this.pointClass.prototype.applyOptions.apply(f2, [t10]);
          let m2 = f2.x;
          if (a10 = g2.length, this.requireSorting && m2 < g2[a10 - 1]) for (r10 = true; a10 && g2[a10 - 1] > m2; ) a10--;
          d10.setRow(f2, a10, true, {
            addColumns: false
          }), p10 && f2.name && (p10[m2] = f2.name), u2?.splice(a10, 0, t10), (r10 || this.processedData) && (this.data.splice(a10, 0, null), this.processData()), "point" === n10.legendType && this.generatePoints(), i10 && (l10[0] && l10[0].remove ? l10[0].remove(false) : ([l10, u2, ...Object.values(d10.getColumns())].filter(rB).forEach((t11) => {
            t11.shift();
          }), d10.rowCount -= 1, rX(d10, "afterDeleteRows"))), false !== o10 && rX(this, "addPoint", {
            point: f2
          }), this.isDirty = true, this.isDirtyData = true, e10 && h10.redraw(s10);
        }
        removePoint(t10, e10, i10) {
          let s10 = this, {
            chart: o10,
            data: r10,
            points: a10,
            dataTable: n10
          } = s10, h10 = r10[t10], l10 = function() {
            [a10?.length === r10.length ? a10 : void 0, r10, s10.options.data, ...Object.values(n10.getColumns())].filter(rB).forEach((e11) => {
              e11.splice(t10, 1);
            }), n10.rowCount -= 1, rX(n10, "afterDeleteRows"), h10?.destroy(), s10.isDirty = true, s10.isDirtyData = true, e10 && o10.redraw();
          };
          rM(i10, o10), e10 = rZ(e10, true), h10 ? h10.firePointEvent("remove", null, l10) : l10();
        }
        remove(t10, e10, i10, s10) {
          let o10 = this, r10 = o10.chart;
          function a10() {
            o10.destroy(s10), r10.isDirtyLegend = r10.isDirtyBox = true, r10.linkSeries(s10), rZ(t10, true) && r10.redraw(e10);
          }
          false !== i10 ? rX(o10, "remove", null, a10) : a10();
        }
        update(t10, e10) {
          rX(this, "update", {
            options: t10 = rz(t10, this.userOptions)
          });
          let i10 = this, s10 = i10.chart, o10 = i10.userOptions, r10 = i10.initialType || i10.type, a10 = s10.options.plotOptions, n10 = rC[r10].prototype, h10 = i10.finishedAnimating && {
            animation: false
          }, l10 = {}, d10, c10, p10 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], u2 = t10.type || o10.type || s10.options.chart.type, g2 = !(this.hasDerivedData || u2 && u2 !== this.type || void 0 !== t10.keys || void 0 !== t10.pointStart || void 0 !== t10.pointInterval || void 0 !== t10.relativeXValue || t10.joinBy || t10.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some((t11) => i10.hasOptionChanged(t11)));
          u2 = u2 || r10, g2 ? (p10.push("data", "isDirtyData", "isDirtyCanvas", "points", "dataTable", "processedData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), false !== t10.visible && p10.push("area", "graph"), i10.parallelArrays.forEach(function(t11) {
            p10.push(t11 + "Data");
          }), t10.data && (t10.dataSorting && rW(i10.options.dataSorting, t10.dataSorting), this.setData(t10.data, false))) : this.dataTable.modified = this.dataTable, t10 = r_(o10, {
            index: void 0 === o10.index ? i10.index : o10.index,
            pointStart: a10?.series?.pointStart ?? o10.pointStart ?? i10.getColumn("x")[0]
          }, !g2 && {
            data: i10.options.data
          }, t10, h10), g2 && t10.data && (t10.data = i10.options.data), (p10 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p10)).forEach(function(t11) {
            p10[t11] = i10[t11], delete i10[t11];
          });
          let f2 = false;
          if (rC[u2]) {
            if (f2 = u2 !== i10.type, i10.remove(false, false, false, true), f2) {
              if (s10.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i10, rC[u2].prototype);
              else {
                let t11 = Object.hasOwnProperty.call(i10, "hcEvents") && i10.hcEvents;
                for (c10 in n10) i10[c10] = void 0;
                rW(i10, rC[u2].prototype), t11 ? i10.hcEvents = t11 : delete i10.hcEvents;
              }
            }
          } else rN(17, true, s10, {
            missingModuleFor: u2
          });
          if (p10.forEach(function(t11) {
            i10[t11] = p10[t11];
          }), i10.init(s10, t10), g2 && this.points) for (let t11 of (false === (d10 = i10.options).visible ? (l10.graphic = 1, l10.dataLabel = 1) : (this.hasMarkerChanged(d10, o10) && (l10.graphic = 1), i10.hasDataLabels?.() || (l10.dataLabel = 1)), this.points)) t11 && t11.series && (t11.resolveColor(), Object.keys(l10).length && t11.destroyElements(l10), false === d10.showInLegend && t11.legendItem && s10.legend.destroyItem(t11));
          i10.initialType = r10, s10.linkSeries(), s10.setSortedData(), f2 && i10.linkedSeries.length && (i10.isDirtyData = true), rX(this, "afterUpdate"), rZ(e10, true) && s10.redraw(!!g2 && void 0);
        }
        setName(t10) {
          this.name = this.options.name = this.userOptions.name = t10, this.chart.isDirtyLegend = true;
        }
        hasOptionChanged(t10) {
          let e10 = this.chart, i10 = this.options[t10], s10 = e10.options.plotOptions, o10 = this.userOptions[t10], r10 = rZ(s10?.[this.type]?.[t10], s10?.series?.[t10]);
          return o10 && !rB(r10) ? i10 !== o10 : i10 !== rZ(r10, i10);
        }
        onMouseOver() {
          let t10 = this.chart, e10 = t10.hoverSeries, i10 = t10.pointer;
          i10?.setHoverChartIndex(), e10 && e10 !== this && e10.onMouseOut(), this.options.events.mouseOver && rX(this, "mouseOver"), this.setState("hover"), t10.hoverSeries = this;
        }
        onMouseOut() {
          let t10 = this.options, e10 = this.chart, i10 = e10.tooltip, s10 = e10.hoverPoint;
          e10.hoverSeries = null, s10 && s10.onMouseOut(), this && t10.events.mouseOut && rX(this, "mouseOut"), i10 && !this.stickyTracking && (!i10.shared || this.noSharedTooltip) && i10.hide(), e10.series.forEach(function(t11) {
            t11.setState("", true);
          });
        }
        setState(t10, e10) {
          let i10 = this, s10 = i10.options, o10 = i10.graph, r10 = s10.inactiveOtherPoints, a10 = s10.states, n10 = rZ(a10[t10 || "normal"] && a10[t10 || "normal"].animation, i10.chart.options.chart.animation), h10 = s10.lineWidth, l10 = s10.opacity;
          if (t10 = t10 || "", i10.state !== t10 && ([i10.group, i10.markerGroup, i10.dataLabelsGroup].forEach(function(e11) {
            e11 && (i10.state && e11.removeClass("highcharts-series-" + i10.state), t10 && e11.addClass("highcharts-series-" + t10));
          }), i10.state = t10, !i10.chart.styledMode)) {
            if (a10[t10] && false === a10[t10].enabled) return;
            if (t10 && (h10 = a10[t10].lineWidth || h10 + (a10[t10].lineWidthPlus || 0), l10 = rZ(a10[t10].opacity, l10)), o10 && !o10.dashstyle && rU(h10)) for (let t11 of [o10, ...this.zones.map((t12) => t12.graph)]) t11?.animate({
              "stroke-width": h10
            }, n10);
            r10 || [i10.group, i10.markerGroup, i10.dataLabelsGroup, i10.labelBySeries].forEach(function(t11) {
              t11 && t11.animate({
                opacity: l10
              }, n10);
            });
          }
          e10 && r10 && i10.points && i10.setAllPointsToState(t10 || void 0);
        }
        setAllPointsToState(t10) {
          this.points.forEach(function(e10) {
            e10.setState && e10.setState(t10);
          });
        }
        setVisible(t10, e10) {
          let i10 = this, s10 = i10.chart, o10 = s10.options.chart.ignoreHiddenSeries, r10 = i10.visible;
          i10.visible = t10 = i10.options.visible = i10.userOptions.visible = void 0 === t10 ? !r10 : t10;
          let a10 = t10 ? "show" : "hide";
          ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach((t11) => {
            i10[t11]?.[a10]();
          }), (s10.hoverSeries === i10 || s10.hoverPoint?.series === i10) && i10.onMouseOut(), i10.legendItem && s10.legend.colorizeItem(i10, t10), i10.isDirty = true, i10.options.stacking && s10.series.forEach((t11) => {
            t11.options.stacking && t11.visible && (t11.isDirty = true);
          }), i10.linkedSeries.forEach((e11) => {
            e11.setVisible(t10, false);
          }), o10 && (s10.isDirtyBox = true), rX(i10, a10), false !== e10 && s10.redraw();
        }
        show() {
          this.setVisible(true);
        }
        hide() {
          this.setVisible(false);
        }
        select(t10) {
          this.selected = t10 = this.options.selected = void 0 === t10 ? !this.selected : t10, this.checkbox && (this.checkbox.checked = t10), rX(this, t10 ? "select" : "unselect");
        }
        shouldShowTooltip(t10, e10, i10 = {}) {
          return i10.series = this, i10.visiblePlotOnly = true, this.chart.isInsidePlot(t10, e10, i10);
        }
        drawLegendSymbol(t10, e10) {
          rf[this.options.legendSymbol || "rectangle"]?.call(this, t10, e10);
        }
      }
      rJ.defaultOptions = {
        lineWidth: 2,
        allowPointSelect: false,
        crisp: true,
        showCheckbox: false,
        animation: {
          duration: 1e3
        },
        enableMouseTracking: true,
        events: {},
        marker: {
          enabledThreshold: 2,
          lineColor: "#ffffff",
          lineWidth: 0,
          radius: 4,
          states: {
            normal: {
              animation: true
            },
            hover: {
              animation: {
                duration: 150
              },
              enabled: true,
              radiusPlus: 2,
              lineWidthPlus: 1
            },
            select: {
              fillColor: "#cccccc",
              lineColor: "#000000",
              lineWidth: 2
            }
          }
        },
        point: {
          events: {}
        },
        dataLabels: {
          animation: {},
          align: "center",
          borderWidth: 0,
          defer: true,
          formatter: function() {
            let {
              numberFormatter: t10
            } = this.series.chart;
            return "number" != typeof this.y ? "" : t10(this.y, -1);
          },
          padding: 5,
          style: {
            fontSize: "0.7em",
            fontWeight: "bold",
            color: "contrast",
            textOutline: "1px contrast"
          },
          verticalAlign: "bottom",
          x: 0,
          y: 0
        },
        cropThreshold: 300,
        opacity: 1,
        pointRange: 0,
        softThreshold: true,
        states: {
          normal: {
            animation: true
          },
          hover: {
            animation: {
              duration: 150
            },
            lineWidthPlus: 1,
            marker: {},
            halo: {
              size: 10,
              opacity: 0.25
            }
          },
          select: {
            animation: {
              duration: 0
            }
          },
          inactive: {
            animation: {
              duration: 150
            },
            opacity: 0.2
          }
        },
        stickyTracking: true,
        turboThreshold: 1e3,
        findNearestPointBy: "x"
      }, rJ.types = rv.seriesTypes, rJ.registerType = rv.registerSeriesType, rW(rJ.prototype, {
        axisTypes: ["xAxis", "yAxis"],
        coll: "series",
        colorCounter: 0,
        directTouch: false,
        invertible: true,
        isCartesian: true,
        kdAxisArray: ["clientX", "plotY"],
        parallelArrays: ["x", "y"],
        pointClass: oK,
        requireSorting: true,
        sorted: true
      }), rv.series = rJ;
      let rQ = rJ, {
        animObject: r0,
        setAnimation: r1
      } = t_, {
        registerEventOptions: r2
      } = ss, {
        composed: r3,
        marginNames: r5
      } = L, {
        distribute: r6
      } = ev, {
        format: r9
      } = eg, {
        addEvent: r4,
        createElement: r8,
        css: r7,
        defined: at,
        discardElement: ae,
        find: ai,
        fireEvent: as,
        isNumber: ao,
        merge: ar,
        pick: aa,
        pushUnique: an,
        relativeLength: ah,
        stableSort: al,
        syncTimeout: ad
      } = ti;
      class ac {
        constructor(t10, e10) {
          this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t10, this.setOptions(e10), e10.enabled && (this.render(), r2(this, e10), r4(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          })), r4(this.chart, "render", () => {
            this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
          });
        }
        setOptions(t10) {
          let e10 = aa(t10.padding, 8);
          this.options = t10, this.chart.styledMode || (this.itemStyle = t10.itemStyle, this.itemHiddenStyle = ar(this.itemStyle, t10.itemHiddenStyle)), this.itemMarginTop = t10.itemMarginTop, this.itemMarginBottom = t10.itemMarginBottom, this.padding = e10, this.initialItemY = e10 - 5, this.symbolWidth = aa(t10.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t10.layout && !this.chart.inverted, this.baseline = void 0;
        }
        update(t10, e10) {
          let i10 = this.chart;
          this.setOptions(ar(true, this.options, t10)), "events" in this.options && r2(this, this.options), this.destroy(), i10.isDirtyLegend = i10.isDirtyBox = true, aa(e10, true) && i10.redraw(), as(this, "afterUpdate", {
            redraw: e10
          });
        }
        colorizeItem(t10, e10) {
          let i10 = t10.color, {
            area: s10,
            group: o10,
            label: r10,
            line: a10,
            symbol: n10
          } = t10.legendItem || {};
          if ((t10 instanceof rQ || t10 instanceof oK) && (t10.color = t10.options?.legendSymbolColor || i10), o10?.[e10 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
            let {
              itemHiddenStyle: i11 = {}
            } = this, o11 = i11.color, {
              fillColor: h10,
              fillOpacity: l10,
              lineColor: d10,
              marker: c10
            } = t10.options, p10 = (t11) => (!e10 && (t11.fill && (t11.fill = o11), t11.stroke && (t11.stroke = o11)), t11);
            r10?.css(ar(e10 ? this.itemStyle : i11)), a10?.attr(p10({
              stroke: d10 || t10.color
            })), n10 && n10.attr(p10(c10 && n10.isMarker ? t10.pointAttribs() : {
              fill: t10.color
            })), s10?.attr(p10({
              fill: h10 || t10.color,
              "fill-opacity": h10 ? 1 : l10 ?? 0.75
            }));
          }
          t10.color = i10, as(this, "afterColorizeItem", {
            item: t10,
            visible: e10
          });
        }
        positionItems() {
          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
        }
        positionItem(t10) {
          let {
            group: e10,
            x: i10 = 0,
            y: s10 = 0
          } = t10.legendItem || {}, o10 = this.options, r10 = o10.symbolPadding, a10 = !o10.rtl, n10 = t10.checkbox;
          if (e10 && e10.element) {
            let o11 = {
              translateX: a10 ? i10 : this.legendWidth - i10 - 2 * r10 - 4,
              translateY: s10
            };
            e10[at(e10.translateY) ? "animate" : "attr"](o11, void 0, () => {
              as(this, "afterPositionItem", {
                item: t10
              });
            });
          }
          n10 && (n10.x = i10, n10.y = s10);
        }
        destroyItem(t10) {
          let e10 = t10.checkbox, i10 = t10.legendItem || {};
          for (let t11 of ["group", "label", "line", "symbol"]) i10[t11] && (i10[t11] = i10[t11].destroy());
          e10 && ae(e10), t10.legendItem = void 0;
        }
        destroy() {
          for (let t10 of this.getAllItems()) this.destroyItem(t10);
          for (let t10 of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t10] && (this[t10] = this[t10].destroy());
          this.display = null;
        }
        positionCheckboxes() {
          let t10;
          let e10 = this.group && this.group.alignAttr, i10 = this.clipHeight || this.legendHeight, s10 = this.titleHeight;
          e10 && (t10 = e10.translateY, this.allItems.forEach(function(o10) {
            let r10;
            let a10 = o10.checkbox;
            a10 && (r10 = t10 + s10 + a10.y + (this.scrollOffset || 0) + 3, r7(a10, {
              left: e10.translateX + o10.checkboxOffset + a10.x - 20 + "px",
              top: r10 + "px",
              display: this.proximate || r10 > t10 - 6 && r10 < t10 + i10 - 6 ? "" : "none"
            }));
          }, this));
        }
        renderTitle() {
          let t10 = this.options, e10 = this.padding, i10 = t10.title, s10, o10 = 0;
          i10.text && (this.title || (this.title = this.chart.renderer.label(i10.text, e10 - 3, e10 - 4, void 0, void 0, void 0, t10.useHTML, void 0, "legend-title").attr({
            zIndex: 1
          }), this.chart.styledMode || this.title.css(i10.style), this.title.add(this.group)), i10.width || this.title.css({
            width: this.maxLegendWidth + "px"
          }), o10 = (s10 = this.title.getBBox()).height, this.offsetWidth = s10.width, this.contentGroup.attr({
            translateY: o10
          })), this.titleHeight = o10;
        }
        setText(t10) {
          let e10 = this.options;
          t10.legendItem.label.attr({
            text: e10.labelFormat ? r9(e10.labelFormat, t10, this.chart) : e10.labelFormatter.call(t10)
          });
        }
        renderItem(t10) {
          let e10 = t10.legendItem = t10.legendItem || {}, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = "horizontal" === o10.layout, a10 = this.symbolWidth, n10 = o10.symbolPadding || 0, h10 = this.itemStyle, l10 = this.itemHiddenStyle, d10 = r10 ? aa(o10.itemDistance, 20) : 0, c10 = !o10.rtl, p10 = !t10.series, u2 = !p10 && t10.series.drawLegendSymbol ? t10.series : t10, g2 = u2.options, f2 = !!this.createCheckboxForItem && g2 && g2.showCheckbox, m2 = o10.useHTML, x2 = t10.options.className, y2 = e10.label, b2 = a10 + n10 + d10 + (f2 ? 20 : 0);
          !y2 && (e10.group = s10.g("legend-item").addClass("highcharts-" + u2.type + "-series highcharts-color-" + t10.colorIndex + (x2 ? " " + x2 : "") + (p10 ? " highcharts-series-" + t10.index : "")).attr({
            zIndex: 1
          }).add(this.scrollGroup), e10.label = y2 = s10.text("", c10 ? a10 + n10 : -n10, this.baseline || 0, m2), i10.styledMode || y2.css(ar(t10.visible ? h10 : l10)), y2.attr({
            align: c10 ? "left" : "right",
            zIndex: 2
          }).add(e10.group), !this.baseline && (this.fontMetrics = s10.fontMetrics(y2), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y2.attr("y", this.baseline), this.symbolHeight = aa(o10.symbolHeight, this.fontMetrics.f), o10.squareSymbol && (this.symbolWidth = aa(o10.symbolWidth, Math.max(this.symbolHeight, 16)), b2 = this.symbolWidth + n10 + d10 + (f2 ? 20 : 0), c10 && y2.attr("x", this.symbolWidth + n10))), u2.drawLegendSymbol(this, t10), this.setItemEvents && this.setItemEvents(t10, y2, m2)), f2 && !t10.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t10), this.colorizeItem(t10, t10.visible), (i10.styledMode || !h10.width) && y2.css({
            width: (o10.itemWidth || this.widthOption || i10.spacingBox.width) - b2 + "px"
          }), this.setText(t10);
          let v2 = y2.getBBox(), k2 = this.fontMetrics && this.fontMetrics.h || 0;
          t10.itemWidth = t10.checkboxOffset = o10.itemWidth || e10.labelWidth || v2.width + b2, this.maxItemWidth = Math.max(this.maxItemWidth, t10.itemWidth), this.totalItemWidth += t10.itemWidth, this.itemHeight = t10.itemHeight = Math.round(e10.labelHeight || (v2.height > 1.5 * k2 ? v2.height : k2));
        }
        layoutItem(t10) {
          let e10 = this.options, i10 = this.padding, s10 = "horizontal" === e10.layout, o10 = t10.itemHeight, r10 = this.itemMarginBottom, a10 = this.itemMarginTop, n10 = s10 ? aa(e10.itemDistance, 20) : 0, h10 = this.maxLegendWidth, l10 = e10.alignColumns && this.totalItemWidth > h10 ? this.maxItemWidth : t10.itemWidth, d10 = t10.legendItem || {};
          s10 && this.itemX - i10 + l10 > h10 && (this.itemX = i10, this.lastLineHeight && (this.itemY += a10 + this.lastLineHeight + r10), this.lastLineHeight = 0), this.lastItemY = a10 + this.itemY + r10, this.lastLineHeight = Math.max(o10, this.lastLineHeight), d10.x = this.itemX, d10.y = this.itemY, s10 ? this.itemX += l10 : (this.itemY += a10 + o10 + r10, this.lastLineHeight = o10), this.offsetWidth = this.widthOption || Math.max((s10 ? this.itemX - i10 - (t10.checkbox ? 0 : n10) : l10) + i10, this.offsetWidth);
        }
        getAllItems() {
          let t10 = [];
          return this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.options;
            e10 && aa(i10.showInLegend, !at(i10.linkedTo) && void 0, true) && (t10 = t10.concat((e10.legendItem || {}).labels || ("point" === i10.legendType ? e10.data : e10)));
          }), as(this, "afterGetAllItems", {
            allItems: t10
          }), t10;
        }
        getAlignment() {
          let t10 = this.options;
          return this.proximate ? t10.align.charAt(0) + "tv" : t10.floating ? "" : t10.align.charAt(0) + t10.verticalAlign.charAt(0) + t10.layout.charAt(0);
        }
        adjustMargins(t10, e10) {
          let i10 = this.chart, s10 = this.options, o10 = this.getAlignment();
          o10 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(r10, a10) {
            r10.test(o10) && !at(t10[a10]) && (i10[r5[a10]] = Math.max(i10[r5[a10]], i10.legend[(a10 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][a10] * s10[a10 % 2 ? "x" : "y"] + aa(s10.margin, 12) + e10[a10] + (i10.titleOffset[a10] || 0)));
          });
        }
        proximatePositions() {
          let t10;
          let e10 = this.chart, i10 = [], s10 = "left" === this.options.align;
          for (let o10 of (this.allItems.forEach(function(t11) {
            let o11, r10, a10 = s10, n10, h10;
            t11.yAxis && (t11.xAxis.options.reversed && (a10 = !a10), t11.points && (o11 = ai(a10 ? t11.points : t11.points.slice(0).reverse(), function(t12) {
              return ao(t12.plotY);
            })), r10 = this.itemMarginTop + t11.legendItem.label.getBBox().height + this.itemMarginBottom, h10 = t11.yAxis.top - e10.plotTop, n10 = t11.visible ? (o11 ? o11.plotY : t11.yAxis.height) + (h10 - 0.3 * r10) : h10 + t11.yAxis.height, i10.push({
              target: n10,
              size: r10,
              item: t11
            }));
          }, this), r6(i10, e10.plotHeight))) t10 = o10.item.legendItem || {}, ao(o10.pos) && (t10.y = e10.plotTop - e10.spacing[0] + o10.pos);
        }
        render() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.options, s10 = this.padding, o10 = this.getAllItems(), r10, a10, n10, h10 = this.group, l10, d10 = this.box;
          this.itemX = s10, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = ah(i10.width, t10.spacingBox.width - s10), l10 = t10.spacingBox.width - 2 * s10 - i10.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l10 /= 2), this.maxLegendWidth = this.widthOption || l10, h10 || (this.group = h10 = e10.g("legend").addClass(i10.className || "").attr({
            zIndex: 7
          }).add(), this.contentGroup = e10.g().attr({
            zIndex: 1
          }).add(h10), this.scrollGroup = e10.g().add(this.contentGroup)), this.renderTitle(), al(o10, (t11, e11) => (t11.options && t11.options.legendIndex || 0) - (e11.options && e11.options.legendIndex || 0)), i10.reversed && o10.reverse(), this.allItems = o10, this.display = r10 = !!o10.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o10.forEach(this.renderItem, this), o10.forEach(this.layoutItem, this), a10 = (this.widthOption || this.offsetWidth) + s10, n10 = this.lastItemY + this.lastLineHeight + this.titleHeight, n10 = this.handleOverflow(n10) + s10, d10 || (this.box = d10 = e10.rect().addClass("highcharts-legend-box").attr({
            r: i10.borderRadius
          }).add(h10)), t10.styledMode || d10.attr({
            stroke: i10.borderColor,
            "stroke-width": i10.borderWidth || 0,
            fill: i10.backgroundColor || "none"
          }).shadow(i10.shadow), a10 > 0 && n10 > 0 && d10[d10.placed ? "animate" : "attr"](d10.crisp.call({}, {
            x: 0,
            y: 0,
            width: a10,
            height: n10
          }, d10.strokeWidth())), h10[r10 ? "show" : "hide"](), t10.styledMode && "none" === h10.getStyle("display") && (a10 = n10 = 0), this.legendWidth = a10, this.legendHeight = n10, r10 && this.align(), this.proximate || this.positionItems(), as(this, "afterRender");
        }
        align(t10 = this.chart.spacingBox) {
          let e10 = this.chart, i10 = this.options, s10 = t10.y;
          /(lth|ct|rth)/.test(this.getAlignment()) && e10.titleOffset[0] > 0 ? s10 += e10.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e10.titleOffset[2] > 0 && (s10 -= e10.titleOffset[2]), s10 !== t10.y && (t10 = ar(t10, {
            y: s10
          })), e10.hasRendered || (this.group.placed = false), this.group.align(ar(i10, {
            width: this.legendWidth,
            height: this.legendHeight,
            verticalAlign: this.proximate ? "top" : i10.verticalAlign
          }), true, t10);
        }
        handleOverflow(t10) {
          let e10 = this, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = o10.y, a10 = "top" === o10.verticalAlign, n10 = this.padding, h10 = o10.maxHeight, l10 = o10.navigation, d10 = aa(l10.animation, true), c10 = l10.arrowSize || 12, p10 = this.pages, u2 = this.allItems, g2 = function(t11) {
            "number" == typeof t11 ? k2.attr({
              height: t11
            }) : k2 && (e10.clipRect = k2.destroy(), e10.contentGroup.clip()), e10.contentGroup.div && (e10.contentGroup.div.style.clip = t11 ? "rect(" + n10 + "px,9999px," + (n10 + t11) + "px,0)" : "auto");
          }, f2 = function(t11) {
            return e10[t11] = s10.circle(0, 0, 1.3 * c10).translate(c10 / 2, c10 / 2).add(v2), i10.styledMode || e10[t11].attr("fill", "rgba(0,0,0,0.0001)"), e10[t11];
          }, m2, x2, y2, b2 = i10.spacingBox.height + (a10 ? -r10 : r10) - n10, v2 = this.nav, k2 = this.clipRect;
          return "horizontal" !== o10.layout || "middle" === o10.verticalAlign || o10.floating || (b2 /= 2), h10 && (b2 = Math.min(b2, h10)), p10.length = 0, t10 && b2 > 0 && t10 > b2 && false !== l10.enabled ? (this.clipHeight = m2 = Math.max(b2 - 20 - this.titleHeight - n10, 0), this.currentPage = aa(this.currentPage, 1), this.fullHeight = t10, u2.forEach((t11, e11) => {
            let i11 = (y2 = t11.legendItem || {}).y || 0, s11 = Math.round(y2.label.getBBox().height), o11 = p10.length;
            (!o11 || i11 - p10[o11 - 1] > m2 && (x2 || i11) !== p10[o11 - 1]) && (p10.push(x2 || i11), o11++), y2.pageIx = o11 - 1, x2 && ((u2[e11 - 1].legendItem || {}).pageIx = o11 - 1), e11 === u2.length - 1 && i11 + s11 - p10[o11 - 1] > m2 && i11 > p10[o11 - 1] && (p10.push(i11), y2.pageIx = o11), i11 !== x2 && (x2 = i11);
          }), k2 || (k2 = e10.clipRect = s10.clipRect(0, n10 - 2, 9999, 0), e10.contentGroup.clip(k2)), g2(m2), v2 || (this.nav = v2 = s10.g().attr({
            zIndex: 1
          }).add(this.group), this.up = s10.symbol("triangle", 0, 0, c10, c10).add(v2), f2("upTracker").on("click", function() {
            e10.scroll(-1, d10);
          }), this.pager = s10.text("", 15, 10).addClass("highcharts-legend-navigation"), !i10.styledMode && l10.style && this.pager.css(l10.style), this.pager.add(v2), this.down = s10.symbol("triangle-down", 0, 0, c10, c10).add(v2), f2("downTracker").on("click", function() {
            e10.scroll(1, d10);
          })), e10.scroll(0), t10 = b2) : v2 && (g2(), this.nav = v2.destroy(), this.scrollGroup.attr({
            translateY: 1
          }), this.clipHeight = 0), t10;
        }
        scroll(t10, e10) {
          let i10 = this.chart, s10 = this.pages, o10 = s10.length, r10 = this.clipHeight, a10 = this.options.navigation, n10 = this.pager, h10 = this.padding, l10 = this.currentPage + t10;
          l10 > o10 && (l10 = o10), l10 > 0 && (void 0 !== e10 && r1(e10, i10), this.nav.attr({
            translateX: h10,
            translateY: r10 + this.padding + 7 + this.titleHeight,
            visibility: "inherit"
          }), [this.up, this.upTracker].forEach(function(t11) {
            t11.attr({
              class: 1 === l10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }), n10.attr({
            text: l10 + "/" + o10
          }), [this.down, this.downTracker].forEach(function(t11) {
            t11.attr({
              x: 18 + this.pager.getBBox().width,
              class: l10 === o10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }, this), i10.styledMode || (this.up.attr({
            fill: 1 === l10 ? a10.inactiveColor : a10.activeColor
          }), this.upTracker.css({
            cursor: 1 === l10 ? "default" : "pointer"
          }), this.down.attr({
            fill: l10 === o10 ? a10.inactiveColor : a10.activeColor
          }), this.downTracker.css({
            cursor: l10 === o10 ? "default" : "pointer"
          })), this.scrollOffset = -s10[l10 - 1] + this.initialItemY, this.scrollGroup.animate({
            translateY: this.scrollOffset
          }), this.currentPage = l10, this.positionCheckboxes(), ad(() => {
            as(this, "afterScroll", {
              currentPage: l10
            });
          }, r0(aa(e10, i10.renderer.globalAnimation, true)).duration));
        }
        setItemEvents(t10, e10, i10) {
          let s10 = this, o10 = t10.legendItem || {}, r10 = s10.chart.renderer.boxWrapper, a10 = t10 instanceof oK, n10 = t10 instanceof rQ, h10 = "highcharts-legend-" + (a10 ? "point" : "series") + "-active", l10 = s10.chart.styledMode, d10 = i10 ? [e10, o10.symbol] : [o10.group], c10 = (e11) => {
            s10.allItems.forEach((i11) => {
              t10 !== i11 && [i11].concat(i11.linkedSeries || []).forEach((t11) => {
                t11.setState(e11, !a10);
              });
            });
          };
          for (let i11 of d10) i11 && i11.on("mouseover", function() {
            t10.visible && c10("inactive"), t10.setState("hover"), t10.visible && r10.addClass(h10), l10 || e10.css(s10.options.itemHoverStyle);
          }).on("mouseout", function() {
            s10.chart.styledMode || e10.css(ar(t10.visible ? s10.itemStyle : s10.itemHiddenStyle)), c10(""), r10.removeClass(h10), t10.setState();
          }).on("click", function(e11) {
            let i12 = function() {
              t10.setVisible && t10.setVisible(), c10(t10.visible ? "inactive" : "");
            };
            r10.removeClass(h10), as(s10, "itemClick", {
              browserEvent: e11,
              legendItem: t10
            }, i12), a10 ? t10.firePointEvent("legendItemClick", {
              browserEvent: e11
            }) : n10 && as(t10, "legendItemClick", {
              browserEvent: e11
            });
          });
        }
        createCheckboxForItem(t10) {
          t10.checkbox = r8("input", {
            type: "checkbox",
            className: "highcharts-legend-checkbox",
            checked: t10.selected,
            defaultChecked: t10.selected
          }, this.options.itemCheckboxStyle, this.chart.container), r4(t10.checkbox, "click", function(e10) {
            let i10 = e10.target;
            as(t10.series || t10, "checkboxClick", {
              checked: i10.checked,
              item: t10
            }, function() {
              t10.select();
            });
          });
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          an(r3, "Core.Legend") && r4(e10, "beforeMargins", function() {
            this.legend = new t10(this, this.options.legend);
          });
        };
      }(ac || (ac = {}));
      let ap = ac, {
        animate: au,
        animObject: ag,
        setAnimation: af
      } = t_, {
        defaultOptions: am
      } = tT, {
        numberFormat: ax
      } = eg, {
        registerEventOptions: ay
      } = ss, {
        charts: ab,
        doc: av,
        marginNames: ak,
        svg: aM,
        win: aw
      } = L, {
        seriesTypes: aS
      } = rv, {
        addEvent: aA,
        attr: aT,
        createElement: aC,
        css: aP,
        defined: aO,
        diffObjects: aE,
        discardElement: aL,
        erase: aD,
        error: aB,
        extend: aI,
        find: az,
        fireEvent: aR,
        getAlignFactor: aN,
        getStyle: aW,
        isArray: aG,
        isNumber: aX,
        isObject: aH,
        isString: aF,
        merge: aY,
        objectEach: aj,
        pick: aU,
        pInt: aV,
        relativeLength: a_,
        removeEvent: a$,
        splat: aZ,
        syncTimeout: aq,
        uniqueKey: aK
      } = ti;
      class aJ {
        static chart(t10, e10, i10) {
          return new aJ(t10, e10, i10);
        }
        constructor(t10, e10, i10) {
          this.sharedClips = {};
          let s10 = [...arguments];
          (aF(t10) || t10.nodeName) && (this.renderTo = s10.shift()), this.init(s10[0], s10[1]);
        }
        setZoomOptions() {
          let t10 = this.options.chart, e10 = t10.zooming;
          this.zooming = __spreadProps(__spreadValues({}, e10), {
            type: aU(t10.zoomType, e10.type),
            key: aU(t10.zoomKey, e10.key),
            pinchType: aU(t10.pinchType, e10.pinchType),
            singleTouch: aU(t10.zoomBySingleTouch, e10.singleTouch, false),
            resetButton: aY(e10.resetButton, t10.resetZoomButton)
          });
        }
        init(t10, e10) {
          aR(this, "init", {
            args: arguments
          }, function() {
            let i10 = aY(am, t10), s10 = i10.chart, o10 = this.renderTo || s10.renderTo;
            this.userOptions = aI({}, t10), (this.renderTo = aF(o10) ? av.getElementById(o10) : o10) || aB(13, true, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e10, this.isResizing = 0, this.options = i10, this.axes = [], this.series = [], this.locale = i10.lang.locale ?? this.renderTo.closest("[lang]")?.lang, this.time = new tv(aI(i10.time || {}, {
              locale: this.locale
            })), i10.time = this.time.options, this.numberFormatter = (s10.numberFormatter || ax).bind(this), this.styledMode = s10.styledMode, this.hasCartesianSeries = s10.showAxes, this.index = ab.length, ab.push(this), L.chartCount++, ay(this, s10), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), aR(this, "afterInit"), this.firstRender();
          });
        }
        initSeries(t10) {
          let e10 = this.options.chart, i10 = t10.type || e10.type, s10 = aS[i10];
          s10 || aB(17, true, this, {
            missingModuleFor: i10
          });
          let o10 = new s10();
          return "function" == typeof o10.init && o10.init(this, t10), o10;
        }
        setSortedData() {
          this.getSeriesOrderByLinks().forEach(function(t10) {
            t10.points || t10.data || !t10.enabledDataSorting || t10.setData(t10.options.data, false);
          });
        }
        getSeriesOrderByLinks() {
          return this.series.concat().sort(function(t10, e10) {
            return t10.linkedSeries.length || e10.linkedSeries.length ? e10.linkedSeries.length - t10.linkedSeries.length : 0;
          });
        }
        orderItems(t10, e10 = 0) {
          let i10 = this[t10], s10 = this.options[t10] = aZ(this.options[t10]).slice(), o10 = this.userOptions[t10] = this.userOptions[t10] ? aZ(this.userOptions[t10]).slice() : [];
          if (this.hasRendered && (s10.splice(e10), o10.splice(e10)), i10) for (let t11 = e10, r10 = i10.length; t11 < r10; ++t11) {
            let e11 = i10[t11];
            e11 && (e11.index = t11, e11 instanceof rQ && (e11.name = e11.getName()), e11.options.isInternal || (s10[t11] = e11.options, o10[t11] = e11.userOptions));
          }
        }
        isInsidePlot(t10, e10, i10 = {}) {
          let {
            inverted: s10,
            plotBox: o10,
            plotLeft: r10,
            plotTop: a10,
            scrollablePlotBox: n10
          } = this, {
            scrollLeft: h10 = 0,
            scrollTop: l10 = 0
          } = i10.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, d10 = i10.series, c10 = i10.visiblePlotOnly && n10 || o10, p10 = i10.inverted ? e10 : t10, u2 = i10.inverted ? t10 : e10, g2 = {
            x: p10,
            y: u2,
            isInsidePlot: true,
            options: i10
          };
          if (!i10.ignoreX) {
            let t11 = d10 && (s10 && !this.polar ? d10.yAxis : d10.xAxis) || {
              pos: r10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + p10 : r10 + p10;
            e11 >= Math.max(h10 + r10, t11.pos) && e11 <= Math.min(h10 + r10 + c10.width, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          if (!i10.ignoreY && g2.isInsidePlot) {
            let t11 = !s10 && i10.axis && !i10.axis.isXAxis && i10.axis || d10 && (s10 ? d10.xAxis : d10.yAxis) || {
              pos: a10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + u2 : a10 + u2;
            e11 >= Math.max(l10 + a10, t11.pos) && e11 <= Math.min(l10 + a10 + c10.height, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          return aR(this, "afterIsInsidePlot", g2), g2.isInsidePlot;
        }
        redraw(t10) {
          aR(this, "beforeRedraw");
          let e10 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i10 = this.series, s10 = this.pointer, o10 = this.legend, r10 = this.userOptions.legend, a10 = this.renderer, n10 = a10.isHidden(), h10 = [], l10, d10, c10, p10 = this.isDirtyBox, u2 = this.isDirtyLegend, g2;
          for (a10.rootFontSize = a10.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(false), af(!!this.hasRendered && t10, this), n10 && this.temporaryDisplay(), this.layOutTitles(false), c10 = i10.length; c10--; ) if (((g2 = i10[c10]).options.stacking || g2.options.centerInCategory) && (d10 = true, g2.isDirty)) {
            l10 = true;
            break;
          }
          if (l10) for (c10 = i10.length; c10--; ) (g2 = i10[c10]).options.stacking && (g2.isDirty = true);
          i10.forEach(function(t11) {
            t11.isDirty && ("point" === t11.options.legendType ? ("function" == typeof t11.updateTotals && t11.updateTotals(), u2 = true) : r10 && (r10.labelFormatter || r10.labelFormat) && (u2 = true)), t11.isDirtyData && aR(t11, "updatedData");
          }), u2 && o10 && o10.options.enabled && (o10.render(), this.isDirtyLegend = false), d10 && this.getStacks(), e10.forEach(function(t11) {
            t11.updateNames(), t11.setScale();
          }), this.getMargins(), e10.forEach(function(t11) {
            t11.isDirty && (p10 = true);
          }), e10.forEach(function(t11) {
            let e11 = t11.min + "," + t11.max;
            t11.extKey !== e11 && (t11.extKey = e11, h10.push(function() {
              aR(t11, "afterSetExtremes", aI(t11.eventArgs, t11.getExtremes())), delete t11.eventArgs;
            })), (p10 || d10) && t11.redraw();
          }), p10 && this.drawChartBox(), aR(this, "predraw"), i10.forEach(function(t11) {
            (p10 || t11.isDirty) && t11.visible && t11.redraw(), t11.isDirtyData = false;
          }), s10 && s10.reset(true), a10.draw(), aR(this, "redraw"), aR(this, "render"), n10 && this.temporaryDisplay(true), h10.forEach(function(t11) {
            t11.call();
          });
        }
        get(t10) {
          let e10 = this.series;
          function i10(e11) {
            return e11.id === t10 || e11.options && e11.options.id === t10;
          }
          let s10 = az(this.axes, i10) || az(this.series, i10);
          for (let t11 = 0; !s10 && t11 < e10.length; t11++) s10 = az(e10[t11].points || [], i10);
          return s10;
        }
        createAxes() {
          let t10 = this.userOptions;
          for (let e10 of (aR(this, "createAxes"), ["xAxis", "yAxis"])) for (let i10 of t10[e10] = aZ(t10[e10] || {})) new s_(this, i10, e10);
          aR(this, "afterCreateAxes");
        }
        getSelectedPoints() {
          return this.series.reduce((t10, e10) => (e10.getPointsCollection().forEach((e11) => {
            aU(e11.selectedStaging, e11.selected) && t10.push(e11);
          }), t10), []);
        }
        getSelectedSeries() {
          return this.series.filter((t10) => t10.selected);
        }
        setTitle(t10, e10, i10) {
          this.applyDescription("title", t10), this.applyDescription("subtitle", e10), this.applyDescription("caption", void 0), this.layOutTitles(i10);
        }
        applyDescription(t10, e10) {
          let i10 = this, s10 = this.options[t10] = aY(this.options[t10], e10), o10 = this[t10];
          o10 && e10 && (this[t10] = o10 = o10.destroy()), s10 && !o10 && ((o10 = this.renderer.text(s10.text, 0, 0, s10.useHTML).attr({
            align: s10.align,
            class: "highcharts-" + t10,
            zIndex: s10.zIndex || 4
          }).css({
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          }).add()).update = function(e11, s11) {
            i10.applyDescription(t10, e11), i10.layOutTitles(s11);
          }, this.styledMode || o10.css(aI("title" === t10 ? {
            fontSize: this.options.isStock ? "1em" : "1.2em"
          } : {}, s10.style)), o10.textPxLength = o10.getBBox().width, o10.css({
            whiteSpace: s10.style?.whiteSpace
          }), this[t10] = o10);
        }
        layOutTitles(t10 = true) {
          let e10 = [0, 0, 0], {
            options: i10,
            renderer: s10,
            spacingBox: o10
          } = this;
          ["title", "subtitle", "caption"].forEach((t11) => {
            let i11 = this[t11], r11 = this.options[t11], a10 = aY(o10), n10 = i11?.textPxLength || 0;
            if (i11 && r11) {
              aR(this, "layOutTitle", {
                alignTo: a10,
                key: t11,
                textPxLength: n10
              });
              let o11 = s10.fontMetrics(i11), h10 = o11.b, l10 = o11.h, d10 = r11.verticalAlign || "top", c10 = "top" === d10, p10 = c10 && r11.minScale || 1, u2 = "title" === t11 ? c10 ? -3 : 0 : c10 ? e10[0] + 2 : 0, g2 = Math.min(a10.width / n10, 1), f2 = Math.max(p10, g2), m2 = aY({
                y: "bottom" === d10 ? h10 : u2 + h10
              }, {
                align: "title" === t11 ? g2 < p10 ? "left" : "center" : this.title?.alignValue
              }, r11), x2 = r11.width || (g2 > p10 ? this.chartWidth : a10.width) / f2;
              i11.alignValue !== m2.align && (i11.placed = false);
              let y2 = Math.round(i11.css({
                width: `${x2}px`
              }).getBBox(r11.useHTML).height);
              if (m2.height = y2, i11.align(m2, false, a10).attr({
                align: m2.align,
                scaleX: f2,
                scaleY: f2,
                "transform-origin": `${a10.x + n10 * f2 * aN(m2.align)} ${l10}`
              }), !r11.floating) {
                let t12 = y2 * (y2 < 1.2 * l10 ? 1 : f2);
                "top" === d10 ? e10[0] = Math.ceil(e10[0] + t12) : "bottom" === d10 && (e10[2] = Math.ceil(e10[2] + t12));
              }
            }
          }, this), e10[0] && "top" === (i10.title?.verticalAlign || "top") && (e10[0] += i10.title?.margin || 0), e10[2] && i10.caption?.verticalAlign === "bottom" && (e10[2] += i10.caption?.margin || 0);
          let r10 = !this.titleOffset || this.titleOffset.join(",") !== e10.join(",");
          this.titleOffset = e10, aR(this, "afterLayOutTitles"), !this.isDirtyBox && r10 && (this.isDirtyBox = this.isDirtyLegend = r10, this.hasRendered && t10 && this.isDirtyBox && this.redraw());
        }
        getContainerBox() {
          let t10 = [].map.call(this.renderTo.children, (t11) => {
            if (t11 !== this.container) {
              let e11 = t11.style.display;
              return t11.style.display = "none", [t11, e11];
            }
          }), e10 = {
            width: aW(this.renderTo, "width", true) || 0,
            height: aW(this.renderTo, "height", true) || 0
          };
          return t10.filter(Boolean).forEach(([t11, e11]) => {
            t11.style.display = e11;
          }), e10;
        }
        getChartSize() {
          let t10 = this.options.chart, e10 = t10.width, i10 = t10.height, s10 = this.getContainerBox(), o10 = s10.height <= 1 || !this.renderTo.parentElement?.style.height && "100%" === this.renderTo.style.height;
          this.chartWidth = Math.max(0, e10 || s10.width || 600), this.chartHeight = Math.max(0, a_(i10, this.chartWidth) || (o10 ? 400 : s10.height)), this.containerBox = s10;
        }
        temporaryDisplay(t10) {
          let e10 = this.renderTo, i10;
          if (t10) for (; e10 && e10.style; ) e10.hcOrigStyle && (aP(e10, e10.hcOrigStyle), delete e10.hcOrigStyle), e10.hcOrigDetached && (av.body.removeChild(e10), e10.hcOrigDetached = false), e10 = e10.parentNode;
          else for (; e10 && e10.style && (av.body.contains(e10) || e10.parentNode || (e10.hcOrigDetached = true, av.body.appendChild(e10)), ("none" === aW(e10, "display", false) || e10.hcOricDetached) && (e10.hcOrigStyle = {
            display: e10.style.display,
            height: e10.style.height,
            overflow: e10.style.overflow
          }, i10 = {
            display: "block",
            overflow: "hidden"
          }, e10 !== this.renderTo && (i10.height = 0), aP(e10, i10), e10.offsetWidth || e10.style.setProperty("display", "block", "important")), (e10 = e10.parentNode) !== av.body); ) ;
        }
        setClassName(t10) {
          this.container.className = "highcharts-container " + (t10 || "");
        }
        getContainer() {
          let t10;
          let e10 = this.options, i10 = e10.chart, s10 = "data-highcharts-chart", o10 = aK(), r10 = this.renderTo, a10 = aV(aT(r10, s10));
          aX(a10) && ab[a10] && ab[a10].hasRendered && ab[a10].destroy(), aT(r10, s10, this.index), r10.innerHTML = t4.emptyHTML, i10.skipClone || r10.offsetWidth || this.temporaryDisplay(), this.getChartSize();
          let n10 = this.chartHeight, h10 = this.chartWidth;
          aP(r10, {
            overflow: "hidden"
          }), this.styledMode || (t10 = aI({
            position: "relative",
            overflow: "hidden",
            width: h10 + "px",
            height: n10 + "px",
            textAlign: "left",
            lineHeight: "normal",
            zIndex: 0,
            "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
            userSelect: "none",
            "touch-action": "manipulation",
            outline: "none",
            padding: "0px"
          }, i10.style || {}));
          let l10 = aC("div", {
            id: o10
          }, t10, r10);
          this.container = l10, this.getChartSize(), h10 === this.chartWidth || (h10 = this.chartWidth, this.styledMode || aP(l10, {
            width: aU(i10.style?.width, h10 + "px")
          })), this.containerBox = this.getContainerBox(), this._cursor = l10.style.cursor;
          let d10 = i10.renderer || !aM ? ef.getRendererType(i10.renderer) : i_;
          if (this.renderer = new d10(l10, h10, n10, void 0, i10.forExport, e10.exporting && e10.exporting.allowHTML, this.styledMode), af(void 0, this), this.setClassName(i10.className), this.styledMode) for (let t11 in e10.defs) this.renderer.definition(e10.defs[t11]);
          else this.renderer.setStyle(i10.style);
          this.renderer.chartIndex = this.index, aR(this, "afterGetContainer");
        }
        getMargins(t10) {
          let {
            spacing: e10,
            margin: i10,
            titleOffset: s10
          } = this;
          this.resetMargins(), s10[0] && !aO(i10[0]) && (this.plotTop = Math.max(this.plotTop, s10[0] + e10[0])), s10[2] && !aO(i10[2]) && (this.marginBottom = Math.max(this.marginBottom, s10[2] + e10[2])), this.legend && this.legend.display && this.legend.adjustMargins(i10, e10), aR(this, "getMargins"), t10 || this.getAxisMargins();
        }
        getAxisMargins() {
          let t10 = this, e10 = t10.axisOffset = [0, 0, 0, 0], i10 = t10.colorAxis, s10 = t10.margin, o10 = function(t11) {
            t11.forEach(function(t12) {
              t12.visible && t12.getOffset();
            });
          };
          t10.hasCartesianSeries ? o10(t10.axes) : i10 && i10.length && o10(i10), ak.forEach(function(i11, o11) {
            aO(s10[o11]) || (t10[i11] += e10[o11]);
          }), t10.setChartSize();
        }
        getOptions() {
          return aE(this.userOptions, am);
        }
        reflow(t10) {
          let e10 = this, i10 = e10.containerBox, s10 = e10.getContainerBox();
          delete e10.pointer?.chartPosition, !e10.isPrinting && !e10.isResizing && i10 && s10.width && ((s10.width !== i10.width || s10.height !== i10.height) && (ti.clearTimeout(e10.reflowTimeout), e10.reflowTimeout = aq(function() {
            e10.container && e10.setSize(void 0, void 0, false);
          }, t10 ? 100 : 0)), e10.containerBox = s10);
        }
        setReflow() {
          let t10 = this, e10 = (e11) => {
            t10.options?.chart.reflow && t10.hasLoaded && t10.reflow(e11);
          };
          if ("function" == typeof ResizeObserver) new ResizeObserver(e10).observe(t10.renderTo);
          else {
            let t11 = aA(aw, "resize", e10);
            aA(this, "destroy", t11);
          }
        }
        setSize(t10, e10, i10) {
          let s10 = this, o10 = s10.renderer;
          s10.isResizing += 1, af(i10, s10);
          let r10 = o10.globalAnimation;
          s10.oldChartHeight = s10.chartHeight, s10.oldChartWidth = s10.chartWidth, void 0 !== t10 && (s10.options.chart.width = t10), void 0 !== e10 && (s10.options.chart.height = e10), s10.getChartSize();
          let {
            chartWidth: a10,
            chartHeight: n10,
            scrollablePixelsX: h10 = 0,
            scrollablePixelsY: l10 = 0
          } = s10;
          (s10.isDirtyBox || a10 !== s10.oldChartWidth || n10 !== s10.oldChartHeight) && (s10.styledMode || (r10 ? au : aP)(s10.container, {
            width: `${a10 + h10}px`,
            height: `${n10 + l10}px`
          }, r10), s10.setChartSize(true), o10.setSize(a10, n10, r10), s10.axes.forEach(function(t11) {
            t11.isDirty = true, t11.setScale();
          }), s10.isDirtyLegend = true, s10.isDirtyBox = true, s10.layOutTitles(), s10.getMargins(), s10.redraw(r10), s10.oldChartHeight = void 0, aR(s10, "resize"), setTimeout(() => {
            s10 && aR(s10, "endResize");
          }, ag(r10).duration)), s10.isResizing -= 1;
        }
        setChartSize(t10) {
          let e10, i10, s10, o10;
          let {
            chartHeight: r10,
            chartWidth: a10,
            inverted: n10,
            spacing: h10,
            renderer: l10
          } = this, d10 = this.clipOffset, c10 = Math[n10 ? "floor" : "round"];
          this.plotLeft = e10 = Math.round(this.plotLeft), this.plotTop = i10 = Math.round(this.plotTop), this.plotWidth = s10 = Math.max(0, Math.round(a10 - e10 - this.marginRight)), this.plotHeight = o10 = Math.max(0, Math.round(r10 - i10 - this.marginBottom)), this.plotSizeX = n10 ? o10 : s10, this.plotSizeY = n10 ? s10 : o10, this.spacingBox = l10.spacingBox = {
            x: h10[3],
            y: h10[0],
            width: a10 - h10[3] - h10[1],
            height: r10 - h10[0] - h10[2]
          }, this.plotBox = l10.plotBox = {
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }, d10 && (this.clipBox = {
            x: c10(d10[3]),
            y: c10(d10[0]),
            width: c10(this.plotSizeX - d10[1] - d10[3]),
            height: c10(this.plotSizeY - d10[0] - d10[2])
          }), t10 || (this.axes.forEach(function(t11) {
            t11.setAxisSize(), t11.setAxisTranslation();
          }), l10.alignElements()), aR(this, "afterSetChartSize", {
            skipAxes: t10
          });
        }
        resetMargins() {
          aR(this, "resetMargins");
          let t10 = this, e10 = t10.options.chart, i10 = e10.plotBorderWidth || 0, s10 = i10 / 2;
          ["margin", "spacing"].forEach(function(i11) {
            let s11 = e10[i11], o10 = aH(s11) ? s11 : [s11, s11, s11, s11];
            ["Top", "Right", "Bottom", "Left"].forEach(function(s12, r10) {
              t10[i11][r10] = aU(e10[i11 + s12], o10[r10]);
            });
          }), ak.forEach(function(e11, i11) {
            t10[e11] = aU(t10.margin[i11], t10.spacing[i11]);
          }), t10.axisOffset = [0, 0, 0, 0], t10.clipOffset = [s10, s10, s10, s10], t10.plotBorderWidth = i10;
        }
        drawChartBox() {
          let t10 = this.options.chart, e10 = this.renderer, i10 = this.chartWidth, s10 = this.chartHeight, o10 = this.styledMode, r10 = this.plotBGImage, a10 = t10.backgroundColor, n10 = t10.plotBackgroundColor, h10 = t10.plotBackgroundImage, l10 = this.plotLeft, d10 = this.plotTop, c10 = this.plotWidth, p10 = this.plotHeight, u2 = this.plotBox, g2 = this.clipRect, f2 = this.clipBox, m2 = this.chartBackground, x2 = this.plotBackground, y2 = this.plotBorder, b2, v2, k2, M2 = "animate";
          m2 || (this.chartBackground = m2 = e10.rect().addClass("highcharts-background").add(), M2 = "attr"), o10 ? b2 = v2 = m2.strokeWidth() : (v2 = (b2 = t10.borderWidth || 0) + (t10.shadow ? 8 : 0), k2 = {
            fill: a10 || "none"
          }, (b2 || m2["stroke-width"]) && (k2.stroke = t10.borderColor, k2["stroke-width"] = b2), m2.attr(k2).shadow(t10.shadow)), m2[M2]({
            x: v2 / 2,
            y: v2 / 2,
            width: i10 - v2 - b2 % 2,
            height: s10 - v2 - b2 % 2,
            r: t10.borderRadius
          }), M2 = "animate", x2 || (M2 = "attr", this.plotBackground = x2 = e10.rect().addClass("highcharts-plot-background").add()), x2[M2](u2), !o10 && (x2.attr({
            fill: n10 || "none"
          }).shadow(t10.plotShadow), h10 && (r10 ? (h10 !== r10.attr("href") && r10.attr("href", h10), r10.animate(u2)) : this.plotBGImage = e10.image(h10, l10, d10, c10, p10).add())), g2 ? g2.animate({
            width: f2.width,
            height: f2.height
          }) : this.clipRect = e10.clipRect(f2), M2 = "animate", y2 || (M2 = "attr", this.plotBorder = y2 = e10.rect().addClass("highcharts-plot-border").attr({
            zIndex: 1
          }).add()), o10 || y2.attr({
            stroke: t10.plotBorderColor,
            "stroke-width": t10.plotBorderWidth || 0,
            fill: "none"
          }), y2[M2](y2.crisp({
            x: l10,
            y: d10,
            width: c10,
            height: p10
          }, -y2.strokeWidth())), this.isDirtyBox = false, aR(this, "afterDrawChartBox");
        }
        propFromSeries() {
          let t10, e10, i10;
          let s10 = this, o10 = s10.options.chart, r10 = s10.options.series;
          ["inverted", "angular", "polar"].forEach(function(a10) {
            for (e10 = aS[o10.type], i10 = o10[a10] || e10 && e10.prototype[a10], t10 = r10 && r10.length; !i10 && t10--; ) (e10 = aS[r10[t10].type]) && e10.prototype[a10] && (i10 = true);
            s10[a10] = i10;
          });
        }
        linkSeries(t10) {
          let e10 = this, i10 = e10.series;
          i10.forEach(function(t11) {
            t11.linkedSeries.length = 0;
          }), i10.forEach(function(t11) {
            let {
              linkedTo: i11
            } = t11.options;
            if (aF(i11)) {
              let s10;
              (s10 = ":previous" === i11 ? e10.series[t11.index - 1] : e10.get(i11)) && s10.linkedParent !== t11 && (s10.linkedSeries.push(t11), t11.linkedParent = s10, s10.enabledDataSorting && t11.setDataSortingOptions(), t11.visible = aU(t11.options.visible, s10.options.visible, t11.visible));
            }
          }), aR(this, "afterLinkSeries", {
            isUpdating: t10
          });
        }
        renderSeries() {
          this.series.forEach(function(t10) {
            t10.translate(), t10.render();
          });
        }
        render() {
          let t10 = this.axes, e10 = this.colorAxis, i10 = this.renderer, s10 = this.options.chart.axisLayoutRuns || 2, o10 = (t11) => {
            t11.forEach((t12) => {
              t12.visible && t12.render();
            });
          }, r10 = 0, a10 = true, n10, h10 = 0;
          for (let e11 of (this.setTitle(), aR(this, "beforeMargins"), this.getStacks?.(), this.getMargins(true), this.setChartSize(), t10)) {
            let {
              options: t11
            } = e11, {
              labels: i11
            } = t11;
            if (this.hasCartesianSeries && e11.horiz && e11.visible && i11.enabled && e11.series.length && "colorAxis" !== e11.coll && !this.polar) {
              r10 = t11.tickLength, e11.createGroups();
              let s11 = new sm(e11, 0, "", true), o11 = s11.createLabel("x", i11);
              if (s11.destroy(), o11 && aU(i11.reserveSpace, !aX(t11.crossing)) && (r10 = o11.getBBox().height + i11.distance + Math.max(t11.offset || 0, 0)), r10) {
                o11?.destroy();
                break;
              }
            }
          }
          for (this.plotHeight = Math.max(this.plotHeight - r10, 0); (a10 || n10 || s10 > 1) && h10 < s10; ) {
            let e11 = this.plotWidth, i11 = this.plotHeight;
            for (let e12 of t10) 0 === h10 ? e12.setScale() : (e12.horiz && a10 || !e12.horiz && n10) && e12.setTickInterval(true);
            0 === h10 ? this.getAxisMargins() : this.getMargins(), a10 = e11 / this.plotWidth > (h10 ? 1 : 1.1), n10 = i11 / this.plotHeight > (h10 ? 1 : 1.05), h10++;
          }
          this.drawChartBox(), this.hasCartesianSeries ? o10(t10) : e10 && e10.length && o10(e10), this.seriesGroup || (this.seriesGroup = i10.g("series-group").attr({
            zIndex: 3
          }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = true;
        }
        addCredits(t10) {
          let e10 = this, i10 = aY(true, this.options.credits, t10);
          i10.enabled && !this.credits && (this.credits = this.renderer.text(i10.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
            i10.href && (aw.location.href = i10.href);
          }).attr({
            align: i10.position.align,
            zIndex: 8
          }), e10.styledMode || this.credits.css(i10.style), this.credits.add().align(i10.position), this.credits.update = function(t11) {
            e10.credits = e10.credits.destroy(), e10.addCredits(t11);
          });
        }
        destroy() {
          let t10;
          let e10 = this, i10 = e10.axes, s10 = e10.series, o10 = e10.container, r10 = o10 && o10.parentNode;
          for (aR(e10, "destroy"), e10.renderer.forExport ? aD(ab, e10) : ab[e10.index] = void 0, L.chartCount--, e10.renderTo.removeAttribute("data-highcharts-chart"), a$(e10), t10 = i10.length; t10--; ) i10[t10] = i10[t10].destroy();
          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t10 = s10.length; t10--; ) s10[t10] = s10[t10].destroy();
          ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(t11) {
            let i11 = e10[t11];
            i11 && i11.destroy && (e10[t11] = i11.destroy());
          }), o10 && (o10.innerHTML = t4.emptyHTML, a$(o10), r10 && aL(o10)), aj(e10, function(t11, i11) {
            delete e10[i11];
          });
        }
        firstRender() {
          let t10 = this, e10 = t10.options;
          t10.getContainer(), t10.resetMargins(), t10.setChartSize(), t10.propFromSeries(), t10.createAxes();
          let i10 = aG(e10.series) ? e10.series : [];
          e10.series = [], i10.forEach(function(e11) {
            t10.initSeries(e11);
          }), t10.linkSeries(), t10.setSortedData(), aR(t10, "beforeRender"), t10.render(), t10.pointer?.getChartPosition(), t10.renderer.imgCount || t10.hasLoaded || t10.onload(), t10.temporaryDisplay(true);
        }
        onload() {
          this.callbacks.concat([this.callback]).forEach(function(t10) {
            t10 && void 0 !== this.index && t10.apply(this, [this]);
          }, this), aR(this, "load"), aR(this, "render"), aO(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = true;
        }
        warnIfA11yModuleNotLoaded() {
          let {
            options: t10,
            title: e10
          } = this;
          !t10 || this.accessibility || (this.renderer.boxWrapper.attr({
            role: "img",
            "aria-label": (e10 && e10.element.textContent || "").replace(/</g, "&lt;")
          }), t10.accessibility && false === t10.accessibility.enabled || aB('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this));
        }
        addSeries(t10, e10, i10) {
          let s10;
          let o10 = this;
          return t10 && (e10 = aU(e10, true), aR(o10, "addSeries", {
            options: t10
          }, function() {
            s10 = o10.initSeries(t10), o10.isDirtyLegend = true, o10.linkSeries(), s10.enabledDataSorting && s10.setData(t10.data, false), aR(o10, "afterAddSeries", {
              series: s10
            }), e10 && o10.redraw(i10);
          })), s10;
        }
        addAxis(t10, e10, i10, s10) {
          return this.createAxis(e10 ? "xAxis" : "yAxis", {
            axis: t10,
            redraw: i10,
            animation: s10
          });
        }
        addColorAxis(t10, e10, i10) {
          return this.createAxis("colorAxis", {
            axis: t10,
            redraw: e10,
            animation: i10
          });
        }
        createAxis(t10, e10) {
          let i10 = new s_(this, e10.axis, t10);
          return aU(e10.redraw, true) && this.redraw(e10.animation), i10;
        }
        showLoading(t10) {
          let e10 = this, i10 = e10.options, s10 = i10.loading, o10 = function() {
            r10 && aP(r10, {
              left: e10.plotLeft + "px",
              top: e10.plotTop + "px",
              width: e10.plotWidth + "px",
              height: e10.plotHeight + "px"
            });
          }, r10 = e10.loadingDiv, a10 = e10.loadingSpan;
          r10 || (e10.loadingDiv = r10 = aC("div", {
            className: "highcharts-loading highcharts-loading-hidden"
          }, null, e10.container)), a10 || (e10.loadingSpan = a10 = aC("span", {
            className: "highcharts-loading-inner"
          }, null, r10), aA(e10, "redraw", o10)), r10.className = "highcharts-loading", t4.setElementHTML(a10, aU(t10, i10.lang.loading, "")), e10.styledMode || (aP(r10, aI(s10.style, {
            zIndex: 10
          })), aP(a10, s10.labelStyle), e10.loadingShown || (aP(r10, {
            opacity: 0,
            display: ""
          }), au(r10, {
            opacity: s10.style.opacity || 0.5
          }, {
            duration: s10.showDuration || 0
          }))), e10.loadingShown = true, o10();
        }
        hideLoading() {
          let t10 = this.options, e10 = this.loadingDiv;
          e10 && (e10.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || au(e10, {
            opacity: 0
          }, {
            duration: t10.loading.hideDuration || 100,
            complete: function() {
              aP(e10, {
                display: "none"
              });
            }
          })), this.loadingShown = false;
        }
        update(t10, e10, i10, s10) {
          let o10, r10, a10;
          let n10 = this, h10 = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }, l10 = t10.isResponsiveOptions, d10 = [];
          aR(n10, "update", {
            options: t10
          }), l10 || n10.setResponsive(false, true), t10 = aE(t10, n10.options), n10.userOptions = aY(n10.userOptions, t10);
          let c10 = t10.chart;
          c10 && (aY(true, n10.options.chart, c10), this.setZoomOptions(), "className" in c10 && n10.setClassName(c10.className), ("inverted" in c10 || "polar" in c10 || "type" in c10) && (n10.propFromSeries(), o10 = true), "alignTicks" in c10 && (o10 = true), "events" in c10 && ay(this, c10), aj(c10, function(t11, e11) {
            -1 !== n10.propsRequireUpdateSeries.indexOf("chart." + e11) && (r10 = true), -1 !== n10.propsRequireDirtyBox.indexOf(e11) && (n10.isDirtyBox = true), -1 === n10.propsRequireReflow.indexOf(e11) || (n10.isDirtyBox = true, l10 || (a10 = true));
          }), !n10.styledMode && c10.style && n10.renderer.setStyle(n10.options.chart.style || {})), !n10.styledMode && t10.colors && (this.options.colors = t10.colors), aj(t10, function(e11, i11) {
            n10[i11] && "function" == typeof n10[i11].update ? n10[i11].update(e11, false) : "function" == typeof n10[h10[i11]] ? n10[h10[i11]](e11) : "colors" !== i11 && -1 === n10.collectionsWithUpdate.indexOf(i11) && aY(true, n10.options[i11], t10[i11]), "chart" !== i11 && -1 !== n10.propsRequireUpdateSeries.indexOf(i11) && (r10 = true);
          }), this.collectionsWithUpdate.forEach(function(e11) {
            t10[e11] && (aZ(t10[e11]).forEach(function(t11, s11) {
              let o11;
              let r11 = aO(t11.id);
              r11 && (o11 = n10.get(t11.id)), !o11 && n10[e11] && (o11 = n10[e11][aU(t11.index, s11)]) && (r11 && aO(o11.options.id) || o11.options.isInternal) && (o11 = void 0), o11 && o11.coll === e11 && (o11.update(t11, false), i10 && (o11.touched = true)), !o11 && i10 && n10.collectionsWithInit[e11] && (n10.collectionsWithInit[e11][0].apply(n10, [t11].concat(n10.collectionsWithInit[e11][1] || []).concat([false])).touched = true);
            }), i10 && n10[e11].forEach(function(t11) {
              t11.touched || t11.options.isInternal ? delete t11.touched : d10.push(t11);
            }));
          }), d10.forEach(function(t11) {
            t11.chart && t11.remove && t11.remove(false);
          }), o10 && n10.axes.forEach(function(t11) {
            t11.update({}, false);
          }), r10 && n10.getSeriesOrderByLinks().forEach(function(t11) {
            t11.chart && t11.update({}, false);
          }, this);
          let p10 = c10 && c10.width, u2 = c10 && (aF(c10.height) ? a_(c10.height, p10 || n10.chartWidth) : c10.height);
          a10 || aX(p10) && p10 !== n10.chartWidth || aX(u2) && u2 !== n10.chartHeight ? n10.setSize(p10, u2, s10) : aU(e10, true) && n10.redraw(s10), aR(n10, "afterUpdate", {
            options: t10,
            redraw: e10,
            animation: s10
          });
        }
        setSubtitle(t10, e10) {
          this.applyDescription("subtitle", t10), this.layOutTitles(e10);
        }
        setCaption(t10, e10) {
          this.applyDescription("caption", t10), this.layOutTitles(e10);
        }
        showResetZoom() {
          let t10 = this, e10 = am.lang, i10 = t10.zooming.resetButton, s10 = i10.theme, o10 = "chart" === i10.relativeTo || "spacingBox" === i10.relativeTo ? null : "plotBox";
          function r10() {
            t10.zoomOut();
          }
          aR(this, "beforeShowResetZoom", null, function() {
            t10.resetZoomButton = t10.renderer.button(e10.resetZoom, null, null, r10, s10).attr({
              align: i10.position.align,
              title: e10.resetZoomTitle
            }).addClass("highcharts-reset-zoom").add().align(i10.position, false, o10);
          }), aR(this, "afterShowResetZoom");
        }
        zoomOut() {
          aR(this, "selection", {
            resetSelection: true
          }, () => this.transform({
            reset: true,
            trigger: "zoom"
          }));
        }
        pan(t10, e10) {
          let i10 = this, s10 = "object" == typeof e10 ? e10 : {
            enabled: e10,
            type: "x"
          }, o10 = s10.type, r10 = o10 && i10[{
            x: "xAxis",
            xy: "axes",
            y: "yAxis"
          }[o10]].filter((t11) => t11.options.panningEnabled && !t11.options.isInternal), a10 = i10.options.chart;
          a10?.panning && (a10.panning = s10), aR(this, "pan", {
            originalEvent: t10
          }, () => {
            i10.transform({
              axes: r10,
              event: t10,
              to: {
                x: t10.chartX - (i10.mouseDownX || 0),
                y: t10.chartY - (i10.mouseDownY || 0)
              },
              trigger: "pan"
            }), aP(i10.container, {
              cursor: "move"
            });
          });
        }
        transform(t10) {
          let {
            axes: e10 = this.axes,
            event: i10,
            from: s10 = {},
            reset: o10,
            selection: r10,
            to: a10 = {},
            trigger: n10
          } = t10, {
            inverted: h10,
            time: l10
          } = this, d10 = false, c10, p10;
          for (let t11 of (this.hoverPoints?.forEach((t12) => t12.setState()), e10)) {
            let {
              horiz: e11,
              len: u2,
              minPointOffset: g2 = 0,
              options: f2,
              reversed: m2
            } = t11, x2 = e11 ? "width" : "height", y2 = e11 ? "x" : "y", b2 = aU(a10[x2], t11.len), v2 = aU(s10[x2], t11.len), k2 = 10 > Math.abs(b2) ? 1 : b2 / v2, M2 = (s10[y2] || 0) + v2 / 2 - t11.pos, w2 = M2 - ((a10[y2] ?? t11.pos) + b2 / 2 - t11.pos) / k2, S2 = m2 && !h10 || !m2 && h10 ? -1 : 1;
            if (!o10 && (M2 < 0 || M2 > t11.len)) continue;
            let A2 = t11.toValue(w2, true) + (r10 || t11.isOrdinal ? 0 : g2 * S2), T2 = t11.toValue(w2 + u2 / k2, true) - (r10 || t11.isOrdinal ? 0 : g2 * S2 || 0), C2 = t11.allExtremes;
            if (A2 > T2 && ([A2, T2] = [T2, A2]), 1 === k2 && !o10 && "yAxis" === t11.coll && !C2) {
              for (let e12 of t11.series) {
                let t12 = e12.getExtremes(e12.getProcessedData(true).modified.getColumn("y") || [], true);
                C2 ?? (C2 = {
                  dataMin: Number.MAX_VALUE,
                  dataMax: -Number.MAX_VALUE
                }), aX(t12.dataMin) && aX(t12.dataMax) && (C2.dataMin = Math.min(t12.dataMin, C2.dataMin), C2.dataMax = Math.max(t12.dataMax, C2.dataMax));
              }
              t11.allExtremes = C2;
            }
            let {
              dataMin: P2,
              dataMax: O2,
              min: E2,
              max: L2
            } = aI(t11.getExtremes(), C2 || {}), D2 = l10.parse(f2.min), B2 = l10.parse(f2.max), I2 = P2 ?? D2, z2 = O2 ?? B2, R2 = T2 - A2, N2 = t11.categories ? 0 : Math.min(R2, z2 - I2), W2 = I2 - N2 * (aO(D2) ? 0 : f2.minPadding), G2 = z2 + N2 * (aO(B2) ? 0 : f2.maxPadding), X2 = t11.allowZoomOutside || 1 === k2 || "zoom" !== n10 && k2 > 1, H2 = Math.min(D2 ?? W2, W2, X2 ? E2 : W2), F2 = Math.max(B2 ?? G2, G2, X2 ? L2 : G2);
            (!t11.isOrdinal || t11.options.overscroll || 1 !== k2 || o10) && (A2 < H2 && (A2 = H2, k2 >= 1 && (T2 = A2 + R2)), T2 > F2 && (T2 = F2, k2 >= 1 && (A2 = T2 - R2)), (o10 || t11.series.length && (A2 !== E2 || T2 !== L2) && A2 >= H2 && T2 <= F2) && (r10 ? r10[t11.coll].push({
              axis: t11,
              min: A2,
              max: T2
            }) : (t11.isPanning = "zoom" !== n10, t11.isPanning && (p10 = true), t11.setExtremes(o10 ? void 0 : A2, o10 ? void 0 : T2, false, false, {
              move: w2,
              trigger: n10,
              scale: k2
            }), !o10 && (A2 > H2 || T2 < F2) && "mousewheel" !== n10 && (c10 = true)), d10 = true), i10 && (this[e11 ? "mouseDownX" : "mouseDownY"] = i10[e11 ? "chartX" : "chartY"]));
          }
          return d10 && (r10 ? aR(this, "selection", r10, () => {
            delete t10.selection, t10.trigger = "zoom", this.transform(t10);
          }) : (!c10 || p10 || this.resetZoomButton ? !c10 && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw("zoom" === n10 && (this.options.chart.animation ?? this.pointCount < 100)))), d10;
        }
      }
      aI(aJ.prototype, {
        callbacks: [],
        collectionsWithInit: {
          xAxis: [aJ.prototype.addAxis, [true]],
          yAxis: [aJ.prototype.addAxis, [false]],
          series: [aJ.prototype.addSeries]
        },
        collectionsWithUpdate: ["xAxis", "yAxis", "series"],
        propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],
        propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],
        propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]
      });
      let aQ = aJ, {
        stop: a0
      } = t_, {
        composed: a1
      } = L, {
        addEvent: a2,
        createElement: a3,
        css: a5,
        defined: a6,
        erase: a9,
        merge: a4,
        pushUnique: a8
      } = ti;
      function a7() {
        let t10 = this.scrollablePlotArea;
        (this.scrollablePixelsX || this.scrollablePixelsY) && !t10 && (this.scrollablePlotArea = t10 = new ne(this)), t10?.applyFixed();
      }
      function nt() {
        this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = true);
      }
      class ne {
        static compose(t10, e10, i10) {
          a8(a1, this.compose) && (a2(t10, "afterInit", nt), a2(e10, "afterSetChartSize", (t11) => this.afterSetSize(t11.target, t11)), a2(e10, "render", a7), a2(i10, "show", nt));
        }
        static afterSetSize(t10, e10) {
          let i10, s10, o10;
          let {
            minWidth: r10,
            minHeight: a10
          } = t10.options.chart.scrollablePlotArea || {}, {
            clipBox: n10,
            plotBox: h10,
            inverted: l10,
            renderer: d10
          } = t10;
          if (!d10.forExport && (r10 ? (t10.scrollablePixelsX = i10 = Math.max(0, r10 - t10.chartWidth), i10 && (t10.scrollablePlotBox = a4(t10.plotBox), h10.width = t10.plotWidth += i10, n10[l10 ? "height" : "width"] += i10, o10 = true)) : a10 && (t10.scrollablePixelsY = s10 = Math.max(0, a10 - t10.chartHeight), a6(s10) && (t10.scrollablePlotBox = a4(t10.plotBox), h10.height = t10.plotHeight += s10, n10[l10 ? "width" : "height"] += s10, o10 = false)), a6(o10) && !e10.skipAxes)) for (let e11 of t10.axes) (e11.horiz === o10 || t10.hasParallelCoordinates && "yAxis" === e11.coll) && (e11.setAxisSize(), e11.setAxisTranslation());
        }
        constructor(t10) {
          let e10;
          let i10 = t10.options.chart, s10 = ef.getRendererType(), o10 = i10.scrollablePlotArea || {}, r10 = this.moveFixedElements.bind(this), a10 = {
            WebkitOverflowScrolling: "touch",
            overflowX: "hidden",
            overflowY: "hidden"
          };
          t10.scrollablePixelsX && (a10.overflowX = "auto"), t10.scrollablePixelsY && (a10.overflowY = "auto"), this.chart = t10;
          let n10 = this.parentDiv = a3("div", {
            className: "highcharts-scrolling-parent"
          }, {
            position: "relative"
          }, t10.renderTo), h10 = this.scrollingContainer = a3("div", {
            className: "highcharts-scrolling"
          }, a10, n10), l10 = this.innerContainer = a3("div", {
            className: "highcharts-inner-container"
          }, void 0, h10), d10 = this.fixedDiv = a3("div", {
            className: "highcharts-fixed"
          }, {
            position: "absolute",
            overflow: "hidden",
            pointerEvents: "none",
            zIndex: (i10.style?.zIndex || 0) + 2,
            top: 0
          }, void 0, true), c10 = this.fixedRenderer = new s10(d10, t10.chartWidth, t10.chartHeight, i10.style);
          this.mask = c10.path().attr({
            fill: i10.backgroundColor || "#fff",
            "fill-opacity": o10.opacity ?? 0.85,
            zIndex: -1
          }).addClass("highcharts-scrollable-mask").add(), h10.parentNode.insertBefore(d10, h10), a5(t10.renderTo, {
            overflow: "visible"
          }), a2(t10, "afterShowResetZoom", r10), a2(t10, "afterApplyDrilldown", r10), a2(t10, "afterLayOutTitles", r10), a2(h10, "scroll", () => {
            let {
              pointer: i11,
              hoverPoint: s11
            } = t10;
            i11 && (delete i11.chartPosition, s11 && (e10 = s11), i11.runPointActions(void 0, e10, true));
          }), l10.appendChild(t10.container);
        }
        applyFixed() {
          let {
            chart: t10,
            fixedRenderer: e10,
            isDirty: i10,
            scrollingContainer: s10
          } = this, {
            axisOffset: o10,
            chartWidth: r10,
            chartHeight: a10,
            container: n10,
            plotHeight: h10,
            plotLeft: l10,
            plotTop: d10,
            plotWidth: c10,
            scrollablePixelsX: p10 = 0,
            scrollablePixelsY: u2 = 0
          } = t10, {
            scrollPositionX: g2 = 0,
            scrollPositionY: f2 = 0
          } = t10.options.chart.scrollablePlotArea || {}, m2 = r10 + p10, x2 = a10 + u2;
          e10.setSize(r10, a10), (i10 ?? true) && (this.isDirty = false, this.moveFixedElements()), a0(t10.container), a5(n10, {
            width: `${m2}px`,
            height: `${x2}px`
          }), t10.renderer.boxWrapper.attr({
            width: m2,
            height: x2,
            viewBox: [0, 0, m2, x2].join(" ")
          }), t10.chartBackground?.attr({
            width: m2,
            height: x2
          }), a5(s10, {
            width: `${r10}px`,
            height: `${a10}px`
          }), a6(i10) || (s10.scrollLeft = p10 * g2, s10.scrollTop = u2 * f2);
          let y2 = d10 - o10[0] - 1, b2 = l10 - o10[3] - 1, v2 = d10 + h10 + o10[2] + 1, k2 = l10 + c10 + o10[1] + 1, M2 = l10 + c10 - p10, w2 = d10 + h10 - u2, S2 = [["M", 0, 0]];
          p10 ? S2 = [["M", 0, y2], ["L", l10 - 1, y2], ["L", l10 - 1, v2], ["L", 0, v2], ["Z"], ["M", M2, y2], ["L", r10, y2], ["L", r10, v2], ["L", M2, v2], ["Z"]] : u2 && (S2 = [["M", b2, 0], ["L", b2, d10 - 1], ["L", k2, d10 - 1], ["L", k2, 0], ["Z"], ["M", b2, w2], ["L", b2, a10], ["L", k2, a10], ["L", k2, w2], ["Z"]]), "adjustHeight" !== t10.redrawTrigger && this.mask.attr({
            d: S2
          });
        }
        moveFixedElements() {
          let t10;
          let {
            container: e10,
            inverted: i10,
            scrollablePixelsX: s10,
            scrollablePixelsY: o10
          } = this.chart, r10 = this.fixedRenderer, a10 = ne.fixedSelectors;
          if (s10 && !i10 ? t10 = ".highcharts-yaxis" : s10 && i10 ? t10 = ".highcharts-xaxis" : o10 && !i10 ? t10 = ".highcharts-xaxis" : o10 && i10 && (t10 = ".highcharts-yaxis"), t10 && !(this.chart.hasParallelCoordinates && ".highcharts-yaxis" === t10)) for (let e11 of [`${t10}:not(.highcharts-radial-axis)`, `${t10}-labels:not(.highcharts-radial-axis-labels)`]) a8(a10, e11);
          else for (let t11 of [".highcharts-xaxis", ".highcharts-yaxis"]) for (let e11 of [`${t11}:not(.highcharts-radial-axis)`, `${t11}-labels:not(.highcharts-radial-axis-labels)`]) a9(a10, e11);
          for (let t11 of a10) [].forEach.call(e10.querySelectorAll(t11), (t12) => {
            (t12.namespaceURI === r10.SVG_NS ? r10.box : r10.box.parentNode).appendChild(t12), t12.style.pointerEvents = "auto";
          });
        }
      }
      ne.fixedSelectors = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-drillup-button", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-range-selector-group", ".highcharts-reset-zoom", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];
      let {
        format: ni
      } = eg, {
        series: ns
      } = rv, {
        destroyObjectProperties: no,
        fireEvent: nr,
        getAlignFactor: na,
        isNumber: nn,
        pick: nh
      } = ti, nl = class {
        constructor(t10, e10, i10, s10, o10) {
          let r10 = t10.chart.inverted, a10 = t10.reversed;
          this.axis = t10;
          let n10 = this.isNegative = !!i10 != !!a10;
          this.options = e10 = e10 || {}, this.x = s10, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = false, this.stack = o10, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
            align: e10.align || (r10 ? n10 ? "left" : "right" : "center"),
            verticalAlign: e10.verticalAlign || (r10 ? "middle" : n10 ? "bottom" : "top"),
            y: e10.y,
            x: e10.x
          }, this.textAlign = e10.textAlign || (r10 ? n10 ? "right" : "left" : "center");
        }
        destroy() {
          no(this, this.axis);
        }
        render(t10) {
          let e10 = this.axis.chart, i10 = this.options, s10 = i10.format, o10 = s10 ? ni(s10, this, e10) : i10.formatter.call(this);
          if (this.label) this.label.attr({
            text: o10,
            visibility: "hidden"
          });
          else {
            this.label = e10.renderer.label(o10, null, void 0, i10.shape, void 0, void 0, i10.useHTML, false, "stack-labels");
            let s11 = {
              r: i10.borderRadius || 0,
              text: o10,
              padding: nh(i10.padding, 5),
              visibility: "hidden"
            };
            e10.styledMode || (s11.fill = i10.backgroundColor, s11.stroke = i10.borderColor, s11["stroke-width"] = i10.borderWidth, this.label.css(i10.style || {})), this.label.attr(s11), this.label.added || this.label.add(t10);
          }
          this.label.labelrank = e10.plotSizeY, nr(this, "afterRender");
        }
        setOffset(t10, e10, i10, s10, o10, r10) {
          let {
            alignOptions: a10,
            axis: n10,
            label: h10,
            options: l10,
            textAlign: d10
          } = this, c10 = n10.chart, p10 = this.getStackBox({
            xOffset: t10,
            width: e10,
            boxBottom: i10,
            boxTop: s10,
            defaultX: o10,
            xAxis: r10
          }), {
            verticalAlign: u2
          } = a10;
          if (h10 && p10) {
            let t11 = h10.getBBox(void 0, 0), e11 = h10.padding, i11 = "justify" === nh(l10.overflow, "justify"), s11;
            a10.x = l10.x || 0, a10.y = l10.y || 0;
            let {
              x: o11,
              y: r11
            } = this.adjustStackPosition({
              labelBox: t11,
              verticalAlign: u2,
              textAlign: d10
            });
            p10.x -= o11, p10.y -= r11, h10.align(a10, false, p10), (s11 = c10.isInsidePlot(h10.alignAttr.x + a10.x + o11, h10.alignAttr.y + a10.y + r11)) || (i11 = false), i11 && ns.prototype.justifyDataLabel.call(n10, h10, a10, h10.alignAttr, t11, p10), h10.attr({
              x: h10.alignAttr.x,
              y: h10.alignAttr.y,
              rotation: l10.rotation,
              rotationOriginX: t11.width * na(l10.textAlign || "center"),
              rotationOriginY: t11.height / 2
            }), nh(!i11 && l10.crop, true) && (s11 = nn(h10.x) && nn(h10.y) && c10.isInsidePlot(h10.x - e11 + (h10.width || 0), h10.y) && c10.isInsidePlot(h10.x + e11, h10.y)), h10[s11 ? "show" : "hide"]();
          }
          nr(this, "afterSetOffset", {
            xOffset: t10,
            width: e10
          });
        }
        adjustStackPosition({
          labelBox: t10,
          verticalAlign: e10,
          textAlign: i10
        }) {
          return {
            x: t10.width / 2 + t10.width / 2 * (2 * na(i10) - 1),
            y: t10.height / 2 * 2 * (1 - na(e10))
          };
        }
        getStackBox(t10) {
          let e10 = this.axis, i10 = e10.chart, {
            boxTop: s10,
            defaultX: o10,
            xOffset: r10,
            width: a10,
            boxBottom: n10
          } = t10, h10 = e10.stacking.usePercentage ? 100 : nh(s10, this.total, 0), l10 = e10.toPixels(h10), d10 = t10.xAxis || i10.xAxis[0], c10 = nh(o10, d10.translate(this.x)) + r10, p10 = Math.abs(l10 - e10.toPixels(n10 || nn(e10.min) && e10.logarithmic && e10.logarithmic.lin2log(e10.min) || 0)), u2 = i10.inverted, g2 = this.isNegative;
          return u2 ? {
            x: (g2 ? l10 : l10 - p10) - i10.plotLeft,
            y: d10.height - c10 - a10 + d10.top - i10.plotTop,
            width: p10,
            height: a10
          } : {
            x: c10 + d10.transB - i10.plotLeft,
            y: (g2 ? l10 - p10 : l10) - i10.plotTop,
            width: a10,
            height: p10
          };
        }
      }, {
        getDeferredAnimation: nd
      } = t_, {
        series: {
          prototype: nc
        }
      } = rv, {
        addEvent: np,
        correctFloat: nu,
        defined: ng,
        destroyObjectProperties: nf,
        fireEvent: nm,
        isNumber: nx,
        objectEach: ny,
        pick: nb
      } = ti;
      function nv() {
        let t10 = this.inverted;
        this.axes.forEach((t11) => {
          t11.stacking && t11.stacking.stacks && t11.hasVisibleSeries && (t11.stacking.oldStacks = t11.stacking.stacks);
        }), this.series.forEach((e10) => {
          let i10 = e10.xAxis && e10.xAxis.options || {};
          e10.options.stacking && e10.reserveSpace() && (e10.stackKey = [e10.type, nb(e10.options.stack, ""), t10 ? i10.top : i10.left, t10 ? i10.height : i10.width].join(","));
        });
      }
      function nk() {
        let t10 = this.stacking;
        if (t10) {
          let e10 = t10.stacks;
          ny(e10, (t11, i10) => {
            nf(t11), delete e10[i10];
          }), t10.stackTotalGroup?.destroy();
        }
      }
      function nM() {
        this.stacking || (this.stacking = new nP(this));
      }
      function nw(t10, e10, i10, s10) {
        return !ng(t10) || t10.x !== e10 || s10 && t10.stackKey !== s10 ? t10 = {
          x: e10,
          index: 0,
          key: s10,
          stackKey: s10
        } : t10.index++, t10.key = [i10, e10, t10.index].join(","), t10;
      }
      function nS() {
        let t10;
        let e10 = this, i10 = e10.yAxis, s10 = e10.stackKey || "", o10 = i10.stacking.stacks, r10 = e10.getColumn("x", true), a10 = e10.options.stacking, n10 = e10[a10 + "Stacker"];
        n10 && [s10, "-" + s10].forEach((i11) => {
          let s11 = r10.length, a11, h10, l10;
          for (; s11--; ) a11 = r10[s11], t10 = e10.getStackIndicator(t10, a11, e10.index, i11), h10 = o10[i11]?.[a11], (l10 = h10?.points[t10.key || ""]) && n10.call(e10, l10, h10, s11);
        });
      }
      function nA(t10, e10, i10) {
        let s10 = e10.total ? 100 / e10.total : 0;
        t10[0] = nu(t10[0] * s10), t10[1] = nu(t10[1] * s10), this.stackedYData[i10] = t10[1];
      }
      function nT(t10) {
        (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? nc.setStackedPoints.call(this, t10, "group") : t10.stacking.resetStacks());
      }
      function nC(t10, e10) {
        let i10, s10, o10, r10, a10, n10, h10;
        let l10 = e10 || this.options.stacking;
        if (!l10 || !this.reserveSpace() || ({
          group: "xAxis"
        }[l10] || "yAxis") !== t10.coll) return;
        let d10 = this.getColumn("x", true), c10 = this.getColumn(this.pointValKey || "y", true), p10 = [], u2 = c10.length, g2 = this.options, f2 = g2.threshold || 0, m2 = g2.startFromThreshold ? f2 : 0, x2 = g2.stack, y2 = e10 ? `${this.type},${l10}` : this.stackKey || "", b2 = "-" + y2, v2 = this.negStacks, k2 = t10.stacking, M2 = k2.stacks, w2 = k2.oldStacks;
        for (k2.stacksTouched += 1, h10 = 0; h10 < u2; h10++) {
          let e11 = d10[h10] || 0, u3 = c10[h10], g3 = nx(u3) && u3 || 0;
          n10 = (i10 = this.getStackIndicator(i10, e11, this.index)).key || "", M2[a10 = (s10 = v2 && g3 < (m2 ? 0 : f2)) ? b2 : y2] || (M2[a10] = {}), M2[a10][e11] || (w2[a10]?.[e11] ? (M2[a10][e11] = w2[a10][e11], M2[a10][e11].total = null) : M2[a10][e11] = new nl(t10, t10.options.stackLabels, !!s10, e11, x2)), o10 = M2[a10][e11], null !== u3 ? (o10.points[n10] = o10.points[this.index] = [nb(o10.cumulative, m2)], ng(o10.cumulative) || (o10.base = n10), o10.touched = k2.stacksTouched, i10.index > 0 && false === this.singleStacks && (o10.points[n10][0] = o10.points[this.index + "," + e11 + ",0"][0])) : (delete o10.points[n10], delete o10.points[this.index]);
          let S2 = o10.total || 0;
          "percent" === l10 ? (r10 = s10 ? y2 : b2, S2 = v2 && M2[r10]?.[e11] ? (r10 = M2[r10][e11]).total = Math.max(r10.total || 0, S2) + Math.abs(g3) : nu(S2 + Math.abs(g3))) : "group" === l10 ? nx(u3) && S2++ : S2 = nu(S2 + g3), "group" === l10 ? o10.cumulative = (S2 || 1) - 1 : o10.cumulative = nu(nb(o10.cumulative, m2) + g3), o10.total = S2, null !== u3 && (o10.points[n10].push(o10.cumulative), p10[h10] = o10.cumulative, o10.hasValidPoints = true);
        }
        "percent" === l10 && (k2.usePercentage = true), "group" !== l10 && (this.stackedYData = p10), k2.oldStacks = {};
      }
      class nP {
        constructor(t10) {
          this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t10;
        }
        buildStacks() {
          let t10, e10;
          let i10 = this.axis, s10 = i10.series, o10 = "xAxis" === i10.coll, r10 = i10.options.reversedStacks, a10 = s10.length;
          for (this.resetStacks(), this.usePercentage = false, e10 = a10; e10--; ) t10 = s10[r10 ? e10 : a10 - e10 - 1], o10 && t10.setGroupedPoints(i10), t10.setStackedPoints(i10);
          if (!o10) for (e10 = 0; e10 < a10; e10++) s10[e10].modifyStacks();
          nm(i10, "afterBuildStacks");
        }
        cleanStacks() {
          this.oldStacks && (this.stacks = this.oldStacks, ny(this.stacks, (t10) => {
            ny(t10, (t11) => {
              t11.cumulative = t11.total;
            });
          }));
        }
        resetStacks() {
          ny(this.stacks, (t10) => {
            ny(t10, (e10, i10) => {
              nx(e10.touched) && e10.touched < this.stacksTouched ? (e10.destroy(), delete t10[i10]) : (e10.total = null, e10.cumulative = null);
            });
          });
        }
        renderStackTotals() {
          let t10 = this.axis, e10 = t10.chart, i10 = e10.renderer, s10 = this.stacks, o10 = nd(e10, t10.options.stackLabels?.animation || false), r10 = this.stackTotalGroup = this.stackTotalGroup || i10.g("stack-labels").attr({
            zIndex: 6,
            opacity: 0
          }).add();
          r10.translate(e10.plotLeft, e10.plotTop), ny(s10, (t11) => {
            ny(t11, (t12) => {
              t12.render(r10);
            });
          }), r10.animate({
            opacity: 1
          }, o10);
        }
      }
      (m || (m = {})).compose = function(t10, e10, i10) {
        let s10 = e10.prototype, o10 = i10.prototype;
        s10.getStacks || (np(t10, "init", nM), np(t10, "destroy", nk), s10.getStacks = nv, o10.getStackIndicator = nw, o10.modifyStacks = nS, o10.percentStacker = nA, o10.setGroupedPoints = nT, o10.setStackedPoints = nC);
      };
      let nO = m, {
        defined: nE,
        merge: nL,
        isObject: nD
      } = ti;
      class nB extends rQ {
        drawGraph() {
          let t10 = this.options, e10 = (this.gappedPath || this.getGraphPath).call(this), i10 = this.chart.styledMode;
          [this, ...this.zones].forEach((s10, o10) => {
            let r10, a10 = s10.graph, n10 = a10 ? "animate" : "attr", h10 = s10.dashStyle || t10.dashStyle;
            a10 ? (a10.endX = this.preventGraphAnimation ? null : e10.xMap, a10.animate({
              d: e10
            })) : e10.length && (s10.graph = a10 = this.chart.renderer.path(e10).addClass("highcharts-graph" + (o10 ? ` highcharts-zone-graph-${o10 - 1} ` : " ") + (o10 && s10.className || "")).attr({
              zIndex: 1
            }).add(this.group)), a10 && !i10 && (r10 = {
              stroke: !o10 && t10.lineColor || s10.color || this.color || "#cccccc",
              "stroke-width": t10.lineWidth || 0,
              fill: this.fillGraph && this.color || "none"
            }, h10 ? r10.dashstyle = h10 : "square" !== t10.linecap && (r10["stroke-linecap"] = r10["stroke-linejoin"] = "round"), a10[n10](r10).shadow(t10.shadow && nL({
              filterUnits: "userSpaceOnUse"
            }, nD(t10.shadow) ? t10.shadow : {}))), a10 && (a10.startX = e10.xMap, a10.isArea = e10.isArea);
          });
        }
        getGraphPath(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = [], a10 = [], n10, h10 = o10.step, l10 = (t10 = t10 || s10.points).reversed;
          return l10 && t10.reverse(), (h10 = {
            right: 1,
            center: 2
          }[h10] || h10 && 3) && l10 && (h10 = 4 - h10), (t10 = this.getValidPoints(t10, false, !(o10.connectNulls && !e10 && !i10))).forEach(function(l11, d10) {
            let c10;
            let p10 = l11.plotX, u2 = l11.plotY, g2 = t10[d10 - 1], f2 = l11.isNull || "number" != typeof u2;
            (l11.leftCliff || g2 && g2.rightCliff) && !i10 && (n10 = true), f2 && !nE(e10) && d10 > 0 ? n10 = !o10.connectNulls : f2 && !e10 ? n10 = true : (0 === d10 || n10 ? c10 = [["M", l11.plotX, l11.plotY]] : s10.getPointSpline ? c10 = [s10.getPointSpline(t10, l11, d10)] : h10 ? (c10 = 1 === h10 ? [["L", g2.plotX, u2]] : 2 === h10 ? [["L", (g2.plotX + p10) / 2, g2.plotY], ["L", (g2.plotX + p10) / 2, u2]] : [["L", p10, g2.plotY]]).push(["L", p10, u2]) : c10 = [["L", p10, u2]], a10.push(l11.x), h10 && (a10.push(l11.x), 2 === h10 && a10.push(l11.x)), r10.push.apply(r10, c10), n10 = false);
          }), r10.xMap = a10, s10.graphPath = r10, r10;
        }
      }
      nB.defaultOptions = nL(rQ.defaultOptions, {
        legendSymbol: "lineMarker"
      }), rv.registerSeriesType("line", nB);
      let {
        seriesTypes: {
          line: nI
        }
      } = rv, {
        extend: nz,
        merge: nR,
        objectEach: nN,
        pick: nW
      } = ti;
      class nG extends nI {
        drawGraph() {
          this.areaPath = [], super.drawGraph.apply(this);
          let {
            areaPath: t10,
            options: e10
          } = this;
          [this, ...this.zones].forEach((i10, s10) => {
            let o10 = {}, r10 = i10.fillColor || e10.fillColor, a10 = i10.area, n10 = a10 ? "animate" : "attr";
            a10 ? (a10.endX = this.preventGraphAnimation ? null : t10.xMap, a10.animate({
              d: t10
            })) : (o10.zIndex = 0, (a10 = i10.area = this.chart.renderer.path(t10).addClass("highcharts-area" + (s10 ? ` highcharts-zone-area-${s10 - 1} ` : " ") + (s10 && i10.className || "")).add(this.group)).isArea = true), this.chart.styledMode || (o10.fill = r10 || i10.color || this.color, o10["fill-opacity"] = r10 ? 1 : e10.fillOpacity ?? 0.75, a10.css({
              pointerEvents: this.stickyTracking ? "none" : "auto"
            })), a10[n10](o10), a10.startX = t10.xMap, a10.shiftUnit = e10.step ? 2 : 1;
          });
        }
        getGraphPath(t10) {
          let e10, i10, s10;
          let o10 = nI.prototype.getGraphPath, r10 = this.options, a10 = r10.stacking, n10 = this.yAxis, h10 = [], l10 = [], d10 = this.index, c10 = n10.stacking.stacks[this.stackKey], p10 = r10.threshold, u2 = Math.round(n10.getThreshold(r10.threshold)), g2 = nW(r10.connectNulls, "percent" === a10), f2 = function(i11, s11, o11) {
            let r11 = t10[i11], g3 = a10 && c10[r11.x].points[d10], f3 = r11[o11 + "Null"] || 0, m3 = r11[o11 + "Cliff"] || 0, x3, y3, b3 = true;
            m3 || f3 ? (x3 = (f3 ? g3[0] : g3[1]) + m3, y3 = g3[0] + m3, b3 = !!f3) : !a10 && t10[s11] && t10[s11].isNull && (x3 = y3 = p10), void 0 !== x3 && (l10.push({
              plotX: e10,
              plotY: null === x3 ? u2 : n10.getThreshold(x3),
              isNull: b3,
              isCliff: true
            }), h10.push({
              plotX: e10,
              plotY: null === y3 ? u2 : n10.getThreshold(y3),
              doCurve: false
            }));
          };
          t10 = t10 || this.points, a10 && (t10 = this.getStackPoints(t10));
          for (let o11 = 0, r11 = t10.length; o11 < r11; ++o11) a10 || (t10[o11].leftCliff = t10[o11].rightCliff = t10[o11].leftNull = t10[o11].rightNull = void 0), i10 = t10[o11].isNull, e10 = nW(t10[o11].rectPlotX, t10[o11].plotX), s10 = a10 ? nW(t10[o11].yBottom, u2) : u2, i10 && !g2 || (g2 || f2(o11, o11 - 1, "left"), i10 && !a10 && g2 || (l10.push(t10[o11]), h10.push({
            x: o11,
            plotX: e10,
            plotY: s10
          })), g2 || f2(o11, o11 + 1, "right"));
          let m2 = o10.call(this, l10, true, true);
          h10.reversed = true;
          let x2 = o10.call(this, h10, true, true), y2 = x2[0];
          y2 && "M" === y2[0] && (x2[0] = ["L", y2[1], y2[2]]);
          let b2 = m2.concat(x2);
          b2.length && b2.push(["Z"]);
          let v2 = o10.call(this, l10, false, g2);
          return this.chart.series.length > 1 && a10 && l10.some((t11) => t11.isCliff) && (b2.hasStackedCliffs = v2.hasStackedCliffs = true), b2.xMap = m2.xMap, this.areaPath = b2, v2;
        }
        getStackPoints(t10) {
          let e10 = this, i10 = [], s10 = [], o10 = this.xAxis, r10 = this.yAxis, a10 = r10.stacking.stacks[this.stackKey], n10 = {}, h10 = r10.series, l10 = h10.length, d10 = r10.options.reversedStacks ? 1 : -1, c10 = h10.indexOf(e10);
          if (t10 = t10 || this.points, this.options.stacking) {
            for (let e11 = 0; e11 < t10.length; e11++) t10[e11].leftNull = t10[e11].rightNull = void 0, n10[t10[e11].x] = t10[e11];
            nN(a10, function(t11, e11) {
              null !== t11.total && s10.push(e11);
            }), s10.sort(function(t11, e11) {
              return t11 - e11;
            });
            let p10 = h10.map((t11) => t11.visible);
            s10.forEach(function(t11, u2) {
              let g2 = 0, f2, m2;
              if (n10[t11] && !n10[t11].isNull) i10.push(n10[t11]), [-1, 1].forEach(function(i11) {
                let o11 = 1 === i11 ? "rightNull" : "leftNull", r11 = a10[s10[u2 + i11]], g3 = 0;
                if (r11) {
                  let i12 = c10;
                  for (; i12 >= 0 && i12 < l10; ) {
                    let s11 = h10[i12].index;
                    !(f2 = r11.points[s11]) && (s11 === e10.index ? n10[t11][o11] = true : p10[i12] && (m2 = a10[t11].points[s11]) && (g3 -= m2[1] - m2[0])), i12 += d10;
                  }
                }
                n10[t11][1 === i11 ? "rightCliff" : "leftCliff"] = g3;
              });
              else {
                let e11 = c10;
                for (; e11 >= 0 && e11 < l10; ) {
                  let i11 = h10[e11].index;
                  if (f2 = a10[t11].points[i11]) {
                    g2 = f2[1];
                    break;
                  }
                  e11 += d10;
                }
                g2 = nW(g2, 0), g2 = r10.translate(g2, 0, 1, 0, 1), i10.push({
                  isNull: true,
                  plotX: o10.translate(t11, 0, 0, 0, 1),
                  x: t11,
                  plotY: g2,
                  yBottom: g2
                });
              }
            });
          }
          return i10;
        }
      }
      nG.defaultOptions = nR(nI.defaultOptions, {
        threshold: 0,
        legendSymbol: "areaMarker"
      }), nz(nG.prototype, {
        singleStacks: false
      }), rv.registerSeriesType("area", nG);
      let {
        line: nX
      } = rv.seriesTypes, {
        merge: nH,
        pick: nF
      } = ti;
      class nY extends nX {
        getPointSpline(t10, e10, i10) {
          let s10, o10, r10, a10;
          let n10 = e10.plotX || 0, h10 = e10.plotY || 0, l10 = t10[i10 - 1], d10 = t10[i10 + 1];
          function c10(t11) {
            return t11 && !t11.isNull && false !== t11.doCurve && !e10.isCliff;
          }
          if (c10(l10) && c10(d10)) {
            let t11 = l10.plotX || 0, i11 = l10.plotY || 0, c11 = d10.plotX || 0, p11 = d10.plotY || 0, u2 = 0;
            s10 = (1.5 * n10 + t11) / 2.5, o10 = (1.5 * h10 + i11) / 2.5, r10 = (1.5 * n10 + c11) / 2.5, a10 = (1.5 * h10 + p11) / 2.5, r10 !== s10 && (u2 = (a10 - o10) * (r10 - n10) / (r10 - s10) + h10 - a10), o10 += u2, a10 += u2, o10 > i11 && o10 > h10 ? (o10 = Math.max(i11, h10), a10 = 2 * h10 - o10) : o10 < i11 && o10 < h10 && (o10 = Math.min(i11, h10), a10 = 2 * h10 - o10), a10 > p11 && a10 > h10 ? (a10 = Math.max(p11, h10), o10 = 2 * h10 - a10) : a10 < p11 && a10 < h10 && (a10 = Math.min(p11, h10), o10 = 2 * h10 - a10), e10.rightContX = r10, e10.rightContY = a10, e10.controlPoints = {
              low: [s10, o10],
              high: [r10, a10]
            };
          }
          let p10 = ["C", nF(l10.rightContX, l10.plotX, 0), nF(l10.rightContY, l10.plotY, 0), nF(s10, n10, 0), nF(o10, h10, 0), n10, h10];
          return l10.rightContX = l10.rightContY = void 0, p10;
        }
      }
      nY.defaultOptions = nH(nX.defaultOptions), rv.registerSeriesType("spline", nY);
      let nj = nY, {
        area: nU,
        area: {
          prototype: nV
        }
      } = rv.seriesTypes, {
        extend: n_,
        merge: n$
      } = ti;
      class nZ extends nj {
      }
      nZ.defaultOptions = n$(nj.defaultOptions, nU.defaultOptions), n_(nZ.prototype, {
        getGraphPath: nV.getGraphPath,
        getStackPoints: nV.getStackPoints,
        drawGraph: nV.drawGraph
      }), rv.registerSeriesType("areaspline", nZ);
      let {
        animObject: nq
      } = t_, {
        parse: nK
      } = tL, {
        noop: nJ
      } = L, {
        clamp: nQ,
        crisp: n0,
        defined: n1,
        extend: n2,
        fireEvent: n3,
        isArray: n5,
        isNumber: n6,
        merge: n9,
        pick: n4,
        objectEach: n8
      } = ti;
      class n7 extends rQ {
        animate(t10) {
          let e10, i10;
          let s10 = this, o10 = this.yAxis, r10 = o10.pos, a10 = o10.reversed, n10 = s10.options, {
            clipOffset: h10,
            inverted: l10
          } = this.chart, d10 = {}, c10 = l10 ? "translateX" : "translateY";
          t10 && h10 ? (d10.scaleY = 1e-3, i10 = nQ(o10.toPixels(n10.threshold || 0), r10, r10 + o10.len), l10 ? (i10 += a10 ? -Math.floor(h10[0]) : Math.ceil(h10[2]), d10.translateX = i10 - o10.len) : (i10 += a10 ? Math.ceil(h10[0]) : -Math.floor(h10[2]), d10.translateY = i10), s10.clipBox && s10.setClip(), s10.group.attr(d10)) : (e10 = Number(s10.group.attr(c10)), s10.group.animate({
            scaleY: 1
          }, n2(nq(s10.options.animation), {
            step: function(t11, i11) {
              s10.group && (d10[c10] = e10 + i11.pos * (r10 - e10), s10.group.attr(d10));
            }
          })));
        }
        init(t10, e10) {
          super.init.apply(this, arguments);
          let i10 = this;
          (t10 = i10.chart).hasRendered && t10.series.forEach(function(t11) {
            t11.type === i10.type && (t11.isDirty = true);
          });
        }
        getColumnMetrics() {
          let t10 = this, e10 = t10.options, i10 = t10.xAxis, s10 = t10.yAxis, o10 = i10.options.reversedStacks, r10 = i10.reversed && !o10 || !i10.reversed && o10, a10 = {}, n10, h10 = 0;
          false === e10.grouping ? h10 = 1 : t10.chart.series.forEach(function(e11) {
            let i11;
            let o11 = e11.yAxis, r11 = e11.options;
            e11.type === t10.type && e11.reserveSpace() && s10.len === o11.len && s10.pos === o11.pos && (r11.stacking && "group" !== r11.stacking ? (void 0 === a10[n10 = e11.stackKey] && (a10[n10] = h10++), i11 = a10[n10]) : false !== r11.grouping && (i11 = h10++), e11.columnIndex = i11);
          });
          let l10 = Math.min(Math.abs(i10.transA) * (!i10.brokenAxis?.hasBreaks && i10.ordinal?.slope || e10.pointRange || i10.closestPointRange || i10.tickInterval || 1), i10.len), d10 = l10 * e10.groupPadding, c10 = (l10 - 2 * d10) / (h10 || 1), p10 = Math.min(e10.maxPointWidth || i10.len, n4(e10.pointWidth, c10 * (1 - 2 * e10.pointPadding))), u2 = (t10.columnIndex || 0) + (r10 ? 1 : 0);
          return t10.columnMetrics = {
            width: p10,
            offset: (c10 - p10) / 2 + (d10 + u2 * c10 - l10 / 2) * (r10 ? -1 : 1),
            paddedWidth: c10,
            columnCount: h10
          }, t10.columnMetrics;
        }
        crispCol(t10, e10, i10, s10) {
          let o10 = this.borderWidth, r10 = this.chart.inverted;
          return s10 = n0(e10 + s10, o10, r10) - (e10 = n0(e10, o10, r10)), this.options.crisp && (i10 = n0(t10 + i10, o10) - (t10 = n0(t10, o10))), {
            x: t10,
            y: e10,
            width: i10,
            height: s10
          };
        }
        adjustForMissingColumns(t10, e10, i10, s10) {
          if (!i10.isNull && s10.columnCount > 1) {
            let o10 = this.xAxis.series.filter((t11) => t11.visible).map((t11) => t11.index), r10 = 0, a10 = 0;
            n8(this.xAxis.stacking?.stacks, (t11) => {
              let e11 = "number" == typeof i10.x ? t11[i10.x.toString()]?.points : void 0, s11 = e11?.[this.index], n11 = {};
              if (e11 && n5(s11)) {
                let t12 = this.index, i11 = Object.keys(e11).filter((t13) => !t13.match(",") && e11[t13] && e11[t13].length > 1).map(parseFloat).filter((t13) => -1 !== o10.indexOf(t13)).filter((e12) => {
                  let i12 = this.chart.series[e12].options, s12 = i12.stacking && i12.stack;
                  if (n1(s12)) {
                    if (n6(n11[s12])) return t12 === e12 && (t12 = n11[s12]), false;
                    n11[s12] = e12;
                  }
                  return true;
                }).sort((t13, e12) => e12 - t13);
                r10 = i11.indexOf(t12), a10 = i11.length;
              }
            }), r10 = this.xAxis.reversed ? a10 - 1 - r10 : r10;
            let n10 = (a10 - 1) * s10.paddedWidth + e10;
            t10 = (i10.plotX || 0) + n10 / 2 - e10 - r10 * s10.paddedWidth;
          }
          return t10;
        }
        translate() {
          let t10 = this, e10 = t10.chart, i10 = t10.options, s10 = t10.dense = t10.closestPointRange * t10.xAxis.transA < 2, o10 = t10.borderWidth = n4(i10.borderWidth, s10 ? 0 : 1), r10 = t10.xAxis, a10 = t10.yAxis, n10 = i10.threshold, h10 = n4(i10.minPointLength, 5), l10 = t10.getColumnMetrics(), d10 = l10.width, c10 = t10.pointXOffset = l10.offset, p10 = t10.dataMin, u2 = t10.dataMax, g2 = t10.translatedThreshold = a10.getThreshold(n10), f2 = t10.barW = Math.max(d10, 1 + 2 * o10);
          i10.pointPadding && i10.crisp && (f2 = Math.ceil(f2)), rQ.prototype.translate.apply(t10), t10.points.forEach(function(s11) {
            let o11 = n4(s11.yBottom, g2), m2 = 999 + Math.abs(o11), x2 = s11.plotX || 0, y2 = nQ(s11.plotY, -m2, a10.len + m2), b2, v2 = Math.min(y2, o11), k2 = Math.max(y2, o11) - v2, M2 = d10, w2 = x2 + c10, S2 = f2;
            h10 && Math.abs(k2) < h10 && (k2 = h10, b2 = !a10.reversed && !s11.negative || a10.reversed && s11.negative, n6(n10) && n6(u2) && s11.y === n10 && u2 <= n10 && (a10.min || 0) < n10 && (p10 !== u2 || (a10.max || 0) <= n10) && (b2 = !b2, s11.negative = !s11.negative), v2 = Math.abs(v2 - g2) > h10 ? o11 - h10 : g2 - (b2 ? h10 : 0)), n1(s11.options.pointWidth) && (w2 -= Math.round(((M2 = S2 = Math.ceil(s11.options.pointWidth)) - d10) / 2)), i10.centerInCategory && (w2 = t10.adjustForMissingColumns(w2, M2, s11, l10)), s11.barX = w2, s11.pointWidth = M2, s11.tooltipPos = e10.inverted ? [nQ(a10.len + a10.pos - e10.plotLeft - y2, a10.pos - e10.plotLeft, a10.len + a10.pos - e10.plotLeft), r10.len + r10.pos - e10.plotTop - w2 - S2 / 2, k2] : [r10.left - e10.plotLeft + w2 + S2 / 2, nQ(y2 + a10.pos - e10.plotTop, a10.pos - e10.plotTop, a10.len + a10.pos - e10.plotTop), k2], s11.shapeType = t10.pointClass.prototype.shapeType || "roundedRect", s11.shapeArgs = t10.crispCol(w2, s11.isNull ? g2 : v2, S2, s11.isNull ? 0 : k2);
          }), n3(this, "afterColumnTranslate");
        }
        drawGraph() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = this.pointAttrToOptions || {}, o10 = s10.stroke || "borderColor", r10 = s10["stroke-width"] || "borderWidth", a10, n10, h10, l10 = t10 && t10.color || this.color, d10 = t10 && t10[o10] || i10[o10] || l10, c10 = t10 && t10.options.dashStyle || i10.dashStyle, p10 = t10 && t10[r10] || i10[r10] || this[r10] || 0, u2 = n4(t10 && t10.opacity, i10.opacity, 1);
          t10 && this.zones.length && (n10 = t10.getZone(), l10 = t10.options.color || n10 && (n10.color || t10.nonZonedColor) || this.color, n10 && (d10 = n10.borderColor || d10, c10 = n10.dashStyle || c10, p10 = n10.borderWidth || p10)), e10 && t10 && (h10 = (a10 = n9(i10.states[e10], t10.options.states && t10.options.states[e10] || {})).brightness, l10 = a10.color || void 0 !== h10 && nK(l10).brighten(a10.brightness).get() || l10, d10 = a10[o10] || d10, p10 = a10[r10] || p10, c10 = a10.dashStyle || c10, u2 = n4(a10.opacity, u2));
          let g2 = {
            fill: l10,
            stroke: d10,
            "stroke-width": p10,
            opacity: u2
          };
          return c10 && (g2.dashstyle = c10), g2;
        }
        drawPoints(t10 = this.points) {
          let e10;
          let i10 = this, s10 = this.chart, o10 = i10.options, r10 = s10.renderer, a10 = o10.animationLimit || 250;
          t10.forEach(function(t11) {
            let n10 = t11.plotY, h10 = t11.graphic, l10 = !!h10, d10 = h10 && s10.pointCount < a10 ? "animate" : "attr";
            n6(n10) && null !== t11.y ? (e10 = t11.shapeArgs, h10 && t11.hasNewShapeType() && (h10 = h10.destroy()), i10.enabledDataSorting && (t11.startXPos = i10.xAxis.reversed ? -(e10 && e10.width || 0) : i10.xAxis.width), !h10 && (t11.graphic = h10 = r10[t11.shapeType](e10).add(t11.group || i10.group), h10 && i10.enabledDataSorting && s10.hasRendered && s10.pointCount < a10 && (h10.attr({
              x: t11.startXPos
            }), l10 = true, d10 = "animate")), h10 && l10 && h10[d10](n9(e10)), s10.styledMode || h10[d10](i10.pointAttribs(t11, t11.selected && "select")).shadow(false !== t11.allowShadow && o10.shadow), h10 && (h10.addClass(t11.getClassName(), true), h10.attr({
              visibility: t11.visible ? "inherit" : "hidden"
            }))) : h10 && (t11.graphic = h10.destroy());
          });
        }
        drawTracker(t10 = this.points) {
          let e10;
          let i10 = this, s10 = i10.chart, o10 = s10.pointer, r10 = function(t11) {
            o10?.normalize(t11);
            let e11 = o10?.getPointFromEvent(t11), r11 = !s10.scrollablePlotArea || s10.isInsidePlot(t11.chartX - s10.plotLeft, t11.chartY - s10.plotTop, {
              visiblePlotOnly: true
            });
            o10 && e11 && i10.options.enableMouseTracking && r11 && (o10.isDirectTouch = true, e11.onMouseOver(t11));
          };
          t10.forEach(function(t11) {
            e10 = n5(t11.dataLabels) ? t11.dataLabels : t11.dataLabel ? [t11.dataLabel] : [], t11.graphic && (t11.graphic.element.point = t11), e10.forEach(function(e11) {
              (e11.div || e11.element).point = t11;
            });
          }), i10._hasTracking || (i10.trackerGroups.forEach(function(t11) {
            i10[t11] && (i10[t11].addClass("highcharts-tracker").on("mouseover", r10).on("mouseout", function(t12) {
              o10?.onTrackerMouseOut(t12);
            }).on("touchstart", r10), !s10.styledMode && i10.options.cursor && i10[t11].css({
              cursor: i10.options.cursor
            }));
          }), i10._hasTracking = true), n3(this, "afterDrawTracker");
        }
        remove() {
          let t10 = this, e10 = t10.chart;
          e10.hasRendered && e10.series.forEach(function(e11) {
            e11.type === t10.type && (e11.isDirty = true);
          }), rQ.prototype.remove.apply(t10, arguments);
        }
      }
      n7.defaultOptions = n9(rQ.defaultOptions, {
        borderRadius: 3,
        centerInCategory: false,
        groupPadding: 0.2,
        marker: null,
        pointPadding: 0.1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: false,
            brightness: 0.1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: true,
        stickyTracking: false,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      }), n2(n7.prototype, {
        directTouch: true,
        getSymbol: nJ,
        negStacks: true,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), rv.registerSeriesType("column", n7);
      let ht = n7, {
        getDeferredAnimation: he
      } = t_, {
        format: hi
      } = eg, {
        defined: hs,
        extend: ho,
        fireEvent: hr,
        getAlignFactor: ha,
        isArray: hn,
        isString: hh,
        merge: hl,
        objectEach: hd,
        pick: hc,
        pInt: hp,
        splat: hu
      } = ti;
      !function(t10) {
        function e10() {
          return h10(this).some((t11) => t11?.enabled);
        }
        function i10(t11, e11, i11, s11, o11) {
          let {
            chart: r11,
            enabledDataSorting: a11
          } = this, n11 = this.isCartesian && r11.inverted, h11 = t11.plotX, l11 = t11.plotY, d10 = i11.rotation || 0, c10 = hs(h11) && hs(l11) && r11.isInsidePlot(h11, Math.round(l11), {
            inverted: n11,
            paneCoordinates: true,
            series: this
          }), p10 = 0 === d10 && "justify" === hc(i11.overflow, a11 ? "none" : "justify"), u2 = this.visible && false !== t11.visible && hs(h11) && (t11.series.forceDL || a11 && !p10 || c10 || hc(i11.inside, !!this.options.stacking) && s11 && r11.isInsidePlot(h11, n11 ? s11.x + 1 : s11.y + s11.height - 1, {
            inverted: n11,
            paneCoordinates: true,
            series: this
          })), g2 = t11.pos();
          if (u2 && g2) {
            var f2;
            let h12 = e11.getBBox(), l12 = e11.getBBox(void 0, 0);
            if (s11 = ho({
              x: g2[0],
              y: Math.round(g2[1]),
              width: 0,
              height: 0
            }, s11 || {}), "plotEdges" === i11.alignTo && this.isCartesian && (s11[n11 ? "x" : "y"] = 0, s11[n11 ? "width" : "height"] = this.yAxis?.len || 0), ho(i11, {
              width: h12.width,
              height: h12.height
            }), f2 = s11, a11 && this.xAxis && !p10 && this.setDataLabelStartPos(t11, e11, o11, c10, f2), e11.align(hl(i11, {
              width: l12.width,
              height: l12.height
            }), false, s11, false), e11.alignAttr.x += ha(i11.align) * (l12.width - h12.width), e11.alignAttr.y += ha(i11.verticalAlign) * (l12.height - h12.height), e11[e11.placed ? "animate" : "attr"]({
              "text-align": e11.alignAttr["text-align"] || "center",
              x: e11.alignAttr.x + (h12.width - l12.width) / 2,
              y: e11.alignAttr.y + (h12.height - l12.height) / 2,
              rotationOriginX: (e11.width || 0) / 2,
              rotationOriginY: (e11.height || 0) / 2
            }), p10 && s11.height >= 0) this.justifyDataLabel(e11, i11, e11.alignAttr, h12, s11, o11);
            else if (hc(i11.crop, true)) {
              let {
                x: t12,
                y: i12
              } = e11.alignAttr;
              u2 = r11.isInsidePlot(t12, i12, {
                paneCoordinates: true,
                series: this
              }) && r11.isInsidePlot(t12 + h12.width - 1, i12 + h12.height - 1, {
                paneCoordinates: true,
                series: this
              });
            }
            i11.shape && !d10 && e11[o11 ? "attr" : "animate"]({
              anchorX: g2[0],
              anchorY: g2[1]
            });
          }
          o11 && a11 && (e11.placed = false), u2 || a11 && !p10 ? (e11.show(), e11.placed = true) : (e11.hide(), e11.placed = false);
        }
        function s10() {
          return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
        }
        function o10(t11) {
          let e11 = this.hasRendered || 0, i11 = this.initDataLabelsGroup().attr({
            opacity: +e11
          });
          return !e11 && i11 && (this.visible && i11.show(), this.options.animation ? i11.animate({
            opacity: 1
          }, t11) : i11.attr({
            opacity: 1
          })), i11;
        }
        function r10(t11) {
          let e11;
          t11 = t11 || this.points;
          let i11 = this, s11 = i11.chart, o11 = i11.options, r11 = s11.renderer, {
            backgroundColor: a11,
            plotBackgroundColor: l11
          } = s11.options.chart, d10 = r11.getContrast(hh(l11) && l11 || hh(a11) && a11 || "#000000"), c10 = h10(i11), {
            animation: p10,
            defer: u2
          } = c10[0], g2 = u2 ? he(s11, p10, i11) : {
            defer: 0,
            duration: 0
          };
          hr(this, "drawDataLabels"), i11.hasDataLabels?.() && (e11 = this.initDataLabels(g2), t11.forEach((t12) => {
            let a12 = t12.dataLabels || [];
            hu(n10(c10, t12.dlOptions || t12.options?.dataLabels)).forEach((n11, h12) => {
              let l12 = n11.enabled && (t12.visible || t12.dataLabelOnHidden) && (!t12.isNull || t12.dataLabelOnNull) && function(t13, e12) {
                let i12 = e12.filter;
                if (i12) {
                  let e13 = i12.operator, s12 = t13[i12.property], o12 = i12.value;
                  return ">" === e13 && s12 > o12 || "<" === e13 && s12 < o12 || ">=" === e13 && s12 >= o12 || "<=" === e13 && s12 <= o12 || "==" === e13 && s12 == o12 || "===" === e13 && s12 === o12 || "!=" === e13 && s12 != o12 || "!==" === e13 && s12 !== o12;
                }
                return true;
              }(t12, n11), {
                backgroundColor: c11,
                borderColor: p11,
                distance: u3,
                style: g3 = {}
              } = n11, f2, m2, x2, y2 = {}, b2 = a12[h12], v2 = !b2, k2;
              l12 && (m2 = hs(f2 = hc(n11[t12.formatPrefix + "Format"], n11.format)) ? hi(f2, t12, s11) : (n11[t12.formatPrefix + "Formatter"] || n11.formatter).call(t12, n11), x2 = n11.rotation, !s11.styledMode && (g3.color = hc(n11.color, g3.color, hh(i11.color) ? i11.color : void 0, "#000000"), "contrast" === g3.color ? ("none" !== c11 && (k2 = c11), t12.contrastColor = r11.getContrast("auto" !== k2 && k2 || t12.color || i11.color), g3.color = k2 || !hs(u3) && n11.inside || 0 > hp(u3 || 0) || o11.stacking ? t12.contrastColor : d10) : delete t12.contrastColor, o11.cursor && (g3.cursor = o11.cursor)), y2 = {
                r: n11.borderRadius || 0,
                rotation: x2,
                padding: n11.padding,
                zIndex: 1
              }, s11.styledMode || (y2.fill = "auto" === c11 ? t12.color : c11, y2.stroke = "auto" === p11 ? t12.color : p11, y2["stroke-width"] = n11.borderWidth), hd(y2, (t13, e12) => {
                void 0 === t13 && delete y2[e12];
              })), !b2 || l12 && hs(m2) && !!b2.div == !!n11.useHTML && (b2.rotation && n11.rotation || b2.rotation === n11.rotation) || (b2 = void 0, v2 = true), l12 && hs(m2) && (b2 ? y2.text = m2 : (b2 = r11.label(m2, 0, 0, n11.shape, void 0, void 0, n11.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + t12.colorIndex + " " + (n11.className || "") + (n11.useHTML ? " highcharts-tracker" : "")), b2 && (b2.options = n11, b2.attr(y2), s11.styledMode ? g3.width && b2.css({
                width: g3.width,
                textOverflow: g3.textOverflow,
                whiteSpace: g3.whiteSpace
              }) : b2.css(g3).shadow(n11.shadow), hr(b2, "beforeAddingDataLabel", {
                labelOptions: n11,
                point: t12
              }), b2.added || b2.add(e11), i11.alignDataLabel(t12, b2, n11, void 0, v2), b2.isActive = true, a12[h12] && a12[h12] !== b2 && a12[h12].destroy(), a12[h12] = b2));
            });
            let h11 = a12.length;
            for (; h11--; ) a12[h11] && a12[h11].isActive ? a12[h11].isActive = false : (a12[h11]?.destroy(), a12.splice(h11, 1));
            t12.dataLabel = a12[0], t12.dataLabels = a12;
          })), hr(this, "afterDrawDataLabels");
        }
        function a10(t11, e11, i11, s11, o11, r11) {
          let a11 = this.chart, n11 = e11.align, h11 = e11.verticalAlign, l11 = t11.box ? 0 : t11.padding || 0, d10 = a11.inverted ? this.yAxis : this.xAxis, c10 = d10 ? d10.left - a11.plotLeft : 0, p10 = a11.inverted ? this.xAxis : this.yAxis, u2 = p10 ? p10.top - a11.plotTop : 0, {
            x: g2 = 0,
            y: f2 = 0
          } = e11, m2, x2;
          return (m2 = (i11.x || 0) + l11 + c10) < 0 && ("right" === n11 && g2 >= 0 ? (e11.align = "left", e11.inside = true) : g2 -= m2, x2 = true), (m2 = (i11.x || 0) + s11.width - l11 + c10) > a11.plotWidth && ("left" === n11 && g2 <= 0 ? (e11.align = "right", e11.inside = true) : g2 += a11.plotWidth - m2, x2 = true), (m2 = i11.y + l11 + u2) < 0 && ("bottom" === h11 && f2 >= 0 ? (e11.verticalAlign = "top", e11.inside = true) : f2 -= m2, x2 = true), (m2 = (i11.y || 0) + s11.height - l11 + u2) > a11.plotHeight && ("top" === h11 && f2 <= 0 ? (e11.verticalAlign = "bottom", e11.inside = true) : f2 += a11.plotHeight - m2, x2 = true), x2 && (e11.x = g2, e11.y = f2, t11.placed = !r11, t11.align(e11, void 0, o11)), x2;
        }
        function n10(t11, e11) {
          let i11 = [], s11;
          if (hn(t11) && !hn(e11)) i11 = t11.map(function(t12) {
            return hl(t12, e11);
          });
          else if (hn(e11) && !hn(t11)) i11 = e11.map(function(e12) {
            return hl(t11, e12);
          });
          else if (hn(t11) || hn(e11)) {
            if (hn(t11) && hn(e11)) for (s11 = Math.max(t11.length, e11.length); s11--; ) i11[s11] = hl(t11[s11], e11[s11]);
          } else i11 = hl(t11, e11);
          return i11;
        }
        function h10(t11) {
          let e11 = t11.chart.options.plotOptions;
          return hu(n10(n10(e11?.series?.dataLabels, e11?.[t11.type]?.dataLabels), t11.options.dataLabels));
        }
        function l10(t11, e11, i11, s11, o11) {
          let r11 = this.chart, a11 = r11.inverted, n11 = this.xAxis, h11 = n11.reversed, l11 = ((a11 ? e11.height : e11.width) || 0) / 2, d10 = t11.pointWidth, c10 = d10 ? d10 / 2 : 0;
          e11.startXPos = a11 ? o11.x : h11 ? -l11 - c10 : n11.width - l11 + c10, e11.startYPos = a11 ? h11 ? this.yAxis.height - l11 + c10 : -l11 - c10 : o11.y, s11 ? "hidden" === e11.visibility && (e11.show(), e11.attr({
            opacity: 0
          }).animate({
            opacity: 1
          })) : e11.attr({
            opacity: 1
          }).animate({
            opacity: 0
          }, void 0, e11.hide), r11.hasRendered && (i11 && e11.attr({
            x: e11.startXPos,
            y: e11.startYPos
          }), e11.placed = true);
        }
        t10.compose = function(t11) {
          let n11 = t11.prototype;
          n11.initDataLabels || (n11.initDataLabels = o10, n11.initDataLabelsGroup = s10, n11.alignDataLabel = i10, n11.drawDataLabels = r10, n11.justifyDataLabel = a10, n11.setDataLabelStartPos = l10, n11.hasDataLabels = e10);
        };
      }(x || (x = {}));
      let hg = x, {
        composed: hf
      } = L, {
        series: hm
      } = rv, {
        merge: hx,
        pick: hy,
        pushUnique: hb
      } = ti;
      !function(t10) {
        function e10(t11, e11, i10, s10, o10) {
          let r10 = this.chart.inverted, a10 = t11.series, n10 = (a10.xAxis ? a10.xAxis.len : this.chart.plotSizeX) || 0, h10 = (a10.yAxis ? a10.yAxis.len : this.chart.plotSizeY) || 0, l10 = t11.dlBox || t11.shapeArgs, d10 = hy(t11.below, t11.plotY > hy(this.translatedThreshold, h10)), c10 = hy(i10.inside, !!this.options.stacking);
          if (l10) {
            if (s10 = hx(l10), !("allow" === i10.overflow && false === i10.crop)) {
              s10.y < 0 && (s10.height += s10.y, s10.y = 0);
              let t12 = s10.y + s10.height - h10;
              t12 > 0 && t12 < s10.height - 1 && (s10.height -= t12);
            }
            r10 && (s10 = {
              x: h10 - s10.y - s10.height,
              y: n10 - s10.x - s10.width,
              width: s10.height,
              height: s10.width
            }), c10 || (r10 ? (s10.x += d10 ? 0 : s10.width, s10.width = 0) : (s10.y += d10 ? s10.height : 0, s10.height = 0));
          }
          i10.align = hy(i10.align, !r10 || c10 ? "center" : d10 ? "right" : "left"), i10.verticalAlign = hy(i10.verticalAlign, r10 || c10 ? "middle" : d10 ? "top" : "bottom"), hm.prototype.alignDataLabel.call(this, t11, e11, i10, s10, o10), i10.inside && t11.contrastColor && e11.css({
            color: t11.contrastColor
          });
        }
        t10.compose = function(t11) {
          hg.compose(hm), hb(hf, "ColumnDataLabel") && (t11.prototype.alignDataLabel = e10);
        };
      }(y || (y = {}));
      let hv = y, {
        extend: hk,
        merge: hM
      } = ti;
      class hw extends ht {
      }
      hw.defaultOptions = hM(ht.defaultOptions, {}), hk(hw.prototype, {
        inverted: true
      }), rv.registerSeriesType("bar", hw);
      let {
        column: hS,
        line: hA
      } = rv.seriesTypes, {
        addEvent: hT,
        extend: hC,
        merge: hP
      } = ti;
      class hO extends hA {
        applyJitter() {
          let t10 = this, e10 = this.options.jitter, i10 = this.points.length;
          e10 && this.points.forEach(function(s10, o10) {
            ["x", "y"].forEach(function(r10, a10) {
              if (e10[r10] && !s10.isNull) {
                let n10 = `plot${r10.toUpperCase()}`, h10 = t10[`${r10}Axis`], l10 = e10[r10] * h10.transA;
                if (h10 && !h10.logarithmic) {
                  let t11 = Math.max(0, (s10[n10] || 0) - l10), e11 = Math.min(h10.len, (s10[n10] || 0) + l10);
                  s10[n10] = t11 + (e11 - t11) * function(t12) {
                    let e12 = 1e4 * Math.sin(t12);
                    return e12 - Math.floor(e12);
                  }(o10 + a10 * i10), "x" === r10 && (s10.clientX = s10.plotX);
                }
              }
            });
          });
        }
        drawGraph() {
          this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
        }
      }
      hO.defaultOptions = hP(hA.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: true
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      }), hC(hO.prototype, {
        drawTracker: hS.prototype.drawTracker,
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]
      }), hT(hO, "afterTranslate", function() {
        this.applyJitter();
      }), rv.registerSeriesType("scatter", hO);
      let {
        deg2rad: hE
      } = L, {
        fireEvent: hL,
        isNumber: hD,
        pick: hB,
        relativeLength: hI
      } = ti;
      !function(t10) {
        t10.getCenter = function() {
          let t11 = this.options, e10 = this.chart, i10 = 2 * (t11.slicedOffset || 0), s10 = e10.plotWidth - 2 * i10, o10 = e10.plotHeight - 2 * i10, r10 = t11.center, a10 = Math.min(s10, o10), n10 = t11.thickness, h10, l10 = t11.size, d10 = t11.innerSize || 0, c10, p10;
          "string" == typeof l10 && (l10 = parseFloat(l10)), "string" == typeof d10 && (d10 = parseFloat(d10));
          let u2 = [hB(r10?.[0], "50%"), hB(r10?.[1], "50%"), hB(l10 && l10 < 0 ? void 0 : t11.size, "100%"), hB(d10 && d10 < 0 ? void 0 : t11.innerSize || 0, "0%")];
          for (!e10.angular || this instanceof rQ || (u2[3] = 0), c10 = 0; c10 < 4; ++c10) p10 = u2[c10], h10 = c10 < 2 || 2 === c10 && /%$/.test(p10), u2[c10] = hI(p10, [s10, o10, a10, u2[2]][c10]) + (h10 ? i10 : 0);
          return u2[3] > u2[2] && (u2[3] = u2[2]), hD(n10) && 2 * n10 < u2[2] && n10 > 0 && (u2[3] = u2[2] - 2 * n10), hL(this, "afterGetCenter", {
            positions: u2
          }), u2;
        }, t10.getStartAndEndRadians = function(t11, e10) {
          let i10 = hD(t11) ? t11 : 0, s10 = hD(e10) && e10 > i10 && e10 - i10 < 360 ? e10 : i10 + 360;
          return {
            start: hE * (i10 + -90),
            end: hE * (s10 + -90)
          };
        };
      }(b || (b = {}));
      let hz = b, {
        setAnimation: hR
      } = t_, {
        addEvent: hN,
        defined: hW,
        extend: hG,
        isNumber: hX,
        pick: hH,
        relativeLength: hF
      } = ti;
      class hY extends oK {
        getConnectorPath(t10) {
          let e10 = t10.dataLabelPosition, i10 = t10.options || {}, s10 = i10.connectorShape, o10 = this.connectorShapes[s10] || s10;
          return e10 && o10.call(this, __spreadProps(__spreadValues({}, e10.computed), {
            alignment: e10.alignment
          }), e10.connectorPosition, i10) || [];
        }
        getTranslate() {
          return this.sliced && this.slicedTranslation || {
            translateX: 0,
            translateY: 0
          };
        }
        haloPath(t10) {
          let e10 = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e10.x, e10.y, e10.r + t10, e10.r + t10, {
            innerR: e10.r - 1,
            start: e10.start,
            end: e10.end,
            borderRadius: e10.borderRadius
          });
        }
        constructor(t10, e10, i10) {
          super(t10, e10, i10), this.half = 0, this.name ?? (this.name = "Slice");
          let s10 = (t11) => {
            this.slice("select" === t11.type);
          };
          hN(this, "select", s10), hN(this, "unselect", s10);
        }
        isValid() {
          return hX(this.y) && this.y >= 0;
        }
        setVisible(t10, e10 = true) {
          t10 !== this.visible && this.update({
            visible: t10 ?? !this.visible
          }, e10, void 0, false);
        }
        slice(t10, e10, i10) {
          let s10 = this.series;
          hR(i10, s10.chart), e10 = hH(e10, true), this.sliced = this.options.sliced = t10 = hW(t10) ? t10 : !this.sliced, s10.options.data[s10.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
        }
      }
      hG(hY.prototype, {
        connectorShapes: {
          fixedOffset: function(t10, e10, i10) {
            let s10 = e10.breakAt, o10 = e10.touchingSliceAt, r10 = i10.softConnector ? ["C", t10.x + ("left" === t10.alignment ? -5 : 5), t10.y, 2 * s10.x - o10.x, 2 * s10.y - o10.y, s10.x, s10.y] : ["L", s10.x, s10.y];
            return [["M", t10.x, t10.y], r10, ["L", o10.x, o10.y]];
          },
          straight: function(t10, e10) {
            let i10 = e10.touchingSliceAt;
            return [["M", t10.x, t10.y], ["L", i10.x, i10.y]];
          },
          crookedLine: function(t10, e10, i10) {
            let {
              angle: s10 = this.angle || 0,
              breakAt: o10,
              touchingSliceAt: r10
            } = e10, {
              series: a10
            } = this, [n10, h10, l10] = a10.center, d10 = l10 / 2, {
              plotLeft: c10,
              plotWidth: p10
            } = a10.chart, u2 = "left" === t10.alignment, {
              x: g2,
              y: f2
            } = t10, m2 = o10.x;
            if (i10.crookDistance) {
              let t11 = hF(i10.crookDistance, 1);
              m2 = u2 ? n10 + d10 + (p10 + c10 - n10 - d10) * (1 - t11) : c10 + (n10 - d10) * t11;
            } else m2 = n10 + (h10 - f2) * Math.tan(s10 - Math.PI / 2);
            let x2 = [["M", g2, f2]];
            return (u2 ? m2 <= g2 && m2 >= o10.x : m2 >= g2 && m2 <= o10.x) && x2.push(["L", m2, f2]), x2.push(["L", o10.x, o10.y], ["L", r10.x, r10.y]), x2;
          }
        }
      });
      let {
        getStartAndEndRadians: hj
      } = hz, {
        noop: hU
      } = L, {
        clamp: hV,
        extend: h_,
        fireEvent: h$,
        merge: hZ,
        pick: hq
      } = ti;
      class hK extends rQ {
        animate(t10) {
          let e10 = this, i10 = e10.points, s10 = e10.startAngleRad;
          t10 || i10.forEach(function(t11) {
            let i11 = t11.graphic, o10 = t11.shapeArgs;
            i11 && o10 && (i11.attr({
              r: hq(t11.startR, e10.center && e10.center[3] / 2),
              start: s10,
              end: s10
            }), i11.animate({
              r: o10.r,
              start: o10.start,
              end: o10.end
            }, e10.options.animation));
          });
        }
        drawEmpty() {
          let t10, e10;
          let i10 = this.startAngleRad, s10 = this.endAngleRad, o10 = this.options;
          0 === this.total && this.center ? (t10 = this.center[0], e10 = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t10, e10, this.center[1] / 2, 0, i10, s10).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
            d: ir.arc(t10, e10, this.center[2] / 2, 0, {
              start: i10,
              end: s10,
              innerR: this.center[3] / 2
            })
          }), this.chart.styledMode || this.graph.attr({
            "stroke-width": o10.borderWidth,
            fill: o10.fillColor || "none",
            stroke: o10.color || "#cccccc"
          })) : this.graph && (this.graph = this.graph.destroy());
        }
        drawPoints() {
          let t10 = this.chart.renderer;
          this.points.forEach(function(e10) {
            e10.graphic && e10.hasNewShapeType() && (e10.graphic = e10.graphic.destroy()), e10.graphic || (e10.graphic = t10[e10.shapeType](e10.shapeArgs).add(e10.series.group), e10.delayedRendering = true);
          });
        }
        generatePoints() {
          super.generatePoints(), this.updateTotals();
        }
        getX(t10, e10, i10, s10) {
          let o10 = this.center, r10 = this.radii ? this.radii[i10.index] || 0 : o10[2] / 2, a10 = s10.dataLabelPosition, n10 = a10?.distance || 0, h10 = Math.asin(hV((t10 - o10[1]) / (r10 + n10), -1, 1));
          return o10[0] + Math.cos(h10) * (r10 + n10) * (e10 ? -1 : 1) + (n10 > 0 ? (e10 ? -1 : 1) * (s10.padding || 0) : 0);
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        redrawPoints() {
          let t10, e10, i10, s10;
          let o10 = this, r10 = o10.chart;
          this.drawEmpty(), o10.group && !r10.styledMode && o10.group.shadow(o10.options.shadow), o10.points.forEach(function(a10) {
            let n10 = {};
            e10 = a10.graphic, !a10.isNull && e10 ? (s10 = a10.shapeArgs, t10 = a10.getTranslate(), r10.styledMode || (i10 = o10.pointAttribs(a10, a10.selected && "select")), a10.delayedRendering ? (e10.setRadialReference(o10.center).attr(s10).attr(t10), r10.styledMode || e10.attr(i10).attr({
              "stroke-linejoin": "round"
            }), a10.delayedRendering = false) : (e10.setRadialReference(o10.center), r10.styledMode || hZ(true, n10, i10), hZ(true, n10, s10, t10), e10.animate(n10)), e10.attr({
              visibility: a10.visible ? "inherit" : "hidden"
            }), e10.addClass(a10.getClassName(), true)) : e10 && (a10.graphic = e10.destroy());
          });
        }
        sortByAngle(t10, e10) {
          t10.sort(function(t11, i10) {
            return void 0 !== t11.angle && (i10.angle - t11.angle) * e10;
          });
        }
        translate(t10) {
          h$(this, "translate"), this.generatePoints();
          let e10 = this.options, i10 = e10.slicedOffset, s10 = hj(e10.startAngle, e10.endAngle), o10 = this.startAngleRad = s10.start, r10 = (this.endAngleRad = s10.end) - o10, a10 = this.points, n10 = e10.ignoreHiddenPoint, h10 = a10.length, l10, d10, c10, p10, u2, g2, f2, m2 = 0;
          for (t10 || (this.center = t10 = this.getCenter()), g2 = 0; g2 < h10; g2++) {
            f2 = a10[g2], l10 = o10 + m2 * r10, f2.isValid() && (!n10 || f2.visible) && (m2 += f2.percentage / 100), d10 = o10 + m2 * r10;
            let e11 = {
              x: t10[0],
              y: t10[1],
              r: t10[2] / 2,
              innerR: t10[3] / 2,
              start: Math.round(1e3 * l10) / 1e3,
              end: Math.round(1e3 * d10) / 1e3
            };
            f2.shapeType = "arc", f2.shapeArgs = e11, (c10 = (d10 + l10) / 2) > 1.5 * Math.PI ? c10 -= 2 * Math.PI : c10 < -Math.PI / 2 && (c10 += 2 * Math.PI), f2.slicedTranslation = {
              translateX: Math.round(Math.cos(c10) * i10),
              translateY: Math.round(Math.sin(c10) * i10)
            }, p10 = Math.cos(c10) * t10[2] / 2, u2 = Math.sin(c10) * t10[2] / 2, f2.tooltipPos = [t10[0] + 0.7 * p10, t10[1] + 0.7 * u2], f2.half = c10 < -Math.PI / 2 || c10 > Math.PI / 2 ? 1 : 0, f2.angle = c10;
          }
          h$(this, "afterTranslate");
        }
        updateTotals() {
          let t10 = this.points, e10 = t10.length, i10 = this.options.ignoreHiddenPoint, s10, o10, r10 = 0;
          for (s10 = 0; s10 < e10; s10++) (o10 = t10[s10]).isValid() && (!i10 || o10.visible) && (r10 += o10.y);
          for (s10 = 0, this.total = r10; s10 < e10; s10++) (o10 = t10[s10]).percentage = r10 > 0 && (o10.visible || !i10) ? o10.y / r10 * 100 : 0, o10.total = r10;
        }
      }
      hK.defaultOptions = hZ(rQ.defaultOptions, {
        borderRadius: 3,
        center: [null, null],
        clip: false,
        colorByPoint: true,
        dataLabels: {
          connectorPadding: 5,
          connectorShape: "crookedLine",
          crookDistance: void 0,
          distance: 30,
          enabled: true,
          formatter: function() {
            return this.isNull ? void 0 : this.name;
          },
          softConnector: true,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: true,
        inactiveOtherPoints: true,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: false,
        slicedOffset: 10,
        stickyTracking: false,
        tooltip: {
          followPointer: true
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: 0.1
          }
        }
      }), h_(hK.prototype, {
        axisTypes: [],
        directTouch: true,
        drawGraph: void 0,
        drawTracker: ht.prototype.drawTracker,
        getCenter: hz.getCenter,
        getSymbol: hU,
        invertible: false,
        isCartesian: false,
        noSharedTooltip: true,
        pointAttribs: ht.prototype.pointAttribs,
        pointClass: hY,
        requireSorting: false,
        searchPoint: hU,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), rv.registerSeriesType("pie", hK);
      let {
        composed: hJ,
        noop: hQ
      } = L, {
        distribute: h0
      } = ev, {
        series: h1
      } = rv, {
        arrayMax: h2,
        clamp: h3,
        defined: h5,
        pick: h6,
        pushUnique: h9,
        relativeLength: h4
      } = ti;
      !function(t10) {
        let e10 = {
          radialDistributionY: function(t11, e11) {
            return (e11.dataLabelPosition?.top || 0) + t11.distributeBox.pos;
          },
          radialDistributionX: function(t11, e11, i11, s11, o11) {
            let r11 = o11.dataLabelPosition;
            return t11.getX(i11 < (r11?.top || 0) + 2 || i11 > (r11?.bottom || 0) - 2 ? s11 : i11, e11.half, e11, o11);
          },
          justify: function(t11, e11, i11, s11) {
            return s11[0] + (t11.half ? -1 : 1) * (i11 + (e11.dataLabelPosition?.distance || 0));
          },
          alignToPlotEdges: function(t11, e11, i11, s11) {
            let o11 = t11.getBBox().width;
            return e11 ? o11 + s11 : i11 - o11 - s11;
          },
          alignToConnectors: function(t11, e11, i11, s11) {
            let o11 = 0, r11;
            return t11.forEach(function(t12) {
              (r11 = t12.dataLabel.getBBox().width) > o11 && (o11 = r11);
            }), e11 ? o11 + s11 : i11 - o11 - s11;
          }
        };
        function i10(t11, e11) {
          let i11 = Math.PI / 2, {
            start: s11 = 0,
            end: o11 = 0
          } = t11.shapeArgs || {}, r11 = t11.angle || 0;
          e11 > 0 && s11 < i11 && o11 > i11 && r11 > i11 / 2 && r11 < 1.5 * i11 && (r11 = r11 <= i11 ? Math.max(i11 / 2, (s11 + i11) / 2) : Math.min(1.5 * i11, (i11 + o11) / 2));
          let {
            center: a10,
            options: n10
          } = this, h10 = a10[2] / 2, l10 = Math.cos(r11), d10 = Math.sin(r11), c10 = a10[0] + l10 * h10, p10 = a10[1] + d10 * h10, u2 = Math.min((n10.slicedOffset || 0) + (n10.borderWidth || 0), e11 / 5);
          return {
            natural: {
              x: c10 + l10 * e11,
              y: p10 + d10 * e11
            },
            computed: {},
            alignment: e11 < 0 ? "center" : t11.half ? "right" : "left",
            connectorPosition: {
              angle: r11,
              breakAt: {
                x: c10 + l10 * u2,
                y: p10 + d10 * u2
              },
              touchingSliceAt: {
                x: c10,
                y: p10
              }
            },
            distance: e11
          };
        }
        function s10() {
          let t11 = this, e11 = t11.points, i11 = t11.chart, s11 = i11.plotWidth, o11 = i11.plotHeight, r11 = i11.plotLeft, a10 = Math.round(i11.chartWidth / 3), n10 = t11.center, h10 = n10[2] / 2, l10 = n10[1], d10 = [[], []], c10 = [0, 0, 0, 0], p10 = t11.dataLabelPositioners, u2, g2, f2, m2 = 0;
          t11.visible && t11.hasDataLabels?.() && (e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((t13) => {
              t13.shortened && (t13.attr({
                width: "auto"
              }).css({
                width: "auto",
                textOverflow: "clip"
              }), t13.shortened = false);
            });
          }), h1.prototype.drawDataLabels.apply(t11), e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((e12, i12) => {
              let s12 = n10[2] / 2, o12 = e12.options, r12 = h4(o12?.distance || 0, s12);
              0 === i12 && d10[t12.half].push(t12), !h5(o12?.style?.width) && e12.getBBox().width > a10 && (e12.css({
                width: Math.round(0.7 * a10) + "px"
              }), e12.shortened = true), e12.dataLabelPosition = this.getDataLabelPosition(t12, r12), m2 = Math.max(m2, r12);
            });
          }), d10.forEach((e12, a11) => {
            let d11 = e12.length, u3 = [], x2, y2, b2 = 0, v2;
            d11 && (t11.sortByAngle(e12, a11 - 0.5), m2 > 0 && (x2 = Math.max(0, l10 - h10 - m2), y2 = Math.min(l10 + h10 + m2, i11.plotHeight), e12.forEach((t12) => {
              (t12.dataLabels || []).forEach((e13) => {
                let s12 = e13.dataLabelPosition;
                s12 && s12.distance > 0 && (s12.top = Math.max(0, l10 - h10 - s12.distance), s12.bottom = Math.min(l10 + h10 + s12.distance, i11.plotHeight), b2 = e13.getBBox().height || 21, e13.lineHeight = i11.renderer.fontMetrics(e13.text || e13).h + 2 * e13.padding, t12.distributeBox = {
                  target: (e13.dataLabelPosition?.natural.y || 0) - s12.top + e13.lineHeight / 2,
                  size: b2,
                  rank: t12.y
                }, u3.push(t12.distributeBox));
              });
            }), h0(u3, v2 = y2 + b2 - x2, v2 / 5)), e12.forEach((i12) => {
              (i12.dataLabels || []).forEach((l11) => {
                let d12 = l11.options || {}, m3 = i12.distributeBox, x3 = l11.dataLabelPosition, y3 = x3?.natural.y || 0, b3 = d12.connectorPadding || 0, v3 = l11.lineHeight || 21, k2 = (v3 - l11.getBBox().height) / 2, M2 = 0, w2 = y3, S2 = "inherit";
                if (x3) {
                  if (u3 && h5(m3) && x3.distance > 0 && (void 0 === m3.pos ? S2 = "hidden" : (f2 = m3.size, w2 = p10.radialDistributionY(i12, l11))), d12.justify) M2 = p10.justify(i12, l11, h10, n10);
                  else switch (d12.alignTo) {
                    case "connectors":
                      M2 = p10.alignToConnectors(e12, a11, s11, r11);
                      break;
                    case "plotEdges":
                      M2 = p10.alignToPlotEdges(l11, a11, s11, r11);
                      break;
                    default:
                      M2 = p10.radialDistributionX(t11, i12, w2 - k2, y3, l11);
                  }
                  if (x3.attribs = {
                    visibility: S2,
                    align: x3.alignment
                  }, x3.posAttribs = {
                    x: M2 + (d12.x || 0) + ({
                      left: b3,
                      right: -b3
                    }[x3.alignment] || 0),
                    y: w2 + (d12.y || 0) - v3 / 2
                  }, x3.computed.x = M2, x3.computed.y = w2 - k2, h6(d12.crop, true)) {
                    let t12;
                    M2 - (g2 = l11.getBBox().width) < b3 && 1 === a11 ? (t12 = Math.round(g2 - M2 + b3), c10[3] = Math.max(t12, c10[3])) : M2 + g2 > s11 - b3 && 0 === a11 && (t12 = Math.round(M2 + g2 - s11 + b3), c10[1] = Math.max(t12, c10[1])), w2 - f2 / 2 < 0 ? c10[0] = Math.max(Math.round(-w2 + f2 / 2), c10[0]) : w2 + f2 / 2 > o11 && (c10[2] = Math.max(Math.round(w2 + f2 / 2 - o11), c10[2])), x3.sideOverflow = t12;
                  }
                }
              });
            }));
          }), (0 === h2(c10) || this.verifyDataLabelOverflow(c10)) && (this.placeDataLabels(), this.points.forEach((e12) => {
            (e12.dataLabels || []).forEach((s12) => {
              let {
                connectorColor: o12,
                connectorWidth: r12 = 1
              } = s12.options || {}, a11 = s12.dataLabelPosition;
              if (r12) {
                let n11;
                u2 = s12.connector, a11 && a11.distance > 0 ? (n11 = !u2, u2 || (s12.connector = u2 = i11.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e12.colorIndex + (e12.className ? " " + e12.className : "")).add(t11.dataLabelsGroup)), i11.styledMode || u2.attr({
                  "stroke-width": r12,
                  stroke: o12 || e12.color || "#666666"
                }), u2[n11 ? "attr" : "animate"]({
                  d: e12.getConnectorPath(s12)
                }), u2.attr({
                  visibility: a11.attribs?.visibility
                })) : u2 && (s12.connector = u2.destroy());
              }
            });
          })));
        }
        function o10() {
          this.points.forEach((t11) => {
            (t11.dataLabels || []).forEach((t12) => {
              let e11 = t12.dataLabelPosition;
              e11 ? (e11.sideOverflow && (t12.css({
                width: Math.max(t12.getBBox().width - e11.sideOverflow, 0) + "px",
                textOverflow: (t12.options?.style || {}).textOverflow || "ellipsis"
              }), t12.shortened = true), t12.attr(e11.attribs), t12[t12.moved ? "animate" : "attr"](e11.posAttribs), t12.moved = true) : t12 && t12.attr({
                y: -9999
              });
            }), delete t11.distributeBox;
          }, this);
        }
        function r10(t11) {
          let e11 = this.center, i11 = this.options, s11 = i11.center, o11 = i11.minSize || 80, r11 = o11, a10 = null !== i11.size;
          return !a10 && (null !== s11[0] ? r11 = Math.max(e11[2] - Math.max(t11[1], t11[3]), o11) : (r11 = Math.max(e11[2] - t11[1] - t11[3], o11), e11[0] += (t11[3] - t11[1]) / 2), null !== s11[1] ? r11 = h3(r11, o11, e11[2] - Math.max(t11[0], t11[2])) : (r11 = h3(r11, o11, e11[2] - t11[0] - t11[2]), e11[1] += (t11[0] - t11[2]) / 2), r11 < e11[2] ? (e11[2] = r11, e11[3] = Math.min(i11.thickness ? Math.max(0, r11 - 2 * i11.thickness) : Math.max(0, h4(i11.innerSize || 0, r11)), r11), this.translate(e11), this.drawDataLabels && this.drawDataLabels()) : a10 = true), a10;
        }
        t10.compose = function(t11) {
          if (hg.compose(h1), h9(hJ, "PieDataLabel")) {
            let a10 = t11.prototype;
            a10.dataLabelPositioners = e10, a10.alignDataLabel = hQ, a10.drawDataLabels = s10, a10.getDataLabelPosition = i10, a10.placeDataLabels = o10, a10.verifyDataLabelOverflow = r10;
          }
        };
      }(v || (v = {}));
      let h8 = v;
      !function(t10) {
        t10.getCenterOfPoints = function(t11) {
          let e10 = t11.reduce((t12, e11) => (t12.x += e11.x, t12.y += e11.y, t12), {
            x: 0,
            y: 0
          });
          return {
            x: e10.x / t11.length,
            y: e10.y / t11.length
          };
        }, t10.getDistanceBetweenPoints = function(t11, e10) {
          return Math.sqrt(Math.pow(e10.x - t11.x, 2) + Math.pow(e10.y - t11.y, 2));
        }, t10.getAngleBetweenPoints = function(t11, e10) {
          return Math.atan2(e10.x - t11.x, e10.y - t11.y);
        }, t10.pointInPolygon = function({
          x: t11,
          y: e10
        }, i10) {
          let s10 = i10.length, o10, r10, a10 = false;
          for (o10 = 0, r10 = s10 - 1; o10 < s10; r10 = o10++) {
            let [s11, n10] = i10[o10], [h10, l10] = i10[r10];
            n10 > e10 != l10 > e10 && t11 < (h10 - s11) * (e10 - n10) / (l10 - n10) + s11 && (a10 = !a10);
          }
          return a10;
        };
      }(k || (k = {}));
      let {
        pointInPolygon: h7
      } = k, {
        addEvent: lt,
        fireEvent: le,
        objectEach: li,
        pick: ls
      } = ti;
      function lo(t10) {
        let e10 = t10.length, i10 = (t11, e11) => !(e11.x >= t11.x + t11.width || e11.x + e11.width <= t11.x || e11.y >= t11.y + t11.height || e11.y + e11.height <= t11.y), s10 = (t11, e11) => {
          for (let i11 of t11) if (h7({
            x: i11[0],
            y: i11[1]
          }, e11)) return true;
          return false;
        }, o10, r10, a10, n10, h10, l10 = false;
        for (let i11 = 0; i11 < e10; i11++) (o10 = t10[i11]) && (o10.oldOpacity = o10.opacity, o10.newOpacity = 1, o10.absoluteBox = function(t11) {
          if (t11 && (!t11.alignAttr || t11.placed)) {
            let e11 = t11.box ? 0 : t11.padding || 0, i12 = t11.alignAttr || {
              x: t11.attr("x"),
              y: t11.attr("y")
            }, s11 = t11.getBBox();
            return t11.width = s11.width, t11.height = s11.height, {
              x: i12.x + (t11.parentGroup?.translateX || 0) + e11,
              y: i12.y + (t11.parentGroup?.translateY || 0) + e11,
              width: (t11.width || 0) - 2 * e11,
              height: (t11.height || 0) - 2 * e11,
              polygon: s11?.polygon
            };
          }
        }(o10));
        t10.sort((t11, e11) => (e11.labelrank || 0) - (t11.labelrank || 0));
        for (let o11 = 0; o11 < e10; ++o11) {
          n10 = (r10 = t10[o11]) && r10.absoluteBox;
          let l11 = n10?.polygon;
          for (let d10 = o11 + 1; d10 < e10; ++d10) {
            h10 = (a10 = t10[d10]) && a10.absoluteBox;
            let e11 = false;
            if (n10 && h10 && r10 !== a10 && 0 !== r10.newOpacity && 0 !== a10.newOpacity && "hidden" !== r10.visibility && "hidden" !== a10.visibility) {
              let t11 = h10.polygon;
              if (l11 && t11 && l11 !== t11 ? s10(l11, t11) && (e11 = true) : i10(n10, h10) && (e11 = true), e11) {
                let t12 = r10.labelrank < a10.labelrank ? r10 : a10, e12 = t12.text;
                t12.newOpacity = 0, e12?.element.querySelector("textPath") && e12.hide();
              }
            }
          }
        }
        for (let e11 of t10) lr(e11, this) && (l10 = true);
        l10 && le(this, "afterHideAllOverlappingLabels");
      }
      function lr(t10, e10) {
        let i10, s10, o10 = false;
        return t10 && (s10 = t10.newOpacity, t10.oldOpacity !== s10 && (t10.hasClass("highcharts-data-label") ? (t10[s10 ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), i10 = function() {
          e10.styledMode || t10.css({
            pointerEvents: s10 ? "auto" : "none"
          });
        }, o10 = true, t10[t10.isOld ? "animate" : "attr"]({
          opacity: s10
        }, void 0, i10), le(e10, "afterHideOverlappingLabel")) : t10.attr({
          opacity: s10
        })), t10.isOld = true), o10;
      }
      function la() {
        let t10 = this, e10 = [];
        for (let i10 of t10.labelCollectors || []) e10 = e10.concat(i10());
        for (let i10 of t10.yAxis || []) i10.stacking && i10.options.stackLabels && !i10.options.stackLabels.allowOverlap && li(i10.stacking.stacks, (t11) => {
          li(t11, (t12) => {
            t12.label && e10.push(t12.label);
          });
        });
        for (let i10 of t10.series || []) if (i10.visible && i10.hasDataLabels?.()) {
          let s10 = (i11) => {
            for (let s11 of i11) s11.visible && (s11.dataLabels || []).forEach((i12) => {
              let o10 = i12.options || {};
              i12.labelrank = ls(o10.labelrank, s11.labelrank, s11.shapeArgs?.height), o10.allowOverlap ?? Number(o10.distance) > 0 ? (i12.oldOpacity = i12.opacity, i12.newOpacity = 1, lr(i12, t10)) : e10.push(i12);
            });
          };
          s10(i10.nodes || []), s10(i10.points);
        }
        this.hideOverlappingLabels(e10);
      }
      let ln = {
        compose: function(t10) {
          let e10 = t10.prototype;
          e10.hideOverlappingLabels || (e10.hideOverlappingLabels = lo, lt(t10, "render", la));
        }
      }, {
        defaultOptions: lh
      } = tT, {
        noop: ll
      } = L, {
        addEvent: ld,
        extend: lc,
        isObject: lp,
        merge: lu,
        relativeLength: lg
      } = ti, lf = {
        radius: 0,
        scope: "stack",
        where: void 0
      }, lm = ll, lx = ll;
      function ly(t10, e10, i10, s10, o10 = {}) {
        let r10 = lm(t10, e10, i10, s10, o10), {
          innerR: a10 = 0,
          r: n10 = i10,
          start: h10 = 0,
          end: l10 = 0
        } = o10;
        if (o10.open || !o10.borderRadius) return r10;
        let d10 = l10 - h10, c10 = Math.sin(d10 / 2), p10 = Math.max(Math.min(lg(o10.borderRadius || 0, n10 - a10), (n10 - a10) / 2, n10 * c10 / (1 + c10)), 0), u2 = Math.min(p10, d10 / Math.PI * 2 * a10), g2 = r10.length - 1;
        for (; g2--; ) !function(t11, e11, i11) {
          let s11, o11, r11;
          let a11 = t11[e11], n11 = t11[e11 + 1];
          if ("Z" === n11[0] && (n11 = t11[0]), ("M" === a11[0] || "L" === a11[0]) && "A" === n11[0] ? (s11 = a11, o11 = n11, r11 = true) : "A" === a11[0] && ("M" === n11[0] || "L" === n11[0]) && (s11 = n11, o11 = a11), s11 && o11 && o11.params) {
            let a12 = o11[1], n12 = o11[5], h11 = o11.params, {
              start: l11,
              end: d11,
              cx: c11,
              cy: p11
            } = h11, u3 = n12 ? a12 - i11 : a12 + i11, g3 = u3 ? Math.asin(i11 / u3) : 0, f2 = n12 ? g3 : -g3, m2 = Math.cos(g3) * u3;
            r11 ? (h11.start = l11 + f2, s11[1] = c11 + m2 * Math.cos(l11), s11[2] = p11 + m2 * Math.sin(l11), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + a12 * Math.cos(h11.start), p11 + a12 * Math.sin(h11.start)])) : (h11.end = d11 - f2, o11[6] = c11 + a12 * Math.cos(h11.end), o11[7] = p11 + a12 * Math.sin(h11.end), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + m2 * Math.cos(d11), p11 + m2 * Math.sin(d11)])), o11[4] = Math.abs(h11.end - h11.start) < Math.PI ? 0 : 1;
          }
        }(r10, g2, g2 > 1 ? u2 : p10);
        return r10;
      }
      function lb() {
        if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
          let {
            options: t10,
            yAxis: e10
          } = this, i10 = "percent" === t10.stacking, s10 = lh.plotOptions?.[this.type]?.borderRadius, o10 = lv(t10.borderRadius, lp(s10) ? s10 : {}), r10 = e10.options.reversed;
          for (let s11 of this.points) {
            let {
              shapeArgs: a10
            } = s11;
            if ("roundedRect" === s11.shapeType && a10) {
              let {
                width: n10 = 0,
                height: h10 = 0,
                y: l10 = 0
              } = a10, d10 = l10, c10 = h10;
              if ("stack" === o10.scope && s11.stackTotal) {
                let o11 = e10.translate(i10 ? 100 : s11.stackTotal, false, true, false, true), r11 = e10.translate(t10.threshold || 0, false, true, false, true), a11 = this.crispCol(0, Math.min(o11, r11), 0, Math.abs(o11 - r11));
                d10 = a11.y, c10 = a11.height;
              }
              let p10 = (s11.negative ? -1 : 1) * (r10 ? -1 : 1) == -1, u2 = o10.where;
              !u2 && this.is("waterfall") && Math.abs((s11.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (u2 = "all"), u2 || (u2 = "end");
              let g2 = Math.min(lg(o10.radius, n10), n10 / 2, "all" === u2 ? h10 / 2 : 1 / 0) || 0;
              "end" === u2 && (p10 && (d10 -= g2), c10 += g2), lc(a10, {
                brBoxHeight: c10,
                brBoxY: d10,
                r: g2
              });
            }
          }
        }
      }
      function lv(t10, e10) {
        return lp(t10) || (t10 = {
          radius: t10 || 0
        }), lu(lf, e10, t10);
      }
      function lk() {
        let t10 = lv(this.options.borderRadius);
        for (let e10 of this.points) {
          let i10 = e10.shapeArgs;
          i10 && (i10.borderRadius = lg(t10.radius, (i10.r || 0) - (i10.innerR || 0)));
        }
      }
      function lM(t10, e10, i10, s10, o10 = {}) {
        let r10 = lx(t10, e10, i10, s10, o10), {
          r: a10 = 0,
          brBoxHeight: n10 = s10,
          brBoxY: h10 = e10
        } = o10, l10 = e10 - h10, d10 = h10 + n10 - (e10 + s10), c10 = l10 - a10 > -0.1 ? 0 : a10, p10 = d10 - a10 > -0.1 ? 0 : a10, u2 = Math.max(c10 && l10, 0), g2 = Math.max(p10 && d10, 0), f2 = [t10 + c10, e10], m2 = [t10 + i10 - c10, e10], x2 = [t10 + i10, e10 + c10], y2 = [t10 + i10, e10 + s10 - p10], b2 = [t10 + i10 - p10, e10 + s10], v2 = [t10 + p10, e10 + s10], k2 = [t10, e10 + s10 - p10], M2 = [t10, e10 + c10], w2 = (t11, e11) => Math.sqrt(Math.pow(t11, 2) - Math.pow(e11, 2));
        if (u2) {
          let t11 = w2(c10, c10 - u2);
          f2[0] -= t11, m2[0] += t11, x2[1] = M2[1] = e10 + c10 - u2;
        }
        if (s10 < c10 - u2) {
          let o11 = w2(c10, c10 - u2 - s10);
          x2[0] = y2[0] = t10 + i10 - c10 + o11, b2[0] = Math.min(x2[0], b2[0]), v2[0] = Math.max(y2[0], v2[0]), k2[0] = M2[0] = t10 + c10 - o11, x2[1] = M2[1] = e10 + s10;
        }
        if (g2) {
          let t11 = w2(p10, p10 - g2);
          b2[0] += t11, v2[0] -= t11, y2[1] = k2[1] = e10 + s10 - p10 + g2;
        }
        if (s10 < p10 - g2) {
          let o11 = w2(p10, p10 - g2 - s10);
          x2[0] = y2[0] = t10 + i10 - p10 + o11, m2[0] = Math.min(x2[0], m2[0]), f2[0] = Math.max(y2[0], f2[0]), k2[0] = M2[0] = t10 + p10 - o11, y2[1] = k2[1] = e10;
        }
        return r10.length = 0, r10.push(["M", ...f2], ["L", ...m2], ["A", c10, c10, 0, 0, 1, ...x2], ["L", ...y2], ["A", p10, p10, 0, 0, 1, ...b2], ["L", ...v2], ["A", p10, p10, 0, 0, 1, ...k2], ["L", ...M2], ["A", c10, c10, 0, 0, 1, ...f2], ["Z"]), r10;
      }
      let {
        diffObjects: lw,
        extend: lS,
        find: lA,
        merge: lT,
        pick: lC,
        uniqueKey: lP
      } = ti;
      !function(t10) {
        function e10(t11, e11) {
          let i11 = t11.condition;
          (i11.callback || function() {
            return this.chartWidth <= lC(i11.maxWidth, Number.MAX_VALUE) && this.chartHeight <= lC(i11.maxHeight, Number.MAX_VALUE) && this.chartWidth >= lC(i11.minWidth, 0) && this.chartHeight >= lC(i11.minHeight, 0);
          }).call(this) && e11.push(t11._id);
        }
        function i10(t11, e11) {
          let i11 = this.options.responsive, s10 = this.currentResponsive, o10 = [], r10;
          !e11 && i11 && i11.rules && i11.rules.forEach((t12) => {
            void 0 === t12._id && (t12._id = lP()), this.matchResponsiveRule(t12, o10);
          }, this);
          let a10 = lT(...o10.map((t12) => lA((i11 || {}).rules || [], (e12) => e12._id === t12)).map((t12) => t12 && t12.chartOptions));
          a10.isResponsiveOptions = true, o10 = o10.toString() || void 0;
          let n10 = s10 && s10.ruleIds;
          o10 === n10 || (s10 && (this.currentResponsive = void 0, this.updatingResponsive = true, this.update(s10.undoOptions, t11, true), this.updatingResponsive = false), o10 ? ((r10 = lw(a10, this.options, true, this.collectionsWithUpdate)).isResponsiveOptions = true, this.currentResponsive = {
            ruleIds: o10,
            mergedOptions: a10,
            undoOptions: r10
          }, this.updatingResponsive || this.update(a10, t11, true)) : this.currentResponsive = void 0);
        }
        t10.compose = function(t11) {
          let s10 = t11.prototype;
          return s10.matchResponsiveRule || lS(s10, {
            matchResponsiveRule: e10,
            setResponsive: i10
          }), t11;
        };
      }(M || (M = {}));
      let lO = M;
      L.AST = t4, L.Axis = s_, L.Chart = aQ, L.Color = tL, L.DataLabel = hg, L.DataTableCore = rc, L.Fx = tR, L.HTMLElement = i9, L.Legend = ap, L.LegendSymbol = rf, L.OverlappingDataLabels = L.OverlappingDataLabels || ln, L.PlotLineOrBand = on, L.Point = oK, L.Pointer = ra, L.RendererRegistry = ef, L.Series = rQ, L.SeriesRegistry = rv, L.StackItem = nl, L.SVGElement = e0, L.SVGRenderer = i_, L.Templating = eg, L.Tick = sm, L.Time = tv, L.Tooltip = oL, L.animate = t_.animate, L.animObject = t_.animObject, L.chart = aQ.chart, L.color = tL.parse, L.dateFormat = eg.dateFormat, L.defaultOptions = tT.defaultOptions, L.distribute = ev.distribute, L.format = eg.format, L.getDeferredAnimation = t_.getDeferredAnimation, L.getOptions = tT.getOptions, L.numberFormat = eg.numberFormat, L.seriesType = rv.seriesType, L.setAnimation = t_.setAnimation, L.setOptions = tT.setOptions, L.stop = t_.stop, L.time = tT.defaultTime, L.timers = tR.timers, {
        compose: function(t10, e10, i10) {
          let s10 = t10.types.pie;
          if (!e10.symbolCustomAttribs.includes("borderRadius")) {
            let o10 = i10.prototype.symbols;
            ld(t10, "afterColumnTranslate", lb, {
              order: 9
            }), ld(s10, "afterTranslate", lk), e10.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), lm = o10.arc, lx = o10.roundedRect, o10.arc = ly, o10.roundedRect = lM;
          }
        },
        optionsToObject: lv
      }.compose(L.Series, L.SVGElement, L.SVGRenderer), hv.compose(L.Series.types.column), hg.compose(L.Series), sJ.compose(L.Axis), i9.compose(L.SVGRenderer), ap.compose(L.Chart), s2.compose(L.Axis), ln.compose(L.Chart), h8.compose(L.Series.types.pie), on.compose(L.Chart, L.Axis), ra.compose(L.Chart), lO.compose(L.Chart), ne.compose(L.Axis, L.Chart, L.Series), nO.compose(L.Axis, L.Chart, L.Series), oL.compose(L.Pointer), ti.extend(L, ti);
      let {
        tooltipFormatter: lE
      } = oK.prototype, {
        addEvent: lL,
        arrayMax: lD,
        arrayMin: lB,
        correctFloat: lI,
        defined: lz,
        isArray: lR,
        isNumber: lN,
        isString: lW,
        pick: lG
      } = ti;
      !function(t10) {
        function e10(t11, e11, i11) {
          !this.isXAxis && (this.series.forEach(function(i12) {
            "compare" === t11 && "boolean" != typeof e11 ? i12.setCompare(e11, false) : "cumulative" !== t11 || lW(e11) || i12.setCumulative(e11, false);
          }), lG(i11, true) && this.chart.redraw());
        }
        function i10(t11) {
          let e11 = this, {
            numberFormatter: i11
          } = e11.series.chart, s11 = function(s12) {
            t11 = t11.replace("{point." + s12 + "}", (e11[s12] > 0 && "change" === s12 ? "+" : "") + i11(e11[s12], lG(e11.series.tooltipOptions.changeDecimals, 2)));
          };
          return lz(e11.change) && s11("change"), lz(e11.cumulativeSum) && s11("cumulativeSum"), lE.apply(this, [t11]);
        }
        function s10() {
          let t11;
          let e11 = this.options.compare;
          ("percent" === e11 || "value" === e11 || this.options.cumulative) && (t11 = new d10(this), "percent" === e11 || "value" === e11 ? t11.initCompare(e11) : t11.initCumulative()), this.dataModify = t11;
        }
        function o10(t11) {
          let e11 = t11.dataExtremes, i11 = e11.activeYData;
          if (this.dataModify && e11) {
            let t12;
            this.options.compare ? t12 = [this.dataModify.modifyValue(e11.dataMin), this.dataModify.modifyValue(e11.dataMax)] : this.options.cumulative && lR(i11) && i11.length >= 2 && (t12 = d10.getCumulativeExtremes(i11)), t12 && (e11.dataMin = lB(t12), e11.dataMax = lD(t12));
          }
        }
        function r10(t11, e11) {
          this.options.compare = this.userOptions.compare = t11, this.update({}, lG(e11, true)), this.dataModify && ("value" === t11 || "percent" === t11) ? this.dataModify.initCompare(t11) : this.points.forEach((t12) => {
            delete t12.change;
          });
        }
        function a10() {
          let t11 = this.getColumn(this.pointArrayMap && (this.options.pointValKey || this.pointValKey) || "y", true);
          if (this.xAxis && t11.length && this.dataModify) {
            let e11 = this.getColumn("x", true), i11 = this.dataTable.rowCount, s11 = true === this.options.compareStart ? 0 : 1;
            for (let o11 = 0; o11 < i11 - s11; o11++) {
              let i12 = t11[o11];
              if (lN(i12) && 0 !== i12 && e11[o11 + s11] >= (this.xAxis.min || 0)) {
                this.dataModify.compareValue = i12;
                break;
              }
            }
          }
        }
        function n10(t11, e11) {
          this.setModifier("compare", t11, e11);
        }
        function h10(t11, e11) {
          t11 = lG(t11, false), this.options.cumulative = this.userOptions.cumulative = t11, this.update({}, lG(e11, true)), this.dataModify ? this.dataModify.initCumulative() : this.points.forEach((t12) => {
            delete t12.cumulativeSum;
          });
        }
        function l10(t11, e11) {
          this.setModifier("cumulative", t11, e11);
        }
        t10.compose = function(t11, d11, c10) {
          let p10 = d11.prototype, u2 = c10.prototype, g2 = t11.prototype;
          return g2.setCompare || (g2.setCompare = r10, g2.setCumulative = h10, lL(t11, "afterInit", s10), lL(t11, "afterGetExtremes", o10), lL(t11, "afterProcessData", a10)), p10.setCompare || (p10.setCompare = n10, p10.setModifier = e10, p10.setCumulative = l10, u2.tooltipFormatter = i10), t11;
        };
        class d10 {
          constructor(t11) {
            this.series = t11;
          }
          modifyValue() {
            return 0;
          }
          static getCumulativeExtremes(t11) {
            let e11 = 1 / 0, i11 = -1 / 0;
            return t11.reduce((t12, s11) => {
              let o11 = t12 + s11;
              return e11 = Math.min(e11, o11, t12), i11 = Math.max(i11, o11, t12), o11;
            }), [e11, i11];
          }
          initCompare(t11) {
            this.modifyValue = function(e11, i11) {
              null === e11 && (e11 = 0);
              let s11 = this.compareValue;
              if (void 0 !== e11 && void 0 !== s11) {
                if ("value" === t11 ? e11 -= s11 : e11 = e11 / s11 * 100 - (100 === this.series.options.compareBase ? 0 : 100), void 0 !== i11) {
                  let t12 = this.series.points[i11];
                  t12 && (t12.change = e11);
                }
                return e11;
              }
              return 0;
            };
          }
          initCumulative() {
            this.modifyValue = function(t11, e11) {
              if (null === t11 && (t11 = 0), void 0 !== t11 && void 0 !== e11) {
                let i11 = e11 > 0 ? this.series.points[e11 - 1] : null;
                i11 && i11.cumulativeSum && (t11 = lI(i11.cumulativeSum + t11));
                let s11 = this.series.points[e11], o11 = s11.series.options.cumulativeStart, r11 = s11.x <= this.series.xAxis.max && s11.x >= this.series.xAxis.min;
                return s11 && (!o11 || r11 ? s11.cumulativeSum = t11 : s11.cumulativeSum = void 0), t11;
              }
              return 0;
            };
          }
        }
        t10.Additions = d10;
      }(w || (w = {}));
      let lX = w, {
        isTouchDevice: lH
      } = L, {
        addEvent: lF,
        merge: lY,
        pick: lj
      } = ti, lU = [];
      function lV() {
        this.navigator && this.navigator.setBaseSeries(null, false);
      }
      function l_() {
        let t10, e10, i10;
        let s10 = this.legend, o10 = this.navigator;
        if (o10) {
          t10 = s10 && s10.options, e10 = o10.xAxis, i10 = o10.yAxis;
          let {
            scrollbarHeight: r10,
            scrollButtonSize: a10
          } = o10;
          this.inverted ? (o10.left = o10.opposite ? this.chartWidth - r10 - o10.height : this.spacing[3] + r10, o10.top = this.plotTop + a10) : (o10.left = lj(e10.left, this.plotLeft + a10), o10.top = o10.navigatorOptions.top || this.chartHeight - o10.height - r10 - (this.scrollbar?.options.margin || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t10 && "bottom" === t10.verticalAlign && "proximate" !== t10.layout && t10.enabled && !t10.floating ? s10.legendHeight + lj(t10.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e10 && i10 && (this.inverted ? e10.options.left = i10.options.left = o10.left : e10.options.top = i10.options.top = o10.top, e10.setAxisSize(), i10.setAxisSize());
        }
      }
      function l$(t10) {
        !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new i(this), lj(t10.redraw, true) && this.redraw(t10.animation));
      }
      function lZ() {
        let t10 = this.options;
        (t10.navigator.enabled || t10.scrollbar.enabled) && (this.scroller = this.navigator = new i(this));
      }
      function lq() {
        let t10 = this.options, e10 = t10.navigator, i10 = t10.rangeSelector;
        if ((e10 && e10.enabled || i10 && i10.enabled) && (!lH && "x" === this.zooming.type || lH && "x" === this.zooming.pinchType)) return false;
      }
      function lK(t10) {
        let e10 = t10.navigator;
        if (e10 && t10.xAxis[0]) {
          let i10 = t10.xAxis[0].getExtremes();
          e10.render(i10.min, i10.max);
        }
      }
      function lJ(t10) {
        let e10 = t10.options.navigator || {}, i10 = t10.options.scrollbar || {};
        !this.navigator && !this.scroller && (e10.enabled || i10.enabled) && (lY(true, this.options.navigator, e10), lY(true, this.options.scrollbar, i10), delete t10.options.navigator, delete t10.options.scrollbar);
      }
      let lQ = {
        compose: function(t10, e10) {
          if (ti.pushUnique(lU, t10)) {
            let s10 = t10.prototype;
            i = e10, s10.callbacks.push(lK), lF(t10, "afterAddSeries", lV), lF(t10, "afterSetChartSize", l_), lF(t10, "afterUpdate", l$), lF(t10, "beforeRender", lZ), lF(t10, "beforeShowResetZoom", lq), lF(t10, "update", lJ);
          }
        }
      }, {
        isTouchDevice: l0
      } = L, {
        addEvent: l1,
        correctFloat: l2,
        defined: l3,
        isNumber: l5,
        pick: l6
      } = ti;
      function l9() {
        this.navigatorAxis || (this.navigatorAxis = new l8(this));
      }
      function l4(t10) {
        let e10;
        let i10 = this.chart, s10 = i10.options, o10 = s10.navigator, r10 = this.navigatorAxis, a10 = i10.zooming.pinchType, n10 = s10.rangeSelector, h10 = i10.zooming.type;
        if (this.isXAxis && (o10?.enabled || n10?.enabled)) {
          if ("y" === h10 && "zoom" === t10.trigger) e10 = false;
          else if (("zoom" === t10.trigger && "xy" === h10 || l0 && "xy" === a10) && this.options.range) {
            let e11 = r10.previousZoom;
            l3(t10.min) ? r10.previousZoom = [this.min, this.max] : e11 && (t10.min = e11[0], t10.max = e11[1], r10.previousZoom = void 0);
          }
        }
        void 0 !== e10 && t10.preventDefault();
      }
      class l8 {
        static compose(t10) {
          t10.keepProps.includes("navigatorAxis") || (t10.keepProps.push("navigatorAxis"), l1(t10, "init", l9), l1(t10, "setExtremes", l4));
        }
        constructor(t10) {
          this.axis = t10;
        }
        destroy() {
          this.axis = void 0;
        }
        toFixedRange(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = (o10.pointRange || 0) / 2, a10 = l6(i10, o10.translate(t10, true, !o10.horiz)), n10 = l6(s10, o10.translate(e10, true, !o10.horiz));
          return l3(i10) || (a10 = l2(a10 + r10)), l3(s10) || (n10 = l2(n10 - r10)), l5(a10) && l5(n10) || (a10 = n10 = void 0), {
            min: a10,
            max: n10
          };
        }
      }
      let {
        parse: l7
      } = tL, {
        seriesTypes: dt
      } = rv, de = {
        height: 40,
        margin: 25,
        maskInside: true,
        handles: {
          width: 7,
          borderRadius: 0,
          height: 15,
          symbols: ["navigator-handle", "navigator-handle"],
          enabled: true,
          lineWidth: 1,
          backgroundColor: "#f2f2f2",
          borderColor: "#999999"
        },
        maskFill: l7("#667aff").setOpacity(0.3).get(),
        outlineColor: "#999999",
        outlineWidth: 1,
        series: {
          type: void 0 === dt.areaspline ? "line" : "areaspline",
          fillOpacity: 0.05,
          lineWidth: 1,
          compare: null,
          sonification: {
            enabled: false
          },
          dataGrouping: {
            approximation: "average",
            enabled: true,
            groupPixelWidth: 2,
            firstAnchor: "firstPoint",
            anchor: "middle",
            lastAnchor: "lastPoint",
            units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
          },
          dataLabels: {
            enabled: false,
            zIndex: 2
          },
          id: "highcharts-navigator-series",
          className: "highcharts-navigator-series",
          lineColor: null,
          marker: {
            enabled: false
          },
          threshold: null
        },
        xAxis: {
          className: "highcharts-navigator-xaxis",
          tickLength: 0,
          lineWidth: 0,
          gridLineColor: "#e6e6e6",
          id: "navigator-x-axis",
          gridLineWidth: 1,
          tickPixelInterval: 200,
          labels: {
            align: "left",
            style: {
              color: "#000000",
              fontSize: "0.7em",
              opacity: 0.6,
              textOutline: "2px contrast"
            },
            x: 3,
            y: -4
          },
          crosshair: false
        },
        yAxis: {
          className: "highcharts-navigator-yaxis",
          gridLineWidth: 0,
          startOnTick: false,
          endOnTick: false,
          minPadding: 0.1,
          id: "navigator-y-axis",
          maxPadding: 0.1,
          labels: {
            enabled: false
          },
          crosshair: false,
          title: {
            text: null
          },
          tickLength: 0,
          tickWidth: 0
        }
      }, {
        relativeLength: di
      } = ti, ds = {
        "navigator-handle": function(t10, e10, i10, s10, o10 = {}) {
          let r10 = o10.width ? o10.width / 2 : i10, a10 = di(o10.borderRadius || 0, Math.min(2 * r10, s10));
          return [["M", -1.5, (s10 = o10.height || s10) / 2 - 3.5], ["L", -1.5, s10 / 2 + 4.5], ["M", 0.5, s10 / 2 - 3.5], ["L", 0.5, s10 / 2 + 4.5], ...ir.rect(-r10 - 1, 0.5, 2 * r10 + 1, s10, {
            r: a10
          })];
        }
      }, {
        defined: dr
      } = ti, da = {
        setFixedRange: function(t10) {
          let e10 = this.xAxis[0];
          dr(e10.dataMax) && dr(e10.dataMin) && t10 ? this.fixedRange = Math.min(t10, e10.dataMax - e10.dataMin) : this.fixedRange = t10;
        }
      }, {
        setOptions: dn
      } = tT, {
        composed: dh
      } = L, {
        getRendererType: dl
      } = ef, {
        setFixedRange: dd
      } = da, {
        addEvent: dc,
        extend: dp,
        pushUnique: du
      } = ti;
      function dg() {
        this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
      }
      let df = {
        compose: function(t10, e10, i10) {
          l8.compose(e10), du(dh, "Navigator") && (t10.prototype.setFixedRange = dd, dp(dl().prototype.symbols, ds), dc(i10, "afterUpdate", dg), dn({
            navigator: de
          }));
        }
      }, {
        composed: dm
      } = L, {
        addEvent: dx,
        defined: dy,
        pick: db,
        pushUnique: dv
      } = ti;
      !function(t10) {
        let e10;
        function i10(t11) {
          let e11 = db(t11.options && t11.options.min, t11.min), i11 = db(t11.options && t11.options.max, t11.max);
          return {
            axisMin: e11,
            axisMax: i11,
            scrollMin: dy(t11.dataMin) ? Math.min(e11, t11.min, t11.dataMin, db(t11.threshold, 1 / 0)) : e11,
            scrollMax: dy(t11.dataMax) ? Math.max(i11, t11.max, t11.dataMax, db(t11.threshold, -1 / 0)) : i11
          };
        }
        function s10() {
          let t11 = this.scrollbar, e11 = t11 && !t11.options.opposite, i11 = this.horiz ? 2 : e11 ? 3 : 1;
          t11 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i11] += t11.size + (t11.options.margin || 0));
        }
        function o10() {
          let t11 = this;
          t11.options && t11.options.scrollbar && t11.options.scrollbar.enabled && (t11.options.scrollbar.vertical = !t11.horiz, t11.options.startOnTick = t11.options.endOnTick = false, t11.scrollbar = new e10(t11.chart.renderer, t11.options.scrollbar, t11.chart), dx(t11.scrollbar, "changed", function(e11) {
            let s11, o11;
            let {
              axisMin: r11,
              axisMax: a10,
              scrollMin: n10,
              scrollMax: h10
            } = i10(t11), l10 = h10 - n10;
            if (dy(r11) && dy(a10)) {
              if (t11.horiz && !t11.reversed || !t11.horiz && t11.reversed ? (s11 = n10 + l10 * this.to, o11 = n10 + l10 * this.from) : (s11 = n10 + l10 * (1 - this.from), o11 = n10 + l10 * (1 - this.to)), this.shouldUpdateExtremes(e11.DOMType)) {
                let i11 = "mousemove" !== e11.DOMType && "touchmove" !== e11.DOMType && void 0;
                t11.setExtremes(o11, s11, true, i11, e11);
              } else this.setRange(this.from, this.to);
            }
          }));
        }
        function r10() {
          let t11, e11, s11;
          let {
            scrollMin: o11,
            scrollMax: r11
          } = i10(this), a10 = this.scrollbar, n10 = this.axisTitleMargin + (this.titleOffset || 0), h10 = this.chart.scrollbarsOffsets, l10 = this.options.margin || 0;
          if (a10 && h10) {
            if (this.horiz) this.opposite || (h10[1] += n10), a10.position(this.left, this.top + this.height + 2 + h10[1] - (this.opposite ? l10 : 0), this.width, this.height), this.opposite || (h10[1] += l10), t11 = 1;
            else {
              let e12;
              this.opposite && (h10[0] += n10), e12 = a10.options.opposite ? this.left + this.width + 2 + h10[0] - (this.opposite ? 0 : l10) : this.opposite ? 0 : l10, a10.position(e12, this.top, this.width, this.height), this.opposite && (h10[0] += l10), t11 = 0;
            }
            if (h10[t11] += a10.size + (a10.options.margin || 0), isNaN(o11) || isNaN(r11) || !dy(this.min) || !dy(this.max) || this.dataMin === this.dataMax) a10.setRange(0, 1);
            else if (this.min === this.max) {
              let t12 = this.pointRange / (this.dataMax + 1);
              e11 = t12 * this.min, s11 = t12 * (this.max + 1), a10.setRange(e11, s11);
            } else e11 = (this.min - o11) / (r11 - o11), s11 = (this.max - o11) / (r11 - o11), this.horiz && !this.reversed || !this.horiz && this.reversed ? a10.setRange(e11, s11) : a10.setRange(1 - s11, 1 - e11);
          }
        }
        t10.compose = function(t11, i11) {
          dv(dm, "Axis.Scrollbar") && (e10 = i11, dx(t11, "afterGetOffset", s10), dx(t11, "afterInit", o10), dx(t11, "afterRender", r10));
        };
      }(S || (S = {}));
      let dk = S, dM = {
        height: 10,
        barBorderRadius: 5,
        buttonBorderRadius: 0,
        buttonsEnabled: false,
        liveRedraw: void 0,
        margin: void 0,
        minWidth: 6,
        opposite: true,
        step: 0.2,
        zIndex: 3,
        barBackgroundColor: "#cccccc",
        barBorderWidth: 0,
        barBorderColor: "#cccccc",
        buttonArrowColor: "#333333",
        buttonBackgroundColor: "#e6e6e6",
        buttonBorderColor: "#cccccc",
        buttonBorderWidth: 1,
        rifleColor: "none",
        trackBackgroundColor: "rgba(255, 255, 255, 0.001)",
        trackBorderColor: "#cccccc",
        trackBorderRadius: 5,
        trackBorderWidth: 1
      }, {
        defaultOptions: dw
      } = tT, {
        addEvent: dS,
        correctFloat: dA,
        crisp: dT,
        defined: dC,
        destroyObjectProperties: dP,
        fireEvent: dO,
        merge: dE,
        pick: dL,
        removeEvent: dD
      } = ti;
      class dB {
        static compose(t10) {
          dk.compose(t10, dB);
        }
        static swapXY(t10, e10) {
          return e10 && t10.forEach((t11) => {
            let e11;
            let i10 = t11.length;
            for (let s10 = 0; s10 < i10; s10 += 2) "number" == typeof (e11 = t11[s10 + 1]) && (t11[s10 + 1] = t11[s10 + 2], t11[s10 + 2] = e11);
          }), t10;
        }
        constructor(t10, e10, i10) {
          this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t10, e10, i10);
        }
        addEvents() {
          let t10 = this.options.inverted ? [1, 0] : [0, 1], e10 = this.scrollbarButtons, i10 = this.scrollbarGroup.element, s10 = this.track.element, o10 = this.mouseDownHandler.bind(this), r10 = this.mouseMoveHandler.bind(this), a10 = this.mouseUpHandler.bind(this), n10 = [[e10[t10[0]].element, "click", this.buttonToMinClick.bind(this)], [e10[t10[1]].element, "click", this.buttonToMaxClick.bind(this)], [s10, "click", this.trackClick.bind(this)], [i10, "mousedown", o10], [i10.ownerDocument, "mousemove", r10], [i10.ownerDocument, "mouseup", a10], [i10, "touchstart", o10], [i10.ownerDocument, "touchmove", r10], [i10.ownerDocument, "touchend", a10]];
          n10.forEach(function(t11) {
            dS.apply(null, t11);
          }), this._events = n10;
        }
        buttonToMaxClick(t10) {
          let e10 = (this.to - this.from) * dL(this.options.step, 0.2);
          this.updatePosition(this.from + e10, this.to + e10), dO(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMEvent: t10
          });
        }
        buttonToMinClick(t10) {
          let e10 = dA(this.to - this.from) * dL(this.options.step, 0.2);
          this.updatePosition(dA(this.from - e10), dA(this.to - e10)), dO(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMEvent: t10
          });
        }
        cursorToScrollbarPosition(t10) {
          let e10 = this.options, i10 = e10.minWidth > this.calculatedWidth ? e10.minWidth : 0;
          return {
            chartX: (t10.chartX - this.x - this.xOffset) / (this.barWidth - i10),
            chartY: (t10.chartY - this.y - this.yOffset) / (this.barWidth - i10)
          };
        }
        destroy() {
          let t10 = this, e10 = t10.chart.scroller;
          t10.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(e11) {
            t10[e11] && t10[e11].destroy && (t10[e11] = t10[e11].destroy());
          }), e10 && t10 === e10.scrollbar && (e10.scrollbar = null, dP(e10.scrollbarButtons));
        }
        drawScrollbarButton(t10) {
          let e10 = this.renderer, i10 = this.scrollbarButtons, s10 = this.options, o10 = this.size, r10 = e10.g().add(this.group);
          if (i10.push(r10), s10.buttonsEnabled) {
            let a10 = e10.rect().addClass("highcharts-scrollbar-button").add(r10);
            this.chart.styledMode || a10.attr({
              stroke: s10.buttonBorderColor,
              "stroke-width": s10.buttonBorderWidth,
              fill: s10.buttonBackgroundColor
            }), a10.attr(a10.crisp({
              x: -0.5,
              y: -0.5,
              width: o10,
              height: o10,
              r: s10.buttonBorderRadius
            }, a10.strokeWidth()));
            let n10 = e10.path(dB.swapXY([["M", o10 / 2 + (t10 ? -1 : 1), o10 / 2 - 3], ["L", o10 / 2 + (t10 ? -1 : 1), o10 / 2 + 3], ["L", o10 / 2 + (t10 ? 2 : -2), o10 / 2]], s10.vertical)).addClass("highcharts-scrollbar-arrow").add(i10[t10]);
            this.chart.styledMode || n10.attr({
              fill: s10.buttonArrowColor
            });
          }
        }
        init(t10, e10, i10) {
          this.scrollbarButtons = [], this.renderer = t10, this.userOptions = e10, this.options = dE(dM, dw.scrollbar, e10), this.options.margin = dL(this.options.margin, 10), this.chart = i10, this.size = dL(this.options.size, this.options.height), e10.enabled && (this.render(), this.addEvents());
        }
        mouseDownHandler(t10) {
          let e10 = this.chart.pointer?.normalize(t10) || t10, i10 = this.cursorToScrollbarPosition(e10);
          this.chartX = i10.chartX, this.chartY = i10.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = true;
        }
        mouseMoveHandler(t10) {
          let e10;
          let i10 = this.chart.pointer?.normalize(t10) || t10, s10 = this.options.vertical ? "chartY" : "chartX", o10 = this.initPositions || [];
          this.grabbedCenter && (!t10.touches || 0 !== t10.touches[0][s10]) && (e10 = this.cursorToScrollbarPosition(i10)[s10] - this[s10], this.hasDragged = true, this.updatePosition(o10[0] + e10, o10[1] + e10), this.hasDragged && dO(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMType: t10.type,
            DOMEvent: t10
          }));
        }
        mouseUpHandler(t10) {
          this.hasDragged && dO(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMType: t10.type,
            DOMEvent: t10
          }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
        }
        position(t10, e10, i10, s10) {
          let {
            buttonsEnabled: o10,
            margin: r10 = 0,
            vertical: a10
          } = this.options, n10 = this.rendered ? "animate" : "attr", h10 = s10, l10 = 0;
          this.group.show(), this.x = t10, this.y = e10 + this.trackBorderWidth, this.width = i10, this.height = s10, this.xOffset = h10, this.yOffset = l10, a10 ? (this.width = this.yOffset = i10 = l10 = this.size, this.xOffset = h10 = 0, this.yOffset = l10 = o10 ? this.size : 0, this.barWidth = s10 - (o10 ? 2 * i10 : 0), this.x = t10 += r10) : (this.height = s10 = this.size, this.xOffset = h10 = o10 ? this.size : 0, this.barWidth = i10 - (o10 ? 2 * s10 : 0), this.y = this.y + r10), this.group[n10]({
            translateX: t10,
            translateY: this.y
          }), this.track[n10]({
            width: i10,
            height: s10
          }), this.scrollbarButtons[1][n10]({
            translateX: a10 ? 0 : i10 - h10,
            translateY: a10 ? s10 - l10 : 0
          });
        }
        removeEvents() {
          this._events.forEach(function(t10) {
            dD.apply(null, t10);
          }), this._events.length = 0;
        }
        render() {
          let t10 = this.renderer, e10 = this.options, i10 = this.size, s10 = this.chart.styledMode, o10 = t10.g("scrollbar").attr({
            zIndex: e10.zIndex
          }).hide().add();
          this.group = o10, this.track = t10.rect().addClass("highcharts-scrollbar-track").attr({
            r: e10.trackBorderRadius || 0,
            height: i10,
            width: i10
          }).add(o10), s10 || this.track.attr({
            fill: e10.trackBackgroundColor,
            stroke: e10.trackBorderColor,
            "stroke-width": e10.trackBorderWidth
          });
          let r10 = this.trackBorderWidth = this.track.strokeWidth();
          this.track.attr({
            x: -dT(0, r10),
            y: -dT(0, r10)
          }), this.scrollbarGroup = t10.g().add(o10), this.scrollbar = t10.rect().addClass("highcharts-scrollbar-thumb").attr({
            height: i10 - r10,
            width: i10 - r10,
            r: e10.barBorderRadius || 0
          }).add(this.scrollbarGroup), this.scrollbarRifles = t10.path(dB.swapXY([["M", -3, i10 / 4], ["L", -3, 2 * i10 / 3], ["M", 0, i10 / 4], ["L", 0, 2 * i10 / 3], ["M", 3, i10 / 4], ["L", 3, 2 * i10 / 3]], e10.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s10 || (this.scrollbar.attr({
            fill: e10.barBackgroundColor,
            stroke: e10.barBorderColor,
            "stroke-width": e10.barBorderWidth
          }), this.scrollbarRifles.attr({
            stroke: e10.rifleColor,
            "stroke-width": 1
          })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-dT(0, this.scrollbarStrokeWidth), -dT(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
        }
        setRange(t10, e10) {
          let i10, s10;
          let o10 = this.options, r10 = o10.vertical, a10 = o10.minWidth, n10 = this.barWidth, h10 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
          if (!dC(n10)) return;
          let l10 = n10 * Math.min(e10, 1);
          i10 = Math.ceil(n10 * (t10 = Math.max(t10, 0))), this.calculatedWidth = s10 = dA(l10 - i10), s10 < a10 && (i10 = (n10 - a10 + s10) * t10, s10 = a10);
          let d10 = Math.floor(i10 + this.xOffset + this.yOffset), c10 = s10 / 2 - 0.5;
          this.from = t10, this.to = e10, r10 ? (this.scrollbarGroup[h10]({
            translateY: d10
          }), this.scrollbar[h10]({
            height: s10
          }), this.scrollbarRifles[h10]({
            translateY: c10
          }), this.scrollbarTop = d10, this.scrollbarLeft = 0) : (this.scrollbarGroup[h10]({
            translateX: d10
          }), this.scrollbar[h10]({
            width: s10
          }), this.scrollbarRifles[h10]({
            translateX: c10
          }), this.scrollbarLeft = d10, this.scrollbarTop = 0), s10 <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), false === o10.showFull && (t10 <= 0 && e10 >= 1 ? this.group.hide() : this.group.show()), this.rendered = true;
        }
        shouldUpdateExtremes(t10) {
          return dL(this.options.liveRedraw, L.svg && !L.isTouchDevice && !this.chart.boosted) || "mouseup" === t10 || "touchend" === t10 || !dC(t10);
        }
        trackClick(t10) {
          let e10 = this.chart.pointer?.normalize(t10) || t10, i10 = this.to - this.from, s10 = this.y + this.scrollbarTop, o10 = this.x + this.scrollbarLeft;
          this.options.vertical && e10.chartY > s10 || !this.options.vertical && e10.chartX > o10 ? this.updatePosition(this.from + i10, this.to + i10) : this.updatePosition(this.from - i10, this.to - i10), dO(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMEvent: t10
          });
        }
        update(t10) {
          this.destroy(), this.init(this.chart.renderer, dE(true, this.options, t10), this.chart);
        }
        updatePosition(t10, e10) {
          e10 > 1 && (t10 = dA(1 - dA(e10 - t10)), e10 = 1), t10 < 0 && (e10 = dA(e10 - t10), t10 = 0), this.from = t10, this.to = e10;
        }
      }
      dB.defaultOptions = dM, dw.scrollbar = dE(true, dB.defaultOptions, dw.scrollbar);
      let {
        defaultOptions: dI
      } = tT, {
        isTouchDevice: dz
      } = L, {
        prototype: {
          symbols: dR
        }
      } = i_, {
        addEvent: dN,
        clamp: dW,
        correctFloat: dG,
        defined: dX,
        destroyObjectProperties: dH,
        erase: dF,
        extend: dY,
        find: dj,
        fireEvent: dU,
        isArray: dV,
        isNumber: d_,
        merge: d$,
        pick: dZ,
        removeEvent: dq,
        splat: dK
      } = ti;
      function dJ(t10, ...e10) {
        let i10 = [].filter.call(e10, d_);
        if (i10.length) return Math[t10].apply(0, i10);
      }
      class dQ {
        static compose(t10, e10, i10) {
          lQ.compose(t10, dQ), df.compose(t10, e10, i10);
        }
        constructor(t10) {
          this.isDirty = false, this.scrollbarHeight = 0, this.init(t10);
        }
        drawHandle(t10, e10, i10, s10) {
          let o10 = this.navigatorOptions.handles.height;
          this.handles[e10][s10](i10 ? {
            translateX: Math.round(this.left + this.height / 2),
            translateY: Math.round(this.top + parseInt(t10, 10) + 0.5 - o10)
          } : {
            translateX: Math.round(this.left + parseInt(t10, 10)),
            translateY: Math.round(this.top + this.height / 2 - o10 / 2 - 1)
          });
        }
        drawOutline(t10, e10, i10, s10) {
          let o10 = this.navigatorOptions.maskInside, r10 = this.outline.strokeWidth(), a10 = r10 / 2, n10 = r10 % 2 / 2, h10 = this.scrollButtonSize, l10 = this.size, d10 = this.top, c10 = this.height, p10 = d10 - a10, u2 = d10 + c10, g2 = this.left, f2, m2;
          i10 ? (f2 = d10 + e10 + n10, e10 = d10 + t10 + n10, m2 = [["M", g2 + c10, d10 - h10 - n10], ["L", g2 + c10, f2], ["L", g2, f2], ["M", g2, e10], ["L", g2 + c10, e10], ["L", g2 + c10, d10 + l10 + h10]], o10 && m2.push(["M", g2 + c10, f2 - a10], ["L", g2 + c10, e10 + a10])) : (g2 -= h10, t10 += g2 + h10 - n10, e10 += g2 + h10 - n10, m2 = [["M", g2, p10], ["L", t10, p10], ["L", t10, u2], ["M", e10, u2], ["L", e10, p10], ["L", g2 + l10 + 2 * h10, p10]], o10 && m2.push(["M", t10 - a10, p10], ["L", e10 + a10, p10])), this.outline[s10]({
            d: m2
          });
        }
        drawMasks(t10, e10, i10, s10) {
          let o10, r10, a10, n10;
          let h10 = this.left, l10 = this.top, d10 = this.height;
          i10 ? (a10 = [h10, h10, h10], n10 = [l10, l10 + t10, l10 + e10], r10 = [d10, d10, d10], o10 = [t10, e10 - t10, this.size - e10]) : (a10 = [h10, h10 + t10, h10 + e10], n10 = [l10, l10, l10], r10 = [t10, e10 - t10, this.size - e10], o10 = [d10, d10, d10]), this.shades.forEach((t11, e11) => {
            t11[s10]({
              x: a10[e11],
              y: n10[e11],
              width: r10[e11],
              height: o10[e11]
            });
          });
        }
        renderElements() {
          let t10 = this, e10 = t10.navigatorOptions, i10 = e10.maskInside, s10 = t10.chart, o10 = s10.inverted, r10 = s10.renderer, a10 = {
            cursor: o10 ? "ns-resize" : "ew-resize"
          }, n10 = t10.navigatorGroup ?? (t10.navigatorGroup = r10.g("navigator").attr({
            zIndex: 8,
            visibility: "hidden"
          }).add());
          if ([!i10, i10, !i10].forEach((i11, o11) => {
            let h10 = t10.shades[o11] ?? (t10.shades[o11] = r10.rect().addClass("highcharts-navigator-mask" + (1 === o11 ? "-inside" : "-outside")).add(n10));
            s10.styledMode || (h10.attr({
              fill: i11 ? e10.maskFill : "rgba(0,0,0,0)"
            }), 1 === o11 && h10.css(a10));
          }), t10.outline || (t10.outline = r10.path().addClass("highcharts-navigator-outline").add(n10)), s10.styledMode || t10.outline.attr({
            "stroke-width": e10.outlineWidth,
            stroke: e10.outlineColor
          }), e10.handles?.enabled) {
            let i11 = e10.handles, {
              height: o11,
              width: h10
            } = i11;
            [0, 1].forEach((e11) => {
              let l10 = i11.symbols[e11];
              if (t10.handles[e11] && t10.handles[e11].symbolUrl === l10) {
                if (!t10.handles[e11].isImg && t10.handles[e11].symbolName !== l10) {
                  let i12 = dR[l10].call(dR, -h10 / 2 - 1, 0, h10, o11);
                  t10.handles[e11].attr({
                    d: i12
                  }), t10.handles[e11].symbolName = l10;
                }
              } else t10.handles[e11]?.destroy(), t10.handles[e11] = r10.symbol(l10, -h10 / 2 - 1, 0, h10, o11, i11), t10.handles[e11].attr({
                zIndex: 7 - e11
              }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][e11]).add(n10), t10.addMouseEvents();
              s10.inverted && t10.handles[e11].attr({
                rotation: 90,
                rotationOriginX: Math.floor(-h10 / 2),
                rotationOriginY: (o11 + h10) / 2
              }), s10.styledMode || t10.handles[e11].attr({
                fill: i11.backgroundColor,
                stroke: i11.borderColor,
                "stroke-width": i11.lineWidth,
                width: i11.width,
                height: i11.height,
                x: -h10 / 2 - 1,
                y: 0
              }).css(a10);
            });
          }
        }
        update(t10, e10 = false) {
          let i10 = this.chart, s10 = i10.options.chart.inverted !== i10.scrollbar?.options.vertical;
          if (d$(true, i10.options.navigator, t10), this.navigatorOptions = i10.options.navigator || {}, this.setOpposite(), dX(t10.enabled) || s10) return this.destroy(), this.navigatorEnabled = t10.enabled || this.navigatorEnabled, this.init(i10);
          if (this.navigatorEnabled && (this.isDirty = true, false === t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            dq(t11, "updatedData", this.updatedDataHandler);
          }, this), t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            t11.eventsToUnbind.push(dN(t11, "updatedData", this.updatedDataHandler));
          }, this), (t10.series || t10.baseSeries) && this.setBaseSeries(void 0, false), t10.height || t10.xAxis || t10.yAxis)) {
            this.height = t10.height ?? this.height;
            let e11 = this.getXAxisOffsets();
            this.xAxis.update(__spreadProps(__spreadValues({}, t10.xAxis), {
              offsets: e11,
              [i10.inverted ? "width" : "height"]: this.height,
              [i10.inverted ? "height" : "width"]: void 0
            }), false), this.yAxis.update(__spreadProps(__spreadValues({}, t10.yAxis), {
              [i10.inverted ? "width" : "height"]: this.height
            }), false);
          }
          e10 && i10.redraw();
        }
        render(t10, e10, i10, s10) {
          let o10 = this.chart, r10 = this.xAxis, a10 = r10.pointRange || 0, n10 = r10.navigatorAxis.fake ? o10.xAxis[0] : r10, h10 = this.navigatorEnabled, l10 = this.rendered, d10 = o10.inverted, c10 = o10.xAxis[0].minRange, p10 = o10.xAxis[0].options.maxRange, u2 = this.scrollButtonSize, g2, f2, m2, x2 = this.scrollbarHeight, y2, b2;
          if (this.hasDragged && !dX(i10)) return;
          if (this.isDirty && this.renderElements(), t10 = dG(t10 - a10 / 2), e10 = dG(e10 + a10 / 2), !d_(t10) || !d_(e10)) {
            if (!l10) return;
            i10 = 0, s10 = dZ(r10.width, n10.width);
          }
          this.left = dZ(r10.left, o10.plotLeft + u2 + (d10 ? o10.plotWidth : 0));
          let v2 = this.size = y2 = dZ(r10.len, (d10 ? o10.plotHeight : o10.plotWidth) - 2 * u2);
          g2 = d10 ? x2 : y2 + 2 * u2, i10 = dZ(i10, r10.toPixels(t10, true)), s10 = dZ(s10, r10.toPixels(e10, true)), d_(i10) && Math.abs(i10) !== 1 / 0 || (i10 = 0, s10 = g2);
          let k2 = r10.toValue(i10, true), M2 = r10.toValue(s10, true), w2 = Math.abs(dG(M2 - k2));
          w2 < c10 ? this.grabbedLeft ? i10 = r10.toPixels(M2 - c10 - a10, true) : this.grabbedRight && (s10 = r10.toPixels(k2 + c10 + a10, true)) : dX(p10) && dG(w2 - a10) > p10 && (this.grabbedLeft ? i10 = r10.toPixels(M2 - p10 - a10, true) : this.grabbedRight && (s10 = r10.toPixels(k2 + p10 + a10, true))), this.zoomedMax = dW(Math.max(i10, s10), 0, v2), this.zoomedMin = dW(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i10, s10), 0, v2), this.range = this.zoomedMax - this.zoomedMin, v2 = Math.round(this.zoomedMax);
          let S2 = Math.round(this.zoomedMin);
          h10 && (this.navigatorGroup.attr({
            visibility: "inherit"
          }), b2 = l10 && !this.hasDragged ? "animate" : "attr", this.drawMasks(S2, v2, d10, b2), this.drawOutline(S2, v2, d10, b2), this.navigatorOptions.handles.enabled && (this.drawHandle(S2, 0, d10, b2), this.drawHandle(v2, 1, d10, b2))), this.scrollbar && (d10 ? (m2 = this.top - u2, f2 = this.left - x2 + (h10 || !n10.opposite ? 0 : (n10.titleOffset || 0) + n10.axisTitleMargin), x2 = y2 + 2 * u2) : (m2 = this.top + (h10 ? this.height : -x2), f2 = this.left - u2), this.scrollbar.position(f2, m2, g2, x2), this.scrollbar.setRange(this.zoomedMin / (y2 || 1), this.zoomedMax / (y2 || 1))), this.rendered = true, this.isDirty = false, dU(this, "afterRender");
        }
        addMouseEvents() {
          let t10 = this, e10 = t10.chart, i10 = e10.container, s10 = [], o10, r10;
          t10.mouseMoveHandler = o10 = function(e11) {
            t10.onMouseMove(e11);
          }, t10.mouseUpHandler = r10 = function(e11) {
            t10.onMouseUp(e11);
          }, (s10 = t10.getPartsEvents("mousedown")).push(dN(e10.renderTo, "mousemove", o10), dN(i10.ownerDocument, "mouseup", r10), dN(e10.renderTo, "touchmove", o10), dN(i10.ownerDocument, "touchend", r10)), s10.concat(t10.getPartsEvents("touchstart")), t10.eventsToUnbind = s10, t10.series && t10.series[0] && s10.push(dN(t10.series[0].xAxis, "foundExtremes", function() {
            e10.navigator.modifyNavigatorAxisExtremes();
          }));
        }
        getPartsEvents(t10) {
          let e10 = this, i10 = [];
          return ["shades", "handles"].forEach(function(s10) {
            e10[s10].forEach(function(o10, r10) {
              i10.push(dN(o10.element, t10, function(t11) {
                e10[s10 + "Mousedown"](t11, r10);
              }));
            });
          }), i10;
        }
        shadesMousedown(t10, e10) {
          t10 = this.chart.pointer?.normalize(t10) || t10;
          let i10 = this.chart, s10 = this.xAxis, o10 = this.zoomedMin, r10 = this.size, a10 = this.range, n10 = this.left, h10 = t10.chartX, l10, d10, c10, p10;
          i10.inverted && (h10 = t10.chartY, n10 = this.top), 1 === e10 ? (this.grabbedCenter = h10, this.fixedWidth = a10, this.dragOffset = h10 - o10) : (p10 = h10 - n10 - a10 / 2, 0 === e10 ? p10 = Math.max(0, p10) : 2 === e10 && p10 + a10 >= r10 && (p10 = r10 - a10, this.reversedExtremes ? (p10 -= a10, d10 = this.getUnionExtremes().dataMin) : l10 = this.getUnionExtremes().dataMax), p10 !== o10 && (this.fixedWidth = a10, dX((c10 = s10.navigatorAxis.toFixedRange(p10, p10 + a10, d10, l10)).min) && dU(this, "setRange", {
            min: Math.min(c10.min, c10.max),
            max: Math.max(c10.min, c10.max),
            redraw: true,
            eventArguments: {
              trigger: "navigator"
            }
          })));
        }
        handlesMousedown(t10, e10) {
          t10 = this.chart.pointer?.normalize(t10) || t10;
          let i10 = this.chart, s10 = i10.xAxis[0], o10 = this.reversedExtremes;
          0 === e10 ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o10 ? s10.min : s10.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o10 ? s10.max : s10.min), i10.setFixedRange(void 0);
        }
        onMouseMove(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.navigatorSize, o10 = e10.range, r10 = e10.dragOffset, a10 = i10.inverted, n10 = e10.left, h10;
          (!t10.touches || 0 !== t10.touches[0].pageX) && (h10 = (t10 = i10.pointer?.normalize(t10) || t10).chartX, a10 && (n10 = e10.top, h10 = t10.chartY), e10.grabbedLeft ? (e10.hasDragged = true, e10.render(0, 0, h10 - n10, e10.otherHandlePos)) : e10.grabbedRight ? (e10.hasDragged = true, e10.render(0, 0, e10.otherHandlePos, h10 - n10)) : e10.grabbedCenter && (e10.hasDragged = true, h10 < r10 ? h10 = r10 : h10 > s10 + r10 - o10 && (h10 = s10 + r10 - o10), e10.render(0, 0, h10 - r10, h10 - r10 + o10)), e10.hasDragged && e10.scrollbar && dZ(e10.scrollbar.options.liveRedraw, !dz && !this.chart.boosted) && (t10.DOMType = t10.type, setTimeout(function() {
            e10.onMouseUp(t10);
          }, 0)));
        }
        onMouseUp(t10) {
          let e10, i10, s10, o10, r10, a10;
          let n10 = this.chart, h10 = this.xAxis, l10 = this.scrollbar, d10 = t10.DOMEvent || t10, c10 = n10.inverted, p10 = this.rendered && !this.hasDragged ? "animate" : "attr";
          (this.hasDragged && (!l10 || !l10.hasDragged) || "scrollbar" === t10.trigger) && (s10 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o10 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r10 = this.fixedExtreme), this.zoomedMax === this.size && (r10 = this.reversedExtremes ? s10.dataMin : s10.dataMax), 0 === this.zoomedMin && (o10 = this.reversedExtremes ? s10.dataMax : s10.dataMin), dX((a10 = h10.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o10, r10)).min) && dU(this, "setRange", {
            min: Math.min(a10.min, a10.max),
            max: Math.max(a10.min, a10.max),
            redraw: true,
            animation: !this.hasDragged && null,
            eventArguments: {
              trigger: "navigator",
              triggerOp: "navigator-drag",
              DOMEvent: d10
            }
          })), "mousemove" !== t10.DOMType && "touchmove" !== t10.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && d_(this.zoomedMin) && d_(this.zoomedMax) && (i10 = Math.round(this.zoomedMin), e10 = Math.round(this.zoomedMax), this.shades && this.drawMasks(i10, e10, c10, p10), this.outline && this.drawOutline(i10, e10, c10, p10), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i10, 0, c10, p10), this.drawHandle(e10, 1, c10, p10)));
        }
        removeEvents() {
          this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t10) {
            t10();
          }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
        }
        removeBaseSeriesEvents() {
          let t10 = this.baseSeries || [];
          this.navigatorEnabled && t10[0] && (false !== this.navigatorOptions.adaptToUpdatedData && t10.forEach(function(t11) {
            dq(t11, "updatedData", this.updatedDataHandler);
          }, this), t10[0].xAxis && dq(t10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
        }
        getXAxisOffsets() {
          return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];
        }
        init(t10) {
          let e10 = t10.options, i10 = e10.navigator || {}, s10 = i10.enabled, o10 = e10.scrollbar || {}, r10 = o10.enabled, a10 = s10 && i10.height || 0, n10 = r10 && o10.height || 0, h10 = o10.buttonsEnabled && n10 || 0;
          this.handles = [], this.shades = [], this.chart = t10, this.setBaseSeries(), this.height = a10, this.scrollbarHeight = n10, this.scrollButtonSize = h10, this.scrollbarEnabled = r10, this.navigatorEnabled = s10, this.navigatorOptions = i10, this.scrollbarOptions = o10, this.setOpposite();
          let l10 = this, d10 = l10.baseSeries, c10 = t10.xAxis.length, p10 = t10.yAxis.length, u2 = d10 && d10[0] && d10[0].xAxis || t10.xAxis[0] || {
            options: {}
          };
          if (t10.isDirtyBox = true, l10.navigatorEnabled) {
            let e11 = this.getXAxisOffsets();
            l10.xAxis = new s_(t10, d$({
              breaks: u2.options.breaks,
              ordinal: u2.options.ordinal,
              overscroll: u2.options.overscroll
            }, i10.xAxis, {
              type: "datetime",
              yAxis: i10.yAxis?.id,
              index: c10,
              isInternal: true,
              offset: 0,
              keepOrdinalPadding: true,
              startOnTick: false,
              endOnTick: false,
              minPadding: u2.options.ordinal ? 0 : u2.options.minPadding,
              maxPadding: u2.options.ordinal ? 0 : u2.options.maxPadding,
              zoomEnabled: false
            }, t10.inverted ? {
              offsets: e11,
              width: a10
            } : {
              offsets: e11,
              height: a10
            }), "xAxis"), l10.yAxis = new s_(t10, d$(i10.yAxis, {
              alignTicks: false,
              offset: 0,
              index: p10,
              isInternal: true,
              reversed: dZ(i10.yAxis && i10.yAxis.reversed, t10.yAxis[0] && t10.yAxis[0].reversed, false),
              zoomEnabled: false
            }, t10.inverted ? {
              width: a10
            } : {
              height: a10
            }), "yAxis"), d10 || i10.series.data ? l10.updateNavigatorSeries(false) : 0 === t10.series.length && (l10.unbindRedraw = dN(t10, "beforeRedraw", function() {
              t10.series.length > 0 && !l10.series && (l10.setBaseSeries(), l10.unbindRedraw());
            })), l10.reversedExtremes = t10.inverted && !l10.xAxis.reversed || !t10.inverted && l10.xAxis.reversed, l10.renderElements(), l10.addMouseEvents();
          } else l10.xAxis = {
            chart: t10,
            navigatorAxis: {
              fake: true
            },
            translate: function(e11, i11) {
              let s11 = t10.xAxis[0], o11 = s11.getExtremes(), r11 = s11.len - 2 * h10, a11 = dJ("min", s11.options.min, o11.dataMin), n11 = dJ("max", s11.options.max, o11.dataMax) - a11;
              return i11 ? e11 * n11 / r11 + a11 : r11 * (e11 - a11) / n11;
            },
            toPixels: function(t11) {
              return this.translate(t11);
            },
            toValue: function(t11) {
              return this.translate(t11, true);
            }
          }, l10.xAxis.navigatorAxis.axis = l10.xAxis, l10.xAxis.navigatorAxis.toFixedRange = l8.prototype.toFixedRange.bind(l10.xAxis.navigatorAxis);
          if (t10.options.scrollbar.enabled) {
            let e11 = d$(t10.options.scrollbar, {
              vertical: t10.inverted
            });
            !d_(e11.margin) && l10.navigatorEnabled && (e11.margin = t10.inverted ? -3 : 3), t10.scrollbar = l10.scrollbar = new dB(t10.renderer, e11, t10), dN(l10.scrollbar, "changed", function(t11) {
              let e12 = l10.size, i11 = e12 * this.to, s11 = e12 * this.from;
              l10.hasDragged = l10.scrollbar.hasDragged, l10.render(0, 0, s11, i11), this.shouldUpdateExtremes(t11.DOMType) && setTimeout(function() {
                l10.onMouseUp(t11);
              });
            });
          }
          l10.addBaseSeriesEvents(), l10.addChartEvents();
        }
        setOpposite() {
          let t10 = this.navigatorOptions, e10 = this.navigatorEnabled, i10 = this.chart;
          this.opposite = dZ(t10.opposite, !!(!e10 && i10.inverted));
        }
        getUnionExtremes(t10) {
          let e10;
          let i10 = this.chart.xAxis[0], s10 = this.chart.time, o10 = this.xAxis, r10 = o10.options, a10 = i10.options;
          return t10 && null === i10.dataMin || (e10 = {
            dataMin: dZ(s10.parse(r10?.min), dJ("min", s10.parse(a10.min), i10.dataMin, o10.dataMin, o10.min)),
            dataMax: dZ(s10.parse(r10?.max), dJ("max", s10.parse(a10.max), i10.dataMax, o10.dataMax, o10.max))
          }), e10;
        }
        setBaseSeries(t10, e10) {
          let i10 = this.chart, s10 = this.baseSeries = [];
          t10 = t10 || i10.options && i10.options.navigator.baseSeries || (i10.series.length ? dj(i10.series, (t11) => !t11.options.isInternal).index : 0), (i10.series || []).forEach((e11, i11) => {
            !e11.options.isInternal && (e11.options.showInNavigator || (i11 === t10 || e11.options.id === t10) && false !== e11.options.showInNavigator) && s10.push(e11);
          }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, e10);
        }
        updateNavigatorSeries(t10, e10) {
          let i10 = this, s10 = i10.chart, o10 = i10.baseSeries, r10 = {
            enableMouseTracking: false,
            index: null,
            linkedTo: null,
            group: "nav",
            padXAxis: false,
            xAxis: this.navigatorOptions.xAxis?.id,
            yAxis: this.navigatorOptions.yAxis?.id,
            showInLegend: false,
            stacking: void 0,
            isInternal: true,
            states: {
              inactive: {
                opacity: 1
              }
            }
          }, a10 = i10.series = (i10.series || []).filter((t11) => {
            let e11 = t11.baseSeries;
            return !(0 > o10.indexOf(e11)) || (e11 && (dq(e11, "updatedData", i10.updatedDataHandler), delete e11.navigatorSeries), t11.chart && t11.destroy(), false);
          }), n10, h10, l10 = i10.navigatorOptions.series, d10;
          o10 && o10.length && o10.forEach((t11) => {
            let c10 = t11.navigatorSeries, p10 = dY({
              color: t11.color,
              visible: t11.visible
            }, dV(l10) ? dI.navigator.series : l10);
            if (c10 && false === i10.navigatorOptions.adaptToUpdatedData) return;
            r10.name = "Navigator " + o10.length, d10 = (n10 = t11.options || {}).navigatorOptions || {}, p10.dataLabels = dK(p10.dataLabels), (h10 = d$(n10, r10, p10, d10)).pointRange = dZ(p10.pointRange, d10.pointRange, dI.plotOptions[h10.type || "line"].pointRange);
            let u2 = d10.data || p10.data;
            i10.hasNavigatorData = i10.hasNavigatorData || !!u2, h10.data = u2 || n10.data?.slice(0), c10 && c10.options ? c10.update(h10, e10) : (t11.navigatorSeries = s10.initSeries(h10), s10.setSortedData(), t11.navigatorSeries.baseSeries = t11, a10.push(t11.navigatorSeries));
          }), (l10.data && !(o10 && o10.length) || dV(l10)) && (i10.hasNavigatorData = false, (l10 = dK(l10)).forEach((t11, e11) => {
            r10.name = "Navigator " + (a10.length + 1), (h10 = d$(dI.navigator.series, {
              color: s10.series[e11] && !s10.series[e11].options.isInternal && s10.series[e11].color || s10.options.colors[e11] || s10.options.colors[0]
            }, r10, t11)).data = t11.data, h10.data && (i10.hasNavigatorData = true, a10.push(s10.initSeries(h10)));
          })), t10 && this.addBaseSeriesEvents();
        }
        addBaseSeriesEvents() {
          let t10 = this, e10 = t10.baseSeries || [];
          e10[0] && e10[0].xAxis && e10[0].eventsToUnbind.push(dN(e10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e10.forEach((i10) => {
            i10.eventsToUnbind.push(dN(i10, "show", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
            })), i10.eventsToUnbind.push(dN(i10, "hide", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
            })), false !== this.navigatorOptions.adaptToUpdatedData && i10.xAxis && i10.eventsToUnbind.push(dN(i10, "updatedData", this.updatedDataHandler)), i10.eventsToUnbind.push(dN(i10, "remove", function() {
              e10 && dF(e10, i10), this.navigatorSeries && t10.series && (dF(t10.series, this.navigatorSeries), dX(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
            }));
          });
        }
        getBaseSeriesMin(t10) {
          return this.baseSeries.reduce(function(t11, e10) {
            return Math.min(t11, e10.getColumn("x")[0] ?? t11);
          }, t10);
        }
        modifyNavigatorAxisExtremes() {
          let t10 = this.xAxis;
          if (void 0 !== t10.getExtremes) {
            let e10 = this.getUnionExtremes(true);
            e10 && (e10.dataMin !== t10.min || e10.dataMax !== t10.max) && (t10.min = e10.dataMin, t10.max = e10.dataMax);
          }
        }
        modifyBaseAxisExtremes() {
          let t10, e10;
          let i10 = this.chart.navigator, s10 = this.getExtremes(), o10 = s10.min, r10 = s10.max, a10 = s10.dataMin, n10 = s10.dataMax, h10 = r10 - o10, l10 = i10.stickToMin, d10 = i10.stickToMax, c10 = dZ(this.ordinal?.convertOverscroll(this.options.overscroll), 0), p10 = i10.series && i10.series[0], u2 = !!this.setExtremes;
          !(this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger) && (l10 && (t10 = (e10 = a10) + h10), d10 && (t10 = n10 + c10, l10 || (e10 = Math.max(a10, t10 - h10, i10.getBaseSeriesMin(p10 && p10.xData ? p10.xData[0] : -Number.MAX_VALUE)))), u2 && (l10 || d10) && d_(e10) && (this.min = this.userMin = e10, this.max = this.userMax = t10)), i10.stickToMin = i10.stickToMax = null;
        }
        updatedDataHandler() {
          let t10 = this.chart.navigator, e10 = this.navigatorSeries, i10 = t10.reversedExtremes ? 0 === Math.round(t10.zoomedMin) : Math.round(t10.zoomedMax) >= Math.round(t10.size);
          t10.stickToMax = dZ(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i10), t10.stickToMin = t10.shouldStickToMin(this, t10), e10 && !t10.hasNavigatorData && (e10.options.pointStart = this.getColumn("x")[0], e10.setData(this.options.data, false, null, false));
        }
        shouldStickToMin(t10, e10) {
          let i10 = e10.getBaseSeriesMin(t10.getColumn("x")[0]), s10 = t10.xAxis, o10 = s10.max, r10 = s10.min, a10 = s10.options.range;
          return !!(d_(o10) && d_(r10)) && (a10 && o10 - i10 > 0 ? o10 - i10 < a10 : r10 <= i10);
        }
        addChartEvents() {
          this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(dN(this.chart, "redraw", function() {
            let t10 = this.navigator, e10 = t10 && (t10.baseSeries && t10.baseSeries[0] && t10.baseSeries[0].xAxis || this.xAxis[0]);
            e10 && t10.render(e10.min, e10.max);
          }), dN(this.chart, "getMargins", function() {
            let t10 = this.navigator, e10 = t10.opposite ? "plotTop" : "marginBottom";
            this.inverted && (e10 = t10.opposite ? "marginRight" : "plotLeft"), this[e10] = (this[e10] || 0) + (t10.navigatorEnabled || !this.inverted ? t10.height + t10.scrollbarHeight : 0) + t10.navigatorOptions.margin;
          }), dN(dQ, "setRange", function(t10) {
            this.chart.xAxis[0].setExtremes(t10.min, t10.max, t10.redraw, t10.animation, t10.eventArguments);
          }));
        }
        destroy() {
          this.removeEvents(), this.xAxis && (dF(this.chart.xAxis, this.xAxis), dF(this.chart.axes, this.xAxis)), this.yAxis && (dF(this.chart.yAxis, this.yAxis), dF(this.chart.axes, this.yAxis)), (this.series || []).forEach((t10) => {
            t10.destroy && t10.destroy();
          }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach((t10) => {
            this[t10] && this[t10].destroy && this[t10].destroy(), this[t10] = null;
          }), [this.handles].forEach((t10) => {
            dH(t10);
          }), this.navigatorEnabled = false;
        }
      }
      let {
        addEvent: d0,
        correctFloat: d1,
        css: d2,
        defined: d3,
        error: d5,
        isNumber: d6,
        pick: d9,
        timeUnits: d4,
        isString: d8
      } = ti;
      !function(t10) {
        function e10(t11, i11, s11, o11, r11 = [], a11 = 0, n11) {
          let h11 = {}, l11 = this.options.tickPixelInterval, d11 = this.chart.time, c11 = [], p10, u2, g2, f2, m2, x2 = 0, y2 = [], b2 = -Number.MAX_VALUE;
          if (!this.options.ordinal && !this.options.breaks || !r11 || r11.length < 3 || void 0 === i11) return d11.getTimeTicks.apply(d11, arguments);
          let v2 = r11.length;
          for (p10 = 0; p10 < v2; p10++) {
            if (m2 = p10 && r11[p10 - 1] > s11, r11[p10] < i11 && (x2 = p10), p10 === v2 - 1 || r11[p10 + 1] - r11[p10] > 5 * a11 || m2) {
              if (r11[p10] > b2) {
                for (u2 = d11.getTimeTicks(t11, r11[x2], r11[p10], o11); u2.length && u2[0] <= b2; ) u2.shift();
                u2.length && (b2 = u2[u2.length - 1]), c11.push(y2.length), y2 = y2.concat(u2);
              }
              x2 = p10 + 1;
            }
            if (m2) break;
          }
          if (u2) {
            if (f2 = u2.info, n11 && f2.unitRange <= d4.hour) {
              for (x2 = 1, p10 = y2.length - 1; x2 < p10; x2++) d11.dateFormat("%d", y2[x2]) !== d11.dateFormat("%d", y2[x2 - 1]) && (h11[y2[x2]] = "day", g2 = true);
              g2 && (h11[y2[0]] = "day"), f2.higherRanks = h11;
            }
            f2.segmentStarts = c11, y2.info = f2;
          } else d5(12, false, this.chart);
          if (n11 && d3(l11)) {
            let t12 = y2.length, e11 = [], i12 = [], o12, r12, a12, n12, d12, c12 = t12;
            for (; c12--; ) r12 = this.translate(y2[c12]), a12 && (i12[c12] = a12 - r12), e11[c12] = a12 = r12;
            for (i12.sort((t13, e12) => t13 - e12), (n12 = i12[Math.floor(i12.length / 2)]) < 0.6 * l11 && (n12 = null), c12 = y2[t12 - 1] > s11 ? t12 - 1 : t12, a12 = void 0; c12--; ) d12 = Math.abs(a12 - (r12 = e11[c12])), a12 && d12 < 0.8 * l11 && (null === n12 || d12 < 0.8 * n12) ? (h11[y2[c12]] && !h11[y2[c12 + 1]] ? (o12 = c12 + 1, a12 = r12) : o12 = c12, y2.splice(o12, 1)) : a12 = r12;
          }
          return y2;
        }
        function i10(t11) {
          let e11 = this.ordinal.positions;
          if (!e11) return t11;
          let i11 = e11.length - 1, s11;
          return (t11 < 0 ? t11 = e11[0] : t11 > i11 ? t11 = e11[i11] : (i11 = Math.floor(t11), s11 = t11 - i11), void 0 !== s11 && void 0 !== e11[i11]) ? e11[i11] + (s11 ? s11 * (e11[i11 + 1] - e11[i11]) : 0) : t11;
        }
        function s10(t11) {
          let e11 = this.ordinal, i11 = this.old ? this.old.min : this.min, s11 = this.old ? this.old.transA : this.transA, o11 = e11.getExtendedPositions();
          if (o11?.length) {
            let r11 = d1((t11 - i11) * s11 + this.minPixelPadding), a11 = d1(e11.getIndexOfPoint(r11, o11)), n11 = d1(a11 % 1);
            if (a11 >= 0 && a11 <= o11.length - 1) {
              let t12 = o11[Math.floor(a11)], e12 = o11[Math.ceil(a11)];
              return o11[Math.floor(a11)] + n11 * (e12 - t12);
            }
          }
          return t11;
        }
        function o10(e11, i11) {
          let s11 = t10.Additions.findIndexOf(e11, i11, true);
          if (e11[s11] === i11) return s11;
          let o11 = (i11 - e11[s11]) / (e11[s11 + 1] - e11[s11]);
          return s11 + o11;
        }
        function r10() {
          this.ordinal || (this.ordinal = new t10.Additions(this));
        }
        function a10() {
          let {
            eventArgs: t11,
            options: e11
          } = this;
          if (this.isXAxis && d3(e11.overscroll) && 0 !== e11.overscroll && d6(this.max) && d6(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(false), this.max === this.dataMax && (t11?.trigger !== "pan" || this.isInternal) && t11?.trigger !== "navigator")) {
            let i11 = this.ordinal.convertOverscroll(e11.overscroll);
            this.max += i11, !this.isInternal && d3(this.userMin) && t11?.trigger !== "mousewheel" && (this.min += i11);
          }
        }
        function n10() {
          this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
        }
        function h10() {
          this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
        }
        function l10(t11) {
          let e11 = this.xAxis[0], i11 = e11.ordinal.convertOverscroll(e11.options.overscroll), s11 = t11.originalEvent.chartX, o11 = this.options.chart.panning, r11 = false;
          if (o11 && "y" !== o11.type && e11.options.ordinal && e11.series.length && (!t11.touches || t11.touches.length <= 1)) {
            let t12, o12;
            let a11 = this.mouseDownX, n11 = e11.getExtremes(), h11 = n11.dataMin, l11 = n11.dataMax, d11 = n11.min, c11 = n11.max, p10 = this.hoverPoints, u2 = e11.closestPointRange || e11.ordinal && e11.ordinal.overscrollPointsRange, g2 = Math.round((a11 - s11) / (e11.translationSlope * (e11.ordinal.slope || u2))), f2 = e11.ordinal.getExtendedPositions(), m2 = {
              ordinal: {
                positions: f2,
                extendedOrdinalPositions: f2
              }
            }, x2 = e11.index2val, y2 = e11.val2lin;
            if (d11 <= h11 && g2 < 0 || c11 + i11 >= l11 && g2 > 0) return;
            m2.ordinal.positions ? Math.abs(g2) > 1 && (p10 && p10.forEach(function(t13) {
              t13.setState();
            }), l11 > (o12 = m2.ordinal.positions)[o12.length - 1] && o12.push(l11), this.setFixedRange(c11 - d11), (t12 = e11.navigatorAxis.toFixedRange(void 0, void 0, x2.apply(m2, [y2.apply(m2, [d11, true]) + g2]), x2.apply(m2, [y2.apply(m2, [c11, true]) + g2]))).min >= Math.min(o12[0], d11) && t12.max <= Math.max(o12[o12.length - 1], c11) + i11 && e11.setExtremes(t12.min, t12.max, true, false, {
              trigger: "pan"
            }), this.mouseDownX = s11, d2(this.container, {
              cursor: "move"
            })) : r11 = true;
          } else r11 = true;
          r11 || o11 && /y/.test(o11.type) ? i11 && (e11.max = e11.dataMax + i11) : t11.preventDefault();
        }
        function d10() {
          let t11 = this.xAxis;
          t11 && t11.options.ordinal && (delete t11.ordinal.index, delete t11.ordinal.originalOrdinalRange);
        }
        function c10(t11, e11) {
          let i11;
          let s11 = this.ordinal, r11 = s11.positions, a11 = s11.slope, n11;
          if (!r11) return t11;
          let h11 = r11.length;
          if (r11[0] <= t11 && r11[h11 - 1] >= t11) i11 = o10(r11, t11);
          else {
            if (!((n11 = s11.getExtendedPositions && s11.getExtendedPositions()) && n11.length)) return t11;
            let h12 = n11.length;
            a11 || (a11 = (n11[h12 - 1] - n11[0]) / h12);
            let l11 = o10(n11, r11[0]);
            if (t11 >= n11[0] && t11 <= n11[h12 - 1]) i11 = o10(n11, t11) - l11;
            else {
              if (!e11) return t11;
              i11 = t11 < n11[0] ? -l11 - (n11[0] - t11) / a11 : (t11 - n11[h12 - 1]) / a11 + h12 - l11;
            }
          }
          return e11 ? i11 : a11 * (i11 || 0) + s11.offset;
        }
        t10.compose = function(t11, o11, p10) {
          let u2 = t11.prototype;
          return u2.ordinal2lin || (u2.getTimeTicks = e10, u2.index2val = i10, u2.lin2val = s10, u2.val2lin = c10, u2.ordinal2lin = u2.val2lin, d0(t11, "afterInit", r10), d0(t11, "foundExtremes", a10), d0(t11, "afterSetScale", n10), d0(t11, "initialAxisTranslation", h10), d0(p10, "pan", l10), d0(p10, "touchpan", l10), d0(o11, "updatedData", d10)), t11;
        }, t10.Additions = class {
          constructor(t11) {
            this.index = {}, this.axis = t11;
          }
          beforeSetTickPositions() {
            let t11 = this.axis, e11 = t11.ordinal, i11 = t11.getExtremes(), s11 = i11.min, o11 = i11.max, r11 = t11.brokenAxis?.hasBreaks, a11 = t11.options.ordinal, n11, h11, l11, d11, c11, p10, u2, g2 = [], f2 = Number.MAX_VALUE, m2 = false, x2 = false, y2 = false;
            if (a11 || r11) {
              let i12 = 0;
              if (t11.series.forEach(function(t12, e12) {
                let s12 = t12.getColumn("x", true);
                if (h11 = [], e12 > 0 && "highcharts-navigator-series" !== t12.options.id && s12.length > 1 && (x2 = i12 !== s12[1] - s12[0]), i12 = s12[1] - s12[0], t12.boosted && (y2 = t12.boosted), t12.reserveSpace() && (false !== t12.takeOrdinalPosition || r11) && (n11 = (g2 = g2.concat(s12)).length, g2.sort(function(t13, e13) {
                  return t13 - e13;
                }), f2 = Math.min(f2, d9(t12.closestPointRange, f2)), n11)) {
                  for (e12 = 0; e12 < n11 - 1; ) g2[e12] !== g2[e12 + 1] && h11.push(g2[e12 + 1]), e12++;
                  h11[0] !== g2[0] && h11.unshift(g2[0]), g2 = h11;
                }
              }), t11.ordinal.originalOrdinalRange || (t11.ordinal.originalOrdinalRange = (g2.length - 1) * f2), x2 && y2 && (g2.pop(), g2.shift()), (n11 = g2.length) > 2) {
                for (l11 = g2[1] - g2[0], u2 = n11 - 1; u2-- && !m2; ) g2[u2 + 1] - g2[u2] !== l11 && (m2 = true);
                !t11.options.keepOrdinalPadding && (g2[0] - s11 > l11 || o11 - g2[g2.length - 1] > l11) && (m2 = true);
              } else t11.options.overscroll && (2 === n11 ? f2 = g2[1] - g2[0] : 1 === n11 ? (f2 = t11.ordinal.convertOverscroll(t11.options.overscroll), g2 = [g2[0], g2[0] + f2]) : f2 = e11.overscrollPointsRange);
              m2 || t11.forceOrdinal ? (t11.options.overscroll && (e11.overscrollPointsRange = f2, g2 = g2.concat(e11.getOverscrollPositions())), e11.positions = g2, d11 = t11.ordinal2lin(Math.max(s11, g2[0]), true), c11 = Math.max(t11.ordinal2lin(Math.min(o11, g2[g2.length - 1]), true), 1), e11.slope = p10 = (o11 - s11) / (c11 - d11), e11.offset = s11 - d11 * p10) : (e11.overscrollPointsRange = d9(t11.closestPointRange, e11.overscrollPointsRange), e11.positions = t11.ordinal.slope = e11.offset = void 0);
            }
            t11.isOrdinal = a11 && m2, e11.groupIntervalFactor = null;
          }
          static findIndexOf(t11, e11, i11) {
            let s11 = 0, o11 = t11.length - 1, r11;
            for (; s11 < o11; ) t11[r11 = Math.ceil((s11 + o11) / 2)] <= e11 ? s11 = r11 : o11 = r11 - 1;
            return t11[s11] === e11 ? s11 : i11 ? s11 : -1;
          }
          getExtendedPositions(t11 = true) {
            let e11 = this, i11 = e11.axis, s11 = i11.constructor.prototype, o11 = i11.chart, r11 = i11.series.reduce((t12, e12) => {
              let i12 = e12.currentDataGrouping;
              return t12 + (i12 ? i12.count + i12.unitName : "raw");
            }, ""), a11 = t11 ? i11.ordinal.convertOverscroll(i11.options.overscroll) : 0, n11 = i11.getExtremes(), h11, l11, d11 = e11.index;
            return d11 || (d11 = e11.index = {}), !d11[r11] && ((h11 = {
              series: [],
              chart: o11,
              forceOrdinal: false,
              getExtremes: function() {
                return {
                  min: n11.dataMin,
                  max: n11.dataMax + a11
                };
              },
              applyGrouping: s11.applyGrouping,
              getGroupPixelWidth: s11.getGroupPixelWidth,
              getTimeTicks: s11.getTimeTicks,
              options: {
                ordinal: true
              },
              ordinal: {
                getGroupIntervalFactor: this.getGroupIntervalFactor
              },
              ordinal2lin: s11.ordinal2lin,
              getIndexOfPoint: s11.getIndexOfPoint,
              val2lin: s11.val2lin
            }).ordinal.axis = h11, i11.series.forEach((i12) => {
              l11 = {
                xAxis: h11,
                chart: o11,
                groupPixelWidth: i12.groupPixelWidth,
                destroyGroupedData: L.noop,
                getColumn: i12.getColumn,
                applyGrouping: i12.applyGrouping,
                getProcessedData: i12.getProcessedData,
                reserveSpace: i12.reserveSpace,
                visible: i12.visible
              };
              let s12 = i12.getColumn("x").concat(t11 ? e11.getOverscrollPositions() : []);
              l11.dataTable = new rc({
                columns: {
                  x: s12
                }
              }), l11.options = __spreadProps(__spreadValues({}, i12.options), {
                dataGrouping: i12.currentDataGrouping ? {
                  firstAnchor: i12.options.dataGrouping?.firstAnchor,
                  anchor: i12.options.dataGrouping?.anchor,
                  lastAnchor: i12.options.dataGrouping?.firstAnchor,
                  enabled: true,
                  forced: true,
                  approximation: "open",
                  units: [[i12.currentDataGrouping.unitName, [i12.currentDataGrouping.count]]]
                } : {
                  enabled: false
                }
              }), h11.series.push(l11), i12.processData.apply(l11);
            }), h11.applyGrouping({
              hasExtremesChanged: true
            }), l11?.closestPointRange !== l11?.basePointRange && l11.currentDataGrouping && (h11.forceOrdinal = true), i11.ordinal.beforeSetTickPositions.apply({
              axis: h11
            }), !i11.ordinal.originalOrdinalRange && h11.ordinal.originalOrdinalRange && (i11.ordinal.originalOrdinalRange = h11.ordinal.originalOrdinalRange), h11.ordinal.positions && (d11[r11] = h11.ordinal.positions)), d11[r11];
          }
          getGroupIntervalFactor(t11, e11, i11) {
            let s11 = i11.getColumn("x", true), o11 = s11.length, r11 = [], a11, n11, h11 = this.groupIntervalFactor;
            if (!h11) {
              for (n11 = 0; n11 < o11 - 1; n11++) r11[n11] = s11[n11 + 1] - s11[n11];
              r11.sort(function(t12, e12) {
                return t12 - e12;
              }), a11 = r11[Math.floor(o11 / 2)], t11 = Math.max(t11, s11[0]), e11 = Math.min(e11, s11[o11 - 1]), this.groupIntervalFactor = h11 = o11 * a11 / (e11 - t11);
            }
            return h11;
          }
          getIndexOfPoint(t11, e11) {
            let i11 = this.axis, s11 = i11.min, r11 = i11.minPixelPadding;
            return o10(e11, s11) + d1((t11 - r11) / (i11.translationSlope * (this.slope || i11.closestPointRange || this.overscrollPointsRange)));
          }
          getOverscrollPositions() {
            let t11 = this.axis, e11 = this.convertOverscroll(t11.options.overscroll), i11 = this.overscrollPointsRange, s11 = [], o11 = t11.dataMax;
            if (d3(i11)) for (; o11 < t11.dataMax + e11; ) s11.push(o11 += i11);
            return s11;
          }
          postProcessTickInterval(t11) {
            let e11 = this.axis, i11 = this.slope, s11 = e11.closestPointRange;
            return i11 && s11 ? e11.options.breaks ? s11 || t11 : t11 / (i11 / s11) : t11;
          }
          convertOverscroll(t11 = 0) {
            let e11 = this, i11 = e11.axis, s11 = function(t12) {
              return d9(e11.originalOrdinalRange, d3(i11.dataMax) && d3(i11.dataMin) ? i11.dataMax - i11.dataMin : 0) * t12;
            };
            if (d8(t11)) {
              let e12 = parseInt(t11, 10);
              if (/%$/.test(t11)) return s11(e12 / 100);
              if (/px/.test(t11)) {
                let t12 = Math.min(e12, 0.9 * i11.len) / i11.len;
                return s11(t12 / (1 - t12));
              }
              return 0;
            }
            return t11;
          }
        };
      }(A || (A = {}));
      let d7 = A, ct = {
        lang: {
          rangeSelectorZoom: "Zoom",
          rangeSelectorFrom: "",
          rangeSelectorTo: "→"
        },
        rangeSelector: {
          allButtonsEnabled: false,
          buttons: [{
            type: "month",
            count: 1,
            text: "1m",
            title: "View 1 month"
          }, {
            type: "month",
            count: 3,
            text: "3m",
            title: "View 3 months"
          }, {
            type: "month",
            count: 6,
            text: "6m",
            title: "View 6 months"
          }, {
            type: "ytd",
            text: "YTD",
            title: "View year to date"
          }, {
            type: "year",
            count: 1,
            text: "1y",
            title: "View 1 year"
          }, {
            type: "all",
            text: "All",
            title: "View all"
          }],
          buttonSpacing: 5,
          dropdown: "responsive",
          enabled: void 0,
          verticalAlign: "top",
          buttonTheme: {
            width: 28,
            height: 18,
            padding: 2,
            zIndex: 7
          },
          floating: false,
          x: 0,
          y: 0,
          height: void 0,
          inputBoxBorderColor: "none",
          inputBoxHeight: 17,
          inputBoxWidth: void 0,
          inputDateFormat: "%[ebY]",
          inputDateParser: void 0,
          inputEditDateFormat: "%Y-%m-%d",
          inputEnabled: true,
          inputPosition: {
            align: "right",
            x: 0,
            y: 0
          },
          inputSpacing: 5,
          selected: void 0,
          buttonPosition: {
            align: "left",
            x: 0,
            y: 0
          },
          inputStyle: {
            color: "#334eff",
            cursor: "pointer",
            fontSize: "0.8em"
          },
          labelStyle: {
            color: "#666666",
            fontSize: "0.8em"
          }
        }
      }, {
        defaultOptions: ce
      } = tT, {
        composed: ci
      } = L, {
        addEvent: cs,
        defined: co,
        extend: cr,
        isNumber: ca,
        merge: cn,
        pick: ch,
        pushUnique: cl
      } = ti, cd = [];
      function cc() {
        let t10, e10;
        let i10 = this.range, s10 = i10.type, o10 = this.max, r10 = this.chart.time, a10 = function(t11, e11) {
          let i11 = r10.toParts(t11), o11 = i11.slice();
          "year" === s10 ? o11[0] += e11 : o11[1] += e11;
          let a11 = r10.makeTime.apply(r10, o11), n11 = r10.toParts(a11);
          return "month" === s10 && i11[1] === n11[1] && 1 === Math.abs(e11) && (o11[0] = i11[0], o11[1] = i11[1], o11[2] = 0), (a11 = r10.makeTime.apply(r10, o11)) - t11;
        };
        ca(i10) ? (t10 = o10 - i10, e10 = i10) : i10 && (t10 = o10 + a10(o10, -(i10.count || 1)), this.chart && this.chart.setFixedRange(o10 - t10));
        let n10 = ch(this.dataMin, Number.MIN_VALUE);
        return ca(t10) || (t10 = n10), t10 <= n10 && (t10 = n10, void 0 === e10 && (e10 = a10(t10, i10.count)), this.newMax = Math.min(t10 + e10, ch(this.dataMax, Number.MAX_VALUE))), ca(o10) ? !ca(i10) && i10 && i10._offsetMin && (t10 += i10._offsetMin) : t10 = void 0, t10;
      }
      function cp() {
        this.rangeSelector?.redrawElements();
      }
      function cu() {
        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new s(this));
      }
      function cg() {
        let t10 = this.rangeSelector;
        if (t10) {
          ca(t10.deferredYTDClick) && (t10.clickButton(t10.deferredYTDClick), delete t10.deferredYTDClick);
          let e10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === e10 ? this.extraBottomMargin = true : "top" !== e10 || (this.extraTopMargin = true));
        }
      }
      function cf() {
        let t10;
        let e10 = this.rangeSelector;
        if (!e10) return;
        let i10 = this.xAxis[0].getExtremes(), s10 = this.legend, o10 = e10 && e10.options.verticalAlign;
        ca(i10.min) && e10.render(i10.min, i10.max), s10.display && "top" === o10 && o10 === s10.options.verticalAlign && (t10 = cn(this.spacingBox), "vertical" === s10.options.layout ? t10.y = this.plotTop : t10.y += e10.getHeight(), s10.group.placed = false, s10.align(t10));
      }
      function cm() {
        for (let t10 = 0, e10 = cd.length; t10 < e10; ++t10) {
          let e11 = cd[t10];
          if (e11[0] === this) {
            e11[1].forEach((t11) => t11()), cd.splice(t10, 1);
            return;
          }
        }
      }
      function cx() {
        let t10 = this.rangeSelector;
        if (t10?.options?.enabled) {
          let e10 = t10.getHeight(), i10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === i10 ? this.marginBottom += e10 : "middle" === i10 || (this.plotTop += e10));
        }
      }
      function cy(t10) {
        let e10 = t10.options.rangeSelector, i10 = this.extraBottomMargin, o10 = this.extraTopMargin, r10 = this.rangeSelector;
        if (e10 && e10.enabled && !co(r10) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = r10 = new s(this)), this.extraBottomMargin = false, this.extraTopMargin = false, r10) {
          let t11 = e10 && e10.verticalAlign || r10.options && r10.options.verticalAlign;
          r10.options.floating || ("bottom" === t11 ? this.extraBottomMargin = true : "middle" === t11 || (this.extraTopMargin = true)), (this.extraBottomMargin !== i10 || this.extraTopMargin !== o10) && (this.isDirtyBox = true);
        }
      }
      let cb = {
        compose: function(t10, e10, i10) {
          if (s = i10, cl(ci, "RangeSelector")) {
            let i11 = e10.prototype;
            t10.prototype.minFromRange = cc, cs(e10, "afterGetContainer", cu), cs(e10, "beforeRender", cg), cs(e10, "destroy", cm), cs(e10, "getMargins", cx), cs(e10, "redraw", cf), cs(e10, "update", cy), cs(e10, "beforeRedraw", cp), i11.callbacks.push(cf), cr(ce, {
              rangeSelector: ct.rangeSelector
            }), cr(ce.lang, ct.lang);
          }
        }
      }, {
        defaultOptions: cv
      } = tT, {
        addEvent: ck,
        createElement: cM,
        css: cw,
        defined: cS,
        destroyObjectProperties: cA,
        diffObjects: cT,
        discardElement: cC,
        extend: cP,
        fireEvent: cO,
        isNumber: cE,
        isString: cL,
        merge: cD,
        objectEach: cB,
        pick: cI,
        splat: cz
      } = ti;
      function cR(t10) {
        let e10 = (e11) => RegExp(`%[[a-zA-Z]*${e11}`).test(t10);
        if (cL(t10) ? -1 !== t10.indexOf("%L") : t10.fractionalSecondDigits) return "text";
        let i10 = cL(t10) ? ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(e10) : t10.dateStyle || t10.day || t10.month || t10.year, s10 = cL(t10) ? ["H", "k", "I", "l", "M", "S"].some(e10) : t10.timeStyle || t10.hour || t10.minute || t10.second;
        return i10 && s10 ? "datetime-local" : i10 ? "date" : s10 ? "time" : "text";
      }
      class cN {
        static compose(t10, e10) {
          cb.compose(t10, e10, cN);
        }
        constructor(t10) {
          this.isDirty = false, this.buttonOptions = cN.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.maxButtonWidth = () => {
            let t11 = 0;
            return this.buttons.forEach((e10) => {
              let i10 = e10.getBBox();
              i10.width > t11 && (t11 = i10.width);
            }), t11;
          }, this.init(t10);
        }
        clickButton(t10, e10) {
          let i10 = this.chart, s10 = this.buttonOptions[t10], o10 = i10.xAxis[0], r10 = i10.scroller && i10.scroller.getUnionExtremes() || o10 || {}, a10 = s10.type, n10 = s10.dataGrouping, h10 = r10.dataMin, l10 = r10.dataMax, d10, c10 = cE(o10?.max) ? Math.round(Math.min(o10.max, l10 ?? o10.max)) : void 0, p10, u2 = s10._range, g2, f2, m2, x2 = true;
          if (null !== h10 && null !== l10) {
            if (this.setSelected(t10), n10 && (this.forcedDataGrouping = true, s_.prototype.setDataGrouping.call(o10 || {
              chart: this.chart
            }, n10, false), this.frozenStates = s10.preserveDataGrouping), "month" === a10 || "year" === a10) o10 ? (f2 = {
              range: s10,
              max: c10,
              chart: i10,
              dataMin: h10,
              dataMax: l10
            }, d10 = o10.minFromRange.call(f2), cE(f2.newMax) && (c10 = f2.newMax), x2 = false) : u2 = s10;
            else if (u2) cE(c10) && (c10 = Math.min((d10 = Math.max(c10 - u2, h10)) + u2, l10), x2 = false);
            else if ("ytd" === a10) {
              if (o10) !o10.hasData() || cE(l10) && cE(h10) || (h10 = Number.MAX_VALUE, l10 = -Number.MAX_VALUE, i10.series.forEach((t11) => {
                let e11 = t11.getColumn("x");
                e11.length && (h10 = Math.min(e11[0], h10), l10 = Math.max(e11[e11.length - 1], l10));
              }), e10 = false), cE(l10) && cE(h10) && (d10 = g2 = (m2 = this.getYTDExtremes(l10, h10)).min, c10 = m2.max);
              else {
                this.deferredYTDClick = t10;
                return;
              }
            } else "all" === a10 && o10 && (i10.navigator && i10.navigator.baseSeries[0] && (i10.navigator.baseSeries[0].xAxis.options.range = void 0), d10 = h10, c10 = l10);
            if (x2 && s10._offsetMin && cS(d10) && (d10 += s10._offsetMin), s10._offsetMax && cS(c10) && (c10 += s10._offsetMax), this.dropdown && (this.dropdown.selectedIndex = t10 + 1), o10) cE(d10) && cE(c10) && (o10.setExtremes(d10, c10, cI(e10, true), void 0, {
              trigger: "rangeSelectorButton",
              rangeSelectorButton: s10
            }), i10.setFixedRange(s10._range));
            else {
              p10 = cz(i10.options.xAxis || {})[0];
              let t11 = ck(i10, "afterCreateAxes", function() {
                let t12 = i10.xAxis[0];
                t12.range = t12.options.range = u2, t12.min = t12.options.min = g2;
              });
              ck(i10, "load", function() {
                let e11 = i10.xAxis[0];
                i10.setFixedRange(s10._range), e11.options.range = p10.range, e11.options.min = p10.min, t11();
              });
            }
            cO(this, "afterBtnClick");
          }
        }
        setSelected(t10) {
          this.selected = this.options.selected = t10;
        }
        init(t10) {
          let e10 = this, i10 = t10.options.rangeSelector, s10 = i10.buttons, o10 = i10.selected, r10 = function() {
            let t11 = e10.minInput, i11 = e10.maxInput;
            t11 && t11.blur && cO(t11, "blur"), i11 && i11.blur && cO(i11, "blur");
          };
          e10.chart = t10, e10.options = i10, e10.buttons = [], e10.buttonOptions = s10, this.eventsToUnbind = [], this.eventsToUnbind.push(ck(t10.container, "mousedown", r10)), this.eventsToUnbind.push(ck(t10, "resize", r10)), s10.forEach(e10.computeButtonRange), void 0 !== o10 && s10[o10] && this.clickButton(o10, false), this.eventsToUnbind.push(ck(t10, "load", function() {
            t10.xAxis && t10.xAxis[0] && ck(t10.xAxis[0], "setExtremes", function(i11) {
              cE(this.max) && cE(this.min) && this.max - this.min !== t10.fixedRange && "rangeSelectorButton" !== i11.trigger && "updatedData" !== i11.trigger && e10.forcedDataGrouping && !e10.frozenStates && this.setDataGrouping(false, false);
            });
          })), this.createElements();
        }
        updateButtonStates() {
          let t10 = this, e10 = this.chart, i10 = this.dropdown, s10 = this.dropdownLabel, o10 = e10.xAxis[0], r10 = Math.round(o10.max - o10.min), a10 = !o10.hasVisibleSeries, n10 = 24 * 36e5, h10 = e10.scroller && e10.scroller.getUnionExtremes() || o10, l10 = h10.dataMin, d10 = h10.dataMax, c10 = t10.getYTDExtremes(d10, l10), p10 = c10.min, u2 = c10.max, g2 = t10.selected, f2 = t10.options.allButtonsEnabled, m2 = Array(t10.buttonOptions.length).fill(0), x2 = cE(g2), y2 = t10.buttons, b2 = false, v2 = null;
          t10.buttonOptions.forEach((e11, i11) => {
            let s11 = e11._range, h11 = e11.type, c11 = e11.count || 1, y3 = e11._offsetMax - e11._offsetMin, k2 = i11 === g2, M2 = s11 > d10 - l10, w2 = s11 < o10.minRange, S2 = false, A2 = s11 === r10;
            if (k2 && M2 && (b2 = true), o10.isOrdinal && o10.ordinal?.positions && s11 && r10 < s11) {
              let t11 = o10.ordinal.positions, e12 = d7.Additions.findIndexOf(t11, o10.min, true), i12 = Math.min(d7.Additions.findIndexOf(t11, o10.max, true) + 1, t11.length - 1);
              t11[i12] - t11[e12] > s11 && (A2 = true);
            } else ("month" === h11 || "year" === h11) && r10 + 36e5 >= {
              month: 28,
              year: 365
            }[h11] * n10 * c11 - y3 && r10 - 36e5 <= {
              month: 31,
              year: 366
            }[h11] * n10 * c11 + y3 ? A2 = true : "ytd" === h11 ? (A2 = u2 - p10 + y3 === r10, S2 = !k2) : "all" === h11 && (A2 = o10.max - o10.min >= d10 - l10);
            let T2 = !f2 && !(b2 && "all" === h11) && (M2 || w2 || a10), C2 = b2 && "all" === h11 || !S2 && A2 || k2 && t10.frozenStates;
            T2 ? m2[i11] = 3 : C2 && (!x2 || i11 === g2) && (v2 = i11);
          }), null !== v2 ? (m2[v2] = 2, t10.setSelected(v2), this.dropdown && (this.dropdown.selectedIndex = v2 + 1)) : (t10.setSelected(), this.dropdown && (this.dropdown.selectedIndex = -1), s10 && (s10.setState(0), s10.attr({
            text: (cv.lang.rangeSelectorZoom || "") + " ▾"
          })));
          for (let e11 = 0; e11 < m2.length; e11++) {
            let o11 = m2[e11], r11 = y2[e11];
            if (r11.state !== o11 && (r11.setState(o11), i10)) {
              i10.options[e11 + 1].disabled = 3 === o11, 2 === o11 && (s10 && (s10.setState(2), s10.attr({
                text: t10.buttonOptions[e11].text + " ▾"
              })), i10.selectedIndex = e11 + 1);
              let r12 = s10.getBBox();
              cw(i10, {
                width: `${r12.width}px`,
                height: `${r12.height}px`
              });
            }
          }
        }
        computeButtonRange(t10) {
          let e10 = t10.type, i10 = t10.count || 1, s10 = {
            millisecond: 1,
            second: 1e3,
            minute: 6e4,
            hour: 36e5,
            day: 864e5,
            week: 6048e5
          };
          s10[e10] ? t10._range = s10[e10] * i10 : ("month" === e10 || "year" === e10) && (t10._range = 24 * {
            month: 30,
            year: 365
          }[e10] * 36e5 * i10), t10._offsetMin = cI(t10.offsetMin, 0), t10._offsetMax = cI(t10.offsetMax, 0), t10._range += t10._offsetMax - t10._offsetMin;
        }
        getInputValue(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput, i10 = this.chart.options.rangeSelector, s10 = this.chart.time;
          return e10 ? ("text" === e10.type && i10.inputDateParser || this.defaultInputDateParser)(e10.value, "UTC" === s10.timezone, s10) : 0;
        }
        setInputValue(t10, e10) {
          let i10 = this.options, s10 = this.chart.time, o10 = "min" === t10 ? this.minInput : this.maxInput, r10 = "min" === t10 ? this.minDateBox : this.maxDateBox;
          if (o10) {
            o10.setAttribute("type", cR(i10.inputDateFormat || "%e %b %Y"));
            let t11 = o10.getAttribute("data-hc-time"), a10 = cS(t11) ? Number(t11) : void 0;
            if (cS(e10)) {
              let t12 = a10;
              cS(t12) && o10.setAttribute("data-hc-time-previous", t12), o10.setAttribute("data-hc-time", e10), a10 = e10;
            }
            o10.value = s10.dateFormat(this.inputTypeFormats[o10.type] || i10.inputEditDateFormat, a10), r10 && r10.attr({
              text: s10.dateFormat(i10.inputDateFormat, a10)
            });
          }
        }
        setInputExtremes(t10, e10, i10) {
          let s10 = "min" === t10 ? this.minInput : this.maxInput;
          if (s10) {
            let t11 = this.inputTypeFormats[s10.type], o10 = this.chart.time;
            if (t11) {
              let r10 = o10.dateFormat(t11, e10);
              s10.min !== r10 && (s10.min = r10);
              let a10 = o10.dateFormat(t11, i10);
              s10.max !== a10 && (s10.max = a10);
            }
          }
        }
        showInput(t10) {
          let e10 = "min" === t10 ? this.minDateBox : this.maxDateBox, i10 = "min" === t10 ? this.minInput : this.maxInput;
          if (i10 && e10 && this.inputGroup) {
            let t11 = "text" === i10.type, {
              translateX: s10 = 0,
              translateY: o10 = 0
            } = this.inputGroup, {
              x: r10 = 0,
              width: a10 = 0,
              height: n10 = 0
            } = e10, {
              inputBoxWidth: h10
            } = this.options;
            cw(i10, {
              width: t11 ? a10 + (h10 ? -2 : 20) + "px" : "auto",
              height: n10 - 2 + "px",
              border: "2px solid silver"
            }), t11 && h10 ? cw(i10, {
              left: s10 + r10 + "px",
              top: o10 + "px"
            }) : cw(i10, {
              left: Math.min(Math.round(r10 + s10 - (i10.offsetWidth - a10) / 2), this.chart.chartWidth - i10.offsetWidth) + "px",
              top: o10 - (i10.offsetHeight - n10) / 2 + "px"
            });
          }
        }
        hideInput(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput;
          e10 && cw(e10, {
            top: "-9999em",
            border: 0,
            width: "1px",
            height: "1px"
          });
        }
        defaultInputDateParser(t10, e10, i10) {
          return i10?.parse(t10) || 0;
        }
        drawInput(t10) {
          let {
            chart: e10,
            div: i10,
            inputGroup: s10
          } = this, o10 = this, r10 = e10.renderer.style || {}, a10 = e10.renderer, n10 = e10.options.rangeSelector, h10 = cv.lang, l10 = "min" === t10;
          function d10(t11) {
            let {
              maxInput: i11,
              minInput: s11
            } = o10, r11 = e10.xAxis[0], a11 = e10.scroller?.getUnionExtremes() || r11, n11 = a11.dataMin, h11 = a11.dataMax, d11 = e10.xAxis[0].getExtremes()[t11], c11 = o10.getInputValue(t11);
            cE(c11) && c11 !== d11 && (l10 && i11 && cE(n11) ? c11 > Number(i11.getAttribute("data-hc-time")) ? c11 = void 0 : c11 < n11 && (c11 = n11) : s11 && cE(h11) && (c11 < Number(s11.getAttribute("data-hc-time")) ? c11 = void 0 : c11 > h11 && (c11 = h11)), void 0 !== c11 && r11.setExtremes(l10 ? c11 : r11.min, l10 ? r11.max : c11, void 0, void 0, {
              trigger: "rangeSelectorInput"
            }));
          }
          let c10 = h10[l10 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "", p10 = a10.label(c10, 0).addClass("highcharts-range-label").attr({
            padding: c10 ? 2 : 0,
            height: c10 ? n10.inputBoxHeight : 0
          }).add(s10), u2 = a10.label("", 0).addClass("highcharts-range-input").attr({
            padding: 2,
            width: n10.inputBoxWidth,
            height: n10.inputBoxHeight,
            "text-align": "center"
          }).on("click", function() {
            o10.showInput(t10), o10[t10 + "Input"].focus();
          });
          e10.styledMode || u2.attr({
            stroke: n10.inputBoxBorderColor,
            "stroke-width": 1
          }), u2.add(s10);
          let g2 = cM("input", {
            name: t10,
            className: "highcharts-range-selector"
          }, void 0, i10);
          g2.setAttribute("type", cR(n10.inputDateFormat || "%e %b %Y")), e10.styledMode || (p10.css(cD(r10, n10.labelStyle)), u2.css(cD({
            color: "#333333"
          }, r10, n10.inputStyle)), cw(g2, cP({
            position: "absolute",
            border: 0,
            boxShadow: "0 0 15px rgba(0,0,0,0.3)",
            width: "1px",
            height: "1px",
            padding: 0,
            textAlign: "center",
            fontSize: r10.fontSize,
            fontFamily: r10.fontFamily,
            top: "-9999em"
          }, n10.inputStyle))), g2.onfocus = () => {
            o10.showInput(t10);
          }, g2.onblur = () => {
            g2 === L.doc.activeElement && d10(t10), o10.hideInput(t10), o10.setInputValue(t10), g2.blur();
          };
          let f2 = false;
          return g2.onchange = () => {
            f2 || (d10(t10), o10.hideInput(t10), g2.blur());
          }, g2.onkeypress = (e11) => {
            13 === e11.keyCode && d10(t10);
          }, g2.onkeydown = (e11) => {
            f2 = true, ("ArrowUp" === e11.key || "ArrowDown" === e11.key || "Tab" === e11.key) && d10(t10);
          }, g2.onkeyup = () => {
            f2 = false;
          }, {
            dateBox: u2,
            input: g2,
            label: p10
          };
        }
        getPosition() {
          let t10 = this.chart, e10 = t10.options.rangeSelector, i10 = "top" === e10.verticalAlign ? t10.plotTop - t10.axisOffset[0] : 0;
          return {
            buttonTop: i10 + e10.buttonPosition.y,
            inputTop: i10 + e10.inputPosition.y - 10
          };
        }
        getYTDExtremes(t10, e10) {
          let i10 = this.chart.time, s10 = i10.toParts(t10)[0];
          return {
            max: t10,
            min: Math.max(e10, i10.makeTime(s10, 0))
          };
        }
        createElements() {
          let t10 = this.chart, e10 = t10.renderer, i10 = t10.container, s10 = t10.options, o10 = s10.rangeSelector, r10 = o10.inputEnabled, a10 = cI(s10.chart.style?.zIndex, 0) + 1;
          false !== o10.enabled && (this.group = e10.g("range-selector-group").attr({
            zIndex: 7
          }).add(), this.div = cM("div", void 0, {
            position: "relative",
            height: 0,
            zIndex: a10
          }), this.buttonOptions.length && this.renderButtons(), i10.parentNode && i10.parentNode.insertBefore(this.div, i10), r10 && this.createInputs());
        }
        createInputs() {
          this.inputGroup = this.chart.renderer.g("input-group").add(this.group);
          let t10 = this.drawInput("min");
          this.minDateBox = t10.dateBox, this.minLabel = t10.label, this.minInput = t10.input;
          let e10 = this.drawInput("max");
          this.maxDateBox = e10.dateBox, this.maxLabel = e10.label, this.maxInput = e10.input;
        }
        render(t10, e10) {
          if (false === this.options.enabled) return;
          let i10 = this.chart, s10 = i10.options.rangeSelector;
          if (s10.inputEnabled) {
            this.inputGroup || this.createInputs(), this.setInputValue("min", t10), this.setInputValue("max", e10), this.chart.styledMode || (this.maxLabel?.css(s10.labelStyle), this.minLabel?.css(s10.labelStyle));
            let o10 = i10.scroller && i10.scroller.getUnionExtremes() || i10.xAxis[0] || {};
            if (cS(o10.dataMin) && cS(o10.dataMax)) {
              let t11 = i10.xAxis[0].minRange || 0;
              this.setInputExtremes("min", o10.dataMin, Math.min(o10.dataMax, this.getInputValue("max")) - t11), this.setInputExtremes("max", Math.max(o10.dataMin, this.getInputValue("min")) + t11, o10.dataMax);
            }
            if (this.inputGroup) {
              let t11 = 0;
              [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach((e11) => {
                if (e11) {
                  let {
                    width: i11
                  } = e11.getBBox();
                  i11 && (e11.attr({
                    x: t11
                  }), t11 += i11 + s10.inputSpacing);
                }
              });
            }
          } else this.inputGroup && (this.inputGroup.destroy(), delete this.inputGroup);
          !this.chart.styledMode && this.zoomText && this.zoomText.css(s10.labelStyle), this.alignElements(), this.updateButtonStates();
        }
        renderButtons() {
          var t10;
          let {
            chart: e10,
            options: i10
          } = this, s10 = cv.lang, o10 = e10.renderer, r10 = cD(i10.buttonTheme), a10 = r10 && r10.states;
          delete r10.width, delete r10.states, this.buttonGroup = o10.g("range-selector-buttons").add(this.group);
          let n10 = this.dropdown = cM("select", void 0, {
            position: "absolute",
            padding: 0,
            border: 0,
            cursor: "pointer",
            opacity: 1e-4
          }, this.div), h10 = e10.userOptions.rangeSelector?.buttonTheme;
          this.dropdownLabel = o10.button("", 0, 0, () => {
          }, cD(r10, {
            "stroke-width": cI(r10["stroke-width"], 0),
            width: "auto",
            paddingLeft: cI(i10.buttonTheme.paddingLeft, h10?.padding, 8),
            paddingRight: cI(i10.buttonTheme.paddingRight, h10?.padding, 8)
          }), a10 && a10.hover, a10 && a10.select, a10 && a10.disabled).hide().add(this.group), ck(n10, "touchstart", () => {
            n10.style.fontSize = "16px";
          });
          let l10 = L.isMS ? "mouseover" : "mouseenter", d10 = L.isMS ? "mouseout" : "mouseleave";
          ck(n10, l10, () => {
            cO(this.dropdownLabel.element, l10);
          }), ck(n10, d10, () => {
            cO(this.dropdownLabel.element, d10);
          }), ck(n10, "change", () => {
            cO(this.buttons[n10.selectedIndex - 1].element, "click");
          }), this.zoomText = o10.label(s10.rangeSelectorZoom || "", 0).attr({
            padding: i10.buttonTheme.padding,
            height: i10.buttonTheme.height,
            paddingLeft: 0,
            paddingRight: 0
          }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(i10.labelStyle), (t10 = i10.buttonTheme)["stroke-width"] ?? (t10["stroke-width"] = 0)), cM("option", {
            textContent: this.zoomText.textStr,
            disabled: true
          }, void 0, n10), this.createButtons();
        }
        createButtons() {
          let {
            options: t10
          } = this, e10 = cD(t10.buttonTheme), i10 = e10 && e10.states, s10 = e10.width || 28;
          delete e10.width, delete e10.states, this.buttonOptions.forEach((t11, e11) => {
            this.createButton(t11, e11, s10, i10);
          });
        }
        createButton(t10, e10, i10, s10) {
          let {
            dropdown: o10,
            buttons: r10,
            chart: a10,
            options: n10
          } = this, h10 = a10.renderer, l10 = cD(n10.buttonTheme);
          o10?.add(cM("option", {
            textContent: t10.title || t10.text
          }), e10 + 2), r10[e10] = h10.button(t10.text, 0, 0, (i11) => {
            let s11;
            let o11 = t10.events && t10.events.click;
            o11 && (s11 = o11.call(t10, i11)), false !== s11 && this.clickButton(e10), this.isActive = true;
          }, l10, s10 && s10.hover, s10 && s10.select, s10 && s10.disabled).attr({
            "text-align": "center",
            width: i10
          }).add(this.buttonGroup), t10.title && r10[e10].attr("title", t10.title);
        }
        alignElements() {
          let {
            buttonGroup: t10,
            buttons: e10,
            chart: i10,
            group: s10,
            inputGroup: o10,
            options: r10,
            zoomText: a10
          } = this, n10 = i10.options, h10 = n10.exporting && false !== n10.exporting.enabled && n10.navigation && n10.navigation.buttonOptions, {
            buttonPosition: l10,
            inputPosition: d10,
            verticalAlign: c10
          } = r10, p10 = (t11, e11, s11) => h10 && this.titleCollision(i10) && "top" === c10 && s11 && e11.y - t11.getBBox().height - 12 < (h10.y || 0) + (h10.height || 0) + i10.spacing[0] ? -40 : 0, u2 = i10.plotLeft;
          if (s10 && l10 && d10) {
            let n11 = l10.x - i10.spacing[3];
            if (t10) {
              if (this.positionButtons(), !this.initialButtonGroupWidth) {
                let t11 = 0;
                a10 && (t11 += a10.getBBox().width + 5), e10.forEach((i11, s11) => {
                  t11 += i11.width || 0, s11 !== e10.length - 1 && (t11 += r10.buttonSpacing);
                }), this.initialButtonGroupWidth = t11;
              }
              u2 -= i10.spacing[3];
              let o11 = p10(t10, l10, "right" === l10.align || "right" === d10.align);
              this.alignButtonGroup(o11), this.buttonGroup?.translateY && this.dropdownLabel.attr({
                y: this.buttonGroup.translateY
              }), s10.placed = t10.placed = i10.hasLoaded;
            }
            let h11 = 0;
            r10.inputEnabled && o10 && (h11 = p10(o10, d10, "right" === l10.align || "right" === d10.align), "left" === d10.align ? n11 = u2 : "right" === d10.align && (n11 = -Math.max(i10.axisOffset[1], -h11)), o10.align({
              y: d10.y,
              width: o10.getBBox().width,
              align: d10.align,
              x: d10.x + n11 - 2
            }, true, i10.spacingBox), o10.placed = i10.hasLoaded), this.handleCollision(h11), s10.align({
              verticalAlign: c10
            }, true, i10.spacingBox);
            let g2 = s10.alignAttr.translateY, f2 = s10.getBBox().height + 20, m2 = 0;
            if ("bottom" === c10) {
              let t11 = i10.legend && i10.legend.options;
              m2 = g2 - (f2 = f2 + (t11 && "bottom" === t11.verticalAlign && t11.enabled && !t11.floating ? i10.legend.legendHeight + cI(t11.margin, 10) : 0) - 20) - (r10.floating ? 0 : r10.y) - (i10.titleOffset ? i10.titleOffset[2] : 0) - 10;
            }
            "top" === c10 ? (r10.floating && (m2 = 0), i10.titleOffset && i10.titleOffset[0] && (m2 = i10.titleOffset[0]), m2 += i10.margin[0] - i10.spacing[0] || 0) : "middle" === c10 && (d10.y === l10.y ? m2 = g2 : (d10.y || l10.y) && (d10.y < 0 || l10.y < 0 ? m2 -= Math.min(d10.y, l10.y) : m2 = g2 - f2)), s10.translate(r10.x, r10.y + Math.floor(m2));
            let {
              minInput: x2,
              maxInput: y2,
              dropdown: b2
            } = this;
            r10.inputEnabled && x2 && y2 && (x2.style.marginTop = s10.translateY + "px", y2.style.marginTop = s10.translateY + "px"), b2 && (b2.style.marginTop = s10.translateY + "px");
          }
        }
        redrawElements() {
          let t10 = this.chart, {
            inputBoxHeight: e10,
            inputBoxBorderColor: i10
          } = this.options;
          if (this.maxDateBox?.attr({
            height: e10
          }), this.minDateBox?.attr({
            height: e10
          }), t10.styledMode || (this.maxDateBox?.attr({
            stroke: i10
          }), this.minDateBox?.attr({
            stroke: i10
          })), this.isDirty) {
            this.isDirty = false, this.isCollapsed = void 0;
            let t11 = this.options.buttons ?? [], e11 = Math.min(t11.length, this.buttonOptions.length), {
              dropdown: i11,
              options: s10
            } = this, o10 = cD(s10.buttonTheme), r10 = o10 && o10.states, a10 = o10.width || 28;
            if (t11.length < this.buttonOptions.length) for (let e12 = this.buttonOptions.length - 1; e12 >= t11.length; e12--) {
              let t12 = this.buttons.pop();
              t12?.destroy(), this.dropdown?.options.remove(e12 + 1);
            }
            for (let s11 = e11 - 1; s11 >= 0; s11--) if (0 !== Object.keys(cT(t11[s11], this.buttonOptions[s11])).length) {
              let e12 = t11[s11];
              this.buttons[s11].destroy(), i11?.options.remove(s11 + 1), this.createButton(e12, s11, a10, r10), this.computeButtonRange(e12);
            }
            if (t11.length > this.buttonOptions.length) for (let e12 = this.buttonOptions.length; e12 < t11.length; e12++) this.createButton(t11[e12], e12, a10, r10), this.computeButtonRange(t11[e12]);
            this.buttonOptions = this.options.buttons ?? [], cS(this.options.selected) && this.buttons.length && this.clickButton(this.options.selected, false);
          }
        }
        alignButtonGroup(t10, e10) {
          let {
            chart: i10,
            options: s10,
            buttonGroup: o10,
            dropdown: r10,
            dropdownLabel: a10
          } = this, {
            buttonPosition: n10
          } = s10, h10 = i10.plotLeft - i10.spacing[3], l10 = n10.x - i10.spacing[3], d10 = i10.plotLeft;
          "right" === n10.align ? (l10 += t10 - h10, this.hasVisibleDropdown && (d10 = i10.chartWidth + t10 - this.maxButtonWidth() - 20)) : "center" === n10.align && (l10 -= h10 / 2, this.hasVisibleDropdown && (d10 = i10.chartWidth / 2 - this.maxButtonWidth())), r10 && cw(r10, {
            left: d10 + "px",
            top: o10?.translateY + "px"
          }), a10?.attr({
            x: d10
          }), o10 && o10.align({
            y: n10.y,
            width: cI(e10, this.initialButtonGroupWidth),
            align: n10.align,
            x: l10
          }, true, i10.spacingBox);
        }
        positionButtons() {
          let {
            buttons: t10,
            chart: e10,
            options: i10,
            zoomText: s10
          } = this, o10 = e10.hasLoaded ? "animate" : "attr", {
            buttonPosition: r10
          } = i10, a10 = e10.plotLeft, n10 = a10;
          s10 && "hidden" !== s10.visibility && (s10[o10]({
            x: cI(a10 + r10.x, a10)
          }), n10 += r10.x + s10.getBBox().width + 5);
          for (let e11 = 0, s11 = this.buttonOptions.length; e11 < s11; ++e11) "hidden" !== t10[e11].visibility ? (t10[e11][o10]({
            x: n10
          }), n10 += (t10[e11].width || 0) + i10.buttonSpacing) : t10[e11][o10]({
            x: a10
          });
        }
        handleCollision(t10) {
          let {
            chart: e10,
            buttonGroup: i10,
            inputGroup: s10,
            initialButtonGroupWidth: o10
          } = this, {
            buttonPosition: r10,
            dropdown: a10,
            inputPosition: n10
          } = this.options, h10 = () => {
            s10 && i10 && s10.attr({
              translateX: s10.alignAttr.translateX + (e10.axisOffset[1] >= -t10 ? 0 : -t10),
              translateY: s10.alignAttr.translateY + i10.getBBox().height + 10
            });
          };
          s10 && i10 ? n10.align === r10.align ? (h10(), o10 > e10.plotWidth + t10 - 20 ? this.collapseButtons() : this.expandButtons()) : o10 - t10 + s10.getBBox().width > e10.plotWidth ? "responsive" === a10 ? this.collapseButtons() : h10() : this.expandButtons() : i10 && "responsive" === a10 && (o10 > e10.plotWidth ? this.collapseButtons() : this.expandButtons()), i10 && ("always" === a10 && this.collapseButtons(), "never" === a10 && this.expandButtons()), this.alignButtonGroup(t10);
        }
        collapseButtons() {
          let {
            buttons: t10,
            zoomText: e10
          } = this;
          true !== this.isCollapsed && (this.isCollapsed = true, e10.hide(), t10.forEach((t11) => void t11.hide()), this.showDropdown());
        }
        expandButtons() {
          let {
            buttons: t10,
            zoomText: e10
          } = this;
          false !== this.isCollapsed && (this.isCollapsed = false, this.hideDropdown(), e10.show(), t10.forEach((t11) => void t11.show()), this.positionButtons());
        }
        showDropdown() {
          let {
            buttonGroup: t10,
            dropdownLabel: e10,
            dropdown: i10
          } = this;
          t10 && i10 && (e10.show(), cw(i10, {
            visibility: "inherit"
          }), this.hasVisibleDropdown = true);
        }
        hideDropdown() {
          let {
            dropdown: t10
          } = this;
          t10 && (this.dropdownLabel.hide(), cw(t10, {
            visibility: "hidden",
            width: "1px",
            height: "1px"
          }), this.hasVisibleDropdown = false);
        }
        getHeight() {
          let t10 = this.options, e10 = this.group, i10 = t10.inputPosition, s10 = t10.buttonPosition, o10 = t10.y, r10 = s10.y, a10 = i10.y, n10 = 0;
          if (t10.height) return t10.height;
          this.alignElements(), n10 = e10 ? e10.getBBox(true).height + 13 + o10 : 0;
          let h10 = Math.min(a10, r10);
          return (a10 < 0 && r10 < 0 || a10 > 0 && r10 > 0) && (n10 += Math.abs(h10)), n10;
        }
        titleCollision(t10) {
          return !(t10.options.title.text || t10.options.subtitle.text);
        }
        update(t10, e10 = true) {
          let i10 = this.chart;
          if (cD(true, this.options, t10), this.options.selected && this.options.selected >= this.options.buttons.length && (this.options.selected = void 0, i10.options.rangeSelector.selected = void 0), cS(t10.enabled)) return this.destroy(), this.init(i10);
          this.isDirty = !!t10.buttons, e10 && this.render();
        }
        destroy() {
          let t10 = this, e10 = t10.minInput, i10 = t10.maxInput;
          t10.eventsToUnbind && (t10.eventsToUnbind.forEach((t11) => t11()), t10.eventsToUnbind = void 0), cA(t10.buttons), e10 && (e10.onfocus = e10.onblur = e10.onchange = null), i10 && (i10.onfocus = i10.onblur = i10.onchange = null), cB(t10, function(e11, i11) {
            e11 && "chart" !== i11 && (e11 instanceof e0 ? e11.destroy() : e11 instanceof window.HTMLElement && cC(e11), delete t10[i11]), e11 !== cN.prototype[i11] && (t10[i11] = null);
          }, this), this.buttons = [];
        }
      }
      cP(cN.prototype, {
        inputTypeFormats: {
          "datetime-local": "%Y-%m-%dT%H:%M:%S",
          date: "%Y-%m-%d",
          time: "%H:%M:%S"
        }
      });
      let {
        format: cW
      } = eg, {
        getOptions: cG
      } = tT, {
        setFixedRange: cX
      } = da, {
        addEvent: cH,
        clamp: cF,
        crisp: cY,
        defined: cj,
        extend: cU,
        find: cV,
        isNumber: c_,
        isString: c$,
        merge: cZ,
        pick: cq,
        splat: cK
      } = ti;
      function cJ(t10, e10, i10) {
        return "xAxis" === t10 ? {
          minPadding: 0,
          maxPadding: 0,
          overscroll: 0,
          ordinal: true
        } : "yAxis" === t10 ? {
          labels: {
            y: -2
          },
          opposite: i10.opposite ?? e10.opposite ?? true,
          showLastLabel: !!(e10.categories || "category" === e10.type),
          title: {
            text: i10.title?.text !== "Values" ? i10.title?.text : null
          }
        } : {};
      }
      function cQ(t10, e10) {
        if ("xAxis" === t10) {
          let t11 = cq(e10.navigator && e10.navigator.enabled, de.enabled, true), i10 = {
            type: "datetime",
            categories: void 0
          };
          return t11 && (i10.startOnTick = false, i10.endOnTick = false), i10;
        }
        return {};
      }
      class c0 extends aQ {
        init(t10, e10) {
          let i10 = cG(), s10 = t10.xAxis, o10 = t10.yAxis, r10 = cq(t10.navigator && t10.navigator.enabled, de.enabled, true);
          t10.xAxis = t10.yAxis = void 0;
          let a10 = cZ({
            chart: {
              panning: {
                enabled: true,
                type: "x"
              },
              zooming: {
                pinchType: "x",
                mouseWheel: {
                  type: "x"
                }
              }
            },
            navigator: {
              enabled: r10
            },
            scrollbar: {
              enabled: cq(dM.enabled, true)
            },
            rangeSelector: {
              enabled: cq(ct.rangeSelector.enabled, true)
            },
            title: {
              text: null
            },
            tooltip: {
              split: cq(i10.tooltip && i10.tooltip.split, true),
              crosshairs: true
            },
            legend: {
              enabled: false
            }
          }, t10, {
            isStock: true
          });
          t10.xAxis = s10, t10.yAxis = o10, a10.xAxis = cK(t10.xAxis || {}).map((e11) => cZ(cJ("xAxis", e11, i10.xAxis), e11, cQ("xAxis", t10))), a10.yAxis = cK(t10.yAxis || {}).map((t11) => cZ(cJ("yAxis", t11, i10.yAxis), t11)), super.init(a10, e10);
        }
        createAxis(t10, e10) {
          return e10.axis = cZ(cJ(t10, e10.axis, cG()[t10]), e10.axis, cQ(t10, this.userOptions)), super.createAxis(t10, e10);
        }
      }
      cH(aQ, "update", function(t10) {
        let e10 = t10.options;
        "scrollbar" in e10 && this.navigator && (cZ(true, this.options.scrollbar, e10.scrollbar), this.navigator.update({
          enabled: !!this.navigator.navigatorEnabled
        }), delete e10.scrollbar);
      }), function(t10) {
        function e10(t11) {
          if (!(this.crosshair?.label?.enabled && this.cross && c_(this.min) && c_(this.max))) return;
          let e11 = this.chart, i11 = this.logarithmic, s11 = this.crosshair.label, o11 = this.horiz, r11 = this.opposite, a11 = this.left, n11 = this.top, h11 = this.width, l10 = "inside" === this.options.tickPosition, d10 = false !== this.crosshair.snap, c10 = t11.e || this.cross?.e, p10 = t11.point, u2 = this.crossLabel, g2, f2, m2 = s11.format, x2 = "", y2, b2 = 0, v2 = this.min, k2 = this.max;
          i11 && (v2 = i11.lin2log(this.min), k2 = i11.lin2log(this.max));
          let M2 = o11 ? "center" : r11 ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
          u2 || (u2 = this.crossLabel = e11.renderer.label("", 0, void 0, s11.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (p10 && p10.series ? p10.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
            align: s11.align || M2,
            padding: cq(s11.padding, 8),
            r: cq(s11.borderRadius, 3),
            zIndex: 2
          }).add(this.labelGroup), e11.styledMode || u2.attr({
            fill: s11.backgroundColor || p10 && p10.series && p10.series.color || "#666666",
            stroke: s11.borderColor || "",
            "stroke-width": s11.borderWidth || 0
          }).css(cU({
            color: "#ffffff",
            fontWeight: "normal",
            fontSize: "0.7em",
            textAlign: "center"
          }, s11.style || {}))), o11 ? (g2 = d10 ? (p10.plotX || 0) + a11 : c10.chartX, f2 = n11 + (r11 ? 0 : this.height)) : (g2 = a11 + this.offset + (r11 ? h11 : 0), f2 = d10 ? (p10.plotY || 0) + n11 : c10.chartY), m2 || s11.formatter || (this.dateTime && (x2 = "%b %d, %Y"), m2 = "{value" + (x2 ? ":" + x2 : "") + "}");
          let w2 = d10 ? this.isXAxis ? p10.x : p10.y : this.toValue(o11 ? c10.chartX : c10.chartY), S2 = p10 && p10.series ? p10.series.isPointInside(p10) : c_(w2) && w2 > v2 && w2 < k2, A2 = "";
          m2 ? A2 = cW(m2, {
            value: w2
          }, e11) : s11.formatter && c_(w2) && (A2 = s11.formatter.call(this, w2)), u2.attr({
            text: A2,
            x: g2,
            y: f2,
            visibility: S2 ? "inherit" : "hidden"
          });
          let T2 = u2.getBBox();
          !c_(u2.x) || o11 || r11 || (g2 = u2.x - T2.width / 2), c_(u2.y) && (o11 ? (l10 && !r11 || !l10 && r11) && (f2 = u2.y - T2.height) : f2 = u2.y - T2.height / 2), y2 = o11 ? {
            left: a11,
            right: a11 + this.width
          } : {
            left: "left" === this.labelAlign ? a11 : 0,
            right: "right" === this.labelAlign ? a11 + this.width : e11.chartWidth
          };
          let C2 = u2.translateX || 0;
          C2 < y2.left && (b2 = y2.left - C2), C2 + T2.width >= y2.right && (b2 = -(C2 + T2.width - y2.right)), u2.attr({
            x: Math.max(0, g2 + b2),
            y: Math.max(0, f2),
            anchorX: o11 ? g2 : this.opposite ? 0 : e11.chartWidth,
            anchorY: o11 ? this.opposite ? e11.chartHeight : 0 : f2 + T2.height / 2
          });
        }
        function i10() {
          this.crossLabel && (this.crossLabel = this.crossLabel.hide());
        }
        function s10(t11) {
          let e11 = this.chart, i11 = this.options, s11 = e11._labelPanes = e11._labelPanes || {}, o11 = i11.labels;
          if (e11.options.isStock && "yAxis" === this.coll) {
            let e12 = i11.top + "," + i11.height;
            !s11[e12] && o11.enabled && (15 === o11.distance && 1 === this.side && (o11.distance = 0), void 0 === o11.align && (o11.align = "right"), s11[e12] = this, t11.align = "right", t11.preventDefault());
          }
        }
        function o10() {
          let t11 = this.chart, e11 = this.options && this.options.top + "," + this.options.height;
          e11 && t11._labelPanes && t11._labelPanes[e11] === this && delete t11._labelPanes[e11];
        }
        function r10(t11) {
          let e11 = this, i11 = e11.isLinked && !e11.series && e11.linkedParent ? e11.linkedParent.series : e11.series, s11 = e11.chart, o11 = s11.renderer, r11 = e11.left, a11 = e11.top, n11 = [], h11 = t11.translatedValue, l10 = t11.value, d10 = t11.force, c10, p10, u2, g2, f2 = [], m2, x2;
          if (s11.options.isStock && false !== t11.acrossPanes && "xAxis" === e11.coll || "yAxis" === e11.coll) {
            for (let o12 of (t11.preventDefault(), f2 = ((t12) => {
              let o13 = "xAxis" === t12 ? "yAxis" : "xAxis", r12 = e11.options[o13];
              return c_(r12) ? [s11[o13][r12]] : c$(r12) ? [s11.get(r12)] : i11.map((t13) => t13[o13]);
            })(e11.coll), e11.isXAxis ? s11.yAxis : s11.xAxis)) if (!o12.options.isInternal) {
              let t12 = o12.isXAxis ? "yAxis" : "xAxis";
              e11 === (cj(o12.options[t12]) ? s11[t12][o12.options[t12]] : s11[t12][0]) && f2.push(o12);
            }
            for (let t12 of (m2 = f2.length ? [] : [e11.isXAxis ? s11.yAxis[0] : s11.xAxis[0]], f2)) -1 !== m2.indexOf(t12) || cV(m2, (e12) => e12.pos === t12.pos && e12.len === t12.len) || m2.push(t12);
            if (c_(x2 = cq(h11, e11.translate(l10 || 0, void 0, void 0, t11.old)))) {
              if (e11.horiz) for (let t12 of m2) {
                let i12;
                g2 = (p10 = t12.pos) + t12.len, c10 = u2 = Math.round(x2 + e11.transB), "pass" !== d10 && (c10 < r11 || c10 > r11 + e11.width) && (d10 ? c10 = u2 = cF(c10, r11, r11 + e11.width) : i12 = true), i12 || n11.push(["M", c10, p10], ["L", u2, g2]);
              }
              else for (let t12 of m2) {
                let i12;
                u2 = (c10 = t12.pos) + t12.len, p10 = g2 = Math.round(a11 + e11.height - x2), "pass" !== d10 && (p10 < a11 || p10 > a11 + e11.height) && (d10 ? p10 = g2 = cF(p10, a11, a11 + e11.height) : i12 = true), i12 || n11.push(["M", c10, p10], ["L", u2, g2]);
              }
            }
            t11.path = n11.length > 0 ? o11.crispPolyLine(n11, t11.lineWidth || 1) : void 0;
          }
        }
        function a10(t11) {
          if (this.chart.options.isStock) {
            let e11;
            this.is("column") || this.is("columnrange") ? e11 = {
              borderWidth: 0,
              shadow: false
            } : this.is("scatter") || this.is("sma") || (e11 = {
              marker: {
                enabled: false,
                radius: 2
              }
            }), e11 && (t11.plotOptions[this.type] = cZ(t11.plotOptions[this.type], e11));
          }
        }
        function n10() {
          let t11 = this.chart, e11 = this.options.dataGrouping;
          return false !== this.allowDG && e11 && cq(e11.enabled, t11.options.isStock);
        }
        function h10(t11, e11) {
          for (let i11 = 0; i11 < t11.length; i11 += 2) {
            let s11 = t11[i11], o11 = t11[i11 + 1];
            cj(s11[1]) && s11[1] === o11[1] && (s11[1] = o11[1] = cY(s11[1], e11)), cj(s11[2]) && s11[2] === o11[2] && (s11[2] = o11[2] = cY(s11[2], e11));
          }
          return t11;
        }
        t10.compose = function(t11, l10, d10, c10) {
          let p10 = d10.prototype;
          p10.forceCropping || (cH(l10, "afterDrawCrosshair", e10), cH(l10, "afterHideCrosshair", i10), cH(l10, "autoLabelAlign", s10), cH(l10, "destroy", o10), cH(l10, "getPlotLinePath", r10), t11.prototype.setFixedRange = cX, p10.forceCropping = n10, cH(d10, "setOptions", a10), c10.prototype.crispPolyLine = h10);
        }, t10.stockChart = function(e11, i11, s11) {
          return new t10(e11, i11, s11);
        };
      }(c0 || (c0 = {}));
      let c1 = c0, {
        column: {
          prototype: {
            pointClass: c2
          }
        }
      } = rv.seriesTypes, {
        column: c3
      } = rv.seriesTypes, {
        crisp: c5,
        extend: c6,
        merge: c9
      } = ti;
      class c4 extends c3 {
        extendStem(t10, e10, i10) {
          let s10 = t10[0], o10 = t10[1];
          "number" == typeof s10[2] && (s10[2] = Math.max(i10 + e10, s10[2])), "number" == typeof o10[2] && (o10[2] = Math.min(i10 - e10, o10[2]));
        }
        getPointPath(t10, e10) {
          let i10 = e10.strokeWidth(), s10 = t10.series, o10 = c5(t10.plotX || 0, i10), r10 = Math.round(t10.shapeArgs.width / 2), a10 = [["M", o10, Math.round(t10.yBottom)], ["L", o10, Math.round(t10.plotHigh)]];
          if (null !== t10.close) {
            let e11 = c5(t10.plotClose, i10);
            a10.push(["M", o10, e11], ["L", o10 + r10, e11]), s10.extendStem(a10, i10 / 2, e11);
          }
          return a10;
        }
        drawSinglePoint(t10) {
          let e10 = t10.series, i10 = e10.chart, s10, o10 = t10.graphic;
          void 0 !== t10.plotY && (o10 || (t10.graphic = o10 = i10.renderer.path().add(e10.group)), i10.styledMode || o10.attr(e10.pointAttribs(t10, t10.selected && "select")), s10 = e10.getPointPath(t10, o10), o10[o10 ? "animate" : "attr"]({
            d: s10
          }).addClass(t10.getClassName(), true));
        }
        drawPoints() {
          this.points.forEach(this.drawSinglePoint);
        }
        init() {
          super.init.apply(this, arguments), this.options.stacking = void 0;
        }
        pointAttribs(t10, e10) {
          let i10 = super.pointAttribs.call(this, t10, e10);
          return delete i10.fill, i10;
        }
        toYData(t10) {
          return [t10.high, t10.low, t10.close];
        }
        translate() {
          let t10 = this, e10 = t10.yAxis, i10 = this.pointArrayMap && this.pointArrayMap.slice() || [], s10 = i10.map((t11) => `plot${t11.charAt(0).toUpperCase() + t11.slice(1)}`);
          s10.push("yBottom"), i10.push("low"), super.translate.apply(t10), t10.points.forEach(function(o10) {
            i10.forEach(function(i11, r10) {
              let a10 = o10[i11];
              null !== a10 && (t10.dataModify && (a10 = t10.dataModify.modifyValue(a10)), o10[s10[r10]] = e10.toPixels(a10, true));
            }), o10.tooltipPos[1] = o10.plotHigh + e10.pos - t10.chart.plotTop;
          });
        }
      }
      c4.defaultOptions = c9(c3.defaultOptions, {
        lineWidth: 1,
        tooltip: {
          pointFormat: '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'
        },
        threshold: null,
        states: {
          hover: {
            lineWidth: 3
          }
        },
        stickyTracking: true
      }), c6(c4.prototype, {
        pointClass: class extends c2 {
        },
        animate: null,
        directTouch: false,
        keysAffectYAxis: ["low", "high"],
        pointArrayMap: ["high", "low", "close"],
        pointAttrToOptions: {
          stroke: "color",
          "stroke-width": "lineWidth"
        },
        pointValKey: "close"
      }), rv.registerSeriesType("hlc", c4);
      let {
        seriesTypes: {
          hlc: c8
        }
      } = rv;
      class c7 extends c8.prototype.pointClass {
        getClassName() {
          return super.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
        }
        resolveUpColor() {
          this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
        }
        resolveColor() {
          super.resolveColor(), this.series.is("heikinashi") || this.resolveUpColor();
        }
        getZone() {
          let t10 = super.getZone();
          return this.resolveUpColor(), t10;
        }
        applyOptions() {
          return super.applyOptions.apply(this, arguments), this.resolveColor && this.resolveColor(), this;
        }
      }
      let {
        composed: pt
      } = L, {
        hlc: pe
      } = rv.seriesTypes, {
        addEvent: pi,
        crisp: ps,
        extend: po,
        merge: pr,
        pushUnique: pa
      } = ti;
      function pn(t10) {
        let e10 = t10.options, i10 = e10.dataGrouping;
        i10 && e10.useOhlcData && "highcharts-navigator-series" !== e10.id && (i10.approximation = "ohlc");
      }
      function ph(t10) {
        let e10 = t10.options;
        e10.useOhlcData && "highcharts-navigator-series" !== e10.id && po(this, {
          pointValKey: pl.prototype.pointValKey,
          pointArrayMap: pl.prototype.pointArrayMap,
          toYData: pl.prototype.toYData
        });
      }
      class pl extends pe {
        static compose(t10, ...e10) {
          pa(pt, "OHLCSeries") && (pi(t10, "afterSetOptions", pn), pi(t10, "init", ph));
        }
        getPointPath(t10, e10) {
          let i10 = super.getPointPath(t10, e10), s10 = e10.strokeWidth(), o10 = ps(t10.plotX || 0, s10), r10 = Math.round(t10.shapeArgs.width / 2);
          if (null !== t10.open) {
            let e11 = ps(t10.plotOpen, s10);
            i10.push(["M", o10, e11], ["L", o10 - r10, e11]), super.extendStem(i10, s10 / 2, e11);
          }
          return i10;
        }
        pointAttribs(t10, e10) {
          let i10 = super.pointAttribs.call(this, t10, e10), s10 = this.options;
          return delete i10.fill, !t10.options.color && s10.upColor && t10.open < t10.close && (i10.stroke = s10.upColor), i10;
        }
        toYData(t10) {
          return [t10.open, t10.high, t10.low, t10.close];
        }
      }
      pl.defaultOptions = pr(pe.defaultOptions, {
        tooltip: {
          pointFormat: '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'
        }
      }), po(pl.prototype, {
        pointClass: c7,
        pointArrayMap: ["open", "high", "low", "close"]
      }), rv.registerSeriesType("ohlc", pl);
      let {
        column: pd,
        ohlc: pc
      } = rv.seriesTypes, {
        crisp: pp,
        merge: pu
      } = ti;
      class pg extends pc {
        pointAttribs(t10, e10) {
          let i10 = pd.prototype.pointAttribs.call(this, t10, e10), s10 = this.options, o10 = t10.open < t10.close, r10 = s10.lineColor || this.color, a10 = t10.color || this.color;
          if (i10["stroke-width"] = s10.lineWidth, i10.fill = t10.options.color || o10 && s10.upColor || a10, i10.stroke = t10.options.lineColor || o10 && s10.upLineColor || r10, e10) {
            let t11 = s10.states[e10];
            i10.fill = t11.color || i10.fill, i10.stroke = t11.lineColor || i10.stroke, i10["stroke-width"] = t11.lineWidth || i10["stroke-width"];
          }
          return i10;
        }
        drawPoints() {
          let t10 = this.points, e10 = this.chart, i10 = this.yAxis.reversed;
          for (let s10 of t10) {
            let t11 = s10.graphic, o10, r10, a10, n10, h10, l10, d10, c10, p10, u2 = !t11;
            if (void 0 !== s10.plotY) {
              t11 || (s10.graphic = t11 = e10.renderer.path().add(this.group)), this.chart.styledMode || t11.attr(this.pointAttribs(s10, s10.selected && "select")).shadow(this.options.shadow);
              let g2 = t11.strokeWidth();
              d10 = pp(s10.plotX || 0, g2), a10 = Math.min(o10 = s10.plotOpen, r10 = s10.plotClose), n10 = Math.max(o10, r10), p10 = Math.round(s10.shapeArgs.width / 2), h10 = i10 ? n10 !== s10.yBottom : Math.round(a10) !== Math.round(s10.plotHigh || 0), l10 = i10 ? Math.round(a10) !== Math.round(s10.plotHigh || 0) : n10 !== s10.yBottom, a10 = pp(a10, g2), n10 = pp(n10, g2), (c10 = []).push(["M", d10 - p10, n10], ["L", d10 - p10, a10], ["L", d10 + p10, a10], ["L", d10 + p10, n10], ["Z"], ["M", d10, a10], ["L", d10, h10 ? Math.round(i10 ? s10.yBottom : s10.plotHigh) : a10], ["M", d10, n10], ["L", d10, l10 ? Math.round(i10 ? s10.plotHigh : s10.yBottom) : n10]), t11[u2 ? "attr" : "animate"]({
                d: c10
              }).addClass(s10.getClassName(), true);
            }
          }
        }
      }
      pg.defaultOptions = pu(pc.defaultOptions, {
        tooltip: pc.defaultOptions.tooltip
      }, {
        states: {
          hover: {
            lineWidth: 2
          }
        },
        threshold: null,
        lineColor: "#000000",
        lineWidth: 1,
        upColor: "#ffffff",
        stickyTracking: true
      }), rv.registerSeriesType("candlestick", pg);
      let {
        column: {
          prototype: {
            pointClass: pf
          }
        }
      } = rv.seriesTypes, {
        isNumber: pm
      } = ti, px = class extends pf {
        constructor() {
          super(...arguments), this.ttBelow = false;
        }
        isValid() {
          return pm(this.y) || void 0 === this.y;
        }
        hasNewShapeType() {
          let t10 = this.options.shape || this.series.options.shape;
          return this.graphic && t10 && t10 !== this.graphic.symbolKey;
        }
      };
      !function(t10) {
        let e10 = [];
        function i10(t11, e11, i11, s11, o10) {
          let r10 = o10 && o10.anchorX || t11, a10 = o10 && o10.anchorY || e11, n10 = this.circle(r10 - 1, a10 - 1, 2, 2);
          return n10.push(["M", r10, a10], ["L", t11, e11 + s11], ["L", t11, e11], ["L", t11 + i11, e11], ["L", t11 + i11, e11 + s11], ["L", t11, e11 + s11], ["Z"]), n10;
        }
        function s10(t11, e11) {
          t11[e11 + "pin"] = function(i11, s11, o10, r10, a10) {
            let n10;
            let h10 = a10 && a10.anchorX, l10 = a10 && a10.anchorY;
            if ("circle" === e11 && r10 > o10 && (i11 -= Math.round((r10 - o10) / 2), o10 = r10), n10 = t11[e11](i11, s11, o10, r10, a10), h10 && l10) {
              let a11 = h10;
              if ("circle" === e11) a11 = i11 + o10 / 2;
              else {
                let t12 = n10[0], e12 = n10[1];
                "M" === t12[0] && "L" === e12[0] && (a11 = (t12[1] + e12[1]) / 2);
              }
              let d10 = s11 > l10 ? s11 : s11 + r10;
              n10.push(["M", a11, d10], ["L", h10, l10]), n10 = n10.concat(t11.circle(h10 - 1, l10 - 1, 2, 2));
            }
            return n10;
          };
        }
        t10.compose = function(t11) {
          if (-1 === e10.indexOf(t11)) {
            e10.push(t11);
            let o11 = t11.prototype.symbols;
            o11.flag = i10, s10(o11, "circle"), s10(o11, "square");
          }
          let o10 = ef.getRendererType();
          e10.indexOf(o10) && e10.push(o10);
        };
      }(T || (T = {}));
      let py = T, {
        composed: pb
      } = L, {
        prototype: pv
      } = ht, {
        prototype: pk
      } = rQ, {
        defined: pM,
        pushUnique: pw,
        stableSort: pS
      } = ti;
      !function(t10) {
        function e10(t11) {
          return pk.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, t11);
        }
        function i10() {
          pv.translate.apply(this);
          let t11 = this, e11 = t11.options, i11 = t11.chart, s10 = t11.points, o10 = e11.onSeries, r10 = o10 && i11.get(o10), a10 = r10 && r10.options.step, n10 = r10 && r10.points, h10 = i11.inverted, l10 = t11.xAxis, d10 = t11.yAxis, c10 = s10.length - 1, p10, u2, g2 = e11.onKey || "y", f2 = n10 && n10.length, m2 = 0, x2, y2, b2, v2, k2;
          if (r10 && r10.visible && f2) {
            for (m2 = (r10.pointXOffset || 0) + (r10.barW || 0) / 2, v2 = r10.currentDataGrouping, y2 = n10[f2 - 1].x + (v2 ? v2.totalRange : 0), pS(s10, (t12, e12) => t12.x - e12.x), g2 = "plot" + g2[0].toUpperCase() + g2.substr(1); f2-- && s10[c10]; ) if (x2 = n10[f2], (p10 = s10[c10]).y = x2.y, x2.x <= p10.x && void 0 !== x2[g2]) {
              if (p10.x <= y2 && (p10.plotY = x2[g2], x2.x < p10.x && !a10 && (b2 = n10[f2 + 1]) && void 0 !== b2[g2])) {
                if (pM(p10.plotX) && r10.is("spline")) {
                  let t12 = [x2.plotX || 0, x2.plotY || 0], e12 = [b2.plotX || 0, b2.plotY || 0], i12 = x2.controlPoints?.high || t12, s11 = b2.controlPoints?.low || e12, o11 = (o12, r12) => Math.pow(1 - o12, 3) * t12[r12] + 3 * (1 - o12) * (1 - o12) * o12 * i12[r12] + 3 * (1 - o12) * o12 * o12 * s11[r12] + o12 * o12 * o12 * e12[r12], r11 = 0, a11 = 1, n11;
                  for (let t13 = 0; t13 < 100; t13++) {
                    let t14 = (r11 + a11) / 2, e13 = o11(t14, 0);
                    if (null === e13) break;
                    if (0.25 > Math.abs(e13 - p10.plotX)) {
                      n11 = t14;
                      break;
                    }
                    e13 < p10.plotX ? r11 = t14 : a11 = t14;
                  }
                  pM(n11) && (p10.plotY = o11(n11, 1), p10.y = d10.toValue(p10.plotY, true));
                } else k2 = (p10.x - x2.x) / (b2.x - x2.x), p10.plotY += k2 * (b2[g2] - x2[g2]), p10.y += k2 * (b2.y - x2.y);
              }
              if (c10--, f2++, c10 < 0) break;
            }
          }
          s10.forEach((e12, i12) => {
            let o11;
            e12.plotX += m2, (void 0 === e12.plotY || h10) && (e12.plotX >= 0 && e12.plotX <= l10.len ? h10 ? (e12.plotY = l10.translate(e12.x, 0, 1, 0, 1), e12.plotX = pM(e12.y) ? d10.translate(e12.y, 0, 0, 0, 1) : 0) : e12.plotY = (l10.opposite ? 0 : t11.yAxis.len) + l10.offset : e12.shapeArgs = {}), (u2 = s10[i12 - 1]) && u2.plotX === e12.plotX && (void 0 === u2.stackIndex && (u2.stackIndex = 0), o11 = u2.stackIndex + 1), e12.stackIndex = o11;
          }), this.onSeries = r10;
        }
        t10.compose = function(t11) {
          if (pw(pb, "OnSeries")) {
            let s10 = t11.prototype;
            s10.getPlotBox = e10, s10.translate = i10;
          }
          return t11;
        }, t10.getPlotBox = e10, t10.translate = i10;
      }(C || (C = {}));
      let pA = C, {
        noop: pT
      } = L, {
        distribute: pC
      } = ev, {
        series: pP,
        seriesTypes: {
          column: pO
        }
      } = rv, {
        addEvent: pE,
        defined: pL,
        extend: pD,
        isNumber: pB,
        merge: pI,
        objectEach: pz,
        wrap: pR
      } = ti;
      class pN extends pO {
        animate(t10) {
          t10 && this.setClip();
        }
        drawPoints() {
          let t10, e10, i10, s10, o10, r10, a10, n10, h10, l10, d10;
          let c10 = this.points, p10 = this.chart, u2 = p10.renderer, g2 = p10.inverted, f2 = this.options, m2 = f2.y, x2 = this.yAxis, y2 = {}, b2 = [], v2 = pB(f2.borderRadius) ? f2.borderRadius : 0;
          for (s10 = c10.length; s10--; ) o10 = c10[s10], l10 = (g2 ? o10.plotY : o10.plotX) > this.xAxis.len, t10 = o10.plotX, a10 = o10.stackIndex, i10 = o10.options.shape || f2.shape, void 0 !== (e10 = o10.plotY) && (e10 = o10.plotY + m2 - (void 0 !== a10 && a10 * f2.stackDistance)), o10.anchorX = a10 ? void 0 : o10.plotX, n10 = a10 ? void 0 : o10.plotY, d10 = "flag" !== i10, r10 = o10.graphic, void 0 !== e10 && t10 >= 0 && !l10 ? (r10 && o10.hasNewShapeType() && (r10 = r10.destroy()), r10 || (r10 = o10.graphic = u2.label("", 0, void 0, i10, void 0, void 0, f2.useHTML).addClass("highcharts-point").add(this.markerGroup), o10.graphic.div && (o10.graphic.div.point = o10), r10.isNew = true), r10.attr({
            align: d10 ? "center" : "left",
            width: f2.width,
            height: f2.height,
            "text-align": f2.textAlign,
            r: v2
          }), p10.styledMode || r10.attr(this.pointAttribs(o10)).css(pI(f2.style, o10.style)).shadow(f2.shadow), t10 > 0 && (t10 -= r10.strokeWidth() % 2), h10 = {
            y: e10,
            anchorY: n10
          }, f2.allowOverlapX && (h10.x = t10, h10.anchorX = o10.anchorX), r10.attr({
            text: o10.options.title ?? f2.title ?? "A"
          })[r10.isNew ? "attr" : "animate"](h10), f2.allowOverlapX || (y2[o10.plotX] ? y2[o10.plotX].size = Math.max(y2[o10.plotX].size, r10.width || 0) : y2[o10.plotX] = {
            align: d10 ? 0.5 : 0,
            size: r10.width || 0,
            target: t10,
            anchorX: t10
          }), o10.tooltipPos = [t10, e10 + x2.pos - p10.plotTop]) : r10 && (o10.graphic = r10.destroy());
          if (!f2.allowOverlapX) {
            let t11 = 100;
            for (let e11 of (pz(y2, function(e12) {
              e12.plotX = e12.anchorX, b2.push(e12), t11 = Math.max(e12.size, t11);
            }), pC(b2, g2 ? x2.len : this.xAxis.len, t11), c10)) {
              let t12 = e11.plotX, i11 = e11.graphic, s11 = i11 && y2[t12];
              s11 && i11 && (pL(s11.pos) ? i11[i11.isNew ? "attr" : "animate"]({
                x: s11.pos + (s11.align || 0) * s11.size,
                anchorX: e11.anchorX
              }).show().isNew = false : i11.hide().isNew = true);
            }
          }
          f2.useHTML && this.markerGroup && pR(this.markerGroup, "on", function(t11) {
            return e0.prototype.on.apply(t11.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
          });
        }
        drawTracker() {
          let t10 = this.points;
          for (let e10 of (super.drawTracker(), t10)) {
            let i10 = e10.graphic;
            i10 && (e10.unbindMouseOver && e10.unbindMouseOver(), e10.unbindMouseOver = pE(i10.element, "mouseover", function() {
              for (let s10 of (e10.stackIndex > 0 && !e10.raised && (e10._y = i10.y, i10.attr({
                y: e10._y - 8
              }), e10.raised = true), t10)) s10 !== e10 && s10.raised && s10.graphic && (s10.graphic.attr({
                y: s10._y
              }), s10.raised = false);
            }));
          }
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = t10 && t10.color || this.color, o10 = i10.lineColor, r10 = t10 && t10.lineWidth, a10 = t10 && t10.fillColor || i10.fillColor;
          return e10 && (a10 = i10.states[e10].fillColor, o10 = i10.states[e10].lineColor, r10 = i10.states[e10].lineWidth), {
            fill: a10 || s10,
            stroke: o10 || s10,
            "stroke-width": r10 || i10.lineWidth || 0
          };
        }
        setClip() {
          pP.prototype.setClip.apply(this, arguments), false !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
        }
      }
      pN.compose = py.compose, pN.defaultOptions = pI(pO.defaultOptions, {
        borderRadius: 0,
        pointRange: 0,
        allowOverlapX: false,
        shape: "flag",
        stackDistance: 12,
        textAlign: "center",
        tooltip: {
          pointFormat: "{point.text}"
        },
        threshold: null,
        y: -30,
        fillColor: "#ffffff",
        lineWidth: 1,
        states: {
          hover: {
            lineColor: "#000000",
            fillColor: "#ccd3ff"
          }
        },
        style: {
          fontSize: "0.7em",
          fontWeight: "bold"
        }
      }), pA.compose(pN), pD(pN.prototype, {
        allowDG: false,
        forceCrop: true,
        invertible: false,
        noSharedTooltip: true,
        pointClass: px,
        sorted: false,
        takeOrdinalPosition: false,
        trackerGroups: ["markerGroup"],
        buildKDTree: pT,
        init: pP.prototype.init
      }), rv.registerSeriesType("flags", pN);
      let {
        addEvent: pW,
        find: pG,
        fireEvent: pX,
        isArray: pH,
        isNumber: pF,
        pick: pY
      } = ti;
      !function(t10) {
        function e10() {
          void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
        }
        function i10() {
          this.brokenAxis?.hasBreaks && (this.options.ordinal = false);
        }
        function s10() {
          let t11 = this.brokenAxis;
          if (t11?.hasBreaks) {
            let e11 = this.tickPositions, i11 = this.tickPositions.info, s11 = [];
            for (let i12 = 0; i12 < e11.length; i12++) t11.isInAnyBreak(e11[i12]) || s11.push(e11[i12]);
            this.tickPositions = s11, this.tickPositions.info = i11;
          }
        }
        function o10() {
          this.brokenAxis || (this.brokenAxis = new l10(this));
        }
        function r10() {
          let {
            isDirty: t11,
            options: {
              connectNulls: e11
            },
            points: i11,
            xAxis: s11,
            yAxis: o11
          } = this;
          if (t11) {
            let t12 = i11.length;
            for (; t12--; ) {
              let r11 = i11[t12], a11 = !(null === r11.y && false === e11) && (s11?.brokenAxis?.isInAnyBreak(r11.x, true) || o11?.brokenAxis?.isInAnyBreak(r11.y, true));
              r11.visible = !a11 && false !== r11.options.visible;
            }
          }
        }
        function a10() {
          this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, pY(this.pointArrayMap, ["y"]));
        }
        function n10(t11, e11) {
          let i11, s11, o11;
          let r11 = this, a11 = r11.points;
          if (t11?.brokenAxis?.hasBreaks) {
            let n11 = t11.brokenAxis;
            e11.forEach(function(e12) {
              i11 = n11?.breakArray || [], s11 = t11.isXAxis ? t11.min : pY(r11.options.threshold, t11.min);
              let h11 = t11?.options?.breaks?.filter(function(t12) {
                let e13 = true;
                for (let s12 = 0; s12 < i11.length; s12++) {
                  let o12 = i11[s12];
                  if (o12.from === t12.from && o12.to === t12.to) {
                    e13 = false;
                    break;
                  }
                }
                return e13;
              });
              a11.forEach(function(r12) {
                o11 = pY(r12["stack" + e12.toUpperCase()], r12[e12]), i11.forEach(function(e13) {
                  if (pF(s11) && pF(o11)) {
                    let i12 = "";
                    s11 < e13.from && o11 > e13.to || s11 > e13.from && o11 < e13.from ? i12 = "pointBreak" : (s11 < e13.from && o11 > e13.from && o11 < e13.to || s11 > e13.from && o11 > e13.to && o11 < e13.from) && (i12 = "pointInBreak"), i12 && pX(t11, i12, {
                      point: r12,
                      brk: e13
                    });
                  }
                }), h11?.forEach(function(e13) {
                  pX(t11, "pointOutsideOfBreak", {
                    point: r12,
                    brk: e13
                  });
                });
              });
            });
          }
        }
        function h10() {
          let t11 = this.currentDataGrouping, e11 = t11?.gapSize, i11 = this.points.slice(), s11 = this.yAxis, o11 = this.options.gapSize, r11 = i11.length - 1;
          if (o11 && r11 > 0) {
            let t12, a11;
            for ("value" !== this.options.gapUnit && (o11 *= this.basePointRange), e11 && e11 > o11 && e11 >= this.basePointRange && (o11 = e11); r11--; ) if (a11 && false !== a11.visible || (a11 = i11[r11 + 1]), t12 = i11[r11], false !== a11.visible && false !== t12.visible) {
              if (a11.x - t12.x > o11) {
                let e12 = (t12.x + a11.x) / 2;
                i11.splice(r11 + 1, 0, {
                  isNull: true,
                  x: e12
                }), s11.stacking && this.options.stacking && ((s11.stacking.stacks[this.stackKey][e12] = new nl(s11, s11.options.stackLabels, false, e12, this.stack)).total = 0);
              }
              a11 = t12;
            }
          }
          return this.getGraphPath(i11);
        }
        t10.compose = function(t11, l11) {
          if (!t11.keepProps.includes("brokenAxis")) {
            t11.keepProps.push("brokenAxis"), pW(t11, "init", o10), pW(t11, "afterInit", e10), pW(t11, "afterSetTickPositions", s10), pW(t11, "afterSetOptions", i10);
            let d10 = l11.prototype;
            d10.drawBreaks = n10, d10.gappedPath = h10, pW(l11, "afterGeneratePoints", r10), pW(l11, "afterRender", a10);
          }
          return t11;
        };
        class l10 {
          static isInBreak(t11, e11) {
            let i11 = t11.repeat || 1 / 0, s11 = t11.from, o11 = t11.to - t11.from, r11 = e11 >= s11 ? (e11 - s11) % i11 : i11 - (s11 - e11) % i11;
            return t11.inclusive ? r11 <= o11 : r11 < o11 && 0 !== r11;
          }
          static lin2Val(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !pF(t11)) return t11;
            let s11 = t11, o11, r11;
            for (r11 = 0; r11 < i11.length && !((o11 = i11[r11]).from >= s11); r11++) o11.to < s11 ? s11 += o11.len : l10.isInBreak(o11, s11) && (s11 += o11.len);
            return s11;
          }
          static val2Lin(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !pF(t11)) return t11;
            let s11 = t11, o11, r11;
            for (r11 = 0; r11 < i11.length; r11++) if ((o11 = i11[r11]).to <= t11) s11 -= o11.len;
            else if (o11.from >= t11) break;
            else if (l10.isInBreak(o11, t11)) {
              s11 -= t11 - o11.from;
              break;
            }
            return s11;
          }
          constructor(t11) {
            this.hasBreaks = false, this.axis = t11;
          }
          findBreakAt(t11, e11) {
            return pG(e11, function(e12) {
              return e12.from < t11 && t11 < e12.to;
            });
          }
          isInAnyBreak(t11, e11) {
            let i11 = this.axis, s11 = i11.options.breaks || [], o11 = s11.length, r11, a11, n11;
            if (o11 && pF(t11)) {
              for (; o11--; ) l10.isInBreak(s11[o11], t11) && (r11 = true, a11 || (a11 = pY(s11[o11].showPoints, !i11.isXAxis)));
              n11 = r11 && e11 ? r11 && !a11 : r11;
            }
            return n11;
          }
          setBreaks(t11, e11) {
            let i11 = this, s11 = i11.axis, o11 = s11.chart.time, r11 = pH(t11) && !!t11.length && !!Object.keys(t11[0]).length;
            s11.isDirty = i11.hasBreaks !== r11, i11.hasBreaks = r11, t11?.forEach((t12) => {
              t12.from = o11.parse(t12.from) || 0, t12.to = o11.parse(t12.to) || 0;
            }), t11 !== s11.options.breaks && (s11.options.breaks = s11.userOptions.breaks = t11), s11.forceRedraw = true, s11.series.forEach(function(t12) {
              t12.isDirty = true;
            }), r11 || s11.val2lin !== l10.val2Lin || (delete s11.val2lin, delete s11.lin2val), r11 && (s11.userOptions.ordinal = false, s11.lin2val = l10.lin2Val, s11.val2lin = l10.val2Lin, s11.setExtremes = function(t12, e12, o12, r12, a11) {
              if (i11.hasBreaks) {
                let s12;
                let o13 = this.options.breaks || [];
                for (; s12 = i11.findBreakAt(t12, o13); ) t12 = s12.to;
                for (; s12 = i11.findBreakAt(e12, o13); ) e12 = s12.from;
                e12 < t12 && (e12 = t12);
              }
              s11.constructor.prototype.setExtremes.call(this, t12, e12, o12, r12, a11);
            }, s11.setAxisTranslation = function() {
              if (s11.constructor.prototype.setAxisTranslation.call(this), i11.unitLength = void 0, i11.hasBreaks) {
                let t12 = s11.options.breaks || [], e12 = [], o12 = [], r12 = pY(s11.pointRangePadding, 0), a11 = 0, n11, h11, d10 = s11.userMin || s11.min, c10 = s11.userMax || s11.max, p10, u2;
                t12.forEach(function(t13) {
                  h11 = t13.repeat || 1 / 0, pF(d10) && pF(c10) && (l10.isInBreak(t13, d10) && (d10 += t13.to % h11 - d10 % h11), l10.isInBreak(t13, c10) && (c10 -= c10 % h11 - t13.from % h11));
                }), t12.forEach(function(t13) {
                  if (p10 = t13.from, h11 = t13.repeat || 1 / 0, pF(d10) && pF(c10)) {
                    for (; p10 - h11 > d10; ) p10 -= h11;
                    for (; p10 < d10; ) p10 += h11;
                    for (u2 = p10; u2 < c10; u2 += h11) e12.push({
                      value: u2,
                      move: "in"
                    }), e12.push({
                      value: u2 + t13.to - t13.from,
                      move: "out",
                      size: t13.breakSize
                    });
                  }
                }), e12.sort(function(t13, e13) {
                  return t13.value === e13.value ? ("in" === t13.move ? 0 : 1) - ("in" === e13.move ? 0 : 1) : t13.value - e13.value;
                }), n11 = 0, p10 = d10, e12.forEach(function(t13) {
                  1 === (n11 += "in" === t13.move ? 1 : -1) && "in" === t13.move && (p10 = t13.value), 0 === n11 && pF(p10) && (o12.push({
                    from: p10,
                    to: t13.value,
                    len: t13.value - p10 - (t13.size || 0)
                  }), a11 += t13.value - p10 - (t13.size || 0));
                }), i11.breakArray = o12, pF(d10) && pF(c10) && pF(s11.min) && (i11.unitLength = c10 - d10 - a11 + r12, pX(s11, "afterBreaks"), s11.staticScale ? s11.transA = s11.staticScale : i11.unitLength && (s11.transA *= (c10 - s11.min + r12) / i11.unitLength), r12 && (s11.minPixelPadding = s11.transA * (s11.minPointOffset || 0)), s11.min = d10, s11.max = c10);
              }
            }), pY(e11, true) && s11.chart.redraw();
          }
        }
        t10.Additions = l10;
      }(P || (P = {}));
      let pj = P;
      L.BrokenAxis = L.BrokenAxis || pj, L.BrokenAxis.compose(L.Axis, L.Series);
      let pU = {}, {
        arrayMax: pV,
        arrayMin: p_,
        correctFloat: p$,
        extend: pZ,
        isNumber: pq
      } = ti;
      function pK(t10) {
        let e10 = t10.length, i10 = pJ(t10);
        return pq(i10) && e10 && (i10 = p$(i10 / e10)), i10;
      }
      function pJ(t10) {
        let e10 = t10.length, i10;
        if (!e10 && t10.hasNulls) i10 = null;
        else if (e10) for (i10 = 0; e10--; ) i10 += t10[e10];
        return i10;
      }
      let pQ = {
        average: pK,
        averages: function() {
          let t10 = [];
          return [].forEach.call(arguments, function(e10) {
            t10.push(pK(e10));
          }), void 0 === t10[0] ? void 0 : t10;
        },
        close: function(t10) {
          return t10.length ? t10[t10.length - 1] : t10.hasNulls ? null : void 0;
        },
        high: function(t10) {
          return t10.length ? pV(t10) : t10.hasNulls ? null : void 0;
        },
        hlc: function(t10, e10, i10) {
          if (t10 = pU.high(t10), e10 = pU.low(e10), i10 = pU.close(i10), pq(t10) || pq(e10) || pq(i10)) return [t10, e10, i10];
        },
        low: function(t10) {
          return t10.length ? p_(t10) : t10.hasNulls ? null : void 0;
        },
        ohlc: function(t10, e10, i10, s10) {
          if (t10 = pU.open(t10), e10 = pU.high(e10), i10 = pU.low(i10), s10 = pU.close(s10), pq(t10) || pq(e10) || pq(i10) || pq(s10)) return [t10, e10, i10, s10];
        },
        open: function(t10) {
          return t10.length ? t10[0] : t10.hasNulls ? null : void 0;
        },
        range: function(t10, e10) {
          return (t10 = pU.low(t10), e10 = pU.high(e10), pq(t10) || pq(e10)) ? [t10, e10] : null === t10 && null === e10 ? null : void 0;
        },
        sum: pJ
      };
      pZ(pU, pQ);
      let p0 = {
        common: {
          groupPixelWidth: 2,
          dateTimeLabelFormats: {
            millisecond: ["%[AebHMSL]", "%[AebHMSL]", "-%[HMSL]"],
            second: ["%[AebHMS]", "%[AebHMS]", "-%[HMS]"],
            minute: ["%[AebHM]", "%[AebHM]", "-%[HM]"],
            hour: ["%[AebHM]", "%[AebHM]", "-%[HM]"],
            day: ["%[AebY]", "%[Aeb]", "-%[AebY]"],
            week: ["week from %[AebY]", "%[Aeb]", "-%[AebY]"],
            month: ["%[BY]", "%[B]", "-%[BY]"],
            year: ["%Y", "%Y", "-%Y"]
          }
        },
        seriesSpecific: {
          line: {},
          spline: {},
          area: {},
          areaspline: {},
          arearange: {},
          column: {
            groupPixelWidth: 10
          },
          columnrange: {
            groupPixelWidth: 10
          },
          candlestick: {
            groupPixelWidth: 10
          },
          ohlc: {
            groupPixelWidth: 5
          },
          hlc: {
            groupPixelWidth: 5
          },
          heikinashi: {
            groupPixelWidth: 10
          }
        },
        units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]]
      }, {
        addEvent: p1,
        extend: p2,
        merge: p3,
        pick: p5
      } = ti;
      function p6(t10) {
        let e10 = this, i10 = e10.series;
        i10.forEach(function(t11) {
          t11.groupPixelWidth = void 0;
        }), i10.forEach(function(i11) {
          i11.groupPixelWidth = e10.getGroupPixelWidth && e10.getGroupPixelWidth(), i11.groupPixelWidth && (i11.hasProcessed = true), i11.applyGrouping(!!t10.hasExtremesChanged);
        });
      }
      function p9() {
        let t10 = this.series, e10 = t10.length, i10 = 0, s10 = false, o10, r10;
        for (; e10--; ) (r10 = t10[e10].options.dataGrouping) && (i10 = Math.max(i10, p5(r10.groupPixelWidth, p0.common.groupPixelWidth)), o10 = (t10[e10].dataTable.modified || t10[e10].dataTable).rowCount, (t10[e10].groupPixelWidth || o10 > this.chart.plotSizeX / i10 || o10 && r10.forced) && (s10 = true));
        return s10 ? i10 : 0;
      }
      function p4() {
        this.series.forEach(function(t10) {
          t10.hasProcessed = false;
        });
      }
      function p8(t10, e10) {
        let i10;
        if (e10 = p5(e10, true), t10 || (t10 = {
          forced: false,
          units: null
        }), this instanceof o) for (i10 = this.series.length; i10--; ) this.series[i10].update({
          dataGrouping: t10
        }, false);
        else this.chart.options.series.forEach(function(e11) {
          e11.dataGrouping = "boolean" == typeof t10 ? t10 : p3(t10, e11.dataGrouping);
        });
        this.ordinal && (this.ordinal.slope = void 0), e10 && this.chart.redraw();
      }
      let p7 = {
        compose: function(t10) {
          o = t10;
          let e10 = t10.prototype;
          e10.applyGrouping || (p1(t10, "afterSetScale", p4), p1(t10, "postProcessData", p6), p2(e10, {
            applyGrouping: p6,
            getGroupPixelWidth: p9,
            setDataGrouping: p8
          }));
        }
      }, {
        series: {
          prototype: ut
        }
      } = rv, {
        addEvent: ue,
        defined: ui,
        error: us,
        extend: uo,
        isNumber: ur,
        merge: ua,
        pick: un,
        splat: uh
      } = ti, ul = ut.generatePoints;
      function ud(t10) {
        var e10;
        let i10, s10;
        let o10 = this.chart, r10 = this.options.dataGrouping, a10 = false !== this.allowDG && r10 && un(r10.enabled, o10.options.isStock), n10 = this.reserveSpace(), h10 = this.currentDataGrouping, l10, d10, c10 = false;
        a10 && !this.requireSorting && (this.requireSorting = c10 = true);
        let p10 = false == !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !t10) || !a10;
        if (c10 && (this.requireSorting = false), p10) return;
        this.destroyGroupedData();
        let u2 = r10.groupAll ? this.dataTable : this.dataTable.modified || this.dataTable, g2 = this.getColumn("x", !r10.groupAll), f2 = o10.plotSizeX, m2 = this.xAxis, x2 = m2.getExtremes(), y2 = m2.options.ordinal, b2 = this.groupPixelWidth;
        if (b2 && g2 && u2.rowCount && f2 && ur(x2.min)) {
          s10 = true, this.isDirty = true, this.points = null;
          let t11 = x2.min, a11 = x2.max, h11 = y2 && m2.ordinal && m2.ordinal.getGroupIntervalFactor(t11, a11, this) || 1, c11 = b2 * (a11 - t11) / f2 * h11, p11 = m2.getTimeTicks(sJ.Additions.prototype.normalizeTimeTickInterval(c11, r10.units || p0.units), Math.min(t11, g2[0]), Math.max(a11, g2[g2.length - 1]), m2.options.startOfWeek, g2, this.closestPointRange), v2 = ut.groupData.apply(this, [u2, p11, r10.approximation]), k2 = v2.modified, M2 = k2.getColumn("x", true), w2 = 0;
          for (r10?.smoothed && k2.rowCount && (r10.firstAnchor = "firstPoint", r10.anchor = "middle", r10.lastAnchor = "lastPoint", us(32, false, o10, {
            "dataGrouping.smoothed": "use dataGrouping.anchor"
          })), i10 = 1; i10 < p11.length; i10++) p11.info.segmentStarts && -1 !== p11.info.segmentStarts.indexOf(i10) || (w2 = Math.max(p11[i10] - p11[i10 - 1], w2));
          (l10 = p11.info).gapSize = w2, this.closestPointRange = p11.info.totalRange, this.groupMap = v2.groupMap, this.currentDataGrouping = l10, !function(t12, e11, i11) {
            let s11 = t12.options.dataGrouping, o11 = t12.currentDataGrouping && t12.currentDataGrouping.gapSize, r11 = t12.getColumn("x");
            if (!(s11 && r11.length && o11 && t12.groupMap)) return;
            let a12 = e11.length - 1, n11 = s11.anchor, h12 = s11.firstAnchor, l11 = s11.lastAnchor, d11 = e11.length - 1, c12 = 0;
            if (h12 && r11[0] >= e11[0]) {
              let i12;
              c12++;
              let s12 = t12.groupMap[0].start, a13 = t12.groupMap[0].length;
              ur(s12) && ur(a13) && (i12 = s12 + (a13 - 1)), e11[0] = {
                start: e11[0],
                middle: e11[0] + 0.5 * o11,
                end: e11[0] + o11,
                firstPoint: r11[0],
                lastPoint: i12 && r11[i12]
              }[h12];
            }
            if (a12 > 0 && l11 && o11 && e11[a12] >= i11 - o11) {
              d11--;
              let i12 = t12.groupMap[t12.groupMap.length - 1].start;
              e11[a12] = {
                start: e11[a12],
                middle: e11[a12] + 0.5 * o11,
                end: e11[a12] + o11,
                firstPoint: i12 && r11[i12],
                lastPoint: r11[r11.length - 1]
              }[l11];
            }
            if (n11 && "start" !== n11) {
              let t13 = o11 * {
                middle: 0.5,
                end: 1
              }[n11];
              for (; d11 >= c12; ) e11[d11] += t13, d11--;
            }
          }(this, M2 || [], a11), n10 && M2 && (ui((e10 = M2)[0]) && ur(m2.min) && ur(m2.dataMin) && e10[0] < m2.min && ((!ui(m2.options.min) && m2.min <= m2.dataMin || m2.min === m2.dataMin) && (m2.min = Math.min(e10[0], m2.min)), m2.dataMin = Math.min(e10[0], m2.dataMin)), ui(e10[e10.length - 1]) && ur(m2.max) && ur(m2.dataMax) && e10[e10.length - 1] > m2.max && ((!ui(m2.options.max) && ur(m2.dataMax) && m2.max >= m2.dataMax || m2.max === m2.dataMax) && (m2.max = Math.max(e10[e10.length - 1], m2.max)), m2.dataMax = Math.max(e10[e10.length - 1], m2.dataMax))), r10.groupAll && (this.allGroupedTable = k2, M2 = (k2 = (d10 = this.cropData(k2, m2.min || 0, m2.max || 0)).modified).getColumn("x"), this.cropStart = d10.start), this.dataTable.modified = k2;
        } else this.groupMap = void 0, this.currentDataGrouping = void 0;
        this.hasGroupedData = s10, this.preventGraphAnimation = (h10 && h10.totalRange) !== (l10 && l10.totalRange);
      }
      function uc() {
        this.groupedData && (this.groupedData.forEach(function(t10, e10) {
          t10 && (this.groupedData[e10] = t10.destroy ? t10.destroy() : null);
        }, this), this.groupedData.length = 0, delete this.allGroupedTable);
      }
      function up() {
        ul.apply(this), this.destroyGroupedData(), this.groupedData = this.hasGroupedData ? this.points : null;
      }
      function uu() {
        return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") || this.options.cumulative ? "sum" : "average";
      }
      function ug(t10, e10, i10) {
        let s10 = t10.getColumn("x", true) || [], o10 = t10.getColumn("y", true), r10 = this, a10 = r10.data, n10 = r10.options && r10.options.data, h10 = [], l10 = new rc(), d10 = [], c10 = t10.rowCount, p10 = !!o10, u2 = [], g2 = r10.pointArrayMap, f2 = g2 && g2.length, m2 = ["x"].concat(g2 || ["y"]), x2 = (g2 || ["y"]).map(() => []), y2 = this.options.dataGrouping && this.options.dataGrouping.groupAll, b2, v2, k2, M2 = 0, w2 = 0, S2 = "function" == typeof i10 ? i10 : i10 && pU[i10] ? pU[i10] : pU[r10.getDGApproximation && r10.getDGApproximation() || "average"];
        if (f2) {
          let t11 = g2.length;
          for (; t11--; ) u2.push([]);
        } else u2.push([]);
        let A2 = f2 || 1;
        for (let t11 = 0; t11 <= c10; t11++) if (!(s10[t11] < e10[0])) {
          for (; void 0 !== e10[M2 + 1] && s10[t11] >= e10[M2 + 1] || t11 === c10; ) {
            if (b2 = e10[M2], r10.dataGroupInfo = {
              start: y2 ? w2 : r10.cropStart + w2,
              length: u2[0].length,
              groupStart: b2
            }, k2 = S2.apply(r10, u2), r10.pointClass && !ui(r10.dataGroupInfo.options) && (r10.dataGroupInfo.options = ua(r10.pointClass.prototype.optionsToObject.call({
              series: r10
            }, r10.options.data[r10.cropStart + w2])), m2.forEach(function(t12) {
              delete r10.dataGroupInfo.options[t12];
            })), void 0 !== k2) {
              h10.push(b2);
              let t12 = uh(k2);
              for (let e11 = 0; e11 < t12.length; e11++) x2[e11].push(t12[e11]);
              d10.push(r10.dataGroupInfo);
            }
            w2 = t11;
            for (let t12 = 0; t12 < A2; t12++) u2[t12].length = 0, u2[t12].hasNulls = false;
            if (M2 += 1, t11 === c10) break;
          }
          if (t11 === c10) break;
          if (g2) {
            let e11;
            let i11 = y2 ? t11 : r10.cropStart + t11, s11 = a10 && a10[i11] || r10.pointClass.prototype.applyOptions.apply({
              series: r10
            }, [n10[i11]]);
            for (let t12 = 0; t12 < f2; t12++) ur(e11 = s11[g2[t12]]) ? u2[t12].push(e11) : null === e11 && (u2[t12].hasNulls = true);
          } else ur(v2 = p10 ? o10[t11] : null) ? u2[0].push(v2) : null === v2 && (u2[0].hasNulls = true);
        }
        let T2 = {
          x: h10
        };
        return (g2 || ["y"]).forEach((t11, e11) => {
          T2[t11] = x2[e11];
        }), l10.setColumns(T2), {
          groupMap: d10,
          modified: l10
        };
      }
      function uf(t10) {
        let e10 = t10.options, i10 = this.type, s10 = this.chart.options.plotOptions, o10 = this.useCommonDataGrouping && p0.common, r10 = p0.seriesSpecific, a10 = tT.defaultOptions.plotOptions[i10].dataGrouping;
        if (s10 && (r10[i10] || o10)) {
          let t11 = this.chart.rangeSelector;
          a10 || (a10 = ua(p0.common, r10[i10])), e10.dataGrouping = ua(o10, a10, s10.series && s10.series.dataGrouping, s10[i10].dataGrouping, this.userOptions.dataGrouping, !e10.isInternal && t11 && ur(t11.selected) && t11.buttonOptions[t11.selected].dataGrouping);
        }
      }
      let um = {
        compose: function(t10) {
          let e10 = t10.prototype;
          e10.applyGrouping || (ue(t10.prototype.pointClass, "update", function() {
            if (this.dataGroup) return us(24, false, this.series.chart), false;
          }), ue(t10, "afterSetOptions", uf), ue(t10, "destroy", uc), uo(e10, {
            applyGrouping: ud,
            destroyGroupedData: uc,
            generatePoints: up,
            getDGApproximation: uu,
            groupData: ug
          }));
        },
        groupData: ug
      }, {
        format: ux
      } = eg, {
        composed: uy
      } = L, {
        addEvent: ub,
        extend: uv,
        isNumber: uk,
        pick: uM,
        pushUnique: uw
      } = ti;
      function uS(t10) {
        let e10 = this.chart, i10 = e10.time, s10 = t10.point, o10 = s10.series, r10 = o10.options, a10 = o10.tooltipOptions, n10 = r10.dataGrouping, h10 = o10.xAxis, l10 = a10.xDateFormat || "", d10, c10, p10, u2, g2, f2 = a10[t10.isFooter ? "footerFormat" : "headerFormat"];
        if (h10 && "datetime" === h10.options.type && n10 && uk(s10.key)) {
          c10 = o10.currentDataGrouping, p10 = n10.dateTimeLabelFormats || p0.common.dateTimeLabelFormats, c10 ? (u2 = p10[c10.unitName], 1 === c10.count ? l10 = u2[0] : (l10 = u2[1], d10 = u2[2])) : !l10 && p10 && h10.dateTime && (l10 = h10.dateTime.getXDateFormat(s10.x, a10.dateTimeLabelFormats));
          let r11 = uM(o10.groupMap?.[s10.index].groupStart, s10.key), m2 = r11 + (c10?.totalRange || 0) - 1;
          g2 = i10.dateFormat(l10, r11), d10 && (g2 += i10.dateFormat(d10, m2)), o10.chart.styledMode && (f2 = this.styledModeFormat(f2)), t10.text = ux(f2, {
            point: uv(s10, {
              key: g2
            }),
            series: o10
          }, e10), t10.preventDefault();
        }
      }
      let uA = {
        compose: function(t10, e10, i10) {
          p7.compose(t10), um.compose(e10), i10 && uw(uy, "DataGrouping") && ub(i10, "headerFormatter", uS);
        },
        groupData: um.groupData
      };
      L.dataGrouping = L.dataGrouping || {}, L.dataGrouping.approximationDefaults = L.dataGrouping.approximationDefaults || pQ, L.dataGrouping.approximations = L.dataGrouping.approximations || pU, uA.compose(L.Axis, L.Series, L.Tooltip);
      let {
        defined: uT,
        isNumber: uC,
        pick: uP
      } = ti, uO = {
        backgroundColor: "string",
        borderColor: "string",
        borderRadius: "string",
        color: "string",
        fill: "string",
        fontSize: "string",
        labels: "string",
        name: "string",
        stroke: "string",
        title: "string"
      }, {
        addEvent: uE,
        isObject: uL,
        pick: uD,
        defined: uB,
        merge: uI
      } = ti, {
        getAssignedAxis: uz
      } = {
        annotationsFieldsTypes: uO,
        getAssignedAxis: function(t10) {
          return t10.filter((t11) => {
            let e10 = t11.axis.getExtremes(), i10 = e10.min, s10 = e10.max, o10 = uP(t11.axis.minPointOffset, 0);
            return uC(i10) && uC(s10) && t11.value >= i10 - o10 && t11.value <= s10 + o10 && !t11.axis.options.isInternal;
          })[0];
        },
        getFieldType: function(t10, e10) {
          let i10 = uO[t10], s10 = typeof e10;
          return uT(i10) && (s10 = i10), {
            string: "text",
            number: "number",
            boolean: "checkbox"
          }[s10];
        }
      }, uR = [], uN = {
        enabled: true,
        sensitivity: 1.1
      }, uW = (t10) => (uL(t10) || (t10 = {
        enabled: t10 ?? true
      }), uI(uN, t10)), uG = function(t10, e10, i10, s10, o10, a10, n10) {
        let h10 = uD(n10.type, t10.zooming.type, ""), l10 = [];
        "x" === h10 ? l10 = i10 : "y" === h10 ? l10 = s10 : "xy" === h10 && (l10 = t10.axes);
        let d10 = t10.transform({
          axes: l10,
          to: {
            x: o10 - 5,
            y: a10 - 5,
            width: 10,
            height: 10
          },
          from: {
            x: o10 - 5 * e10,
            y: a10 - 5 * e10,
            width: 10 * e10,
            height: 10 * e10
          },
          trigger: "mousewheel"
        });
        return d10 && (uB(r) && clearTimeout(r), r = setTimeout(() => {
          t10.pointer?.drop();
        }, 400)), d10;
      };
      function uX() {
        let t10 = uW(this.zooming.mouseWheel);
        t10.enabled && uE(this.container, "wheel", (e10) => {
          e10 = this.pointer?.normalize(e10) || e10;
          let {
            pointer: i10
          } = this, s10 = i10 && !i10.inClass(e10.target, "highcharts-no-mousewheel");
          if (this.isInsidePlot(e10.chartX - this.plotLeft, e10.chartY - this.plotTop) && s10) {
            let s11 = t10.sensitivity || 1.1, o10 = e10.detail || (e10.deltaY || 0) / 120, r10 = uz(i10.getCoordinates(e10).xAxis), a10 = uz(i10.getCoordinates(e10).yAxis);
            uG(this, Math.pow(s11, o10), r10 ? [r10.axis] : this.xAxis, a10 ? [a10.axis] : this.yAxis, e10.chartX, e10.chartY, t10) && e10.preventDefault?.();
          }
        });
      }
      L.MouseWheelZoom = L.MouseWheelZoom || {
        compose: function(t10) {
          -1 === uR.indexOf(t10) && (uR.push(t10), uE(t10, "afterGetContainer", uX));
        }
      }, L.MouseWheelZoom.compose(L.Chart), L.Navigator = L.Navigator || dQ, L.OrdinalAxis = L.OrdinalAxis || d7, L.RangeSelector = L.RangeSelector || cN, L.Scrollbar = L.Scrollbar || dB, L.stockChart = L.stockChart || c1.stockChart, L.StockChart = L.StockChart || L.stockChart, L.extend(L.StockChart, c1), lX.compose(L.Series, L.Axis, L.Point), pN.compose(L.Renderer), pl.compose(L.Series), L.Navigator.compose(L.Chart, L.Axis, L.Series), L.OrdinalAxis.compose(L.Axis, L.Series, L.Chart), L.RangeSelector.compose(L.Axis, L.Chart), L.Scrollbar.compose(L.Axis), L.StockChart.compose(L.Chart, L.Axis, L.Series, L.SVGRenderer), /**
      * @license Highstock JS v12.1.2 (2024-12-21)
      * @module highcharts/highstock
      *
      * (c) 2009-2024 Torstein Honsi
      *
      * License: www.highcharts.com/license
      */
      L.product = "Highstock";
      let uH = L;
      return E.default;
    })());
  }
});

// node_modules/highcharts/highcharts-gantt.js
var require_highcharts_gantt = __commonJS({
  "node_modules/highcharts/highcharts-gantt.js"(exports, module) {
    !/**
    * Highcharts JS v12.1.2 (2024-12-21)
    * @module highcharts/highcharts
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? (t._Highcharts = e(), module.exports = t._Highcharts) : "function" == typeof define && define.amd ? define("highcharts/highcharts", [], e) : "object" == typeof exports ? (t._Highcharts = e(), exports.highcharts = t._Highcharts) : (t.Highcharts && t.Highcharts.error(16, true), t.Highcharts = e());
    }("undefined" == typeof window ? exports : window, () => (() => {
      "use strict";
      let t, e, i, s, o;
      var r, n, a, h, l, d, c, p, u, g, f, m, x, y, b, v, M, k, w, S, A, T, P = {};
      P.d = (t10, e10) => {
        for (var i10 in e10) P.o(e10, i10) && !P.o(t10, i10) && Object.defineProperty(t10, i10, {
          enumerable: true,
          get: e10[i10]
        });
      }, P.o = (t10, e10) => Object.prototype.hasOwnProperty.call(t10, e10);
      var C = {};
      P.d(C, {
        default: () => gr
      }), function(t10) {
        t10.SVG_NS = "http://www.w3.org/2000/svg", t10.product = "Highcharts", t10.version = "12.1.2", t10.win = "undefined" != typeof window ? window : {}, t10.doc = t10.win.document, t10.svg = t10.doc && t10.doc.createElementNS && !!t10.doc.createElementNS(t10.SVG_NS, "svg").createSVGRect, t10.pageLang = t10.doc?.documentElement?.closest("[lang]")?.lang, t10.userAgent = t10.win.navigator && t10.win.navigator.userAgent || "", t10.isChrome = t10.win.chrome, t10.isFirefox = -1 !== t10.userAgent.indexOf("Firefox"), t10.isMS = /(edge|msie|trident)/i.test(t10.userAgent) && !t10.win.opera, t10.isSafari = !t10.isChrome && -1 !== t10.userAgent.indexOf("Safari"), t10.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(t10.userAgent), t10.isWebKit = -1 !== t10.userAgent.indexOf("AppleWebKit"), t10.deg2rad = 2 * Math.PI / 360, t10.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], t10.noop = function() {
        }, t10.supportsPassiveEvents = function() {
          let e10 = false;
          if (!t10.isMS) {
            let i10 = Object.defineProperty({}, "passive", {
              get: function() {
                e10 = true;
              }
            });
            t10.win.addEventListener && t10.win.removeEventListener && (t10.win.addEventListener("testPassive", t10.noop, i10), t10.win.removeEventListener("testPassive", t10.noop, i10));
          }
          return e10;
        }(), t10.charts = [], t10.composed = [], t10.dateFormats = {}, t10.seriesTypes = {}, t10.symbolSizes = {}, t10.chartCount = 0;
      }(r || (r = {}));
      let O = r, {
        charts: E,
        doc: L,
        win: B
      } = O;
      function I(t10, e10, i10, s10) {
        let o10 = e10 ? "Highcharts error" : "Highcharts warning";
        32 === t10 && (t10 = `${o10}: Deprecated member`);
        let r10 = H(t10), n10 = r10 ? `${o10} #${t10}: www.highcharts.com/errors/${t10}/` : t10.toString();
        if (void 0 !== s10) {
          let t11 = "";
          r10 && (n10 += "?"), Z(s10, function(e11, i11) {
            t11 += `
 - ${i11}: ${e11}`, r10 && (n10 += encodeURI(i11) + "=" + encodeURI(e11));
          }), n10 += t11;
        }
        J(O, "displayError", {
          chart: i10,
          code: t10,
          message: n10,
          params: s10
        }, function() {
          if (e10) throw Error(n10);
          B.console && -1 === I.messages.indexOf(n10) && console.warn(n10);
        }), I.messages.push(n10);
      }
      function D(t10, e10) {
        return parseInt(t10, e10 || 10);
      }
      function R(t10) {
        return "string" == typeof t10;
      }
      function N(t10) {
        let e10 = Object.prototype.toString.call(t10);
        return "[object Array]" === e10 || "[object Array Iterator]" === e10;
      }
      function z(t10, e10) {
        return !!t10 && "object" == typeof t10 && (!e10 || !N(t10));
      }
      function W(t10) {
        return z(t10) && "number" == typeof t10.nodeType;
      }
      function G(t10) {
        let e10 = t10 && t10.constructor;
        return !!(z(t10, true) && !W(t10) && e10 && e10.name && "Object" !== e10.name);
      }
      function H(t10) {
        return "number" == typeof t10 && !isNaN(t10) && t10 < 1 / 0 && t10 > -1 / 0;
      }
      function F(t10) {
        return null != t10;
      }
      function X(t10, e10, i10) {
        let s10;
        let o10 = R(e10) && !F(i10), r10 = (e11, i11) => {
          F(e11) ? t10.setAttribute(i11, e11) : o10 ? (s10 = t10.getAttribute(i11)) || "class" !== i11 || (s10 = t10.getAttribute(i11 + "Name")) : t10.removeAttribute(i11);
        };
        return R(e10) ? r10(i10, e10) : Z(e10, r10), s10;
      }
      function Y(t10) {
        return N(t10) ? t10 : [t10];
      }
      function j(t10, e10) {
        let i10;
        for (i10 in t10 || (t10 = {}), e10) t10[i10] = e10[i10];
        return t10;
      }
      function U() {
        let t10 = arguments, e10 = t10.length;
        for (let i10 = 0; i10 < e10; i10++) {
          let e11 = t10[i10];
          if (null != e11) return e11;
        }
      }
      function V(t10, e10) {
        j(t10.style, e10);
      }
      function $(t10) {
        return Math.pow(10, Math.floor(Math.log(t10) / Math.LN10));
      }
      function _(t10, e10) {
        return t10 > 1e14 ? t10 : parseFloat(t10.toPrecision(e10 || 14));
      }
      (I || (I = {})).messages = [], Math.easeInOutSine = function(t10) {
        return -0.5 * (Math.cos(Math.PI * t10) - 1);
      };
      let q = Array.prototype.find ? function(t10, e10) {
        return t10.find(e10);
      } : function(t10, e10) {
        let i10;
        let s10 = t10.length;
        for (i10 = 0; i10 < s10; i10++) if (e10(t10[i10], i10)) return t10[i10];
      };
      function Z(t10, e10, i10) {
        for (let s10 in t10) Object.hasOwnProperty.call(t10, s10) && e10.call(i10 || t10[s10], t10[s10], s10, t10);
      }
      function K(t10, e10, i10) {
        function s10(e11, i11) {
          let s11 = t10.removeEventListener;
          s11 && s11.call(t10, e11, i11, false);
        }
        function o10(i11) {
          let o11, r11;
          t10.nodeName && (e10 ? (o11 = {})[e10] = true : o11 = i11, Z(o11, function(t11, e11) {
            if (i11[e11]) for (r11 = i11[e11].length; r11--; ) s10(e11, i11[e11][r11].fn);
          }));
        }
        let r10 = "function" == typeof t10 && t10.prototype || t10;
        if (Object.hasOwnProperty.call(r10, "hcEvents")) {
          let t11 = r10.hcEvents;
          if (e10) {
            let r11 = t11[e10] || [];
            i10 ? (t11[e10] = r11.filter(function(t12) {
              return i10 !== t12.fn;
            }), s10(e10, i10)) : (o10(t11), t11[e10] = []);
          } else o10(t11), delete r10.hcEvents;
        }
      }
      function J(t10, e10, i10, s10) {
        if (i10 = i10 || {}, L.createEvent && (t10.dispatchEvent || t10.fireEvent && t10 !== O)) {
          let s11 = L.createEvent("Events");
          s11.initEvent(e10, true, true), i10 = j(s11, i10), t10.dispatchEvent ? t10.dispatchEvent(i10) : t10.fireEvent(e10, i10);
        } else if (t10.hcEvents) {
          i10.target || j(i10, {
            preventDefault: function() {
              i10.defaultPrevented = true;
            },
            target: t10,
            type: e10
          });
          let s11 = [], o10 = t10, r10 = false;
          for (; o10.hcEvents; ) Object.hasOwnProperty.call(o10, "hcEvents") && o10.hcEvents[e10] && (s11.length && (r10 = true), s11.unshift.apply(s11, o10.hcEvents[e10])), o10 = Object.getPrototypeOf(o10);
          r10 && s11.sort((t11, e11) => t11.order - e11.order), s11.forEach((e11) => {
            false === e11.fn.call(t10, i10) && i10.preventDefault();
          });
        }
        s10 && !i10.defaultPrevented && s10.call(t10, i10);
      }
      let Q = function() {
        let e10 = Math.random().toString(36).substring(2, 9) + "-", i10 = 0;
        return function() {
          return "highcharts-" + (t ? "" : e10) + i10++;
        };
      }();
      B.jQuery && (B.jQuery.fn.highcharts = function() {
        let t10 = [].slice.call(arguments);
        if (this[0]) return t10[0] ? (new O[R(t10[0]) ? t10.shift() : "Chart"](this[0], t10[0], t10[1]), this) : E[X(this[0], "data-highcharts-chart")];
      });
      let tt = {
        addEvent: function(t10, e10, i10, s10 = {}) {
          let o10 = "function" == typeof t10 && t10.prototype || t10;
          Object.hasOwnProperty.call(o10, "hcEvents") || (o10.hcEvents = {});
          let r10 = o10.hcEvents;
          O.Point && t10 instanceof O.Point && t10.series && t10.series.chart && (t10.series.chart.runTrackerClick = true);
          let n10 = t10.addEventListener;
          n10 && n10.call(t10, e10, i10, !!O.supportsPassiveEvents && {
            passive: void 0 === s10.passive ? -1 !== e10.indexOf("touch") : s10.passive,
            capture: false
          }), r10[e10] || (r10[e10] = []);
          let a10 = {
            fn: i10,
            order: "number" == typeof s10.order ? s10.order : 1 / 0
          };
          return r10[e10].push(a10), r10[e10].sort((t11, e11) => t11.order - e11.order), function() {
            K(t10, e10, i10);
          };
        },
        arrayMax: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] > i10 && (i10 = t10[e10]);
          return i10;
        },
        arrayMin: function(t10) {
          let e10 = t10.length, i10 = t10[0];
          for (; e10--; ) t10[e10] < i10 && (i10 = t10[e10]);
          return i10;
        },
        attr: X,
        clamp: function(t10, e10, i10) {
          return t10 > e10 ? t10 < i10 ? t10 : i10 : e10;
        },
        clearTimeout: function(t10) {
          F(t10) && clearTimeout(t10);
        },
        correctFloat: _,
        createElement: function(t10, e10, i10, s10, o10) {
          let r10 = L.createElement(t10);
          return e10 && j(r10, e10), o10 && V(r10, {
            padding: "0",
            border: "none",
            margin: "0"
          }), i10 && V(r10, i10), s10 && s10.appendChild(r10), r10;
        },
        crisp: function(t10, e10 = 0, i10) {
          let s10 = e10 % 2 / 2, o10 = i10 ? -1 : 1;
          return (Math.round(t10 * o10 - s10) + s10) * o10;
        },
        css: V,
        defined: F,
        destroyObjectProperties: function(t10, e10, i10) {
          Z(t10, function(s10, o10) {
            s10 !== e10 && s10?.destroy && s10.destroy(), (s10?.destroy || !i10) && delete t10[o10];
          });
        },
        diffObjects: function(t10, e10, i10, s10) {
          let o10 = {};
          return !function t11(e11, o11, r10, n10) {
            let a10 = i10 ? o11 : e11;
            Z(e11, function(i11, h10) {
              if (!n10 && s10 && s10.indexOf(h10) > -1 && o11[h10]) {
                i11 = Y(i11), r10[h10] = [];
                for (let e12 = 0; e12 < Math.max(i11.length, o11[h10].length); e12++) o11[h10][e12] && (void 0 === i11[e12] ? r10[h10][e12] = o11[h10][e12] : (r10[h10][e12] = {}, t11(i11[e12], o11[h10][e12], r10[h10][e12], n10 + 1)));
              } else z(i11, true) && !i11.nodeType ? (r10[h10] = N(i11) ? [] : {}, t11(i11, o11[h10] || {}, r10[h10], n10 + 1), 0 !== Object.keys(r10[h10]).length || "colorAxis" === h10 && 0 === n10 || delete r10[h10]) : (e11[h10] !== o11[h10] || h10 in e11 && !(h10 in o11)) && "__proto__" !== h10 && "constructor" !== h10 && (r10[h10] = a10[h10]);
            });
          }(t10, e10, o10, 0), o10;
        },
        discardElement: function(t10) {
          t10 && t10.parentElement && t10.parentElement.removeChild(t10);
        },
        erase: function(t10, e10) {
          let i10 = t10.length;
          for (; i10--; ) if (t10[i10] === e10) {
            t10.splice(i10, 1);
            break;
          }
        },
        error: I,
        extend: j,
        extendClass: function(t10, e10) {
          let i10 = function() {
          };
          return i10.prototype = new t10(), j(i10.prototype, e10), i10;
        },
        find: q,
        fireEvent: J,
        getAlignFactor: (t10 = "") => ({
          center: 0.5,
          right: 1,
          middle: 0.5,
          bottom: 1
        })[t10] || 0,
        getClosestDistance: function(t10, e10) {
          let i10, s10, o10, r10;
          let n10 = !e10;
          return t10.forEach((t11) => {
            if (t11.length > 1) for (r10 = s10 = t11.length - 1; r10 > 0; r10--) (o10 = t11[r10] - t11[r10 - 1]) < 0 && !n10 ? (e10?.(), e10 = void 0) : o10 && (void 0 === i10 || o10 < i10) && (i10 = o10);
          }), i10;
        },
        getMagnitude: $,
        getNestedProperty: function(t10, e10) {
          let i10 = t10.split(".");
          for (; i10.length && F(e10); ) {
            let t11 = i10.shift();
            if (void 0 === t11 || "__proto__" === t11) return;
            if ("this" === t11) {
              let t12;
              return z(e10) && (t12 = e10["@this"]), t12 ?? e10;
            }
            let s10 = e10[t11.replace(/[\\'"]/g, "")];
            if (!F(s10) || "function" == typeof s10 || "number" == typeof s10.nodeType || s10 === B) return;
            e10 = s10;
          }
          return e10;
        },
        getStyle: function t10(e10, i10, s10) {
          let o10;
          if ("width" === i10) {
            let i11 = Math.min(e10.offsetWidth, e10.scrollWidth), s11 = e10.getBoundingClientRect && e10.getBoundingClientRect().width;
            return s11 < i11 && s11 >= i11 - 1 && (i11 = Math.floor(s11)), Math.max(0, i11 - (t10(e10, "padding-left", true) || 0) - (t10(e10, "padding-right", true) || 0));
          }
          if ("height" === i10) return Math.max(0, Math.min(e10.offsetHeight, e10.scrollHeight) - (t10(e10, "padding-top", true) || 0) - (t10(e10, "padding-bottom", true) || 0));
          let r10 = B.getComputedStyle(e10, void 0);
          return r10 && (o10 = r10.getPropertyValue(i10), U(s10, "opacity" !== i10) && (o10 = D(o10))), o10;
        },
        insertItem: function(t10, e10) {
          let i10;
          let s10 = t10.options.index, o10 = e10.length;
          for (i10 = t10.options.isInternal ? o10 : 0; i10 < o10 + 1; i10++) if (!e10[i10] || H(s10) && s10 < U(e10[i10].options.index, e10[i10]._i) || e10[i10].options.isInternal) {
            e10.splice(i10, 0, t10);
            break;
          }
          return i10;
        },
        isArray: N,
        isClass: G,
        isDOMElement: W,
        isFunction: function(t10) {
          return "function" == typeof t10;
        },
        isNumber: H,
        isObject: z,
        isString: R,
        merge: function(t10, ...e10) {
          let i10, s10 = [t10, ...e10], o10 = {}, r10 = function(t11, e11) {
            return "object" != typeof t11 && (t11 = {}), Z(e11, function(i11, s11) {
              "__proto__" !== s11 && "constructor" !== s11 && (!z(i11, true) || G(i11) || W(i11) ? t11[s11] = e11[s11] : t11[s11] = r10(t11[s11] || {}, i11));
            }), t11;
          };
          true === t10 && (o10 = s10[1], s10 = Array.prototype.slice.call(s10, 2));
          let n10 = s10.length;
          for (i10 = 0; i10 < n10; i10++) o10 = r10(o10, s10[i10]);
          return o10;
        },
        normalizeTickInterval: function(t10, e10, i10, s10, o10) {
          let r10, n10 = t10;
          i10 = U(i10, $(t10));
          let a10 = t10 / i10;
          for (!e10 && (e10 = o10 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === s10 && (1 === i10 ? e10 = e10.filter(function(t11) {
            return t11 % 1 == 0;
          }) : i10 <= 0.1 && (e10 = [1 / i10]))), r10 = 0; r10 < e10.length && (n10 = e10[r10], (!o10 || !(n10 * i10 >= t10)) && (o10 || !(a10 <= (e10[r10] + (e10[r10 + 1] || e10[r10])) / 2))); r10++) ;
          return _(n10 * i10, -Math.round(Math.log(1e-3) / Math.LN10));
        },
        objectEach: Z,
        offset: function(t10) {
          let e10 = L.documentElement, i10 = t10.parentElement || t10.parentNode ? t10.getBoundingClientRect() : {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          };
          return {
            top: i10.top + (B.pageYOffset || e10.scrollTop) - (e10.clientTop || 0),
            left: i10.left + (B.pageXOffset || e10.scrollLeft) - (e10.clientLeft || 0),
            width: i10.width,
            height: i10.height
          };
        },
        pad: function(t10, e10, i10) {
          return Array((e10 || 2) + 1 - String(t10).replace("-", "").length).join(i10 || "0") + t10;
        },
        pick: U,
        pInt: D,
        pushUnique: function(t10, e10) {
          return 0 > t10.indexOf(e10) && !!t10.push(e10);
        },
        relativeLength: function(t10, e10, i10) {
          return /%$/.test(t10) ? e10 * parseFloat(t10) / 100 + (i10 || 0) : parseFloat(t10);
        },
        removeEvent: K,
        replaceNested: function(t10, ...e10) {
          let i10, s10;
          do
            for (s10 of (i10 = t10, e10)) t10 = t10.replace(s10[0], s10[1]);
          while (t10 !== i10);
          return t10;
        },
        splat: Y,
        stableSort: function(t10, e10) {
          let i10, s10;
          let o10 = t10.length;
          for (s10 = 0; s10 < o10; s10++) t10[s10].safeI = s10;
          for (t10.sort(function(t11, s11) {
            return 0 === (i10 = e10(t11, s11)) ? t11.safeI - s11.safeI : i10;
          }), s10 = 0; s10 < o10; s10++) delete t10[s10].safeI;
        },
        syncTimeout: function(t10, e10, i10) {
          return e10 > 0 ? setTimeout(t10, e10, i10) : (t10.call(0, i10), -1);
        },
        timeUnits: {
          millisecond: 1,
          second: 1e3,
          minute: 6e4,
          hour: 36e5,
          day: 864e5,
          week: 6048e5,
          month: 24192e5,
          year: 314496e5
        },
        ucfirst: function(t10) {
          return R(t10) ? t10.substring(0, 1).toUpperCase() + t10.substring(1) : String(t10);
        },
        uniqueKey: Q,
        useSerialIds: function(e10) {
          return t = U(e10, t);
        },
        wrap: function(t10, e10, i10) {
          let s10 = t10[e10];
          t10[e10] = function() {
            let t11 = arguments, e11 = this;
            return i10.apply(this, [function() {
              return s10.apply(e11, arguments.length ? arguments : t11);
            }].concat([].slice.call(arguments)));
          };
        }
      }, {
        pageLang: te,
        win: ti
      } = O, {
        defined: ts,
        error: to,
        extend: tr,
        isNumber: tn,
        isObject: ta,
        isString: th,
        merge: tl,
        objectEach: td,
        pad: tc,
        splat: tp,
        timeUnits: tu,
        ucfirst: tg
      } = tt, tf = O.isSafari && ti.Intl && !ti.Intl.DateTimeFormat.prototype.formatRange, tm = (t10) => void 0 === t10.main, tx = (t10) => ["D", "L", "M", "X", "J", "V", "S"].indexOf(t10), ty = class {
        constructor(t10) {
          this.options = {
            timezone: "UTC"
          }, this.variableTimezone = false, this.Date = ti.Date, this.update(t10);
        }
        update(t10 = {}) {
          this.dTLCache = {}, this.options = t10 = tl(true, this.options, t10);
          let {
            timezoneOffset: e10,
            useUTC: i10
          } = t10;
          this.Date = t10.Date || ti.Date || Date;
          let s10 = t10.timezone;
          ts(i10) && (s10 = i10 ? "UTC" : void 0), e10 && e10 % 60 == 0 && (s10 = "Etc/GMT" + (e10 > 0 ? "+" : "") + e10 / 60), this.variableTimezone = "UTC" !== s10 && s10?.indexOf("Etc/GMT") !== 0, this.timezone = s10, ["months", "shortMonths", "weekdays", "shortWeekdays"].forEach((t11) => {
            let e11 = /months/i.test(t11), i11 = /short/.test(t11), s11 = {
              timeZone: "UTC"
            };
            s11[e11 ? "month" : "weekday"] = i11 ? "short" : "long", this[t11] = (e11 ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map((t12) => this.dateFormat(s11, (e11 ? 31 : 1) * 24 * 36e5 * t12));
          });
        }
        toParts(t10) {
          let [e10, i10, s10, o10, r10, n10, a10] = this.dateTimeFormat({
            weekday: "narrow",
            day: "numeric",
            month: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
          }, t10, "es").split(/(?:, |\/|:)/g);
          return [o10, +s10 - 1, i10, r10, n10, a10, Math.floor(Number(t10) || 0) % 1e3, tx(e10)].map(Number);
        }
        dateTimeFormat(t10, e10, i10 = this.options.locale || te) {
          let s10 = JSON.stringify(t10) + i10;
          th(t10) && (t10 = this.str2dtf(t10));
          let o10 = this.dTLCache[s10];
          if (!o10) {
            t10.timeZone ?? (t10.timeZone = this.timezone);
            try {
              o10 = new Intl.DateTimeFormat(i10, t10);
            } catch (e11) {
              /Invalid time zone/i.test(e11.message) ? (to(34), t10.timeZone = "UTC", o10 = new Intl.DateTimeFormat(i10, t10)) : to(e11.message, false);
            }
          }
          return this.dTLCache[s10] = o10, o10?.format(e10) || "";
        }
        str2dtf(t10, e10 = {}) {
          let i10 = {
            L: {
              fractionalSecondDigits: 3
            },
            S: {
              second: "2-digit"
            },
            M: {
              minute: "numeric"
            },
            H: {
              hour: "2-digit"
            },
            k: {
              hour: "numeric"
            },
            E: {
              weekday: "narrow"
            },
            a: {
              weekday: "short"
            },
            A: {
              weekday: "long"
            },
            d: {
              day: "2-digit"
            },
            e: {
              day: "numeric"
            },
            b: {
              month: "short"
            },
            B: {
              month: "long"
            },
            m: {
              month: "2-digit"
            },
            o: {
              month: "numeric"
            },
            y: {
              year: "2-digit"
            },
            Y: {
              year: "numeric"
            }
          };
          return Object.keys(i10).forEach((s10) => {
            -1 !== t10.indexOf(s10) && tr(e10, i10[s10]);
          }), e10;
        }
        makeTime(t10, e10, i10 = 1, s10 = 0, o10, r10, n10) {
          let a10 = this.Date.UTC(t10, e10, i10, s10, o10 || 0, r10 || 0, n10 || 0);
          if ("UTC" !== this.timezone) {
            let t11 = this.getTimezoneOffset(a10);
            if (a10 += t11, -1 !== [2, 3, 8, 9, 10, 11].indexOf(e10) && (s10 < 5 || s10 > 20)) {
              let e11 = this.getTimezoneOffset(a10);
              t11 !== e11 ? a10 += e11 - t11 : t11 - 36e5 !== this.getTimezoneOffset(a10 - 36e5) || tf || (a10 -= 36e5);
            }
          }
          return a10;
        }
        parse(t10) {
          if (!th(t10)) return t10 ?? void 0;
          let e10 = (t10 = t10.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t10), i10 = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(t10);
          e10 || i10 || (t10 += "Z");
          let s10 = Date.parse(t10);
          if (tn(s10)) return s10 + (!e10 || i10 ? this.getTimezoneOffset(s10) : 0);
        }
        getTimezoneOffset(t10) {
          if ("UTC" !== this.timezone) {
            let [e10, i10, s10, o10, r10 = 0] = this.dateTimeFormat({
              timeZoneName: "shortOffset"
            }, t10, "en").split(/(GMT|:)/).map(Number), n10 = -(36e5 * (s10 + r10 / 60));
            if (tn(n10)) return n10;
          }
          return 0;
        }
        dateFormat(t10, e10, i10) {
          let s10 = O.defaultOptions?.lang;
          if (!ts(e10) || isNaN(e10)) return s10?.invalidDate || "";
          if (th(t10 = t10 ?? "%Y-%m-%d %H:%M:%S")) {
            let i11;
            let s11 = /%\[([a-zA-Z]+)\]/g;
            for (; i11 = s11.exec(t10); ) t10 = t10.replace(i11[0], this.dateTimeFormat(i11[1], e10));
          }
          if (th(t10) && -1 !== t10.indexOf("%")) {
            let i11 = this, [o10, r10, n10, a10, h10, l10, d10, c10] = this.toParts(e10), p10 = s10?.weekdays || this.weekdays, u10 = s10?.shortWeekdays || this.shortWeekdays, g2 = s10?.months || this.months, f2 = s10?.shortMonths || this.shortMonths;
            td(tr({
              a: u10 ? u10[c10] : p10[c10].substr(0, 3),
              A: p10[c10],
              d: tc(n10),
              e: tc(n10, 2, " "),
              w: c10,
              b: f2[r10],
              B: g2[r10],
              m: tc(r10 + 1),
              o: r10 + 1,
              y: o10.toString().substr(2, 2),
              Y: o10,
              H: tc(a10),
              k: a10,
              I: tc(a10 % 12 || 12),
              l: a10 % 12 || 12,
              M: tc(h10),
              p: a10 < 12 ? "AM" : "PM",
              P: a10 < 12 ? "am" : "pm",
              S: tc(l10),
              L: tc(d10, 3)
            }, O.dateFormats), function(s11, o11) {
              if (th(t10)) for (; -1 !== t10.indexOf("%" + o11); ) t10 = t10.replace("%" + o11, "function" == typeof s11 ? s11.call(i11, e10) : s11);
            });
          } else if (ta(t10)) {
            let i11 = (this.getTimezoneOffset(e10) || 0) / 36e5, s11 = this.timezone || "Etc/GMT" + (i11 >= 0 ? "+" : "") + i11, {
              prefix: o10 = "",
              suffix: r10 = ""
            } = t10;
            t10 = o10 + this.dateTimeFormat(tr({
              timeZone: s11
            }, t10), e10) + r10;
          }
          return i10 ? tg(t10) : t10;
        }
        resolveDTLFormat(t10) {
          return ta(t10, true) ? ta(t10, true) && tm(t10) ? {
            main: t10
          } : t10 : {
            main: (t10 = tp(t10))[0],
            from: t10[1],
            to: t10[2]
          };
        }
        getTimeTicks(t10, e10, i10, s10) {
          let o10 = this, r10 = [], n10 = {}, {
            count: a10 = 1,
            unitRange: h10
          } = t10, [l10, d10, c10, p10, u10, g2] = o10.toParts(e10), f2 = (e10 || 0) % 1e3, m2;
          if (s10 ?? (s10 = 1), ts(e10)) {
            if (f2 = h10 >= tu.second ? 0 : a10 * Math.floor(f2 / a10), h10 >= tu.second && (g2 = h10 >= tu.minute ? 0 : a10 * Math.floor(g2 / a10)), h10 >= tu.minute && (u10 = h10 >= tu.hour ? 0 : a10 * Math.floor(u10 / a10)), h10 >= tu.hour && (p10 = h10 >= tu.day ? 0 : a10 * Math.floor(p10 / a10)), h10 >= tu.day && (c10 = h10 >= tu.month ? 1 : Math.max(1, a10 * Math.floor(c10 / a10))), h10 >= tu.month && (d10 = h10 >= tu.year ? 0 : a10 * Math.floor(d10 / a10)), h10 >= tu.year && (l10 -= l10 % a10), h10 === tu.week) {
              a10 && (e10 = o10.makeTime(l10, d10, c10, p10, u10, g2, f2));
              let t12 = tx(this.dateTimeFormat({
                timeZone: this.timezone,
                weekday: "narrow"
              }, e10, "es"));
              c10 += -t12 + s10 + (t12 < s10 ? -7 : 0);
            }
            e10 = o10.makeTime(l10, d10, c10, p10, u10, g2, f2), o10.variableTimezone && ts(i10) && (m2 = i10 - e10 > 4 * tu.month || o10.getTimezoneOffset(e10) !== o10.getTimezoneOffset(i10));
            let t11 = e10, x2 = 1;
            for (; t11 < i10; ) r10.push(t11), h10 === tu.year ? t11 = o10.makeTime(l10 + x2 * a10, 0) : h10 === tu.month ? t11 = o10.makeTime(l10, d10 + x2 * a10) : m2 && (h10 === tu.day || h10 === tu.week) ? t11 = o10.makeTime(l10, d10, c10 + x2 * a10 * (h10 === tu.day ? 1 : 7)) : m2 && h10 === tu.hour && a10 > 1 ? t11 = o10.makeTime(l10, d10, c10, p10 + x2 * a10) : t11 += h10 * a10, x2++;
            r10.push(t11), h10 <= tu.hour && r10.length < 1e4 && r10.forEach((t12) => {
              t12 % 18e5 == 0 && "000000000" === o10.dateFormat("%H%M%S%L", t12) && (n10[t12] = "day");
            });
          }
          return r10.info = tr(t10, {
            higherRanks: n10,
            totalRange: h10 * a10
          }), r10;
        }
        getDateFormat(t10, e10, i10, s10) {
          let o10 = this.dateFormat("%m-%d %H:%M:%S.%L", e10), r10 = "01-01 00:00:00.000", n10 = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          }, a10 = "millisecond", h10 = a10;
          for (a10 in tu) {
            if (t10 === tu.week && +this.dateFormat("%w", e10) === i10 && o10.substr(6) === r10.substr(6)) {
              a10 = "week";
              break;
            }
            if (tu[a10] > t10) {
              a10 = h10;
              break;
            }
            if (n10[a10] && o10.substr(n10[a10]) !== r10.substr(n10[a10])) break;
            "week" !== a10 && (h10 = a10);
          }
          return this.resolveDTLFormat(s10[a10]).main;
        }
      }, {
        isTouchDevice: tb
      } = O, {
        fireEvent: tv,
        merge: tM
      } = tt, tk = {
        colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"],
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          locale: void 0,
          loading: "Loading...",
          months: void 0,
          shortMonths: void 0,
          weekdays: void 0,
          numericSymbols: ["k", "M", "G", "T", "P", "E"],
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1"
        },
        global: {
          buttonTheme: {
            fill: "#f7f7f7",
            padding: 8,
            r: 2,
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontSize: "0.8em",
              fontWeight: "normal"
            },
            states: {
              hover: {
                fill: "#e6e6e6"
              },
              select: {
                fill: "#e6e9ff",
                style: {
                  color: "#000000",
                  fontWeight: "bold"
                }
              },
              disabled: {
                style: {
                  color: "#cccccc"
                }
              }
            }
          }
        },
        time: {
          Date: void 0,
          timezone: "UTC",
          timezoneOffset: 0,
          useUTC: void 0
        },
        chart: {
          alignThresholds: false,
          panning: {
            enabled: false,
            type: "x"
          },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: {
            theme: {},
            position: {}
          },
          reflow: true,
          type: "line",
          zooming: {
            singleTouch: false,
            resetButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            }
          },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        },
        title: {
          style: {
            color: "#333333",
            fontWeight: "bold"
          },
          text: "Chart title",
          margin: 15,
          minScale: 0.67
        },
        subtitle: {
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: ""
        },
        caption: {
          margin: 15,
          style: {
            color: "#666666",
            fontSize: "0.8em"
          },
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        legend: {
          enabled: true,
          align: "center",
          alignColumns: true,
          className: "highcharts-no-tooltip",
          events: {},
          layout: "horizontal",
          itemMarginBottom: 2,
          itemMarginTop: 2,
          labelFormatter: function() {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            style: {
              fontSize: "0.8em"
            },
            activeColor: "#0022ff",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "0.8em",
            textDecoration: "none",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#666666",
            textDecoration: "line-through"
          },
          shadow: false,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: true,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontSize: "0.8em",
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: 0.5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: true,
          animation: {
            duration: 300,
            easing: (t10) => Math.sqrt(1 - Math.pow(t10 - 1, 2))
          },
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%[AebHMSL]",
            second: "%[AebHMS]",
            minute: "%[AebHM]",
            hour: "%[AebHM]",
            day: "%[AebY]",
            week: "Week from %[AebY]",
            month: "%[BY]",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: false,
          snap: tb ? 25 : 10,
          headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: "#ffffff",
          borderWidth: void 0,
          shadow: true,
          stickOnContact: false,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "0.8em"
          },
          useHTML: false
        },
        credits: {
          enabled: true,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "0.6em"
          },
          text: "Highcharts.com"
        }
      }, tw = new ty(tk.time), tS = {
        defaultOptions: tk,
        defaultTime: tw,
        getOptions: function() {
          return tk;
        },
        setOptions: function(t10) {
          return tv(O, "setOptions", {
            options: t10
          }), tM(true, tk, t10), t10.time && tw.update(tk.time), t10.lang && "locale" in t10.lang && tw.update({
            locale: t10.lang.locale
          }), tk;
        }
      }, {
        isNumber: tA,
        merge: tT,
        pInt: tP,
        defined: tC
      } = tt;
      class tO {
        static parse(t10) {
          return t10 ? new tO(t10) : tO.None;
        }
        constructor(t10) {
          let e10, i10, s10, o10;
          this.rgba = [NaN, NaN, NaN, NaN], this.input = t10;
          let r10 = O.Color;
          if (r10 && r10 !== tO) return new r10(t10);
          if ("object" == typeof t10 && void 0 !== t10.stops) this.stops = t10.stops.map((t11) => new tO(t11[1]));
          else if ("string" == typeof t10) for (this.input = t10 = tO.names[t10.toLowerCase()] || t10, s10 = tO.parsers.length; s10-- && !i10; ) (e10 = (o10 = tO.parsers[s10]).regex.exec(t10)) && (i10 = o10.parse(e10));
          i10 && (this.rgba = i10);
        }
        get(t10) {
          let e10 = this.input, i10 = this.rgba;
          if ("object" == typeof e10 && void 0 !== this.stops) {
            let i11 = tT(e10);
            return i11.stops = [].slice.call(i11.stops), this.stops.forEach((e11, s10) => {
              i11.stops[s10] = [i11.stops[s10][0], e11.get(t10)];
            }), i11;
          }
          return i10 && tA(i10[0]) ? "rgb" !== t10 && (t10 || 1 !== i10[3]) ? "a" === t10 ? `${i10[3]}` : "rgba(" + i10.join(",") + ")" : "rgb(" + i10[0] + "," + i10[1] + "," + i10[2] + ")" : e10;
        }
        brighten(t10) {
          let e10 = this.rgba;
          if (this.stops) this.stops.forEach(function(e11) {
            e11.brighten(t10);
          });
          else if (tA(t10) && 0 !== t10) for (let i10 = 0; i10 < 3; i10++) e10[i10] += tP(255 * t10), e10[i10] < 0 && (e10[i10] = 0), e10[i10] > 255 && (e10[i10] = 255);
          return this;
        }
        setOpacity(t10) {
          return this.rgba[3] = t10, this;
        }
        tweenTo(t10, e10) {
          let i10 = this.rgba, s10 = t10.rgba;
          if (!tA(i10[0]) || !tA(s10[0])) return t10.input || "none";
          let o10 = 1 !== s10[3] || 1 !== i10[3], r10 = (t11, s11) => t11 + (i10[s11] - t11) * (1 - e10), n10 = s10.slice(0, 3).map(r10).map(Math.round);
          return o10 && n10.push(r10(s10[3], 3)), (o10 ? "rgba(" : "rgb(") + n10.join(",") + ")";
        }
      }
      tO.names = {
        white: "#ffffff",
        black: "#000000"
      }, tO.parsers = [{
        regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
        parse: function(t10) {
          return [tP(t10[1]), tP(t10[2]), tP(t10[3]), parseFloat(t10[4], 10)];
        }
      }, {
        regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
        parse: function(t10) {
          return [tP(t10[1]), tP(t10[2]), tP(t10[3]), 1];
        }
      }, {
        regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
        parse: function(t10) {
          return [tP(t10[1] + t10[1], 16), tP(t10[2] + t10[2], 16), tP(t10[3] + t10[3], 16), tC(t10[4]) ? tP(t10[4] + t10[4], 16) / 255 : 1];
        }
      }, {
        regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
        parse: function(t10) {
          return [tP(t10[1], 16), tP(t10[2], 16), tP(t10[3], 16), tC(t10[4]) ? tP(t10[4], 16) / 255 : 1];
        }
      }], tO.None = new tO("");
      let {
        parse: tE
      } = tO, {
        win: tL
      } = O, {
        isNumber: tB,
        objectEach: tI
      } = tt;
      class tD {
        constructor(t10, e10, i10) {
          this.pos = NaN, this.options = e10, this.elem = t10, this.prop = i10;
        }
        dSetter() {
          let t10 = this.paths, e10 = t10 && t10[0], i10 = t10 && t10[1], s10 = this.now || 0, o10 = [];
          if (1 !== s10 && e10 && i10) {
            if (e10.length === i10.length && s10 < 1) for (let t11 = 0; t11 < i10.length; t11++) {
              let r10 = e10[t11], n10 = i10[t11], a10 = [];
              for (let t12 = 0; t12 < n10.length; t12++) {
                let e11 = r10[t12], i11 = n10[t12];
                tB(e11) && tB(i11) && !("A" === n10[0] && (4 === t12 || 5 === t12)) ? a10[t12] = e11 + s10 * (i11 - e11) : a10[t12] = i11;
              }
              o10.push(a10);
            }
            else o10 = i10;
          } else o10 = this.toD || [];
          this.elem.attr("d", o10, void 0, true);
        }
        update() {
          let t10 = this.elem, e10 = this.prop, i10 = this.now, s10 = this.options.step;
          this[e10 + "Setter"] ? this[e10 + "Setter"]() : t10.attr ? t10.element && t10.attr(e10, i10, null, true) : t10.style[e10] = i10 + this.unit, s10 && s10.call(t10, i10, this);
        }
        run(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = function(t11) {
            return !r10.stopped && s10.step(t11);
          }, n10 = tL.requestAnimationFrame || function(t11) {
            setTimeout(t11, 13);
          }, a10 = function() {
            for (let t11 = 0; t11 < tD.timers.length; t11++) tD.timers[t11]() || tD.timers.splice(t11--, 1);
            tD.timers.length && n10(a10);
          };
          t10 !== e10 || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = t10, this.end = e10, this.unit = i10, this.now = this.start, this.pos = 0, r10.elem = this.elem, r10.prop = this.prop, r10() && 1 === tD.timers.push(r10) && n10(a10)) : (delete o10.curAnim[this.prop], o10.complete && 0 === Object.keys(o10.curAnim).length && o10.complete.call(this.elem));
        }
        step(t10) {
          let e10, i10;
          let s10 = +/* @__PURE__ */ new Date(), o10 = this.options, r10 = this.elem, n10 = o10.complete, a10 = o10.duration, h10 = o10.curAnim;
          return r10.attr && !r10.element ? e10 = false : t10 || s10 >= a10 + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h10[this.prop] = true, i10 = true, tI(h10, function(t11) {
            true !== t11 && (i10 = false);
          }), i10 && n10 && n10.call(r10), e10 = false) : (this.pos = o10.easing((s10 - this.startTime) / a10), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e10 = true), e10;
        }
        initPath(t10, e10, i10) {
          let s10 = t10.startX, o10 = t10.endX, r10 = i10.slice(), n10 = t10.isArea, a10 = n10 ? 2 : 1, h10 = e10 && i10.length > e10.length && i10.hasStackedCliffs, l10, d10, c10, p10, u10 = e10 && e10.slice();
          if (!u10 || h10) return [r10, r10];
          function g2(t11, e11) {
            for (; t11.length < d10; ) {
              let i11 = t11[0], s11 = e11[d10 - t11.length];
              if (s11 && "M" === i11[0] && ("C" === s11[0] ? t11[0] = ["C", i11[1], i11[2], i11[1], i11[2], i11[1], i11[2]] : t11[0] = ["L", i11[1], i11[2]]), t11.unshift(i11), n10) {
                let e12 = t11.pop();
                t11.push(t11[t11.length - 1], e12);
              }
            }
          }
          function f2(t11) {
            for (; t11.length < d10; ) {
              let e11 = t11[Math.floor(t11.length / a10) - 1].slice();
              if ("C" === e11[0] && (e11[1] = e11[5], e11[2] = e11[6]), n10) {
                let i11 = t11[Math.floor(t11.length / a10)].slice();
                t11.splice(t11.length / 2, 0, e11, i11);
              } else t11.push(e11);
            }
          }
          if (s10 && o10 && o10.length) {
            for (c10 = 0; c10 < s10.length; c10++) {
              if (s10[c10] === o10[0]) {
                l10 = c10;
                break;
              }
              if (s10[0] === o10[o10.length - s10.length + c10]) {
                l10 = c10, p10 = true;
                break;
              }
              if (s10[s10.length - 1] === o10[o10.length - s10.length + c10]) {
                l10 = s10.length - c10;
                break;
              }
            }
            void 0 === l10 && (u10 = []);
          }
          return u10.length && tB(l10) && (d10 = r10.length + l10 * a10, p10 ? (g2(u10, r10), f2(r10)) : (g2(r10, u10), f2(u10))), [u10, r10];
        }
        fillSetter() {
          tD.prototype.strokeSetter.apply(this, arguments);
        }
        strokeSetter() {
          this.elem.attr(this.prop, tE(this.start).tweenTo(tE(this.end), this.pos), void 0, true);
        }
      }
      tD.timers = [];
      let {
        defined: tR,
        getStyle: tN,
        isArray: tz,
        isNumber: tW,
        isObject: tG,
        merge: tH,
        objectEach: tF,
        pick: tX
      } = tt;
      function tY(t10) {
        return tG(t10) ? tH({
          duration: 500,
          defer: 0
        }, t10) : {
          duration: t10 ? 500 : 0,
          defer: 0
        };
      }
      function tj(t10, e10) {
        let i10 = tD.timers.length;
        for (; i10--; ) tD.timers[i10].elem !== t10 || e10 && e10 !== tD.timers[i10].prop || (tD.timers[i10].stopped = true);
      }
      let tU = {
        animate: function(t10, e10, i10) {
          let s10, o10 = "", r10, n10, a10;
          tG(i10) || (a10 = arguments, i10 = {
            duration: a10[2],
            easing: a10[3],
            complete: a10[4]
          }), tW(i10.duration) || (i10.duration = 400), i10.easing = "function" == typeof i10.easing ? i10.easing : Math[i10.easing] || Math.easeInOutSine, i10.curAnim = tH(e10), tF(e10, function(a11, h10) {
            tj(t10, h10), n10 = new tD(t10, i10, h10), r10 = void 0, "d" === h10 && tz(e10.d) ? (n10.paths = n10.initPath(t10, t10.pathArray, e10.d), n10.toD = e10.d, s10 = 0, r10 = 1) : t10.attr ? s10 = t10.attr(h10) : (s10 = parseFloat(tN(t10, h10)) || 0, "opacity" !== h10 && (o10 = "px")), r10 || (r10 = a11), "string" == typeof r10 && r10.match("px") && (r10 = r10.replace(/px/g, "")), n10.run(s10, r10, o10);
          });
        },
        animObject: tY,
        getDeferredAnimation: function(t10, e10, i10) {
          let s10 = tY(e10), o10 = i10 ? [i10] : t10.series, r10 = 0, n10 = 0;
          return o10.forEach((t11) => {
            let i11 = tY(t11.options.animation);
            r10 = tG(e10) && tR(e10.defer) ? s10.defer : Math.max(r10, i11.duration + i11.defer), n10 = Math.min(s10.duration, i11.duration);
          }), t10.renderer.forExport && (r10 = 0), {
            defer: Math.max(0, r10 - n10),
            duration: Math.min(r10, n10)
          };
        },
        setAnimation: function(t10, e10) {
          e10.renderer.globalAnimation = tX(t10, e10.options.chart.animation, true);
        },
        stop: tj
      }, {
        SVG_NS: tV,
        win: t$
      } = O, {
        attr: t_,
        createElement: tq,
        css: tZ,
        error: tK,
        isFunction: tJ,
        isString: tQ,
        objectEach: t0,
        splat: t1
      } = tt, {
        trustedTypes: t2
      } = t$, t3 = t2 && tJ(t2.createPolicy) && t2.createPolicy("highcharts", {
        createHTML: (t10) => t10
      }), t5 = t3 ? t3.createHTML("") : "";
      class t6 {
        static filterUserAttributes(t10) {
          return t0(t10, (e10, i10) => {
            let s10 = true;
            -1 === t6.allowedAttributes.indexOf(i10) && (s10 = false), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i10) && (s10 = tQ(e10) && t6.allowedReferences.some((t11) => 0 === e10.indexOf(t11))), s10 || (tK(33, false, void 0, {
              "Invalid attribute in config": `${i10}`
            }), delete t10[i10]), tQ(e10) && t10[i10] && (t10[i10] = e10.replace(/</g, "&lt;"));
          }), t10;
        }
        static parseStyle(t10) {
          return t10.split(";").reduce((t11, e10) => {
            let i10 = e10.split(":").map((t12) => t12.trim()), s10 = i10.shift();
            return s10 && i10.length && (t11[s10.replace(/-([a-z])/g, (t12) => t12[1].toUpperCase())] = i10.join(":")), t11;
          }, {});
        }
        static setElementHTML(t10, e10) {
          t10.innerHTML = t6.emptyHTML, e10 && new t6(e10).addToDOM(t10);
        }
        constructor(t10) {
          this.nodes = "string" == typeof t10 ? this.parseMarkup(t10) : t10;
        }
        addToDOM(t10) {
          return function t11(e10, i10) {
            let s10;
            return t1(e10).forEach(function(e11) {
              let o10;
              let r10 = e11.tagName, n10 = e11.textContent ? O.doc.createTextNode(e11.textContent) : void 0, a10 = t6.bypassHTMLFiltering;
              if (r10) {
                if ("#text" === r10) o10 = n10;
                else if (-1 !== t6.allowedTags.indexOf(r10) || a10) {
                  let s11 = "svg" === r10 ? tV : i10.namespaceURI || tV, h10 = O.doc.createElementNS(s11, r10), l10 = e11.attributes || {};
                  t0(e11, function(t12, e12) {
                    "tagName" !== e12 && "attributes" !== e12 && "children" !== e12 && "style" !== e12 && "textContent" !== e12 && (l10[e12] = t12);
                  }), t_(h10, a10 ? l10 : t6.filterUserAttributes(l10)), e11.style && tZ(h10, e11.style), n10 && h10.appendChild(n10), t11(e11.children || [], h10), o10 = h10;
                } else tK(33, false, void 0, {
                  "Invalid tagName in config": r10
                });
              }
              o10 && i10.appendChild(o10), s10 = o10;
            }), s10;
          }(this.nodes, t10);
        }
        parseMarkup(t10) {
          let e10;
          let i10 = [];
          t10 = t10.trim().replace(/ style=(["'])/g, " data-style=$1");
          try {
            e10 = new DOMParser().parseFromString(t3 ? t3.createHTML(t10) : t10, "text/html");
          } catch (t11) {
          }
          if (!e10) {
            let i11 = tq("div");
            i11.innerHTML = t10, e10 = {
              body: i11
            };
          }
          let s10 = (t11, e11) => {
            let i11 = t11.nodeName.toLowerCase(), o10 = {
              tagName: i11
            };
            "#text" === i11 && (o10.textContent = t11.textContent || "");
            let r10 = t11.attributes;
            if (r10) {
              let t12 = {};
              [].forEach.call(r10, (e12) => {
                "data-style" === e12.name ? o10.style = t6.parseStyle(e12.value) : t12[e12.name] = e12.value;
              }), o10.attributes = t12;
            }
            if (t11.childNodes.length) {
              let e12 = [];
              [].forEach.call(t11.childNodes, (t12) => {
                s10(t12, e12);
              }), e12.length && (o10.children = e12);
            }
            e11.push(o10);
          };
          return [].forEach.call(e10.body.childNodes, (t11) => s10(t11, i10)), i10;
        }
      }
      t6.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "in2", "markerHeight", "markerWidth", "offset", "opacity", "operator", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "radius", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], t6.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], t6.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feComposite", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMorphology", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], t6.emptyHTML = t5, t6.bypassHTMLFiltering = false;
      let {
        defaultOptions: t9,
        defaultTime: t4
      } = tS, {
        pageLang: t8
      } = O, {
        extend: t7,
        getNestedProperty: et,
        isArray: ee,
        isNumber: ei,
        isObject: es,
        isString: eo,
        pick: er,
        ucfirst: en
      } = tt, ea = {
        add: (t10, e10) => t10 + e10,
        divide: (t10, e10) => 0 !== e10 ? t10 / e10 : "",
        eq: (t10, e10) => t10 == e10,
        each: function(t10) {
          let e10 = arguments[arguments.length - 1];
          return !!ee(t10) && t10.map((i10, s10) => ed(e10.body, t7(es(i10) ? i10 : {
            "@this": i10
          }, {
            "@index": s10,
            "@first": 0 === s10,
            "@last": s10 === t10.length - 1
          }))).join("");
        },
        ge: (t10, e10) => t10 >= e10,
        gt: (t10, e10) => t10 > e10,
        if: (t10) => !!t10,
        le: (t10, e10) => t10 <= e10,
        lt: (t10, e10) => t10 < e10,
        multiply: (t10, e10) => t10 * e10,
        ne: (t10, e10) => t10 != e10,
        subtract: (t10, e10) => t10 - e10,
        ucfirst: en,
        unless: (t10) => !t10
      }, eh = {}, el = (t10) => /^["'].+["']$/.test(t10);
      function ed(t10 = "", e10, i10) {
        let s10 = /\{([\p{L}\d:\.,;\-\/<>\[\]%_@+"'’= #\(\)]+)\}/gu, o10 = /\(([\p{L}\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/gu, r10 = [], n10 = /f$/, a10 = /\.(\d)/, h10 = i10?.options.lang || t9.lang, l10 = i10 && i10.time || t4, d10 = i10 && i10.numberFormatter || ec, c10 = (t11 = "") => {
          let i11;
          return "true" === t11 || "false" !== t11 && ((i11 = Number(t11)).toString() === t11 ? i11 : el(t11) ? t11.slice(1, -1) : et(t11, e10));
        }, p10, u10, g2 = 0, f2;
        for (; null !== (p10 = s10.exec(t10)); ) {
          let i11 = p10, s11 = o10.exec(p10[1]);
          s11 && (p10 = s11, f2 = true), u10 && u10.isBlock || (u10 = {
            ctx: e10,
            expression: p10[1],
            find: p10[0],
            isBlock: "#" === p10[1].charAt(0),
            start: p10.index,
            startInner: p10.index + p10[0].length,
            length: p10[0].length
          });
          let n11 = (u10.isBlock ? i11 : p10)[1].split(" ")[0].replace("#", "");
          ea[n11] && (u10.isBlock && n11 === u10.fn && g2++, u10.fn || (u10.fn = n11));
          let a11 = "else" === p10[1];
          if (u10.isBlock && u10.fn && (p10[1] === `/${u10.fn}` || a11)) {
            if (g2) !a11 && g2--;
            else {
              let e11 = u10.startInner, i12 = t10.substr(e11, p10.index - e11);
              void 0 === u10.body ? (u10.body = i12, u10.startInner = p10.index + p10[0].length) : u10.elseBody = i12, u10.find += i12 + p10[0], a11 || (r10.push(u10), u10 = void 0);
            }
          } else u10.isBlock || r10.push(u10);
          if (s11 && !u10?.isBlock) break;
        }
        return r10.forEach((s11) => {
          let r11, p11;
          let {
            body: u11,
            elseBody: g3,
            expression: f3,
            fn: m2
          } = s11;
          if (m2) {
            let t11 = [s11], o11 = [], n11 = f3.length, a11 = 0, h11;
            for (p11 = 0; p11 <= n11; p11++) {
              let t12 = f3.charAt(p11);
              h11 || '"' !== t12 && "'" !== t12 ? h11 === t12 && (h11 = "") : h11 = t12, h11 || " " !== t12 && p11 !== n11 || (o11.push(f3.substr(a11, p11 - a11)), a11 = p11 + 1);
            }
            for (p11 = ea[m2].length; p11--; ) t11.unshift(c10(o11[p11 + 1]));
            r11 = ea[m2].apply(e10, t11), s11.isBlock && "boolean" == typeof r11 && (r11 = ed(r11 ? u11 : g3, e10, i10));
          } else {
            let t11 = el(f3) ? [f3] : f3.split(":");
            if (r11 = c10(t11.shift() || ""), t11.length && "number" == typeof r11) {
              let e11 = t11.join(":");
              if (n10.test(e11)) {
                let t12 = parseInt((e11.match(a10) || ["", "-1"])[1], 10);
                null !== r11 && (r11 = d10(r11, t12, h10.decimalPoint, e11.indexOf(",") > -1 ? h10.thousandsSep : ""));
              } else r11 = l10.dateFormat(e11, r11);
            }
            o10.lastIndex = 0, o10.test(s11.find) && eo(r11) && (r11 = `"${r11}"`);
          }
          t10 = t10.replace(s11.find, er(r11, ""));
        }), f2 ? ed(t10, e10, i10) : t10;
      }
      function ec(t10, e10, i10, s10) {
        e10 = +e10;
        let o10, r10, [n10, a10] = (t10 = +t10 || 0).toString().split("e").map(Number), h10 = this?.options?.lang || t9.lang, l10 = (t10.toString().split(".")[1] || "").split("e")[0].length, d10 = e10, c10 = {};
        i10 ?? (i10 = h10.decimalPoint), s10 ?? (s10 = h10.thousandsSep), -1 === e10 ? e10 = Math.min(l10, 20) : ei(e10) ? e10 && a10 < 0 && ((r10 = e10 + a10) >= 0 ? (n10 = +n10.toExponential(r10).split("e")[0], e10 = r10) : (n10 = Math.floor(n10), t10 = e10 < 20 ? +(n10 * Math.pow(10, a10)).toFixed(e10) : 0, a10 = 0)) : e10 = 2, a10 && (e10 ?? (e10 = 2), t10 = n10), ei(e10) && e10 >= 0 && (c10.minimumFractionDigits = e10, c10.maximumFractionDigits = e10), "" === s10 && (c10.useGrouping = false);
        let p10 = s10 || i10, u10 = p10 ? "en" : this?.locale || h10.locale || t8, g2 = JSON.stringify(c10) + u10;
        return o10 = (eh[g2] ?? (eh[g2] = new Intl.NumberFormat(u10, c10))).format(t10), p10 && (o10 = o10.replace(/([,\.])/g, "_$1").replace(/_\,/g, s10 ?? ",").replace("_.", i10 ?? ".")), (e10 || 0 != +o10) && (!(a10 < 0) || d10) || (o10 = "0"), a10 && 0 != +o10 && (o10 += "e" + (a10 < 0 ? "" : "+") + a10), o10;
      }
      let ep = {
        dateFormat: function(t10, e10, i10) {
          return t4.dateFormat(t10, e10, i10);
        },
        format: ed,
        helpers: ea,
        numberFormat: ec
      };
      !function(t10) {
        let e10;
        t10.rendererTypes = {}, t10.getRendererType = function(i10 = e10) {
          return t10.rendererTypes[i10] || t10.rendererTypes[e10];
        }, t10.registerRendererType = function(i10, s10, o10) {
          t10.rendererTypes[i10] = s10, (!e10 || o10) && (e10 = i10, O.Renderer = s10);
        };
      }(n || (n = {}));
      let eu = n, {
        clamp: eg,
        pick: ef,
        pushUnique: em,
        stableSort: ex
      } = tt;
      (a || (a = {})).distribute = function t10(e10, i10, s10) {
        let o10 = e10, r10 = o10.reducedLen || i10, n10 = (t11, e11) => t11.target - e11.target, a10 = [], h10 = e10.length, l10 = [], d10 = a10.push, c10, p10, u10, g2 = true, f2, m2, x2 = 0, y2;
        for (c10 = h10; c10--; ) x2 += e10[c10].size;
        if (x2 > r10) {
          for (ex(e10, (t11, e11) => (e11.rank || 0) - (t11.rank || 0)), u10 = (y2 = e10[0].rank === e10[e10.length - 1].rank) ? h10 / 2 : -1, p10 = y2 ? u10 : h10 - 1; u10 && x2 > r10; ) f2 = e10[c10 = Math.floor(p10)], em(l10, c10) && (x2 -= f2.size), p10 += u10, y2 && p10 >= e10.length && (u10 /= 2, p10 = u10);
          l10.sort((t11, e11) => e11 - t11).forEach((t11) => d10.apply(a10, e10.splice(t11, 1)));
        }
        for (ex(e10, n10), e10 = e10.map((t11) => ({
          size: t11.size,
          targets: [t11.target],
          align: ef(t11.align, 0.5)
        })); g2; ) {
          for (c10 = e10.length; c10--; ) f2 = e10[c10], m2 = (Math.min.apply(0, f2.targets) + Math.max.apply(0, f2.targets)) / 2, f2.pos = eg(m2 - f2.size * f2.align, 0, i10 - f2.size);
          for (c10 = e10.length, g2 = false; c10--; ) c10 > 0 && e10[c10 - 1].pos + e10[c10 - 1].size > e10[c10].pos && (e10[c10 - 1].size += e10[c10].size, e10[c10 - 1].targets = e10[c10 - 1].targets.concat(e10[c10].targets), e10[c10 - 1].align = 0.5, e10[c10 - 1].pos + e10[c10 - 1].size > i10 && (e10[c10 - 1].pos = i10 - e10[c10 - 1].size), e10.splice(c10, 1), g2 = true);
        }
        return d10.apply(o10, a10), c10 = 0, e10.some((e11) => {
          let r11 = 0;
          return (e11.targets || []).some(() => (o10[c10].pos = e11.pos + r11, void 0 !== s10 && Math.abs(o10[c10].pos - o10[c10].target) > s10) ? (o10.slice(0, c10 + 1).forEach((t11) => delete t11.pos), o10.reducedLen = (o10.reducedLen || i10) - 0.1 * i10, o10.reducedLen > 0.1 * i10 && t10(o10, i10, s10), true) : (r11 += o10[c10].size, c10++, false));
        }), ex(o10, n10), o10;
      };
      let ey = a, {
        animate: eb,
        animObject: ev,
        stop: eM
      } = tU, {
        deg2rad: ek,
        doc: ew,
        svg: eS,
        SVG_NS: eA,
        win: eT,
        isFirefox: eP
      } = O, {
        addEvent: eC,
        attr: eO,
        createElement: eE,
        crisp: eL,
        css: eB,
        defined: eI,
        erase: eD,
        extend: eR,
        fireEvent: eN,
        getAlignFactor: ez,
        isArray: eW,
        isFunction: eG,
        isNumber: eH,
        isObject: eF,
        isString: eX,
        merge: eY,
        objectEach: ej,
        pick: eU,
        pInt: eV,
        pushUnique: e$,
        replaceNested: e_,
        syncTimeout: eq,
        uniqueKey: eZ
      } = tt;
      class eK {
        _defaultGetter(t10) {
          let e10 = eU(this[t10 + "Value"], this[t10], this.element ? this.element.getAttribute(t10) : null, 0);
          return /^-?[\d\.]+$/.test(e10) && (e10 = parseFloat(e10)), e10;
        }
        _defaultSetter(t10, e10, i10) {
          i10.setAttribute(e10, t10);
        }
        add(t10) {
          let e10;
          let i10 = this.renderer, s10 = this.element;
          return t10 && (this.parentGroup = t10), void 0 !== this.textStr && "text" === this.element.nodeName && i10.buildText(this), this.added = true, (!t10 || t10.handleZ || this.zIndex) && (e10 = this.zIndexSetter()), e10 || (t10 ? t10.element : i10.box).appendChild(s10), this.onAdd && this.onAdd(), this;
        }
        addClass(t10, e10) {
          let i10 = e10 ? "" : this.attr("class") || "";
          return (t10 = (t10 || "").split(/ /g).reduce(function(t11, e11) {
            return -1 === i10.indexOf(e11) && t11.push(e11), t11;
          }, i10 ? [i10] : []).join(" ")) !== i10 && this.attr("class", t10), this;
        }
        afterSetters() {
          this.doTransform && (this.updateTransform(), this.doTransform = false);
        }
        align(t10, e10, i10, s10 = true) {
          let o10 = this.renderer, r10 = o10.alignedObjects, n10 = !!t10;
          t10 ? (this.alignOptions = t10, this.alignByTranslate = e10, this.alignTo = i10) : (t10 = this.alignOptions || {}, e10 = this.alignByTranslate, i10 = this.alignTo);
          let a10 = !i10 || eX(i10) ? i10 || "renderer" : void 0;
          a10 && (n10 && e$(r10, this), i10 = void 0);
          let h10 = eU(i10, o10[a10], o10), l10 = (h10.x || 0) + (t10.x || 0) + ((h10.width || 0) - (t10.width || 0)) * ez(t10.align), d10 = (h10.y || 0) + (t10.y || 0) + ((h10.height || 0) - (t10.height || 0)) * ez(t10.verticalAlign), c10 = {
            "text-align": t10?.align
          };
          return c10[e10 ? "translateX" : "x"] = Math.round(l10), c10[e10 ? "translateY" : "y"] = Math.round(d10), s10 && (this[this.placed ? "animate" : "attr"](c10), this.placed = true), this.alignAttr = c10, this;
        }
        alignSetter(t10) {
          let e10 = {
            left: "start",
            center: "middle",
            right: "end"
          };
          e10[t10] && (this.alignValue = t10, this.element.setAttribute("text-anchor", e10[t10]));
        }
        animate(t10, e10, i10) {
          let s10 = ev(eU(e10, this.renderer.globalAnimation, true)), o10 = s10.defer;
          return ew.hidden && (s10.duration = 0), 0 !== s10.duration ? (i10 && (s10.complete = i10), eq(() => {
            this.element && eb(this, t10, s10);
          }, o10)) : (this.attr(t10, void 0, i10 || s10.complete), ej(t10, function(t11, e11) {
            s10.step && s10.step.call(this, t11, {
              prop: e11,
              pos: 1,
              elem: this
            });
          }, this)), this;
        }
        applyTextOutline(t10) {
          let e10 = this.element;
          -1 !== t10.indexOf("contrast") && (t10 = t10.replace(/contrast/g, this.renderer.getContrast(e10.style.fill)));
          let i10 = t10.split(" "), s10 = i10[i10.length - 1], o10 = i10[0];
          if (o10 && "none" !== o10 && O.svg) {
            this.fakeTS = true, o10 = o10.replace(/(^[\d\.]+)(.*?)$/g, function(t12, e11, i12) {
              return 2 * Number(e11) + i12;
            }), this.removeTextOutline();
            let t11 = ew.createElementNS(eA, "tspan");
            eO(t11, {
              class: "highcharts-text-outline",
              fill: s10,
              stroke: s10,
              "stroke-width": o10,
              "stroke-linejoin": "round"
            });
            let i11 = e10.querySelector("textPath") || e10;
            [].forEach.call(i11.childNodes, (e11) => {
              let i12 = e11.cloneNode(true);
              i12.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((t12) => i12.removeAttribute(t12)), t11.appendChild(i12);
            });
            let r10 = 0;
            [].forEach.call(i11.querySelectorAll("text tspan"), (t12) => {
              r10 += Number(t12.getAttribute("dy"));
            });
            let n10 = ew.createElementNS(eA, "tspan");
            n10.textContent = "​", eO(n10, {
              x: Number(e10.getAttribute("x")),
              dy: -r10
            }), t11.appendChild(n10), i11.insertBefore(t11, i11.firstChild);
          }
        }
        attr(t10, e10, i10, s10) {
          let {
            element: o10
          } = this, r10 = eK.symbolCustomAttribs, n10, a10, h10 = this, l10;
          return "string" == typeof t10 && void 0 !== e10 && (n10 = t10, (t10 = {})[n10] = e10), "string" == typeof t10 ? h10 = (this[t10 + "Getter"] || this._defaultGetter).call(this, t10, o10) : (ej(t10, function(e11, i11) {
            l10 = false, s10 || eM(this, i11), this.symbolName && -1 !== r10.indexOf(i11) && (a10 || (this.symbolAttr(t10), a10 = true), l10 = true), this.rotation && ("x" === i11 || "y" === i11) && (this.doTransform = true), l10 || (this[i11 + "Setter"] || this._defaultSetter).call(this, e11, i11, o10);
          }, this), this.afterSetters()), i10 && i10.call(this), h10;
        }
        clip(t10) {
          if (t10 && !t10.clipPath) {
            let e10 = eZ() + "-", i10 = this.renderer.createElement("clipPath").attr({
              id: e10
            }).add(this.renderer.defs);
            eR(t10, {
              clipPath: i10,
              id: e10,
              count: 0
            }), t10.add(i10);
          }
          return this.attr("clip-path", t10 ? `url(${this.renderer.url}#${t10.id})` : "none");
        }
        crisp(t10, e10) {
          e10 = Math.round(e10 || t10.strokeWidth || 0);
          let i10 = t10.x || this.x || 0, s10 = t10.y || this.y || 0, o10 = (t10.width || this.width || 0) + i10, r10 = (t10.height || this.height || 0) + s10, n10 = eL(i10, e10), a10 = eL(s10, e10);
          return eR(t10, {
            x: n10,
            y: a10,
            width: eL(o10, e10) - n10,
            height: eL(r10, e10) - a10
          }), eI(t10.strokeWidth) && (t10.strokeWidth = e10), t10;
        }
        complexColor(t10, e10, i10) {
          let s10 = this.renderer, o10, r10, n10, a10, h10, l10, d10, c10, p10, u10, g2 = [], f2;
          eN(this.renderer, "complexColor", {
            args: arguments
          }, function() {
            if (t10.radialGradient ? r10 = "radialGradient" : t10.linearGradient && (r10 = "linearGradient"), r10) {
              if (n10 = t10[r10], h10 = s10.gradients, l10 = t10.stops, p10 = i10.radialReference, eW(n10) && (t10[r10] = n10 = {
                x1: n10[0],
                y1: n10[1],
                x2: n10[2],
                y2: n10[3],
                gradientUnits: "userSpaceOnUse"
              }), "radialGradient" === r10 && p10 && !eI(n10.gradientUnits) && (a10 = n10, n10 = eY(n10, s10.getRadialAttr(p10, a10), {
                gradientUnits: "userSpaceOnUse"
              })), ej(n10, function(t11, e11) {
                "id" !== e11 && g2.push(e11, t11);
              }), ej(l10, function(t11) {
                g2.push(t11);
              }), h10[g2 = g2.join(",")]) u10 = h10[g2].attr("id");
              else {
                n10.id = u10 = eZ();
                let t11 = h10[g2] = s10.createElement(r10).attr(n10).add(s10.defs);
                t11.radAttr = a10, t11.stops = [], l10.forEach(function(e11) {
                  0 === e11[1].indexOf("rgba") ? (d10 = (o10 = tO.parse(e11[1])).get("rgb"), c10 = o10.get("a")) : (d10 = e11[1], c10 = 1);
                  let i11 = s10.createElement("stop").attr({
                    offset: e11[0],
                    "stop-color": d10,
                    "stop-opacity": c10
                  }).add(t11);
                  t11.stops.push(i11);
                });
              }
              f2 = "url(" + s10.url + "#" + u10 + ")", i10.setAttribute(e10, f2), i10.gradient = g2, t10.toString = function() {
                return f2;
              };
            }
          });
        }
        css(t10) {
          let e10 = this.styles, i10 = {}, s10 = this.element, o10, r10 = !e10;
          if (e10 && ej(t10, function(t11, s11) {
            e10 && e10[s11] !== t11 && (i10[s11] = t11, r10 = true);
          }), r10) {
            e10 && (t10 = eR(e10, i10)), null === t10.width || "auto" === t10.width ? delete this.textWidth : "text" === s10.nodeName.toLowerCase() && t10.width && (o10 = this.textWidth = eV(t10.width)), eR(this.styles, t10), o10 && !eS && this.renderer.forExport && delete t10.width;
            let r11 = eP && t10.fontSize || null;
            r11 && (eH(r11) || /^\d+$/.test(r11)) && (t10.fontSize += "px");
            let n10 = eY(t10);
            s10.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "whiteSpace", "width"].forEach((t11) => n10 && delete n10[t11]), n10.color && (n10.fill = n10.color)), eB(s10, n10);
          }
          return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t10.textOutline && this.applyTextOutline(t10.textOutline)), this;
        }
        dashstyleSetter(t10) {
          let e10, i10 = this["stroke-width"];
          if ("inherit" === i10 && (i10 = 1), t10 = t10 && t10.toLowerCase()) {
            let s10 = t10.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            for (e10 = s10.length; e10--; ) s10[e10] = "" + eV(s10[e10]) * eU(i10, NaN);
            t10 = s10.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t10);
          }
        }
        destroy() {
          let t10 = this, e10 = t10.element || {}, i10 = t10.renderer, s10 = e10.ownerSVGElement, o10 = "SPAN" === e10.nodeName && t10.parentGroup || void 0, r10, n10;
          if (e10.onclick = e10.onmouseout = e10.onmouseover = e10.onmousemove = e10.point = null, eM(t10), t10.clipPath && s10) {
            let e11 = t10.clipPath;
            [].forEach.call(s10.querySelectorAll("[clip-path],[CLIP-PATH]"), function(t11) {
              t11.getAttribute("clip-path").indexOf(e11.element.id) > -1 && t11.removeAttribute("clip-path");
            }), t10.clipPath = e11.destroy();
          }
          if (t10.connector = t10.connector?.destroy(), t10.stops) {
            for (n10 = 0; n10 < t10.stops.length; n10++) t10.stops[n10].destroy();
            t10.stops.length = 0, t10.stops = void 0;
          }
          for (t10.safeRemoveChild(e10); o10 && o10.div && 0 === o10.div.childNodes.length; ) r10 = o10.parentGroup, t10.safeRemoveChild(o10.div), delete o10.div, o10 = r10;
          t10.alignOptions && eD(i10.alignedObjects, t10), ej(t10, function(e11, i11) {
            t10[i11] && t10[i11].parentGroup === t10 && t10[i11].destroy && t10[i11].destroy(), delete t10[i11];
          });
        }
        dSetter(t10, e10, i10) {
          eW(t10) && ("string" == typeof t10[0] && (t10 = this.renderer.pathToSegments(t10)), this.pathArray = t10, t10 = t10.reduce((t11, e11, i11) => e11 && e11.join ? (i11 ? t11 + " " : "") + e11.join(" ") : (e11 || "").toString(), "")), /(NaN| {2}|^$)/.test(t10) && (t10 = "M 0 0"), this[e10] !== t10 && (i10.setAttribute(e10, t10), this[e10] = t10);
        }
        fillSetter(t10, e10, i10) {
          "string" == typeof t10 ? i10.setAttribute(e10, t10) : t10 && this.complexColor(t10, e10, i10);
        }
        hrefSetter(t10, e10, i10) {
          i10.setAttributeNS("http://www.w3.org/1999/xlink", e10, t10);
        }
        getBBox(t10, e10) {
          let i10, s10, o10, r10;
          let {
            alignValue: n10,
            element: a10,
            renderer: h10,
            styles: l10,
            textStr: d10
          } = this, {
            cache: c10,
            cacheKeys: p10
          } = h10, u10 = a10.namespaceURI === this.SVG_NS, g2 = eU(e10, this.rotation, 0), f2 = h10.styledMode ? a10 && eK.prototype.getStyle.call(a10, "font-size") : l10.fontSize;
          if (eI(d10) && (-1 === (r10 = d10.toString()).indexOf("<") && (r10 = r10.replace(/\d/g, "0")), r10 += ["", h10.rootFontSize, f2, g2, this.textWidth, n10, l10.lineClamp, l10.textOverflow, l10.fontWeight].join(",")), r10 && !t10 && (i10 = c10[r10]), !i10 || i10.polygon) {
            if (u10 || h10.forExport) {
              try {
                o10 = this.fakeTS && function(t12) {
                  let e11 = a10.querySelector(".highcharts-text-outline");
                  e11 && eB(e11, {
                    display: t12
                  });
                }, eG(o10) && o10("none"), i10 = a10.getBBox ? eR({}, a10.getBBox()) : {
                  width: a10.offsetWidth,
                  height: a10.offsetHeight,
                  x: 0,
                  y: 0
                }, eG(o10) && o10("");
              } catch (t12) {
              }
              (!i10 || i10.width < 0) && (i10 = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              });
            } else i10 = this.htmlGetBBox();
            s10 = i10.height, u10 && (i10.height = s10 = {
              "11px,17": 14,
              "13px,20": 16
            }[`${f2 || ""},${Math.round(s10)}`] || s10), g2 && (i10 = this.getRotatedBox(i10, g2));
            let t11 = {
              bBox: i10
            };
            eN(this, "afterGetBBox", t11), i10 = t11.bBox;
          }
          if (r10 && ("" === d10 || i10.height > 0)) {
            for (; p10.length > 250; ) delete c10[p10.shift()];
            c10[r10] || p10.push(r10), c10[r10] = i10;
          }
          return i10;
        }
        getRotatedBox(t10, e10) {
          let {
            x: i10,
            y: s10,
            width: o10,
            height: r10
          } = t10, {
            alignValue: n10,
            translateY: a10,
            rotationOriginX: h10 = 0,
            rotationOriginY: l10 = 0
          } = this, d10 = ez(n10), c10 = Number(this.element.getAttribute("y") || 0) - (a10 ? 0 : s10), p10 = e10 * ek, u10 = (e10 - 90) * ek, g2 = Math.cos(p10), f2 = Math.sin(p10), m2 = o10 * g2, x2 = o10 * f2, y2 = Math.cos(u10), b2 = Math.sin(u10), [[v2, M2], [k2, w2]] = [h10, l10].map((t11) => [t11 - t11 * g2, t11 * f2]), S2 = i10 + d10 * (o10 - m2) + v2 + w2 + c10 * y2, A2 = S2 + m2, T2 = A2 - r10 * y2, P2 = T2 - m2, C2 = s10 + c10 - d10 * x2 - M2 + k2 + c10 * b2, O2 = C2 + x2, E2 = O2 - r10 * b2, L2 = E2 - x2, B2 = Math.min(S2, A2, T2, P2), I2 = Math.min(C2, O2, E2, L2), D2 = Math.max(S2, A2, T2, P2) - B2, R2 = Math.max(C2, O2, E2, L2) - I2;
          return {
            x: B2,
            y: I2,
            width: D2,
            height: R2,
            polygon: [[S2, C2], [A2, O2], [T2, E2], [P2, L2]]
          };
        }
        getStyle(t10) {
          return eT.getComputedStyle(this.element || this, "").getPropertyValue(t10);
        }
        hasClass(t10) {
          return -1 !== ("" + this.attr("class")).split(" ").indexOf(t10);
        }
        hide() {
          return this.attr({
            visibility: "hidden"
          });
        }
        htmlGetBBox() {
          return {
            height: 0,
            width: 0,
            x: 0,
            y: 0
          };
        }
        constructor(t10, e10) {
          this.onEvents = {}, this.opacity = 1, this.SVG_NS = eA, this.element = "span" === e10 || "body" === e10 ? eE(e10) : ew.createElementNS(this.SVG_NS, e10), this.renderer = t10, this.styles = {}, eN(this, "afterInit");
        }
        on(t10, e10) {
          let {
            onEvents: i10
          } = this;
          return i10[t10] && i10[t10](), i10[t10] = eC(this.element, t10, e10), this;
        }
        opacitySetter(t10, e10, i10) {
          let s10 = Number(Number(t10).toFixed(3));
          this.opacity = s10, i10.setAttribute(e10, s10);
        }
        reAlign() {
          this.alignOptions?.width && "left" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = false, this.align());
        }
        removeClass(t10) {
          return this.attr("class", ("" + this.attr("class")).replace(eX(t10) ? RegExp(`(^| )${t10}( |$)`) : t10, " ").replace(/ +/g, " ").trim());
        }
        removeTextOutline() {
          let t10 = this.element.querySelector("tspan.highcharts-text-outline");
          t10 && this.safeRemoveChild(t10);
        }
        safeRemoveChild(t10) {
          let e10 = t10.parentNode;
          e10 && e10.removeChild(t10);
        }
        setRadialReference(t10) {
          let e10 = this.element.gradient && this.renderer.gradients[this.element.gradient];
          return this.element.radialReference = t10, e10 && e10.radAttr && e10.animate(this.renderer.getRadialAttr(t10, e10.radAttr)), this;
        }
        shadow(t10) {
          let {
            renderer: e10
          } = this, i10 = eY(this.parentGroup?.rotation === 90 ? {
            offsetX: -1,
            offsetY: -1
          } : {}, eF(t10) ? t10 : {}), s10 = e10.shadowDefinition(i10);
          return this.attr({
            filter: t10 ? `url(${e10.url}#${s10})` : "none"
          });
        }
        show(t10 = true) {
          return this.attr({
            visibility: t10 ? "inherit" : "visible"
          });
        }
        "stroke-widthSetter"(t10, e10, i10) {
          this[e10] = t10, i10.setAttribute(e10, t10);
        }
        strokeWidth() {
          if (!this.renderer.styledMode) return this["stroke-width"] || 0;
          let t10 = this.getStyle("stroke-width"), e10 = 0, i10;
          return /px$/.test(t10) ? e10 = eV(t10) : "" !== t10 && (eO(i10 = ew.createElementNS(eA, "rect"), {
            width: t10,
            "stroke-width": 0
          }), this.element.parentNode.appendChild(i10), e10 = i10.getBBox().width, i10.parentNode.removeChild(i10)), e10;
        }
        symbolAttr(t10) {
          let e10 = this;
          eK.symbolCustomAttribs.forEach(function(i10) {
            e10[i10] = eU(t10[i10], e10[i10]);
          }), e10.attr({
            d: e10.renderer.symbols[e10.symbolName](e10.x, e10.y, e10.width, e10.height, e10)
          });
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.textPxLength, this.textStr = t10, this.added && this.renderer.buildText(this), this.reAlign());
        }
        titleSetter(t10) {
          let e10 = this.element, i10 = e10.getElementsByTagName("title")[0] || ew.createElementNS(this.SVG_NS, "title");
          e10.insertBefore ? e10.insertBefore(i10, e10.firstChild) : e10.appendChild(i10), i10.textContent = e_(eU(t10, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        }
        toFront() {
          let t10 = this.element;
          return t10.parentNode.appendChild(t10), this;
        }
        translate(t10, e10) {
          return this.attr({
            translateX: t10,
            translateY: e10
          });
        }
        updateTransform(t10 = "transform") {
          let {
            element: e10,
            matrix: i10,
            rotation: s10 = 0,
            rotationOriginX: o10,
            rotationOriginY: r10,
            scaleX: n10,
            scaleY: a10,
            translateX: h10 = 0,
            translateY: l10 = 0
          } = this, d10 = ["translate(" + h10 + "," + l10 + ")"];
          eI(i10) && d10.push("matrix(" + i10.join(",") + ")"), s10 && (d10.push("rotate(" + s10 + " " + eU(o10, e10.getAttribute("x"), 0) + " " + eU(r10, e10.getAttribute("y") || 0) + ")"), this.text?.element.tagName === "SPAN" && this.text.attr({
            rotation: s10,
            rotationOriginX: (o10 || 0) - this.padding,
            rotationOriginY: (r10 || 0) - this.padding
          })), (eI(n10) || eI(a10)) && d10.push("scale(" + eU(n10, 1) + " " + eU(a10, 1) + ")"), d10.length && !(this.text || this).textPath && e10.setAttribute(t10, d10.join(" "));
        }
        visibilitySetter(t10, e10, i10) {
          "inherit" === t10 ? i10.removeAttribute(e10) : this[e10] !== t10 && i10.setAttribute(e10, t10), this[e10] = t10;
        }
        xGetter(t10) {
          return "circle" === this.element.nodeName && ("x" === t10 ? t10 = "cx" : "y" === t10 && (t10 = "cy")), this._defaultGetter(t10);
        }
        zIndexSetter(t10, e10) {
          let i10 = this.renderer, s10 = this.parentGroup, o10 = (s10 || i10).element || i10.box, r10 = this.element, n10 = o10 === i10.box, a10, h10, l10, d10 = false, c10, p10 = this.added, u10;
          if (eI(t10) ? (r10.setAttribute("data-z-index", t10), t10 = +t10, this[e10] === t10 && (p10 = false)) : eI(this[e10]) && r10.removeAttribute("data-z-index"), this[e10] = t10, p10) {
            for ((t10 = this.zIndex) && s10 && (s10.handleZ = true), u10 = (a10 = o10.childNodes).length - 1; u10 >= 0 && !d10; u10--) c10 = !eI(l10 = (h10 = a10[u10]).getAttribute("data-z-index")), h10 !== r10 && (t10 < 0 && c10 && !n10 && !u10 ? (o10.insertBefore(r10, a10[u10]), d10 = true) : (eV(l10) <= t10 || c10 && (!eI(t10) || t10 >= 0)) && (o10.insertBefore(r10, a10[u10 + 1]), d10 = true));
            d10 || (o10.insertBefore(r10, a10[n10 ? 3 : 0]), d10 = true);
          }
          return d10;
        }
      }
      eK.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], eK.prototype.strokeSetter = eK.prototype.fillSetter, eK.prototype.yGetter = eK.prototype.xGetter, eK.prototype.matrixSetter = eK.prototype.rotationOriginXSetter = eK.prototype.rotationOriginYSetter = eK.prototype.rotationSetter = eK.prototype.scaleXSetter = eK.prototype.scaleYSetter = eK.prototype.translateXSetter = eK.prototype.translateYSetter = eK.prototype.verticalAlignSetter = function(t10, e10) {
        this[e10] = t10, this.doTransform = true;
      };
      let eJ = eK, {
        defined: eQ,
        extend: e0,
        getAlignFactor: e1,
        isNumber: e2,
        merge: e3,
        pick: e5,
        removeEvent: e6
      } = tt;
      class e9 extends eJ {
        constructor(t10, e10, i10, s10, o10, r10, n10, a10, h10, l10) {
          let d10;
          super(t10, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = false, this.textStr = e10, this.x = i10, this.y = s10, this.anchorX = r10, this.anchorY = n10, this.baseline = h10, this.className = l10, this.addClass("button" === l10 ? "highcharts-no-tooltip" : "highcharts-label"), l10 && this.addClass("highcharts-" + l10), this.text = t10.text(void 0, 0, 0, a10).attr({
            zIndex: 1
          }), "string" == typeof o10 && ((d10 = /^url\((.*?)\)$/.test(o10)) || this.renderer.symbols[o10]) && (this.symbolKey = o10), this.bBox = e9.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t10.styledMode || d10, this.deferredAttr = {}, this.alignFactor = 0;
        }
        alignSetter(t10) {
          let e10 = e1(t10);
          this.textAlign = t10, e10 !== this.alignFactor && (this.alignFactor = e10, this.bBox && e2(this.xSetting) && this.attr({
            x: this.xSetting
          }));
        }
        anchorXSetter(t10, e10) {
          this.anchorX = t10, this.boxAttr(e10, Math.round(t10) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(t10, e10) {
          this.anchorY = t10, this.boxAttr(e10, t10 - this.ySetting);
        }
        boxAttr(t10, e10) {
          this.box ? this.box.attr(t10, e10) : this.deferredAttr[t10] = e10;
        }
        css(t10) {
          if (t10) {
            let e10 = {};
            t10 = e3(t10), e9.textProps.forEach((i10) => {
              void 0 !== t10[i10] && (e10[i10] = t10[i10], delete t10[i10]);
            }), this.text.css(e10), "fontSize" in e10 || "fontWeight" in e10 ? this.updateTextPadding() : ("width" in e10 || "textOverflow" in e10) && this.updateBoxSize();
          }
          return eJ.prototype.css.call(this, t10);
        }
        destroy() {
          e6(this.element, "mouseenter"), e6(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), eJ.prototype.destroy.call(this);
        }
        fillSetter(t10, e10) {
          t10 && (this.needsBox = true), this.fill = t10, this.boxAttr(e10, t10);
        }
        getBBox(t10, e10) {
          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
          let {
            padding: i10,
            height: s10 = 0,
            translateX: o10 = 0,
            translateY: r10 = 0,
            width: n10 = 0
          } = this, a10 = e5(this.paddingLeft, i10), h10 = e10 ?? (this.rotation || 0), l10 = {
            width: n10,
            height: s10,
            x: o10 + this.bBox.x - a10,
            y: r10 + this.bBox.y - i10 + this.baselineOffset
          };
          return h10 && (l10 = this.getRotatedBox(l10, h10)), l10;
        }
        getCrispAdjust() {
          return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        }
        heightSetter(t10) {
          this.heightSetting = t10, this.doUpdate = true;
        }
        afterSetters() {
          super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = false);
        }
        onAdd() {
          this.text.add(this), this.attr({
            text: e5(this.textStr, ""),
            x: this.x || 0,
            y: this.y || 0
          }), this.box && eQ(this.anchorX) && this.attr({
            anchorX: this.anchorX,
            anchorY: this.anchorY
          });
        }
        paddingSetter(t10, e10) {
          e2(t10) ? t10 !== this[e10] && (this[e10] = t10, this.updateTextPadding()) : this[e10] = void 0;
        }
        rSetter(t10, e10) {
          this.boxAttr(e10, t10);
        }
        strokeSetter(t10, e10) {
          this.stroke = t10, this.boxAttr(e10, t10);
        }
        "stroke-widthSetter"(t10, e10) {
          t10 && (this.needsBox = true), this["stroke-width"] = t10, this.boxAttr(e10, t10);
        }
        "text-alignSetter"(t10) {
          this.textAlign = this["text-align"] = t10, this.updateTextPadding();
        }
        textSetter(t10) {
          void 0 !== t10 && this.text.attr({
            text: t10
          }), this.updateTextPadding(), this.reAlign();
        }
        updateBoxSize() {
          let t10;
          let e10 = this.text, i10 = {}, s10 = this.padding, o10 = this.bBox = (!e2(this.widthSetting) || !e2(this.heightSetting) || this.textAlign) && eQ(e10.textStr) ? e10.getBBox(void 0, 0) : e9.emptyBBox;
          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o10.height || 0) + 2 * s10;
          let r10 = this.renderer.fontMetrics(e10);
          if (this.baselineOffset = s10 + Math.min((this.text.firstLineMetrics || r10).b, o10.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r10.h) / 2), this.needsBox && !e10.textPath) {
            if (!this.box) {
              let t11 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
              t11.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t11.add(this);
            }
            t10 = this.getCrispAdjust(), i10.x = t10, i10.y = (this.baseline ? -this.baselineOffset : 0) + t10, i10.width = Math.round(this.width), i10.height = Math.round(this.height), this.box.attr(e0(i10, this.deferredAttr)), this.deferredAttr = {};
          }
        }
        updateTextPadding() {
          let t10 = this.text, e10 = t10.styles.textAlign || this.textAlign;
          if (!t10.textPath) {
            this.updateBoxSize();
            let i10 = this.baseline ? 0 : this.baselineOffset, s10 = (this.paddingLeft ?? this.padding) + e1(e10) * (this.widthSetting ?? this.bBox.width);
            (s10 !== t10.x || i10 !== t10.y) && (t10.attr({
              align: e10,
              x: s10
            }), void 0 !== i10 && t10.attr("y", i10)), t10.x = s10, t10.y = i10;
          }
        }
        widthSetter(t10) {
          this.widthSetting = e2(t10) ? t10 : void 0, this.doUpdate = true;
        }
        getPaddedWidth() {
          let t10 = this.padding, e10 = e5(this.paddingLeft, t10), i10 = e5(this.paddingRight, t10);
          return (this.widthSetting || this.bBox.width || 0) + e10 + i10;
        }
        xSetter(t10) {
          this.x = t10, this.alignFactor && (t10 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true), this.xSetting = Math.round(t10), this.attr("translateX", this.xSetting);
        }
        ySetter(t10) {
          this.ySetting = this.y = Math.round(t10), this.attr("translateY", this.ySetting);
        }
      }
      e9.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }, e9.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineClamp", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"];
      let {
        defined: e4,
        isNumber: e8,
        pick: e7
      } = tt;
      function it(t10, e10, i10, s10, o10) {
        let r10 = [];
        if (o10) {
          let n10 = o10.start || 0, a10 = e7(o10.r, i10), h10 = e7(o10.r, s10 || i10), l10 = 2e-4 / (o10.borderRadius ? 1 : Math.max(a10, 1)), d10 = Math.abs((o10.end || 0) - n10 - 2 * Math.PI) < l10, c10 = (o10.end || 0) - (d10 ? l10 : 0), p10 = o10.innerR, u10 = e7(o10.open, d10), g2 = Math.cos(n10), f2 = Math.sin(n10), m2 = Math.cos(c10), x2 = Math.sin(c10), y2 = e7(o10.longArc, c10 - n10 - Math.PI < l10 ? 0 : 1), b2 = ["A", a10, h10, 0, y2, e7(o10.clockwise, 1), t10 + a10 * m2, e10 + h10 * x2];
          b2.params = {
            start: n10,
            end: c10,
            cx: t10,
            cy: e10
          }, r10.push(["M", t10 + a10 * g2, e10 + h10 * f2], b2), e4(p10) && ((b2 = ["A", p10, p10, 0, y2, e4(o10.clockwise) ? 1 - o10.clockwise : 0, t10 + p10 * g2, e10 + p10 * f2]).params = {
            start: c10,
            end: n10,
            cx: t10,
            cy: e10
          }, r10.push(u10 ? ["M", t10 + p10 * m2, e10 + p10 * x2] : ["L", t10 + p10 * m2, e10 + p10 * x2], b2)), u10 || r10.push(["Z"]);
        }
        return r10;
      }
      function ie(t10, e10, i10, s10, o10) {
        return o10 && o10.r ? ii(t10, e10, i10, s10, o10) : [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
      }
      function ii(t10, e10, i10, s10, o10) {
        let r10 = o10?.r || 0;
        return [["M", t10 + r10, e10], ["L", t10 + i10 - r10, e10], ["A", r10, r10, 0, 0, 1, t10 + i10, e10 + r10], ["L", t10 + i10, e10 + s10 - r10], ["A", r10, r10, 0, 0, 1, t10 + i10 - r10, e10 + s10], ["L", t10 + r10, e10 + s10], ["A", r10, r10, 0, 0, 1, t10, e10 + s10 - r10], ["L", t10, e10 + r10], ["A", r10, r10, 0, 0, 1, t10 + r10, e10], ["Z"]];
      }
      let is = {
        arc: it,
        callout: function(t10, e10, i10, s10, o10) {
          let r10 = Math.min(o10 && o10.r || 0, i10, s10), n10 = r10 + 6, a10 = o10 && o10.anchorX, h10 = o10 && o10.anchorY || 0, l10 = ii(t10, e10, i10, s10, {
            r: r10
          });
          if (!e8(a10) || a10 < i10 && a10 > 0 && h10 < s10 && h10 > 0) return l10;
          if (t10 + a10 > i10 - n10) {
            if (h10 > e10 + n10 && h10 < e10 + s10 - n10) l10.splice(3, 1, ["L", t10 + i10, h10 - 6], ["L", t10 + i10 + 6, h10], ["L", t10 + i10, h10 + 6], ["L", t10 + i10, e10 + s10 - r10]);
            else if (a10 < i10) {
              let o11 = h10 < e10 + n10, d10 = o11 ? e10 : e10 + s10;
              l10.splice(o11 ? 2 : 5, 0, ["L", a10, h10], ["L", t10 + i10 - r10, d10]);
            } else l10.splice(3, 1, ["L", t10 + i10, s10 / 2], ["L", a10, h10], ["L", t10 + i10, s10 / 2], ["L", t10 + i10, e10 + s10 - r10]);
          } else if (t10 + a10 < n10) {
            if (h10 > e10 + n10 && h10 < e10 + s10 - n10) l10.splice(7, 1, ["L", t10, h10 + 6], ["L", t10 - 6, h10], ["L", t10, h10 - 6], ["L", t10, e10 + r10]);
            else if (a10 > 0) {
              let i11 = h10 < e10 + n10, o11 = i11 ? e10 : e10 + s10;
              l10.splice(i11 ? 1 : 6, 0, ["L", a10, h10], ["L", t10 + r10, o11]);
            } else l10.splice(7, 1, ["L", t10, s10 / 2], ["L", a10, h10], ["L", t10, s10 / 2], ["L", t10, e10 + r10]);
          } else h10 > s10 && a10 < i10 - n10 ? l10.splice(5, 1, ["L", a10 + 6, e10 + s10], ["L", a10, e10 + s10 + 6], ["L", a10 - 6, e10 + s10], ["L", t10 + r10, e10 + s10]) : h10 < 0 && a10 > n10 && l10.splice(1, 1, ["L", a10 - 6, e10], ["L", a10, e10 - 6], ["L", a10 + 6, e10], ["L", i10 - r10, e10]);
          return l10;
        },
        circle: function(t10, e10, i10, s10) {
          return it(t10 + i10 / 2, e10 + s10 / 2, i10 / 2, s10 / 2, {
            start: 0.5 * Math.PI,
            end: 2.5 * Math.PI,
            open: false
          });
        },
        diamond: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10 / 2], ["L", t10 + i10 / 2, e10 + s10], ["L", t10, e10 + s10 / 2], ["Z"]];
        },
        rect: ie,
        roundedRect: ii,
        square: ie,
        triangle: function(t10, e10, i10, s10) {
          return [["M", t10 + i10 / 2, e10], ["L", t10 + i10, e10 + s10], ["L", t10, e10 + s10], ["Z"]];
        },
        "triangle-down": function(t10, e10, i10, s10) {
          return [["M", t10, e10], ["L", t10 + i10, e10], ["L", t10 + i10 / 2, e10 + s10], ["Z"]];
        }
      }, {
        doc: io,
        SVG_NS: ir,
        win: ia
      } = O, {
        attr: ih,
        extend: il,
        fireEvent: id,
        isString: ic,
        objectEach: ip,
        pick: iu
      } = tt, ig = (t10, e10) => t10.substring(0, e10) + "…", im = class {
        constructor(t10) {
          let e10 = t10.styles;
          this.renderer = t10.renderer, this.svgElement = t10, this.width = t10.textWidth, this.textLineHeight = e10 && e10.lineHeight, this.textOutline = e10 && e10.textOutline, this.ellipsis = !!(e10 && "ellipsis" === e10.textOverflow), this.lineClamp = e10?.lineClamp, this.noWrap = !!(e10 && "nowrap" === e10.whiteSpace);
        }
        buildSVG() {
          let t10 = this.svgElement, e10 = t10.element, i10 = t10.renderer, s10 = iu(t10.textStr, "").toString(), o10 = -1 !== s10.indexOf("<"), r10 = e10.childNodes, n10 = !t10.added && i10.box, a10 = [s10, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, t10.getStyle("font-size"), t10.styles.lineClamp, this.width].join(",");
          if (a10 !== t10.textCache) {
            t10.textCache = a10, delete t10.actualWidth;
            for (let t11 = r10.length; t11--; ) e10.removeChild(r10[t11]);
            if (o10 || this.ellipsis || this.width || t10.textPath || -1 !== s10.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(s10))) {
              if ("" !== s10) {
                n10 && n10.appendChild(e10);
                let i11 = new t6(s10);
                this.modifyTree(i11.nodes), i11.addToDOM(e10), this.modifyDOM(), this.ellipsis && -1 !== (e10.textContent || "").indexOf("…") && t10.attr("title", this.unescapeEntities(t10.textStr || "", ["&lt;", "&gt;"])), n10 && n10.removeChild(e10);
              }
            } else e10.appendChild(io.createTextNode(this.unescapeEntities(s10)));
            ic(this.textOutline) && t10.applyTextOutline && t10.applyTextOutline(this.textOutline);
          }
        }
        modifyDOM() {
          let t10;
          let e10 = this.svgElement, i10 = ih(e10.element, "x");
          for (e10.firstLineMetrics = void 0; t10 = e10.element.firstChild; ) if (/^[\s\u200B]*$/.test(t10.textContent || " ")) e10.element.removeChild(t10);
          else break;
          [].forEach.call(e10.element.querySelectorAll("tspan.highcharts-br"), (t11, s11) => {
            t11.nextSibling && t11.previousSibling && (0 === s11 && 1 === t11.previousSibling.nodeType && (e10.firstLineMetrics = e10.renderer.fontMetrics(t11.previousSibling)), ih(t11, {
              dy: this.getLineHeight(t11.nextSibling),
              x: i10
            }));
          });
          let s10 = this.width || 0;
          if (!s10) return;
          let o10 = (t11, o11) => {
            let r11 = t11.textContent || "", n10 = r11.replace(/([^\^])-/g, "$1- ").split(" "), a10 = !this.noWrap && (n10.length > 1 || e10.element.childNodes.length > 1), h10 = this.getLineHeight(o11), l10 = Math.max(0, s10 - 0.8 * h10), d10 = 0, c10 = e10.actualWidth;
            if (a10) {
              let r12 = [], a11 = [];
              for (; o11.firstChild && o11.firstChild !== t11; ) a11.push(o11.firstChild), o11.removeChild(o11.firstChild);
              for (; n10.length; ) if (n10.length && !this.noWrap && d10 > 0 && (r12.push(t11.textContent || ""), t11.textContent = n10.join(" ").replace(/- /g, "-")), this.truncate(t11, void 0, n10, 0 === d10 && c10 || 0, s10, l10, (t12, e11) => n10.slice(0, e11).join(" ").replace(/- /g, "-")), c10 = e10.actualWidth, d10++, this.lineClamp && d10 >= this.lineClamp) {
                n10.length && (this.truncate(t11, t11.textContent || "", void 0, 0, s10, l10, ig), t11.textContent = t11.textContent?.replace("…", "") + "…");
                break;
              }
              a11.forEach((e11) => {
                o11.insertBefore(e11, t11);
              }), r12.forEach((e11) => {
                o11.insertBefore(io.createTextNode(e11), t11);
                let s11 = io.createElementNS(ir, "tspan");
                s11.textContent = "​", ih(s11, {
                  dy: h10,
                  x: i10
                }), o11.insertBefore(s11, t11);
              });
            } else this.ellipsis && r11 && this.truncate(t11, r11, void 0, 0, s10, l10, ig);
          }, r10 = (t11) => {
            [].slice.call(t11.childNodes).forEach((i11) => {
              i11.nodeType === ia.Node.TEXT_NODE ? o10(i11, t11) : (-1 !== i11.className.baseVal.indexOf("highcharts-br") && (e10.actualWidth = 0), r10(i11));
            });
          };
          r10(e10.element);
        }
        getLineHeight(t10) {
          let e10 = t10.nodeType === ia.Node.TEXT_NODE ? t10.parentElement : t10;
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e10 || this.svgElement.element).h;
        }
        modifyTree(t10) {
          let e10 = (i10, s10) => {
            let {
              attributes: o10 = {},
              children: r10,
              style: n10 = {},
              tagName: a10
            } = i10, h10 = this.renderer.styledMode;
            if ("b" === a10 || "strong" === a10 ? h10 ? o10.class = "highcharts-strong" : n10.fontWeight = "bold" : ("i" === a10 || "em" === a10) && (h10 ? o10.class = "highcharts-emphasized" : n10.fontStyle = "italic"), n10 && n10.color && (n10.fill = n10.color), "br" === a10) {
              o10.class = "highcharts-br", i10.textContent = "​";
              let e11 = t10[s10 + 1];
              e11 && e11.textContent && (e11.textContent = e11.textContent.replace(/^ +/gm, ""));
            } else "a" === a10 && r10 && r10.some((t11) => "#text" === t11.tagName) && (i10.children = [{
              children: r10,
              tagName: "tspan"
            }]);
            "#text" !== a10 && "a" !== a10 && (i10.tagName = "tspan"), il(i10, {
              attributes: o10,
              style: n10
            }), r10 && r10.filter((t11) => "#text" !== t11.tagName).forEach(e10);
          };
          t10.forEach(e10), id(this.svgElement, "afterModifyTree", {
            nodes: t10
          });
        }
        truncate(t10, e10, i10, s10, o10, r10, n10) {
          let a10, h10;
          let l10 = this.svgElement, {
            rotation: d10
          } = l10, c10 = [], p10 = i10 && !s10 ? 1 : 0, u10 = (e10 || i10 || "").length, g2 = u10;
          i10 || (o10 = r10);
          let f2 = function(e11, o11) {
            let r11 = o11 || e11, n11 = t10.parentNode;
            if (n11 && void 0 === c10[r11] && n11.getSubStringLength) try {
              c10[r11] = s10 + n11.getSubStringLength(0, i10 ? r11 + 1 : r11);
            } catch (t11) {
            }
            return c10[r11];
          };
          if (l10.rotation = 0, s10 + (h10 = f2(t10.textContent.length)) > o10) {
            for (; p10 <= u10; ) g2 = Math.ceil((p10 + u10) / 2), i10 && (a10 = n10(i10, g2)), h10 = f2(g2, a10 && a10.length - 1), p10 === u10 ? p10 = u10 + 1 : h10 > o10 ? u10 = g2 - 1 : p10 = g2;
            0 === u10 ? t10.textContent = "" : e10 && u10 === e10.length - 1 || (t10.textContent = a10 || n10(e10 || i10, g2)), this.ellipsis && h10 > o10 && this.truncate(t10, t10.textContent || "", void 0, 0, o10, r10, ig);
          }
          i10 && i10.splice(0, g2), l10.actualWidth = h10, l10.rotation = d10;
        }
        unescapeEntities(t10, e10) {
          return ip(this.renderer.escapes, function(i10, s10) {
            e10 && -1 !== e10.indexOf(i10) || (t10 = t10.toString().replace(RegExp(i10, "g"), s10));
          }), t10;
        }
      }, {
        defaultOptions: ix
      } = tS, {
        charts: iy,
        deg2rad: ib,
        doc: iv,
        isFirefox: iM,
        isMS: ik,
        isWebKit: iw,
        noop: iS,
        SVG_NS: iA,
        symbolSizes: iT,
        win: iP
      } = O, {
        addEvent: iC,
        attr: iO,
        createElement: iE,
        crisp: iL,
        css: iB,
        defined: iI,
        destroyObjectProperties: iD,
        extend: iR,
        isArray: iN,
        isNumber: iz,
        isObject: iW,
        isString: iG,
        merge: iH,
        pick: iF,
        pInt: iX,
        replaceNested: iY,
        uniqueKey: ij
      } = tt;
      class iU {
        constructor(t10, e10, i10, s10, o10, r10, n10) {
          let a10, h10;
          let l10 = this.createElement("svg").attr({
            version: "1.1",
            class: "highcharts-root"
          }), d10 = l10.element;
          n10 || l10.css(this.getStyle(s10 || {})), t10.appendChild(d10), iO(t10, "dir", "ltr"), -1 === t10.innerHTML.indexOf("xmlns") && iO(d10, "xmlns", this.SVG_NS), this.box = d10, this.boxWrapper = l10, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(iv.createTextNode("Created with Highcharts 12.1.2")), this.defs = this.createElement("defs").add(), this.allowHTML = r10, this.forExport = o10, this.styledMode = n10, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l10.getStyle("font-size"), this.setSize(e10, i10, false), iM && t10.getBoundingClientRect && ((a10 = function() {
            iB(t10, {
              left: 0,
              top: 0
            }), h10 = t10.getBoundingClientRect(), iB(t10, {
              left: Math.ceil(h10.left) - h10.left + "px",
              top: Math.ceil(h10.top) - h10.top + "px"
            });
          })(), this.unSubPixelFix = iC(iP, "resize", a10));
        }
        definition(t10) {
          return new t6([t10]).addToDOM(this.defs.element);
        }
        getReferenceURL() {
          if ((iM || iw) && iv.getElementsByTagName("base").length) {
            if (!iI(e)) {
              let t10 = ij(), i10 = new t6([{
                tagName: "svg",
                attributes: {
                  width: 8,
                  height: 8
                },
                children: [{
                  tagName: "defs",
                  children: [{
                    tagName: "clipPath",
                    attributes: {
                      id: t10
                    },
                    children: [{
                      tagName: "rect",
                      attributes: {
                        width: 4,
                        height: 4
                      }
                    }]
                  }]
                }, {
                  tagName: "rect",
                  attributes: {
                    id: "hitme",
                    width: 8,
                    height: 8,
                    "clip-path": `url(#${t10})`,
                    fill: "rgba(0,0,0,0.001)"
                  }
                }]
              }]).addToDOM(iv.body);
              iB(i10, {
                position: "fixed",
                top: 0,
                left: 0,
                zIndex: 9e5
              });
              let s10 = iv.elementFromPoint(6, 6);
              e = "hitme" === (s10 && s10.id), iv.body.removeChild(i10);
            }
            if (e) return iY(iP.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
          }
          return "";
        }
        getStyle(t10) {
          return this.style = iR({
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
            fontSize: "1rem"
          }, t10), this.style;
        }
        setStyle(t10) {
          this.boxWrapper.css(this.getStyle(t10));
        }
        isHidden() {
          return !this.boxWrapper.getBBox().width;
        }
        destroy() {
          let t10 = this.defs;
          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), iD(this.gradients || {}), this.gradients = null, this.defs = t10.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
        }
        createElement(t10) {
          return new this.Element(this, t10);
        }
        getRadialAttr(t10, e10) {
          return {
            cx: t10[0] - t10[2] / 2 + (e10.cx || 0) * t10[2],
            cy: t10[1] - t10[2] / 2 + (e10.cy || 0) * t10[2],
            r: (e10.r || 0) * t10[2]
          };
        }
        shadowDefinition(t10) {
          let e10 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t10).map((e11) => `${e11}-${t10[e11]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i10 = iH({
            color: "#000000",
            offsetX: 1,
            offsetY: 1,
            opacity: 0.15,
            width: 5
          }, t10);
          return this.defs.element.querySelector(`#${e10}`) || this.definition({
            tagName: "filter",
            attributes: {
              id: e10,
              filterUnits: i10.filterUnits
            },
            children: this.getShadowFilterContent(i10)
          }), e10;
        }
        getShadowFilterContent(t10) {
          return [{
            tagName: "feDropShadow",
            attributes: {
              dx: t10.offsetX,
              dy: t10.offsetY,
              "flood-color": t10.color,
              "flood-opacity": Math.min(5 * t10.opacity, 1),
              stdDeviation: t10.width / 2
            }
          }];
        }
        buildText(t10) {
          new im(t10).buildSVG();
        }
        getContrast(t10) {
          let e10 = tO.parse(t10).rgba.map((t11) => {
            let e11 = t11 / 255;
            return e11 <= 0.03928 ? e11 / 12.92 : Math.pow((e11 + 0.055) / 1.055, 2.4);
          }), i10 = 0.2126 * e10[0] + 0.7152 * e10[1] + 0.0722 * e10[2];
          return 1.05 / (i10 + 0.05) > (i10 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
        }
        button(t10, e10, i10, s10, o10 = {}, r10, n10, a10, h10, l10) {
          let d10 = this.label(t10, e10, i10, h10, void 0, void 0, l10, void 0, "button"), c10 = this.styledMode, p10 = arguments, u10 = 0;
          o10 = iH(ix.global.buttonTheme, o10), c10 && (delete o10.fill, delete o10.stroke, delete o10["stroke-width"]);
          let g2 = o10.states || {}, f2 = o10.style || {};
          delete o10.states, delete o10.style;
          let m2 = [t6.filterUserAttributes(o10)], x2 = [f2];
          return c10 || ["hover", "select", "disabled"].forEach((t11, e11) => {
            m2.push(iH(m2[0], t6.filterUserAttributes(p10[e11 + 5] || g2[t11] || {}))), x2.push(m2[e11 + 1].style), delete m2[e11 + 1].style;
          }), iC(d10.element, ik ? "mouseover" : "mouseenter", function() {
            3 !== u10 && d10.setState(1);
          }), iC(d10.element, ik ? "mouseout" : "mouseleave", function() {
            3 !== u10 && d10.setState(u10);
          }), d10.setState = (t11 = 0) => {
            if (1 !== t11 && (d10.state = u10 = t11), d10.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t11]), !c10) {
              d10.attr(m2[t11]);
              let e11 = x2[t11];
              iW(e11) && d10.css(e11);
            }
          }, d10.attr(m2[0]), !c10 && (d10.css(iR({
            cursor: "default"
          }, f2)), l10 && d10.text.css({
            pointerEvents: "none"
          })), d10.on("touchstart", (t11) => t11.stopPropagation()).on("click", function(t11) {
            3 !== u10 && s10.call(d10, t11);
          });
        }
        crispLine(t10, e10) {
          let [i10, s10] = t10;
          return iI(i10[1]) && i10[1] === s10[1] && (i10[1] = s10[1] = iL(i10[1], e10)), iI(i10[2]) && i10[2] === s10[2] && (i10[2] = s10[2] = iL(i10[2], e10)), t10;
        }
        path(t10) {
          let e10 = this.styledMode ? {} : {
            fill: "none"
          };
          return iN(t10) ? e10.d = t10 : iW(t10) && iR(e10, t10), this.createElement("path").attr(e10);
        }
        circle(t10, e10, i10) {
          let s10 = iW(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: i10
          }, o10 = this.createElement("circle");
          return o10.xSetter = o10.ySetter = function(t11, e11, i11) {
            i11.setAttribute("c" + e11, t11);
          }, o10.attr(s10);
        }
        arc(t10, e10, i10, s10, o10, r10) {
          let n10;
          iW(t10) ? (e10 = (n10 = t10).y, i10 = n10.r, s10 = n10.innerR, o10 = n10.start, r10 = n10.end, t10 = n10.x) : n10 = {
            innerR: s10,
            start: o10,
            end: r10
          };
          let a10 = this.symbol("arc", t10, e10, i10, i10, n10);
          return a10.r = i10, a10;
        }
        rect(t10, e10, i10, s10, o10, r10) {
          let n10 = iW(t10) ? t10 : void 0 === t10 ? {} : {
            x: t10,
            y: e10,
            r: o10,
            width: Math.max(i10 || 0, 0),
            height: Math.max(s10 || 0, 0)
          }, a10 = this.createElement("rect");
          return this.styledMode || (void 0 !== r10 && (n10["stroke-width"] = r10, iR(n10, a10.crisp(n10))), n10.fill = "none"), a10.rSetter = function(t11, e11, i11) {
            a10.r = t11, iO(i11, {
              rx: t11,
              ry: t11
            });
          }, a10.rGetter = function() {
            return a10.r || 0;
          }, a10.attr(n10);
        }
        roundedRect(t10) {
          return this.symbol("roundedRect").attr(t10);
        }
        setSize(t10, e10, i10) {
          this.width = t10, this.height = e10, this.boxWrapper.animate({
            width: t10,
            height: e10
          }, {
            step: function() {
              this.attr({
                viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
              });
            },
            duration: iF(i10, true) ? void 0 : 0
          }), this.alignElements();
        }
        g(t10) {
          let e10 = this.createElement("g");
          return t10 ? e10.attr({
            class: "highcharts-" + t10
          }) : e10;
        }
        image(t10, e10, i10, s10, o10, r10) {
          let n10 = {
            preserveAspectRatio: "none"
          };
          iz(e10) && (n10.x = e10), iz(i10) && (n10.y = i10), iz(s10) && (n10.width = s10), iz(o10) && (n10.height = o10);
          let a10 = this.createElement("image").attr(n10), h10 = function(e11) {
            a10.attr({
              href: t10
            }), r10.call(a10, e11);
          };
          if (r10) {
            a10.attr({
              href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
            });
            let e11 = new iP.Image();
            iC(e11, "load", h10), e11.src = t10, e11.complete && h10({});
          } else a10.attr({
            href: t10
          });
          return a10;
        }
        symbol(t10, e10, i10, s10, o10, r10) {
          let n10, a10, h10, l10;
          let d10 = this, c10 = /^url\((.*?)\)$/, p10 = c10.test(t10), u10 = !p10 && (this.symbols[t10] ? t10 : "circle"), g2 = u10 && this.symbols[u10];
          if (g2) "number" == typeof e10 && (a10 = g2.call(this.symbols, e10 || 0, i10 || 0, s10 || 0, o10 || 0, r10)), n10 = this.path(a10), d10.styledMode || n10.attr("fill", "none"), iR(n10, {
            symbolName: u10 || void 0,
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }), r10 && iR(n10, r10);
          else if (p10) {
            h10 = t10.match(c10)[1];
            let s11 = n10 = this.image(h10);
            s11.imgwidth = iF(r10 && r10.width, iT[h10] && iT[h10].width), s11.imgheight = iF(r10 && r10.height, iT[h10] && iT[h10].height), l10 = (t11) => t11.attr({
              width: t11.width,
              height: t11.height
            }), ["width", "height"].forEach((t11) => {
              s11[`${t11}Setter`] = function(t12, e11) {
                this[e11] = t12;
                let {
                  alignByTranslate: i11,
                  element: s12,
                  width: o11,
                  height: n11,
                  imgwidth: a11,
                  imgheight: h11
                } = this, l11 = "width" === e11 ? a11 : h11, d11 = 1;
                r10 && "within" === r10.backgroundSize && o11 && n11 && a11 && h11 ? (d11 = Math.min(o11 / a11, n11 / h11), iO(s12, {
                  width: Math.round(a11 * d11),
                  height: Math.round(h11 * d11)
                })) : s12 && l11 && s12.setAttribute(e11, l11), !i11 && a11 && h11 && this.translate(((o11 || 0) - a11 * d11) / 2, ((n11 || 0) - h11 * d11) / 2);
              };
            }), iI(e10) && s11.attr({
              x: e10,
              y: i10
            }), s11.isImg = true, s11.symbolUrl = t10, iI(s11.imgwidth) && iI(s11.imgheight) ? l10(s11) : (s11.attr({
              width: 0,
              height: 0
            }), iE("img", {
              onload: function() {
                let t11 = iy[d10.chartIndex];
                0 === this.width && (iB(this, {
                  position: "absolute",
                  top: "-999em"
                }), iv.body.appendChild(this)), iT[h10] = {
                  width: this.width,
                  height: this.height
                }, s11.imgwidth = this.width, s11.imgheight = this.height, s11.element && l10(s11), this.parentNode && this.parentNode.removeChild(this), d10.imgCount--, d10.imgCount || !t11 || t11.hasLoaded || t11.onload();
              },
              src: h10
            }), this.imgCount++);
          }
          return n10;
        }
        clipRect(t10, e10, i10, s10) {
          return this.rect(t10, e10, i10, s10, 0);
        }
        text(t10, e10, i10, s10) {
          let o10 = {};
          if (s10 && (this.allowHTML || !this.forExport)) return this.html(t10, e10, i10);
          o10.x = Math.round(e10 || 0), i10 && (o10.y = Math.round(i10)), iI(t10) && (o10.text = t10);
          let r10 = this.createElement("text").attr(o10);
          return s10 && (!this.forExport || this.allowHTML) || (r10.xSetter = function(t11, e11, i11) {
            let s11 = i11.getElementsByTagName("tspan"), o11 = i11.getAttribute(e11);
            for (let i12 = 0, r11; i12 < s11.length; i12++) (r11 = s11[i12]).getAttribute(e11) === o11 && r11.setAttribute(e11, t11);
            i11.setAttribute(e11, t11);
          }), r10;
        }
        fontMetrics(t10) {
          let e10 = iX(eJ.prototype.getStyle.call(t10, "font-size") || 0), i10 = e10 < 24 ? e10 + 3 : Math.round(1.2 * e10), s10 = Math.round(0.8 * i10);
          return {
            h: i10,
            b: s10,
            f: e10
          };
        }
        rotCorr(t10, e10, i10) {
          let s10 = t10;
          return e10 && i10 && (s10 = Math.max(s10 * Math.cos(e10 * ib), 4)), {
            x: -t10 / 3 * Math.sin(e10 * ib),
            y: s10
          };
        }
        pathToSegments(t10) {
          let e10 = [], i10 = [], s10 = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          };
          for (let o10 = 0; o10 < t10.length; o10++) iG(i10[0]) && iz(t10[o10]) && i10.length === s10[i10[0].toUpperCase()] && t10.splice(o10, 0, i10[0].replace("M", "L").replace("m", "l")), "string" == typeof t10[o10] && (i10.length && e10.push(i10.slice(0)), i10.length = 0), i10.push(t10[o10]);
          return e10.push(i10.slice(0)), e10;
        }
        label(t10, e10, i10, s10, o10, r10, n10, a10, h10) {
          return new e9(this, t10, e10, i10, s10, o10, r10, n10, a10, h10);
        }
        alignElements() {
          this.alignedObjects.forEach((t10) => t10.align());
        }
      }
      iR(iU.prototype, {
        Element: eJ,
        SVG_NS: iA,
        escapes: {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "'": "&#39;",
          '"': "&quot;"
        },
        symbols: is,
        draw: iS
      }), eu.registerRendererType("svg", iU, true);
      let {
        composed: iV
      } = O, {
        attr: i$,
        css: i_,
        createElement: iq,
        defined: iZ,
        extend: iK,
        getAlignFactor: iJ,
        isNumber: iQ,
        pInt: i0,
        pushUnique: i1
      } = tt;
      function i2(t10, e10, i10) {
        let s10 = this.div?.style || i10.style;
        eJ.prototype[`${e10}Setter`].call(this, t10, e10, i10), s10 && (s10[e10] = t10);
      }
      let i3 = (t10, e10) => {
        if (!t10.div) {
          let i10 = i$(t10.element, "class"), s10 = t10.css, o10 = iq("div", i10 ? {
            className: i10
          } : void 0, __spreadProps(__spreadValues({
            position: "absolute",
            left: `${t10.translateX || 0}px`,
            top: `${t10.translateY || 0}px`
          }, t10.styles), {
            display: t10.display,
            opacity: t10.opacity,
            visibility: t10.visibility
          }), t10.parentGroup?.div || e10);
          t10.classSetter = (t11, e11, i11) => {
            i11.setAttribute("class", t11), o10.className = t11;
          }, t10.translateXSetter = t10.translateYSetter = (e11, i11) => {
            t10[i11] = e11, o10.style["translateX" === i11 ? "left" : "top"] = `${e11}px`, t10.doTransform = true;
          }, t10.opacitySetter = t10.visibilitySetter = i2, t10.css = (e11) => (s10.call(t10, e11), e11.cursor && (o10.style.cursor = e11.cursor), e11.pointerEvents && (o10.style.pointerEvents = e11.pointerEvents), t10), t10.on = function() {
            return eJ.prototype.on.apply({
              element: o10,
              onEvents: t10.onEvents
            }, arguments), t10;
          }, t10.div = o10;
        }
        return t10.div;
      };
      class i5 extends eJ {
        static compose(t10) {
          i1(iV, this.compose) && (t10.prototype.html = function(t11, e10, i10) {
            return new i5(this, "span").attr({
              text: t11,
              x: Math.round(e10),
              y: Math.round(i10)
            });
          });
        }
        constructor(t10, e10) {
          super(t10, e10), this.css(__spreadValues({
            position: "absolute"
          }, t10.styledMode ? {} : {
            fontFamily: t10.style.fontFamily,
            fontSize: t10.style.fontSize
          }));
        }
        getSpanCorrection(t10, e10, i10) {
          this.xCorr = -t10 * i10, this.yCorr = -e10;
        }
        css(t10) {
          let e10;
          let {
            element: i10
          } = this, s10 = "SPAN" === i10.tagName && t10 && "width" in t10, o10 = s10 && t10.width;
          return s10 && (delete t10.width, this.textWidth = i0(o10) || void 0, e10 = true), t10?.textOverflow === "ellipsis" && (t10.overflow = "hidden"), t10?.lineClamp && (t10.display = "-webkit-box", t10.WebkitLineClamp = t10.lineClamp, t10.WebkitBoxOrient = "vertical", t10.overflow = "hidden"), iQ(Number(t10?.fontSize)) && (t10.fontSize = t10.fontSize + "px"), iK(this.styles, t10), i_(i10, t10), e10 && this.updateTransform(), this;
        }
        htmlGetBBox() {
          let {
            element: t10
          } = this;
          return {
            x: t10.offsetLeft,
            y: t10.offsetTop,
            width: t10.offsetWidth,
            height: t10.offsetHeight
          };
        }
        updateTransform() {
          if (!this.added) {
            this.alignOnAdd = true;
            return;
          }
          let {
            element: t10,
            renderer: e10,
            rotation: i10,
            rotationOriginX: s10,
            rotationOriginY: o10,
            scaleX: r10,
            scaleY: n10,
            styles: a10,
            textAlign: h10 = "left",
            textWidth: l10,
            translateX: d10 = 0,
            translateY: c10 = 0,
            x: p10 = 0,
            y: u10 = 0
          } = this, {
            display: g2 = "block",
            whiteSpace: f2
          } = a10;
          if (i_(t10, {
            marginLeft: `${d10}px`,
            marginTop: `${c10}px`
          }), "SPAN" === t10.tagName) {
            let a11;
            let d11 = [i10, h10, t10.innerHTML, l10, this.textAlign].join(","), c11 = -(this.parentGroup?.padding * 1) || 0;
            if (l10 !== this.oldTextWidth) {
              let e11 = this.textPxLength ? this.textPxLength : (i_(t10, {
                width: "",
                whiteSpace: f2 || "nowrap"
              }), t10.offsetWidth), s11 = l10 || 0;
              (s11 > this.oldTextWidth || e11 > s11) && (/[ \-]/.test(t10.textContent || t10.innerText) || "ellipsis" === t10.style.textOverflow) && (i_(t10, {
                width: e11 > s11 || i10 || r10 ? l10 + "px" : "auto",
                display: g2,
                whiteSpace: f2 || "normal"
              }), this.oldTextWidth = l10);
            }
            d11 !== this.cTT && (a11 = e10.fontMetrics(t10).b, iZ(i10) && (i10 !== (this.oldRotation || 0) || h10 !== this.oldAlign) && this.setSpanRotation(i10, c11, c11), this.getSpanCorrection(!iZ(i10) && !this.textWidth && this.textPxLength || t10.offsetWidth, a11, iJ(h10)));
            let {
              xCorr: m2 = 0,
              yCorr: x2 = 0
            } = this, y2 = {
              left: `${p10 + m2}px`,
              top: `${u10 + x2}px`,
              textAlign: h10,
              transformOrigin: `${(s10 ?? p10) - m2 - p10 - c11}px ${(o10 ?? u10) - x2 - u10 - c11}px`
            };
            (r10 || n10) && (y2.transform = `scale(${r10 ?? 1},${n10 ?? 1})`), i_(t10, y2), this.cTT = d11, this.oldRotation = i10, this.oldAlign = h10;
          }
        }
        setSpanRotation(t10, e10, i10) {
          i_(this.element, {
            transform: `rotate(${t10}deg)`,
            transformOrigin: `${e10}% ${i10}px`
          });
        }
        add(t10) {
          let e10;
          let i10 = this.renderer.box.parentNode, s10 = [];
          if (this.parentGroup = t10, t10 && !(e10 = t10.div)) {
            let o10 = t10;
            for (; o10; ) s10.push(o10), o10 = o10.parentGroup;
            for (let t11 of s10.reverse()) e10 = i3(t11, i10);
          }
          return (e10 || i10).appendChild(this.element), this.added = true, this.alignOnAdd && this.updateTransform(), this;
        }
        textSetter(t10) {
          t10 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t6.setElementHTML(this.element, t10 ?? ""), this.textStr = t10, this.doTransform = true);
        }
        alignSetter(t10) {
          this.alignValue = this.textAlign = t10, this.doTransform = true;
        }
        xSetter(t10, e10) {
          this[e10] = t10, this.doTransform = true;
        }
      }
      let i6 = i5.prototype;
      i6.visibilitySetter = i6.opacitySetter = i2, i6.ySetter = i6.rotationSetter = i6.rotationOriginXSetter = i6.rotationOriginYSetter = i6.xSetter, function(t10) {
        t10.xAxis = {
          alignTicks: true,
          allowDecimals: void 0,
          panningEnabled: true,
          zIndex: 2,
          zoomEnabled: true,
          dateTimeLabelFormats: {
            millisecond: {
              main: "%[HMSL]",
              range: false
            },
            second: {
              main: "%[HMS]",
              range: false
            },
            minute: {
              main: "%[HM]",
              range: false
            },
            hour: {
              main: "%[HM]",
              range: false
            },
            day: {
              main: "%[eb]"
            },
            week: {
              main: "%[eb]"
            },
            month: {
              main: "%[bY]"
            },
            year: {
              main: "%Y"
            }
          },
          endOnTick: false,
          gridLineDashStyle: "Solid",
          gridZIndex: 1,
          labels: {
            autoRotationLimit: 80,
            distance: 15,
            enabled: true,
            indentation: 10,
            overflow: "justify",
            reserveSpace: void 0,
            rotation: void 0,
            staggerLines: 0,
            step: 0,
            useHTML: false,
            zIndex: 7,
            style: {
              color: "#333333",
              cursor: "default",
              fontSize: "0.8em",
              textOverflow: "ellipsis"
            }
          },
          maxPadding: 0.01,
          minorGridLineDashStyle: "Solid",
          minorTickLength: 2,
          minorTickPosition: "outside",
          minorTicksPerMajor: 5,
          minPadding: 0.01,
          offset: void 0,
          reversed: void 0,
          reversedStacks: false,
          showEmpty: true,
          showFirstLabel: true,
          showLastLabel: true,
          startOfWeek: 1,
          startOnTick: false,
          tickLength: 10,
          tickPixelInterval: 100,
          tickmarkPlacement: "between",
          tickPosition: "outside",
          title: {
            align: "middle",
            useHTML: false,
            x: 0,
            y: 0,
            style: {
              color: "#666666",
              fontSize: "0.8em"
            }
          },
          visible: true,
          minorGridLineColor: "#f2f2f2",
          minorGridLineWidth: 1,
          minorTickColor: "#999999",
          lineColor: "#333333",
          lineWidth: 1,
          gridLineColor: "#e6e6e6",
          gridLineWidth: void 0,
          tickColor: "#333333"
        }, t10.yAxis = {
          reversedStacks: true,
          endOnTick: true,
          maxPadding: 0.05,
          minPadding: 0.05,
          tickPixelInterval: 72,
          showLastLabel: true,
          labels: {
            x: void 0
          },
          startOnTick: true,
          title: {
            text: "Values"
          },
          stackLabels: {
            animation: {},
            allowOverlap: false,
            enabled: false,
            crop: true,
            overflow: "justify",
            formatter: function() {
              let {
                numberFormatter: t11
              } = this.axis.chart;
              return t11(this.total || 0, -1);
            },
            style: {
              color: "#000000",
              fontSize: "0.7em",
              fontWeight: "bold",
              textOutline: "1px contrast"
            }
          },
          gridLineWidth: 1,
          lineWidth: 0
        };
      }(h || (h = {}));
      let i9 = h, {
        addEvent: i4,
        isFunction: i8,
        objectEach: i7,
        removeEvent: st
      } = tt;
      (l || (l = {})).registerEventOptions = function(t10, e10) {
        t10.eventOptions = t10.eventOptions || {}, i7(e10.events, function(e11, i10) {
          t10.eventOptions[i10] !== e11 && (t10.eventOptions[i10] && (st(t10, i10, t10.eventOptions[i10]), delete t10.eventOptions[i10]), i8(e11) && (t10.eventOptions[i10] = e11, i4(t10, i10, e11, {
            order: 0
          })));
        });
      };
      let se = l, {
        deg2rad: si
      } = O, {
        clamp: ss,
        correctFloat: so,
        defined: sr,
        destroyObjectProperties: sn,
        extend: sa,
        fireEvent: sh,
        getAlignFactor: sl,
        isNumber: sd,
        merge: sc,
        objectEach: sp,
        pick: su
      } = tt, sg = class {
        constructor(t10, e10, i10, s10, o10) {
          this.isNew = true, this.isNewLabel = true, this.axis = t10, this.pos = e10, this.type = i10 || "", this.parameters = o10 || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, sh(this, "init"), i10 || s10 || this.addLabel();
        }
        addLabel() {
          let t10 = this, e10 = t10.axis, i10 = e10.options, s10 = e10.chart, o10 = e10.categories, r10 = e10.logarithmic, n10 = e10.names, a10 = t10.pos, h10 = su(t10.options && t10.options.labels, i10.labels), l10 = e10.tickPositions, d10 = a10 === l10[0], c10 = a10 === l10[l10.length - 1], p10 = (!h10.step || 1 === h10.step) && 1 === e10.tickInterval, u10 = l10.info, g2 = t10.label, f2, m2, x2, y2 = this.parameters.category || (o10 ? su(o10[a10], n10[a10], a10) : a10);
          r10 && sd(y2) && (y2 = so(r10.lin2log(y2))), e10.dateTime && (u10 ? f2 = (m2 = s10.time.resolveDTLFormat(i10.dateTimeLabelFormats[!i10.grid && u10.higherRanks[a10] || u10.unitName])).main : sd(y2) && (f2 = e10.dateTime.getXDateFormat(y2, i10.dateTimeLabelFormats || {}))), t10.isFirst = d10, t10.isLast = c10;
          let b2 = {
            axis: e10,
            chart: s10,
            dateTimeLabelFormat: f2,
            isFirst: d10,
            isLast: c10,
            pos: a10,
            tick: t10,
            tickPositionInfo: u10,
            value: y2
          };
          sh(this, "labelFormat", b2);
          let v2 = (t11) => h10.formatter ? h10.formatter.call(t11, t11) : h10.format ? (t11.text = e10.defaultLabelFormatter.call(t11), ep.format(h10.format, t11, s10)) : e10.defaultLabelFormatter.call(t11), M2 = v2.call(b2, b2), k2 = m2 && m2.list;
          k2 ? t10.shortenLabel = function() {
            for (x2 = 0; x2 < k2.length; x2++) if (sa(b2, {
              dateTimeLabelFormat: k2[x2]
            }), g2.attr({
              text: v2.call(b2, b2)
            }), g2.getBBox().width < e10.getSlotWidth(t10) - 2 * (h10.padding || 0)) return;
            g2.attr({
              text: ""
            });
          } : t10.shortenLabel = void 0, p10 && e10._addedPlotLB && t10.moveLabel(M2, h10), sr(g2) || t10.movedLabel ? g2 && g2.textStr !== M2 && !p10 && (!g2.textWidth || h10.style.width || g2.styles.width || g2.css({
            width: null
          }), g2.attr({
            text: M2
          }), g2.textPxLength = g2.getBBox().width) : (t10.label = g2 = t10.createLabel(M2, h10), t10.rotation = 0);
        }
        createLabel(t10, e10, i10) {
          let s10 = this.axis, {
            renderer: o10,
            styledMode: r10
          } = s10.chart, n10 = sr(t10) && e10.enabled ? o10.text(t10, i10?.x, i10?.y, e10.useHTML).add(s10.labelGroup) : void 0;
          if (n10) {
            let t11 = e10.style.whiteSpace || "normal";
            r10 || n10.css(sc(e10.style, {
              whiteSpace: "nowrap"
            })), n10.textPxLength = n10.getBBox().width, r10 || n10.css({
              whiteSpace: t11
            });
          }
          return n10;
        }
        destroy() {
          sn(this, this.axis);
        }
        getPosition(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart, n10 = s10 && r10.oldChartHeight || r10.chartHeight, a10 = {
            x: t10 ? so(o10.translate(e10 + i10, void 0, void 0, s10) + o10.transB) : o10.left + o10.offset + (o10.opposite ? (s10 && r10.oldChartWidth || r10.chartWidth) - o10.right - o10.left : 0),
            y: t10 ? n10 - o10.bottom + o10.offset - (o10.opposite ? o10.height : 0) : so(n10 - o10.translate(e10 + i10, void 0, void 0, s10) - o10.transB)
          };
          return a10.y = ss(a10.y, -1e9, 1e9), sh(this, "afterGetPosition", {
            pos: a10
          }), a10;
        }
        getLabelPosition(t10, e10, i10, s10, o10, r10, n10, a10) {
          let h10, l10;
          let d10 = this.axis, c10 = d10.transA, p10 = d10.isLinked && d10.linkedParent ? d10.linkedParent.reversed : d10.reversed, u10 = d10.staggerLines, g2 = d10.tickRotCorr || {
            x: 0,
            y: 0
          }, f2 = s10 || d10.reserveSpaceDefault ? 0 : -d10.labelOffset * ("center" === d10.labelAlign ? 0.5 : 1), m2 = o10.distance, x2 = {};
          return h10 = 0 === d10.side ? i10.rotation ? -m2 : -i10.getBBox().height : 2 === d10.side ? g2.y + m2 : Math.cos(i10.rotation * si) * (g2.y - i10.getBBox(false, 0).height / 2), sr(o10.y) && (h10 = 0 === d10.side && d10.horiz ? o10.y + h10 : o10.y), t10 = t10 + su(o10.x, [0, 1, 0, -1][d10.side] * m2) + f2 + g2.x - (r10 && s10 ? r10 * c10 * (p10 ? -1 : 1) : 0), e10 = e10 + h10 - (r10 && !s10 ? r10 * c10 * (p10 ? 1 : -1) : 0), u10 && (l10 = n10 / (a10 || 1) % u10, d10.opposite && (l10 = u10 - l10 - 1), e10 += l10 * (d10.labelOffset / u10)), x2.x = t10, x2.y = Math.round(e10), sh(this, "afterGetLabelPosition", {
            pos: x2,
            tickmarkOffset: r10,
            index: n10
          }), x2;
        }
        getLabelSize() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        }
        getMarkPath(t10, e10, i10, s10, o10 = false, r10) {
          return r10.crispLine([["M", t10, e10], ["L", t10 + (o10 ? 0 : -i10), e10 + (o10 ? i10 : 0)]], s10);
        }
        handleOverflow(t10) {
          let e10 = this.axis, i10 = e10.options.labels, s10 = t10.x, o10 = e10.chart.chartWidth, r10 = e10.chart.spacing, n10 = su(e10.labelLeft, Math.min(e10.pos, r10[3])), a10 = su(e10.labelRight, Math.max(e10.isRadial ? 0 : e10.pos + e10.len, o10 - r10[1])), h10 = this.label, l10 = this.rotation, d10 = sl(e10.labelAlign || h10.attr("align")), c10 = h10.getBBox().width, p10 = e10.getSlotWidth(this), u10 = p10, g2 = 1, f2, m2, x2;
          l10 || "justify" !== i10.overflow ? l10 < 0 && s10 - d10 * c10 < n10 ? x2 = Math.round(s10 / Math.cos(l10 * si) - n10) : l10 > 0 && s10 + d10 * c10 > a10 && (x2 = Math.round((o10 - s10) / Math.cos(l10 * si))) : (f2 = s10 - d10 * c10, m2 = s10 + (1 - d10) * c10, f2 < n10 ? u10 = t10.x + u10 * (1 - d10) - n10 : m2 > a10 && (u10 = a10 - t10.x + u10 * d10, g2 = -1), (u10 = Math.min(p10, u10)) < p10 && "center" === e10.labelAlign && (t10.x += g2 * (p10 - u10 - d10 * (p10 - Math.min(c10, u10)))), (c10 > u10 || e10.autoRotation && (h10.styles || {}).width) && (x2 = u10)), x2 && h10 && (this.shortenLabel ? this.shortenLabel() : h10.css(sa({}, {
            width: Math.floor(x2) + "px",
            lineClamp: e10.isRadial ? 0 : 1
          })));
        }
        moveLabel(t10, e10) {
          let i10 = this, s10 = i10.label, o10 = i10.axis, r10 = false, n10;
          s10 && s10.textStr === t10 ? (i10.movedLabel = s10, r10 = true, delete i10.label) : sp(o10.ticks, function(e11) {
            r10 || e11.isNew || e11 === i10 || !e11.label || e11.label.textStr !== t10 || (i10.movedLabel = e11.label, r10 = true, e11.labelPos = i10.movedLabel.xy, delete e11.label);
          }), !r10 && (i10.labelPos || s10) && (n10 = i10.labelPos || s10.xy, i10.movedLabel = i10.createLabel(t10, e10, n10), i10.movedLabel && i10.movedLabel.attr({
            opacity: 0
          }));
        }
        render(t10, e10, i10) {
          let s10 = this.axis, o10 = s10.horiz, r10 = this.pos, n10 = su(this.tickmarkOffset, s10.tickmarkOffset), a10 = this.getPosition(o10, r10, n10, e10), h10 = a10.x, l10 = a10.y, d10 = s10.pos, c10 = d10 + s10.len, p10 = o10 ? h10 : l10;
          !s10.chart.polar && this.isNew && (so(p10) < d10 || p10 > c10) && (i10 = 0);
          let u10 = su(i10, this.label && this.label.newOpacity, 1);
          i10 = su(i10, 1), this.isActive = true, this.renderGridLine(e10, i10), this.renderMark(a10, i10), this.renderLabel(a10, e10, u10, t10), this.isNew = false, sh(this, "afterRender");
        }
        renderGridLine(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = {}, r10 = this.pos, n10 = this.type, a10 = su(this.tickmarkOffset, i10.tickmarkOffset), h10 = i10.chart.renderer, l10 = this.gridLine, d10, c10 = s10.gridLineWidth, p10 = s10.gridLineColor, u10 = s10.gridLineDashStyle;
          "minor" === this.type && (c10 = s10.minorGridLineWidth, p10 = s10.minorGridLineColor, u10 = s10.minorGridLineDashStyle), l10 || (i10.chart.styledMode || (o10.stroke = p10, o10["stroke-width"] = c10 || 0, o10.dashstyle = u10), n10 || (o10.zIndex = 1), t10 && (e10 = 0), this.gridLine = l10 = h10.path().attr(o10).addClass("highcharts-" + (n10 ? n10 + "-" : "") + "grid-line").add(i10.gridGroup)), l10 && (d10 = i10.getPlotLinePath({
            value: r10 + a10,
            lineWidth: l10.strokeWidth(),
            force: "pass",
            old: t10,
            acrossPanes: false
          })) && l10[t10 || this.isNew ? "attr" : "animate"]({
            d: d10,
            opacity: e10
          });
        }
        renderMark(t10, e10) {
          let i10 = this.axis, s10 = i10.options, o10 = i10.chart.renderer, r10 = this.type, n10 = i10.tickSize(r10 ? r10 + "Tick" : "tick"), a10 = t10.x, h10 = t10.y, l10 = su(s10["minor" !== r10 ? "tickWidth" : "minorTickWidth"], !r10 && i10.isXAxis ? 1 : 0), d10 = s10["minor" !== r10 ? "tickColor" : "minorTickColor"], c10 = this.mark, p10 = !c10;
          n10 && (i10.opposite && (n10[0] = -n10[0]), c10 || (this.mark = c10 = o10.path().addClass("highcharts-" + (r10 ? r10 + "-" : "") + "tick").add(i10.axisGroup), i10.chart.styledMode || c10.attr({
            stroke: d10,
            "stroke-width": l10
          })), c10[p10 ? "attr" : "animate"]({
            d: this.getMarkPath(a10, h10, n10[0], c10.strokeWidth(), i10.horiz, o10),
            opacity: e10
          }));
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.horiz, n10 = o10.options, a10 = this.label, h10 = n10.labels, l10 = h10.step, d10 = su(this.tickmarkOffset, o10.tickmarkOffset), c10 = t10.x, p10 = t10.y, u10 = true;
          a10 && sd(c10) && (a10.xy = t10 = this.getLabelPosition(c10, p10, a10, r10, h10, d10, s10, l10), (!this.isFirst || this.isLast || n10.showFirstLabel) && (!this.isLast || this.isFirst || n10.showLastLabel) ? !r10 || h10.step || h10.rotation || e10 || 0 === i10 || this.handleOverflow(t10) : u10 = false, l10 && s10 % l10 && (u10 = false), u10 && sd(t10.y) ? (t10.opacity = i10, a10[this.isNewLabel ? "attr" : "animate"](t10).show(true), this.isNewLabel = false) : (a10.hide(), this.isNewLabel = true));
        }
        replaceMovedLabel() {
          let t10 = this.label, e10 = this.axis;
          t10 && !this.isNew && (t10.animate({
            opacity: 0
          }, void 0, t10.destroy), delete this.label), e10.isDirty = true, this.label = this.movedLabel, delete this.movedLabel;
        }
      }, {
        animObject: sf
      } = tU, {
        xAxis: sm,
        yAxis: sx
      } = i9, {
        defaultOptions: sy
      } = tS, {
        registerEventOptions: sb
      } = se, {
        deg2rad: sv
      } = O, {
        arrayMax: sM,
        arrayMin: sk,
        clamp: sw,
        correctFloat: sS,
        defined: sA,
        destroyObjectProperties: sT,
        erase: sP,
        error: sC,
        extend: sO,
        fireEvent: sE,
        getClosestDistance: sL,
        insertItem: sB,
        isArray: sI,
        isNumber: sD,
        isString: sR,
        merge: sN,
        normalizeTickInterval: sz,
        objectEach: sW,
        pick: sG,
        relativeLength: sH,
        removeEvent: sF,
        splat: sX,
        syncTimeout: sY
      } = tt, sj = (t10, e10) => sz(e10, void 0, void 0, sG(t10.options.allowDecimals, e10 < 0.5 || void 0 !== t10.tickAmount), !!t10.tickAmount);
      sO(sy, {
        xAxis: sm,
        yAxis: sN(sm, sx)
      });
      class sU {
        constructor(t10, e10, i10) {
          this.init(t10, e10, i10);
        }
        init(t10, e10, i10 = this.coll) {
          let s10 = "xAxis" === i10, o10 = this.isZAxis || (t10.inverted ? !s10 : s10);
          this.chart = t10, this.horiz = o10, this.isXAxis = s10, this.coll = i10, sE(this, "init", {
            userOptions: e10
          }), this.opposite = sG(e10.opposite, this.opposite), this.side = sG(e10.side, this.side, o10 ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e10);
          let r10 = this.options, n10 = r10.labels;
          this.type ?? (this.type = r10.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r10.uniqueNames ?? true), sE(this, "afterSetType"), this.userOptions = e10, this.minPixelPadding = 0, this.reversed = sG(r10.reversed, this.reversed), this.visible = r10.visible, this.zoomEnabled = r10.zoomEnabled, this.hasNames = "category" === this.type || true === r10.categories, this.categories = sI(r10.categories) && r10.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = sA(r10.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r10.minRange || r10.maxZoom, this.range = r10.range, this.offset = r10.offset || 0, this.max = void 0, this.min = void 0;
          let a10 = sG(r10.crosshair, sX(t10.options.tooltip.crosshairs)[s10 ? 0 : 1]);
          this.crosshair = true === a10 ? {} : a10, -1 === t10.axes.indexOf(this) && (s10 ? t10.axes.splice(t10.xAxis.length, 0, this) : t10.axes.push(this), sB(this, t10[this.coll])), t10.orderItems(this.coll), this.series = this.series || [], t10.inverted && !this.isZAxis && s10 && !sA(this.reversed) && (this.reversed = true), this.labelRotation = sD(n10.rotation) ? n10.rotation : void 0, sb(this, r10), sE(this, "afterInit");
        }
        setOptions(t10) {
          let e10 = this.horiz ? {
            labels: {
              autoRotation: [-45],
              padding: 3
            },
            margin: 15
          } : {
            labels: {
              padding: 1
            },
            title: {
              rotation: 90 * this.side
            }
          };
          this.options = sN(e10, sy[this.coll], t10), sE(this, "afterSetOptions", {
            userOptions: t10
          });
        }
        defaultLabelFormatter() {
          let t10 = this.axis, {
            numberFormatter: e10
          } = this.chart, i10 = sD(this.value) ? this.value : NaN, s10 = t10.chart.time, o10 = t10.categories, r10 = this.dateTimeLabelFormat, n10 = sy.lang, a10 = n10.numericSymbols, h10 = n10.numericSymbolMagnitude || 1e3, l10 = t10.logarithmic ? Math.abs(i10) : t10.tickInterval, d10 = a10 && a10.length, c10, p10;
          if (o10) p10 = `${this.value}`;
          else if (r10) p10 = s10.dateFormat(r10, i10, true);
          else if (d10 && a10 && l10 >= 1e3) for (; d10-- && void 0 === p10; ) l10 >= (c10 = Math.pow(h10, d10 + 1)) && 10 * i10 % c10 == 0 && null !== a10[d10] && 0 !== i10 && (p10 = e10(i10 / c10, -1) + a10[d10]);
          return void 0 === p10 && (p10 = Math.abs(i10) >= 1e4 ? e10(i10, -1) : e10(i10, -1, void 0, "")), p10;
        }
        getSeriesExtremes() {
          let t10;
          let e10 = this;
          sE(this, "getSeriesExtremes", null, function() {
            e10.hasVisibleSeries = false, e10.dataMin = e10.dataMax = e10.threshold = void 0, e10.softThreshold = !e10.isXAxis, e10.series.forEach((i10) => {
              if (i10.reserveSpace()) {
                let s10 = i10.options, o10, r10 = s10.threshold, n10, a10;
                if (e10.hasVisibleSeries = true, e10.positiveValuesOnly && 0 >= (r10 || 0) && (r10 = void 0), e10.isXAxis) (o10 = i10.getColumn("x")).length && (o10 = e10.logarithmic ? o10.filter((t11) => t11 > 0) : o10, n10 = (t10 = i10.getXExtremes(o10)).min, a10 = t10.max, sD(n10) || n10 instanceof Date || (o10 = o10.filter(sD), n10 = (t10 = i10.getXExtremes(o10)).min, a10 = t10.max), o10.length && (e10.dataMin = Math.min(sG(e10.dataMin, n10), n10), e10.dataMax = Math.max(sG(e10.dataMax, a10), a10)));
                else {
                  let t11 = i10.applyExtremes();
                  sD(t11.dataMin) && (n10 = t11.dataMin, e10.dataMin = Math.min(sG(e10.dataMin, n10), n10)), sD(t11.dataMax) && (a10 = t11.dataMax, e10.dataMax = Math.max(sG(e10.dataMax, a10), a10)), sA(r10) && (e10.threshold = r10), (!s10.softThreshold || e10.positiveValuesOnly) && (e10.softThreshold = false);
                }
              }
            });
          }), sE(this, "afterGetSeriesExtremes");
        }
        translate(t10, e10, i10, s10, o10, r10) {
          let n10 = this.linkedParent || this, a10 = s10 && n10.old ? n10.old.min : n10.min;
          if (!sD(a10)) return NaN;
          let h10 = n10.minPixelPadding, l10 = (n10.isOrdinal || n10.brokenAxis?.hasBreaks || n10.logarithmic && o10) && n10.lin2val, d10 = 1, c10 = 0, p10 = s10 && n10.old ? n10.old.transA : n10.transA, u10 = 0;
          return p10 || (p10 = n10.transA), i10 && (d10 *= -1, c10 = n10.len), n10.reversed && (d10 *= -1, c10 -= d10 * (n10.sector || n10.len)), e10 ? (u10 = (t10 = t10 * d10 + c10 - h10) / p10 + a10, l10 && (u10 = n10.lin2val(u10))) : (l10 && (t10 = n10.val2lin(t10)), u10 = d10 * (t10 - a10) * p10 + c10 + d10 * h10 + (sD(r10) ? p10 * r10 : 0), n10.isRadial || (u10 = sS(u10))), u10;
        }
        toPixels(t10, e10) {
          return this.translate(this.chart?.time.parse(t10) ?? NaN, false, !this.horiz, void 0, true) + (e10 ? 0 : this.pos);
        }
        toValue(t10, e10) {
          return this.translate(t10 - (e10 ? 0 : this.pos), true, !this.horiz, void 0, true);
        }
        getPlotLinePath(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.left, o10 = e10.top, r10 = t10.old, n10 = t10.value, a10 = t10.lineWidth, h10 = r10 && i10.oldChartHeight || i10.chartHeight, l10 = r10 && i10.oldChartWidth || i10.chartWidth, d10 = e10.transB, c10 = t10.translatedValue, p10 = t10.force, u10, g2, f2, m2, x2;
          function y2(t11, e11, i11) {
            return "pass" !== p10 && (t11 < e11 || t11 > i11) && (p10 ? t11 = sw(t11, e11, i11) : x2 = true), t11;
          }
          let b2 = {
            value: n10,
            lineWidth: a10,
            old: r10,
            force: p10,
            acrossPanes: t10.acrossPanes,
            translatedValue: c10
          };
          return sE(this, "getPlotLinePath", b2, function(t11) {
            u10 = f2 = (c10 = sw(c10 = sG(c10, e10.translate(n10, void 0, void 0, r10)), -1e9, 1e9)) + d10, g2 = m2 = h10 - c10 - d10, sD(c10) ? e10.horiz ? (g2 = o10, m2 = h10 - e10.bottom + (e10.options.isInternal ? 0 : i10.scrollablePixelsY || 0), u10 = f2 = y2(u10, s10, s10 + e10.width)) : (u10 = s10, f2 = l10 - e10.right + (i10.scrollablePixelsX || 0), g2 = m2 = y2(g2, o10, o10 + e10.height)) : (x2 = true, p10 = false), t11.path = x2 && !p10 ? void 0 : i10.renderer.crispLine([["M", u10, g2], ["L", f2, m2]], a10 || 1);
          }), b2.path;
        }
        getLinearTickPositions(t10, e10, i10) {
          let s10, o10, r10;
          let n10 = sS(Math.floor(e10 / t10) * t10), a10 = sS(Math.ceil(i10 / t10) * t10), h10 = [];
          if (sS(n10 + t10) === n10 && (r10 = 20), this.single) return [e10];
          for (s10 = n10; s10 <= a10 && (h10.push(s10), (s10 = sS(s10 + t10, r10)) !== o10); ) o10 = s10;
          return h10;
        }
        getMinorTickInterval() {
          let {
            minorTicks: t10,
            minorTickInterval: e10
          } = this.options;
          return true === t10 ? sG(e10, "auto") : false !== t10 ? e10 : void 0;
        }
        getMinorTickPositions() {
          let t10 = this.options, e10 = this.tickPositions, i10 = this.minorTickInterval, s10 = this.pointRangePadding || 0, o10 = (this.min || 0) - s10, r10 = (this.max || 0) + s10, n10 = this.brokenAxis?.hasBreaks ? this.brokenAxis.unitLength : r10 - o10, a10 = [], h10;
          if (n10 && n10 / i10 < this.len / 3) {
            let s11 = this.logarithmic;
            if (s11) this.paddedTicks.forEach(function(t11, e11, o11) {
              e11 && a10.push.apply(a10, s11.getLogTickPositions(i10, o11[e11 - 1], o11[e11], true));
            });
            else if (this.dateTime && "auto" === this.getMinorTickInterval()) a10 = a10.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i10), o10, r10, t10.startOfWeek));
            else for (h10 = o10 + (e10[0] - o10) % i10; h10 <= r10 && h10 !== a10[0]; h10 += i10) a10.push(h10);
          }
          return 0 !== a10.length && this.trimTicks(a10), a10;
        }
        adjustForMinRange() {
          let t10 = this.options, e10 = this.logarithmic, i10 = this.chart.time, {
            max: s10,
            min: o10,
            minRange: r10
          } = this, n10, a10, h10, l10;
          this.isXAxis && void 0 === r10 && !e10 && (r10 = sA(t10.min) || sA(t10.max) || sA(t10.floor) || sA(t10.ceiling) ? null : Math.min(5 * (sL(this.series.map((t11) => {
            let e11 = t11.getColumn("x");
            return t11.xIncrement ? e11.slice(0, 2) : e11;
          })) || 0), this.dataMax - this.dataMin)), sD(s10) && sD(o10) && sD(r10) && s10 - o10 < r10 && (a10 = this.dataMax - this.dataMin >= r10, n10 = (r10 - s10 + o10) / 2, h10 = [o10 - n10, i10.parse(t10.min) ?? o10 - n10], a10 && (h10[2] = e10 ? e10.log2lin(this.dataMin) : this.dataMin), l10 = [(o10 = sM(h10)) + r10, i10.parse(t10.max) ?? o10 + r10], a10 && (l10[2] = e10 ? e10.log2lin(this.dataMax) : this.dataMax), (s10 = sk(l10)) - o10 < r10 && (h10[0] = s10 - r10, h10[1] = i10.parse(t10.min) ?? s10 - r10, o10 = sM(h10))), this.minRange = r10, this.min = o10, this.max = s10;
        }
        getClosest() {
          let t10, e10;
          if (this.categories) e10 = 1;
          else {
            let i10 = [];
            this.series.forEach(function(t11) {
              let s10 = t11.closestPointRange, o10 = t11.getColumn("x");
              1 === o10.length ? i10.push(o10[0]) : t11.sorted && sA(s10) && t11.reserveSpace() && (e10 = sA(e10) ? Math.min(e10, s10) : s10);
            }), i10.length && (i10.sort((t11, e11) => t11 - e11), t10 = sL([i10]));
          }
          return t10 && e10 ? Math.min(t10, e10) : t10 || e10;
        }
        nameToX(t10) {
          let e10 = sI(this.options.categories), i10 = e10 ? this.categories : this.names, s10 = t10.options.x, o10;
          return t10.series.requireSorting = false, sA(s10) || (s10 = this.uniqueNames && i10 ? e10 ? i10.indexOf(t10.name) : sG(i10.keys[t10.name], -1) : t10.series.autoIncrement()), -1 === s10 ? !e10 && i10 && (o10 = i10.length) : sD(s10) && (o10 = s10), void 0 !== o10 ? (this.names[o10] = t10.name, this.names.keys[t10.name] = o10) : t10.x && (o10 = t10.x), o10;
        }
        updateNames() {
          let t10 = this, e10 = this.names;
          e10.length > 0 && (Object.keys(e10.keys).forEach(function(t11) {
            delete e10.keys[t11];
          }), e10.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e11) => {
            e11.xIncrement = null, (!e11.points || e11.isDirtyData) && (t10.max = Math.max(t10.max || 0, e11.dataTable.rowCount - 1), e11.processData(), e11.generatePoints());
            let i10 = e11.getColumn("x").slice();
            e11.data.forEach((e12, s10) => {
              let o10 = i10[s10];
              e12?.options && void 0 !== e12.name && void 0 !== (o10 = t10.nameToX(e12)) && o10 !== e12.x && (i10[s10] = e12.x = o10);
            }), e11.dataTable.setColumn("x", i10);
          }));
        }
        setAxisTranslation() {
          let t10 = this, e10 = t10.max - t10.min, i10 = t10.linkedParent, s10 = !!t10.categories, o10 = t10.isXAxis, r10 = t10.axisPointRange || 0, n10, a10 = 0, h10 = 0, l10, d10 = t10.transA;
          (o10 || s10 || r10) && (n10 = t10.getClosest(), i10 ? (a10 = i10.minPointOffset, h10 = i10.pointRangePadding) : t10.series.forEach(function(e11) {
            let i11 = s10 ? 1 : o10 ? sG(e11.options.pointRange, n10, 0) : t10.axisPointRange || 0, l11 = e11.options.pointPlacement;
            if (r10 = Math.max(r10, i11), !t10.single || s10) {
              let t11 = e11.is("xrange") ? !o10 : o10;
              a10 = Math.max(a10, t11 && sR(l11) ? 0 : i11 / 2), h10 = Math.max(h10, t11 && "on" === l11 ? 0 : i11);
            }
          }), l10 = t10.ordinal && t10.ordinal.slope && n10 ? t10.ordinal.slope / n10 : 1, t10.minPointOffset = a10 *= l10, t10.pointRangePadding = h10 *= l10, t10.pointRange = Math.min(r10, t10.single && s10 ? 1 : e10), o10 && n10 && (t10.closestPointRange = n10)), t10.translationSlope = t10.transA = d10 = t10.staticScale || t10.len / (e10 + h10 || 1), t10.transB = t10.horiz ? t10.left : t10.bottom, t10.minPixelPadding = d10 * a10, sE(this, "afterSetAxisTranslation");
        }
        minFromRange() {
          let {
            max: t10,
            min: e10
          } = this;
          return sD(t10) && sD(e10) && t10 - e10 || void 0;
        }
        setTickInterval(t10) {
          let {
            categories: e10,
            chart: i10,
            dataMax: s10,
            dataMin: o10,
            dateTime: r10,
            isXAxis: n10,
            logarithmic: a10,
            options: h10,
            softThreshold: l10
          } = this, d10 = i10.time, c10 = sD(this.threshold) ? this.threshold : void 0, p10 = this.minRange || 0, {
            ceiling: u10,
            floor: g2,
            linkedTo: f2,
            softMax: m2,
            softMin: x2
          } = h10, y2 = sD(f2) && i10[this.coll]?.[f2], b2 = h10.tickPixelInterval, v2 = h10.maxPadding, M2 = h10.minPadding, k2 = 0, w2, S2 = sD(h10.tickInterval) && h10.tickInterval >= 0 ? h10.tickInterval : void 0, A2, T2, P2, C2;
          if (r10 || e10 || y2 || this.getTickAmount(), P2 = sG(this.userMin, d10.parse(h10.min)), C2 = sG(this.userMax, d10.parse(h10.max)), y2 ? (this.linkedParent = y2, w2 = y2.getExtremes(), this.min = sG(w2.min, w2.dataMin), this.max = sG(w2.max, w2.dataMax), this.type !== y2.type && sC(11, true, i10)) : (l10 && sA(c10) && sD(s10) && sD(o10) && (o10 >= c10 ? (A2 = c10, M2 = 0) : s10 <= c10 && (T2 = c10, v2 = 0)), this.min = sG(P2, A2, o10), this.max = sG(C2, T2, s10)), sD(this.max) && sD(this.min) && (a10 && (this.positiveValuesOnly && !t10 && 0 >= Math.min(this.min, sG(o10, this.min)) && sC(10, true, i10), this.min = sS(a10.log2lin(this.min), 16), this.max = sS(a10.log2lin(this.max), 16)), this.range && sD(o10) && (this.userMin = this.min = P2 = Math.max(o10, this.minFromRange() || 0), this.userMax = C2 = this.max, this.range = void 0)), sE(this, "foundExtremes"), this.adjustForMinRange(), sD(this.min) && sD(this.max)) {
            if (!sD(this.userMin) && sD(x2) && x2 < this.min && (this.min = P2 = x2), !sD(this.userMax) && sD(m2) && m2 > this.max && (this.max = C2 = m2), e10 || this.axisPointRange || this.stacking?.usePercentage || y2 || !(k2 = this.max - this.min) || (!sA(P2) && M2 && (this.min -= k2 * M2), sA(C2) || !v2 || (this.max += k2 * v2)), !sD(this.userMin) && sD(g2) && (this.min = Math.max(this.min, g2)), !sD(this.userMax) && sD(u10) && (this.max = Math.min(this.max, u10)), l10 && sD(o10) && sD(s10)) {
              let t11 = c10 || 0;
              !sA(P2) && this.min < t11 && o10 >= t11 ? this.min = h10.minRange ? Math.min(t11, this.max - p10) : t11 : !sA(C2) && this.max > t11 && s10 <= t11 && (this.max = h10.minRange ? Math.max(t11, this.min + p10) : t11);
            }
            !i10.polar && this.min > this.max && (sA(h10.min) ? this.max = this.min : sA(h10.max) && (this.min = this.max)), k2 = this.max - this.min;
          }
          if (this.min !== this.max && sD(this.min) && sD(this.max) ? y2 && !S2 && b2 === y2.options.tickPixelInterval ? this.tickInterval = S2 = y2.tickInterval : this.tickInterval = sG(S2, this.tickAmount ? k2 / Math.max(this.tickAmount - 1, 1) : void 0, e10 ? 1 : k2 * b2 / Math.max(this.len, b2)) : this.tickInterval = 1, n10 && !t10) {
            let t11 = this.min !== this.old?.min || this.max !== this.old?.max;
            this.series.forEach(function(e11) {
              e11.forceCrop = e11.forceCropping?.(), e11.processData(t11);
            }), sE(this, "postProcessData", {
              hasExtremesChanged: t11
            });
          }
          this.setAxisTranslation(), sE(this, "initialAxisTranslation"), this.pointRange && !S2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
          let O2 = sG(h10.minTickInterval, r10 && !this.series.some((t11) => !t11.sorted) ? this.closestPointRange : 0);
          !S2 && this.tickInterval < O2 && (this.tickInterval = O2), r10 || a10 || S2 || (this.tickInterval = sj(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
        }
        setTickPositions() {
          let t10 = this.options, e10 = t10.tickPositions, i10 = t10.tickPositioner, s10 = this.getMinorTickInterval(), o10 = !this.isPanning, r10 = o10 && t10.startOnTick, n10 = o10 && t10.endOnTick, a10 = [], h10;
          if (this.tickmarkOffset = this.categories && "between" === t10.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0, this.single = this.min === this.max && sA(this.min) && !this.tickAmount && (this.min % 1 == 0 || false !== t10.allowDecimals), e10) a10 = e10.slice();
          else if (sD(this.min) && sD(this.max)) {
            if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) a10 = [this.min, this.max], sC(19, false, this.chart);
            else if (this.dateTime) a10 = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t10.units), this.min, this.max, t10.startOfWeek, this.ordinal?.positions, this.closestPointRange, true);
            else if (this.logarithmic) a10 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
            else {
              let t11 = this.tickInterval, e11 = t11;
              for (; e11 <= 2 * t11; ) if (a10 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && a10.length > this.tickAmount) this.tickInterval = sj(this, e11 *= 1.1);
              else break;
            }
            a10.length > this.len && (a10 = [a10[0], a10[a10.length - 1]])[0] === a10[1] && (a10.length = 1), i10 && (this.tickPositions = a10, (h10 = i10.apply(this, [this.min, this.max])) && (a10 = h10));
          }
          this.tickPositions = a10, this.minorTickInterval = "auto" === s10 && this.tickInterval ? this.tickInterval / t10.minorTicksPerMajor : s10, this.paddedTicks = a10.slice(0), this.trimTicks(a10, r10, n10), !this.isLinked && sD(this.min) && sD(this.max) && (this.single && a10.length < 2 && !this.categories && !this.series.some((t11) => t11.is("heatmap") && "between" === t11.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), e10 || h10 || this.adjustTickAmount()), sE(this, "afterSetTickPositions");
        }
        trimTicks(t10, e10, i10) {
          let s10 = t10[0], o10 = t10[t10.length - 1], r10 = !this.isOrdinal && this.minPointOffset || 0;
          if (sE(this, "trimTicks"), !this.isLinked) {
            if (e10 && s10 !== -1 / 0) this.min = s10;
            else for (; this.min - r10 > t10[0]; ) t10.shift();
            if (i10) this.max = o10;
            else for (; this.max + r10 < t10[t10.length - 1]; ) t10.pop();
            0 === t10.length && sA(s10) && !this.options.tickPositions && t10.push((o10 + s10) / 2);
          }
        }
        alignToOthers() {
          let t10;
          let e10 = this, i10 = e10.chart, s10 = [this], o10 = e10.options, r10 = i10.options.chart, n10 = "yAxis" === this.coll && r10.alignThresholds, a10 = [];
          if (e10.thresholdAlignment = void 0, (false !== r10.alignTicks && o10.alignTicks || n10) && false !== o10.startOnTick && false !== o10.endOnTick && !e10.logarithmic) {
            let o11 = (t11) => {
              let {
                horiz: e11,
                options: i11
              } = t11;
              return [e11 ? i11.left : i11.top, i11.width, i11.height, i11.pane].join(",");
            }, r11 = o11(this);
            i10[this.coll].forEach(function(i11) {
              let {
                series: n11
              } = i11;
              n11.length && n11.some((t11) => t11.visible) && i11 !== e10 && o11(i11) === r11 && (t10 = true, s10.push(i11));
            });
          }
          if (t10 && n10) {
            s10.forEach((t12) => {
              let i11 = t12.getThresholdAlignment(e10);
              sD(i11) && a10.push(i11);
            });
            let t11 = a10.length > 1 ? a10.reduce((t12, e11) => t12 += e11, 0) / a10.length : void 0;
            s10.forEach((e11) => {
              e11.thresholdAlignment = t11;
            });
          }
          return t10;
        }
        getThresholdAlignment(t10) {
          if ((!sD(this.dataMin) || this !== t10 && this.series.some((t11) => t11.isDirty || t11.isDirtyData)) && this.getSeriesExtremes(), sD(this.threshold)) {
            let t11 = sw((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
            return this.options.reversed && (t11 = 1 - t11), t11;
          }
        }
        getTickAmount() {
          let t10 = this.options, e10 = t10.tickPixelInterval, i10 = t10.tickAmount;
          sA(t10.tickInterval) || i10 || !(this.len < e10) || this.isRadial || this.logarithmic || !t10.startOnTick || !t10.endOnTick || (i10 = 2), !i10 && this.alignToOthers() && (i10 = Math.ceil(this.len / e10) + 1), i10 < 4 && (this.finalTickAmt = i10, i10 = 5), this.tickAmount = i10;
        }
        adjustTickAmount() {
          let t10 = this, {
            finalTickAmt: e10,
            max: i10,
            min: s10,
            options: o10,
            tickPositions: r10,
            tickAmount: n10,
            thresholdAlignment: a10
          } = t10, h10 = r10?.length, l10 = sG(t10.threshold, t10.softThreshold ? 0 : null), d10, c10, p10 = t10.tickInterval, u10, g2 = () => r10.push(sS(r10[r10.length - 1] + p10)), f2 = () => r10.unshift(sS(r10[0] - p10));
          if (sD(a10) && (u10 = a10 < 0.5 ? Math.ceil(a10 * (n10 - 1)) : Math.floor(a10 * (n10 - 1)), o10.reversed && (u10 = n10 - 1 - u10)), t10.hasData() && sD(s10) && sD(i10)) {
            let a11 = () => {
              t10.transA *= (h10 - 1) / (n10 - 1), t10.min = o10.startOnTick ? r10[0] : Math.min(s10, r10[0]), t10.max = o10.endOnTick ? r10[r10.length - 1] : Math.max(i10, r10[r10.length - 1]);
            };
            if (sD(u10) && sD(t10.threshold)) {
              for (; r10[u10] !== l10 || r10.length !== n10 || r10[0] > s10 || r10[r10.length - 1] < i10; ) {
                for (r10.length = 0, r10.push(t10.threshold); r10.length < n10; ) void 0 === r10[u10] || r10[u10] > t10.threshold ? f2() : g2();
                if (p10 > 8 * t10.tickInterval) break;
                p10 *= 2;
              }
              a11();
            } else if (h10 < n10) {
              for (; r10.length < n10; ) r10.length % 2 || s10 === l10 ? g2() : f2();
              a11();
            }
            if (sA(e10)) {
              for (c10 = d10 = r10.length; c10--; ) (3 === e10 && c10 % 2 == 1 || e10 <= 2 && c10 > 0 && c10 < d10 - 1) && r10.splice(c10, 1);
              t10.finalTickAmt = void 0;
            }
          }
        }
        setScale() {
          let {
            coll: t10,
            stacking: e10
          } = this, i10 = false, s10 = false;
          this.series.forEach((t11) => {
            i10 = i10 || t11.isDirtyData || t11.isDirty, s10 = s10 || t11.xAxis && t11.xAxis.isDirty || false;
          }), this.setAxisSize();
          let o10 = this.len !== (this.old && this.old.len);
          o10 || i10 || s10 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e10 && "yAxis" === t10 && e10.buildStacks(), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e10 && "xAxis" === t10 && e10.buildStacks(), this.isDirty || (this.isDirty = o10 || this.min !== this.old?.min || this.max !== this.old?.max)) : e10 && e10.cleanStacks(), i10 && delete this.allExtremes, sE(this, "afterSetScale");
        }
        setExtremes(t10, e10, i10 = true, s10, o10) {
          let r10 = this.chart;
          this.series.forEach((t11) => {
            delete t11.kdTree;
          }), t10 = r10.time.parse(t10), e10 = r10.time.parse(e10), sE(this, "setExtremes", o10 = sO(o10, {
            min: t10,
            max: e10
          }), (t11) => {
            this.userMin = t11.min, this.userMax = t11.max, this.eventArgs = t11, i10 && r10.redraw(s10);
          });
        }
        setAxisSize() {
          let t10 = this.chart, e10 = this.options, i10 = e10.offsets || [0, 0, 0, 0], s10 = this.horiz, o10 = this.width = Math.round(sH(sG(e10.width, t10.plotWidth - i10[3] + i10[1]), t10.plotWidth)), r10 = this.height = Math.round(sH(sG(e10.height, t10.plotHeight - i10[0] + i10[2]), t10.plotHeight)), n10 = this.top = Math.round(sH(sG(e10.top, t10.plotTop + i10[0]), t10.plotHeight, t10.plotTop)), a10 = this.left = Math.round(sH(sG(e10.left, t10.plotLeft + i10[3]), t10.plotWidth, t10.plotLeft));
          this.bottom = t10.chartHeight - r10 - n10, this.right = t10.chartWidth - o10 - a10, this.len = Math.max(s10 ? o10 : r10, 0), this.pos = s10 ? a10 : n10;
        }
        getExtremes() {
          let t10 = this.logarithmic;
          return {
            min: t10 ? sS(t10.lin2log(this.min)) : this.min,
            max: t10 ? sS(t10.lin2log(this.max)) : this.max,
            dataMin: this.dataMin,
            dataMax: this.dataMax,
            userMin: this.userMin,
            userMax: this.userMax
          };
        }
        getThreshold(t10) {
          let e10 = this.logarithmic, i10 = e10 ? e10.lin2log(this.min) : this.min, s10 = e10 ? e10.lin2log(this.max) : this.max;
          return null === t10 || t10 === -1 / 0 ? t10 = i10 : t10 === 1 / 0 ? t10 = s10 : i10 > t10 ? t10 = i10 : s10 < t10 && (t10 = s10), this.translate(t10, 0, 1, 0, 1);
        }
        autoLabelAlign(t10) {
          let e10 = (sG(t10, 0) - 90 * this.side + 720) % 360, i10 = {
            align: "center"
          };
          return sE(this, "autoLabelAlign", i10, function(t11) {
            e10 > 15 && e10 < 165 ? t11.align = "right" : e10 > 195 && e10 < 345 && (t11.align = "left");
          }), i10.align;
        }
        tickSize(t10) {
          let e10 = this.options, i10 = sG(e10["tick" === t10 ? "tickWidth" : "minorTickWidth"], "tick" === t10 && this.isXAxis && !this.categories ? 1 : 0), s10 = e10["tick" === t10 ? "tickLength" : "minorTickLength"], o10;
          i10 && s10 && ("inside" === e10[t10 + "Position"] && (s10 = -s10), o10 = [s10, i10]);
          let r10 = {
            tickSize: o10
          };
          return sE(this, "afterTickSize", r10), r10.tickSize;
        }
        labelMetrics() {
          let t10 = this.chart.renderer, e10 = this.ticks, i10 = e10[Object.keys(e10)[0]] || {};
          return this.chart.renderer.fontMetrics(i10.label || i10.movedLabel || t10.box);
        }
        unsquish() {
          let t10 = this.options.labels, e10 = t10.padding || 0, i10 = this.horiz, s10 = this.tickInterval, o10 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s10), r10 = t10.rotation, n10 = sS(0.8 * this.labelMetrics().h), a10 = Math.max(this.max - this.min, 0), h10 = function(t11) {
            let i11 = (t11 + 2 * e10) / (o10 || 1);
            return (i11 = i11 > 1 ? Math.ceil(i11) : 1) * s10 > a10 && t11 !== 1 / 0 && o10 !== 1 / 0 && a10 && (i11 = Math.ceil(a10 / s10)), sS(i11 * s10);
          }, l10 = s10, d10, c10 = Number.MAX_VALUE, p10;
          if (i10) {
            if (!t10.staggerLines && (sD(r10) ? p10 = [r10] : o10 < t10.autoRotationLimit && (p10 = t10.autoRotation)), p10) {
              let t11, e11;
              for (let i11 of p10) (i11 === r10 || i11 && i11 >= -90 && i11 <= 90) && (e11 = (t11 = h10(Math.abs(n10 / Math.sin(sv * i11)))) + Math.abs(i11 / 360)) < c10 && (c10 = e11, d10 = i11, l10 = t11);
            }
          } else l10 = h10(0.75 * n10);
          return this.autoRotation = p10, this.labelRotation = sG(d10, sD(r10) ? r10 : 0), t10.step ? s10 : l10;
        }
        getSlotWidth(t10) {
          let e10 = this.chart, i10 = this.horiz, s10 = this.options.labels, o10 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), r10 = e10.margin[3];
          if (t10 && sD(t10.slotWidth)) return t10.slotWidth;
          if (i10 && s10.step < 2 && !this.isRadial) return s10.rotation ? 0 : (this.staggerLines || 1) * this.len / o10;
          if (!i10) {
            let t11 = s10.style.width;
            if (void 0 !== t11) return parseInt(String(t11), 10);
            if (r10) return r10 - e10.spacing[3];
          }
          return 0.33 * e10.chartWidth;
        }
        renderUnsquish() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.tickPositions, s10 = this.ticks, o10 = this.options.labels, r10 = o10.style, n10 = this.horiz, a10 = this.getSlotWidth(), h10 = Math.max(1, Math.round(a10 - (n10 ? 2 * (o10.padding || 0) : o10.distance || 0))), l10 = {}, d10 = this.labelMetrics(), c10 = r10.lineClamp, p10, u10 = c10 ?? (Math.floor(this.len / (i10.length * d10.h)) || 1), g2 = 0;
          sR(o10.rotation) || (l10.rotation = o10.rotation || 0), i10.forEach(function(t11) {
            let e11 = s10[t11];
            e11.movedLabel && e11.replaceMovedLabel();
            let i11 = e11.label?.textPxLength || 0;
            i11 > g2 && (g2 = i11);
          }), this.maxLabelLength = g2, this.autoRotation ? g2 > h10 && g2 > d10.h ? l10.rotation = this.labelRotation : this.labelRotation = 0 : a10 && (p10 = h10), l10.rotation && (p10 = g2 > 0.5 * t10.chartHeight ? 0.33 * t10.chartHeight : g2, c10 || (u10 = 1)), this.labelAlign = o10.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l10.align = this.labelAlign), i10.forEach(function(t11) {
            let e11 = s10[t11], i11 = e11 && e11.label, o11 = r10.width, n11 = {};
            i11 && (i11.attr(l10), e11.shortenLabel ? e11.shortenLabel() : p10 && !o11 && "nowrap" !== r10.whiteSpace && (p10 < (i11.textPxLength || 0) || "SPAN" === i11.element.tagName) ? i11.css(sO(n11, {
              width: `${p10}px`,
              lineClamp: u10
            })) : !i11.styles.width || n11.width || o11 || i11.css({
              width: "auto"
            }), e11.rotation = l10.rotation);
          }, this), this.tickRotCorr = e10.rotCorr(d10.b, this.labelRotation || 0, 0 !== this.side);
        }
        hasData() {
          return this.series.some(function(t10) {
            return t10.hasData();
          }) || this.options.showEmpty && sA(this.min) && sA(this.max);
        }
        addTitle(t10) {
          let e10;
          let i10 = this.chart.renderer, s10 = this.horiz, o10 = this.opposite, r10 = this.options.title, n10 = this.chart.styledMode;
          this.axisTitle || ((e10 = r10.textAlign) || (e10 = (s10 ? {
            low: "left",
            middle: "center",
            high: "right"
          } : {
            low: o10 ? "right" : "left",
            middle: "center",
            high: o10 ? "left" : "right"
          })[r10.align]), this.axisTitle = i10.text(r10.text || "", 0, 0, r10.useHTML).attr({
            zIndex: 7,
            rotation: r10.rotation || 0,
            align: e10
          }).addClass("highcharts-axis-title"), n10 || this.axisTitle.css(sN(r10.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true), n10 || r10.style.width || this.isRadial || this.axisTitle.css({
            width: this.len + "px"
          }), this.axisTitle[t10 ? "show" : "hide"](t10);
        }
        generateTick(t10) {
          let e10 = this.ticks;
          e10[t10] ? e10[t10].addLabel() : e10[t10] = new sg(this, t10);
        }
        createGroups() {
          let {
            axisParent: t10,
            chart: e10,
            coll: i10,
            options: s10
          } = this, o10 = e10.renderer, r10 = (e11, r11, n10) => o10.g(e11).attr({
            zIndex: n10
          }).addClass(`highcharts-${i10.toLowerCase()}${r11} ` + (this.isRadial ? `highcharts-radial-axis${r11} ` : "") + (s10.className || "")).add(t10);
          this.axisGroup || (this.gridGroup = r10("grid", "-grid", s10.gridZIndex), this.axisGroup = r10("axis", "", s10.zIndex), this.labelGroup = r10("axis-labels", "-labels", s10.labels.zIndex));
        }
        getOffset() {
          let t10 = this, {
            chart: e10,
            horiz: i10,
            options: s10,
            side: o10,
            ticks: r10,
            tickPositions: n10,
            coll: a10
          } = t10, h10 = e10.inverted && !t10.isZAxis ? [1, 0, 3, 2][o10] : o10, l10 = t10.hasData(), d10 = s10.title, c10 = s10.labels, p10 = sD(s10.crossing), u10 = e10.axisOffset, g2 = e10.clipOffset, f2 = [-1, 1, 1, -1][o10], m2, x2 = 0, y2, b2 = 0, v2 = 0, M2, k2;
          if (t10.showAxis = m2 = l10 || s10.showEmpty, t10.staggerLines = t10.horiz && c10.staggerLines || void 0, t10.createGroups(), l10 || t10.isLinked ? (n10.forEach(function(e11) {
            t10.generateTick(e11);
          }), t10.renderUnsquish(), t10.reserveSpaceDefault = 0 === o10 || 2 === o10 || {
            1: "left",
            3: "right"
          }[o10] === t10.labelAlign, sG(c10.reserveSpace, !p10 && null, "center" === t10.labelAlign || null, t10.reserveSpaceDefault) && n10.forEach(function(t11) {
            v2 = Math.max(r10[t11].getLabelSize(), v2);
          }), t10.staggerLines && (v2 *= t10.staggerLines), t10.labelOffset = v2 * (t10.opposite ? -1 : 1)) : sW(r10, function(t11, e11) {
            t11.destroy(), delete r10[e11];
          }), d10?.text && false !== d10.enabled && (t10.addTitle(m2), m2 && !p10 && false !== d10.reserveSpace && (t10.titleOffset = x2 = t10.axisTitle.getBBox()[i10 ? "height" : "width"], b2 = sA(y2 = d10.offset) ? 0 : sG(d10.margin, i10 ? 5 : 10))), t10.renderLine(), t10.offset = f2 * sG(s10.offset, u10[o10] ? u10[o10] + (s10.margin || 0) : 0), t10.tickRotCorr = t10.tickRotCorr || {
            x: 0,
            y: 0
          }, k2 = 0 === o10 ? -t10.labelMetrics().h : 2 === o10 ? t10.tickRotCorr.y : 0, M2 = Math.abs(v2) + b2, v2 && (M2 -= k2, M2 += f2 * (i10 ? sG(c10.y, t10.tickRotCorr.y + f2 * c10.distance) : sG(c10.x, f2 * c10.distance))), t10.axisTitleMargin = sG(y2, M2), t10.getMaxLabelDimensions && (t10.maxLabelDimensions = t10.getMaxLabelDimensions(r10, n10)), "colorAxis" !== a10 && g2) {
            let e11 = this.tickSize("tick");
            u10[o10] = Math.max(u10[o10], (t10.axisTitleMargin || 0) + x2 + f2 * t10.offset, M2, n10 && n10.length && e11 ? e11[0] + f2 * t10.offset : 0);
            let i11 = !t10.axisLine || s10.offset ? 0 : t10.axisLine.strokeWidth() / 2;
            g2[h10] = Math.max(g2[h10], i11);
          }
          sE(this, "afterGetOffset");
        }
        getLinePath(t10) {
          let e10 = this.chart, i10 = this.opposite, s10 = this.offset, o10 = this.horiz, r10 = this.left + (i10 ? this.width : 0) + s10, n10 = e10.chartHeight - this.bottom - (i10 ? this.height : 0) + s10;
          return i10 && (t10 *= -1), e10.renderer.crispLine([["M", o10 ? this.left : r10, o10 ? n10 : this.top], ["L", o10 ? e10.chartWidth - this.right : r10, o10 ? n10 : e10.chartHeight - this.bottom]], t10);
        }
        renderLine() {
          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
            stroke: this.options.lineColor,
            "stroke-width": this.options.lineWidth,
            zIndex: 7
          }));
        }
        getTitlePosition(t10) {
          let e10 = this.horiz, i10 = this.left, s10 = this.top, o10 = this.len, r10 = this.options.title, n10 = e10 ? i10 : s10, a10 = this.opposite, h10 = this.offset, l10 = r10.x, d10 = r10.y, c10 = this.chart.renderer.fontMetrics(t10), p10 = t10 ? Math.max(t10.getBBox(false, 0).height - c10.h - 1, 0) : 0, u10 = {
            low: n10 + (e10 ? 0 : o10),
            middle: n10 + o10 / 2,
            high: n10 + (e10 ? o10 : 0)
          }[r10.align], g2 = (e10 ? s10 + this.height : i10) + (e10 ? 1 : -1) * (a10 ? -1 : 1) * (this.axisTitleMargin || 0) + [-p10, p10, c10.f, -p10][this.side], f2 = {
            x: e10 ? u10 + l10 : g2 + (a10 ? this.width : 0) + h10 + l10,
            y: e10 ? g2 + d10 - (a10 ? this.height : 0) + h10 : u10 + d10
          };
          return sE(this, "afterGetTitlePosition", {
            titlePosition: f2
          }), f2;
        }
        renderMinorTick(t10, e10) {
          let i10 = this.minorTicks;
          i10[t10] || (i10[t10] = new sg(this, t10, "minor")), e10 && i10[t10].isNew && i10[t10].render(null, true), i10[t10].render(null, false, 1);
        }
        renderTick(t10, e10, i10) {
          let s10 = this.isLinked, o10 = this.ticks;
          (!s10 || t10 >= this.min && t10 <= this.max || this.grid && this.grid.isColumn) && (o10[t10] || (o10[t10] = new sg(this, t10)), i10 && o10[t10].isNew && o10[t10].render(e10, true, -1), o10[t10].render(e10));
        }
        render() {
          let t10, e10;
          let i10 = this, s10 = i10.chart, o10 = i10.logarithmic, r10 = s10.renderer, n10 = i10.options, a10 = i10.isLinked, h10 = i10.tickPositions, l10 = i10.axisTitle, d10 = i10.ticks, c10 = i10.minorTicks, p10 = i10.alternateBands, u10 = n10.stackLabels, g2 = n10.alternateGridColor, f2 = n10.crossing, m2 = i10.tickmarkOffset, x2 = i10.axisLine, y2 = i10.showAxis, b2 = sf(r10.globalAnimation);
          if (i10.labelEdge.length = 0, i10.overlap = false, [d10, c10, p10].forEach(function(t11) {
            sW(t11, function(t12) {
              t12.isActive = false;
            });
          }), sD(f2)) {
            let t11 = this.isXAxis ? s10.yAxis[0] : s10.xAxis[0], e11 = [1, -1, -1, 1][this.side];
            if (t11) {
              let s11 = t11.toPixels(f2, true);
              i10.horiz && (s11 = t11.len - s11), i10.offset = e11 * s11;
            }
          }
          if (i10.hasData() || a10) {
            let r11 = i10.chart.hasRendered && i10.old && sD(i10.old.min);
            i10.minorTickInterval && !i10.categories && i10.getMinorTickPositions().forEach(function(t11) {
              i10.renderMinorTick(t11, r11);
            }), h10.length && (h10.forEach(function(t11, e11) {
              i10.renderTick(t11, e11, r11);
            }), m2 && (0 === i10.min || i10.single) && (d10[-1] || (d10[-1] = new sg(i10, -1, null, true)), d10[-1].render(-1))), g2 && h10.forEach(function(r12, n11) {
              e10 = void 0 !== h10[n11 + 1] ? h10[n11 + 1] + m2 : i10.max - m2, n11 % 2 == 0 && r12 < i10.max && e10 <= i10.max + (s10.polar ? -m2 : m2) && (p10[r12] || (p10[r12] = new O.PlotLineOrBand(i10, {})), t10 = r12 + m2, p10[r12].options = {
                from: o10 ? o10.lin2log(t10) : t10,
                to: o10 ? o10.lin2log(e10) : e10,
                color: g2,
                className: "highcharts-alternate-grid"
              }, p10[r12].render(), p10[r12].isActive = true);
            }), i10._addedPlotLB || (i10._addedPlotLB = true, (n10.plotLines || []).concat(n10.plotBands || []).forEach(function(t11) {
              i10.addPlotBandOrLine(t11);
            }));
          }
          [d10, c10, p10].forEach(function(t11) {
            let e11 = [], i11 = b2.duration;
            sW(t11, function(t12, i12) {
              t12.isActive || (t12.render(i12, false, 0), t12.isActive = false, e11.push(i12));
            }), sY(function() {
              let i12 = e11.length;
              for (; i12--; ) t11[e11[i12]] && !t11[e11[i12]].isActive && (t11[e11[i12]].destroy(), delete t11[e11[i12]]);
            }, t11 !== p10 && s10.hasRendered && i11 ? i11 : 0);
          }), x2 && (x2[x2.isPlaced ? "animate" : "attr"]({
            d: this.getLinePath(x2.strokeWidth())
          }), x2.isPlaced = true, x2[y2 ? "show" : "hide"](y2)), l10 && y2 && (l10[l10.isNew ? "attr" : "animate"](i10.getTitlePosition(l10)), l10.isNew = false), u10 && u10.enabled && i10.stacking && i10.stacking.renderStackTotals(), i10.old = {
            len: i10.len,
            max: i10.max,
            min: i10.min,
            transA: i10.transA,
            userMax: i10.userMax,
            userMin: i10.userMin
          }, i10.isDirty = false, sE(this, "afterRender");
        }
        redraw() {
          this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t10) {
            t10.render();
          })), this.series.forEach(function(t10) {
            t10.isDirty = true;
          });
        }
        getKeepProps() {
          return this.keepProps || sU.keepProps;
        }
        destroy(t10) {
          let e10 = this, i10 = e10.plotLinesAndBands, s10 = this.eventOptions;
          if (sE(this, "destroy", {
            keepEvents: t10
          }), t10 || sF(e10), [e10.ticks, e10.minorTicks, e10.alternateBands].forEach(function(t11) {
            sT(t11);
          }), i10) {
            let t11 = i10.length;
            for (; t11--; ) i10[t11].destroy();
          }
          for (let t11 in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(t12) {
            e10[t12] && (e10[t12] = e10[t12].destroy());
          }), e10.plotLinesAndBandsGroups) e10.plotLinesAndBandsGroups[t11] = e10.plotLinesAndBandsGroups[t11].destroy();
          sW(e10, function(t11, i11) {
            -1 === e10.getKeepProps().indexOf(i11) && delete e10[i11];
          }), this.eventOptions = s10;
        }
        drawCrosshair(t10, e10) {
          let i10 = this.crosshair, s10 = sG(i10 && i10.snap, true), o10 = this.chart, r10, n10, a10, h10 = this.cross, l10;
          if (sE(this, "drawCrosshair", {
            e: t10,
            point: e10
          }), t10 || (t10 = this.cross && this.cross.e), i10 && false !== (sA(e10) || !s10)) {
            if (s10 ? sA(e10) && (n10 = sG("colorAxis" !== this.coll ? e10.crosshairPos : null, this.isXAxis ? e10.plotX : this.len - e10.plotY)) : n10 = t10 && (this.horiz ? t10.chartX - this.pos : this.len - t10.chartY + this.pos), sA(n10) && (l10 = {
              value: e10 && (this.isXAxis ? e10.x : sG(e10.stackY, e10.y)),
              translatedValue: n10
            }, o10.polar && sO(l10, {
              isCrosshair: true,
              chartX: t10 && t10.chartX,
              chartY: t10 && t10.chartY,
              point: e10
            }), r10 = this.getPlotLinePath(l10) || null), !sA(r10)) {
              this.hideCrosshair();
              return;
            }
            a10 = this.categories && !this.isRadial, h10 || (this.cross = h10 = o10.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a10 ? "category " : "thin ") + (i10.className || "")).attr({
              zIndex: sG(i10.zIndex, 2)
            }).add(), !o10.styledMode && (h10.attr({
              stroke: i10.color || (a10 ? tO.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"),
              "stroke-width": sG(i10.width, 1)
            }).css({
              "pointer-events": "none"
            }), i10.dashStyle && h10.attr({
              dashstyle: i10.dashStyle
            }))), h10.show().attr({
              d: r10
            }), a10 && !i10.width && h10.attr({
              "stroke-width": this.transA
            }), this.cross.e = t10;
          } else this.hideCrosshair();
          sE(this, "afterDrawCrosshair", {
            e: t10,
            point: e10
          });
        }
        hideCrosshair() {
          this.cross && this.cross.hide(), sE(this, "afterHideCrosshair");
        }
        update(t10, e10) {
          let i10 = this.chart;
          t10 = sN(this.userOptions, t10), this.destroy(true), this.init(i10, t10), i10.isDirtyBox = true, sG(e10, true) && i10.redraw();
        }
        remove(t10) {
          let e10 = this.chart, i10 = this.coll, s10 = this.series, o10 = s10.length;
          for (; o10--; ) s10[o10] && s10[o10].remove(false);
          sP(e10.axes, this), sP(e10[i10] || [], this), e10.orderItems(i10), this.destroy(), e10.isDirtyBox = true, sG(t10, true) && e10.redraw();
        }
        setTitle(t10, e10) {
          this.update({
            title: t10
          }, e10);
        }
        setCategories(t10, e10) {
          this.update({
            categories: t10
          }, e10);
        }
      }
      sU.keepProps = ["coll", "extKey", "hcEvents", "len", "names", "series", "userMax", "userMin"];
      let {
        addEvent: sV,
        getMagnitude: s$,
        normalizeTickInterval: s_,
        timeUnits: sq
      } = tt;
      !function(t10) {
        function e10() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function i10() {
          if ("datetime" !== this.type) {
            this.dateTime = void 0;
            return;
          }
          this.dateTime || (this.dateTime = new s10(this));
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("dateTime") || (t11.keepProps.push("dateTime"), t11.prototype.getTimeTicks = e10, sV(t11, "afterSetType", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          normalizeTimeTickInterval(t11, e11) {
            let i11 = e11 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], s11 = i11[i11.length - 1], o10 = sq[s11[0]], r10 = s11[1], n10;
            for (n10 = 0; n10 < i11.length && (o10 = sq[(s11 = i11[n10])[0]], r10 = s11[1], !i11[n10 + 1] || !(t11 <= (o10 * r10[r10.length - 1] + sq[i11[n10 + 1][0]]) / 2)); n10++) ;
            o10 === sq.year && t11 < 5 * o10 && (r10 = [1, 2, 5]);
            let a10 = s_(t11 / o10, r10, "year" === s11[0] ? Math.max(s$(t11 / o10), 1) : 1);
            return {
              unitRange: o10,
              count: a10,
              unitName: s11[0]
            };
          }
          getXDateFormat(t11, e11) {
            let {
              axis: i11
            } = this, s11 = i11.chart.time;
            return i11.closestPointRange ? s11.getDateFormat(i11.closestPointRange, t11, i11.options.startOfWeek, e11) || s11.resolveDTLFormat(e11.year).main : s11.resolveDTLFormat(e11.day).main;
          }
        }
        t10.Additions = s10;
      }(d || (d = {}));
      let sZ = d, {
        addEvent: sK,
        normalizeTickInterval: sJ,
        pick: sQ
      } = tt;
      !function(t10) {
        function e10() {
          "logarithmic" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s10(this));
        }
        function i10() {
          let t11 = this.logarithmic;
          t11 && (this.lin2val = function(e11) {
            return t11.lin2log(e11);
          }, this.val2lin = function(e11) {
            return t11.log2lin(e11);
          });
        }
        t10.compose = function(t11) {
          return t11.keepProps.includes("logarithmic") || (t11.keepProps.push("logarithmic"), sK(t11, "afterSetType", e10), sK(t11, "afterInit", i10)), t11;
        };
        class s10 {
          constructor(t11) {
            this.axis = t11;
          }
          getLogTickPositions(t11, e11, i11, s11) {
            let o10 = this.axis, r10 = o10.len, n10 = o10.options, a10 = [];
            if (s11 || (this.minorAutoInterval = void 0), t11 >= 0.5) t11 = Math.round(t11), a10 = o10.getLinearTickPositions(t11, e11, i11);
            else if (t11 >= 0.08) {
              let o11, r11, n11, h10, l10, d10, c10;
              let p10 = Math.floor(e11);
              for (o11 = t11 > 0.3 ? [1, 2, 4] : t11 > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r11 = p10; r11 < i11 + 1 && !c10; r11++) for (n11 = 0, h10 = o11.length; n11 < h10 && !c10; n11++) (l10 = this.log2lin(this.lin2log(r11) * o11[n11])) > e11 && (!s11 || d10 <= i11) && void 0 !== d10 && a10.push(d10), d10 > i11 && (c10 = true), d10 = l10;
            } else {
              let h10 = this.lin2log(e11), l10 = this.lin2log(i11), d10 = s11 ? o10.getMinorTickInterval() : n10.tickInterval, c10 = n10.tickPixelInterval / (s11 ? 5 : 1), p10 = s11 ? r10 / o10.tickPositions.length : r10;
              t11 = sJ(t11 = sQ("auto" === d10 ? null : d10, this.minorAutoInterval, (l10 - h10) * c10 / (p10 || 1))), a10 = o10.getLinearTickPositions(t11, h10, l10).map(this.log2lin), s11 || (this.minorAutoInterval = t11 / 5);
            }
            return s11 || (o10.tickInterval = t11), a10;
          }
          lin2log(t11) {
            return Math.pow(10, t11);
          }
          log2lin(t11) {
            return Math.log(t11) / Math.LN10;
          }
        }
        t10.Additions = s10;
      }(c || (c = {}));
      let s0 = c, {
        erase: s1,
        extend: s2,
        isNumber: s3
      } = tt;
      !function(t10) {
        let e10;
        function i10(t11) {
          return this.addPlotBandOrLine(t11, "plotBands");
        }
        function s10(t11, i11) {
          let s11 = this.userOptions, o11 = new e10(this, t11);
          if (this.visible && (o11 = o11.render()), o11) {
            if (this._addedPlotLB || (this._addedPlotLB = true, (s11.plotLines || []).concat(s11.plotBands || []).forEach((t12) => {
              this.addPlotBandOrLine(t12);
            })), i11) {
              let e11 = s11[i11] || [];
              e11.push(t11), s11[i11] = e11;
            }
            this.plotLinesAndBands.push(o11);
          }
          return o11;
        }
        function o10(t11) {
          return this.addPlotBandOrLine(t11, "plotLines");
        }
        function r10(t11, e11, i11) {
          i11 = i11 || this.options;
          let s11 = this.getPlotLinePath({
            value: e11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), o11 = [], r11 = this.horiz, n11 = !s3(this.min) || !s3(this.max) || t11 < this.min && e11 < this.min || t11 > this.max && e11 > this.max, a11 = this.getPlotLinePath({
            value: t11,
            force: true,
            acrossPanes: i11.acrossPanes
          }), h11, l10 = 1, d10;
          if (a11 && s11) for (n11 && (d10 = a11.toString() === s11.toString(), l10 = 0), h11 = 0; h11 < a11.length; h11 += 2) {
            let t12 = a11[h11], e12 = a11[h11 + 1], i12 = s11[h11], n12 = s11[h11 + 1];
            ("M" === t12[0] || "L" === t12[0]) && ("M" === e12[0] || "L" === e12[0]) && ("M" === i12[0] || "L" === i12[0]) && ("M" === n12[0] || "L" === n12[0]) && (r11 && i12[1] === t12[1] ? (i12[1] += l10, n12[1] += l10) : r11 || i12[2] !== t12[2] || (i12[2] += l10, n12[2] += l10), o11.push(["M", t12[1], t12[2]], ["L", e12[1], e12[2]], ["L", n12[1], n12[2]], ["L", i12[1], i12[2]], ["Z"])), o11.isFlat = d10;
          }
          return o11;
        }
        function n10(t11) {
          this.removePlotBandOrLine(t11);
        }
        function a10(t11) {
          let e11 = this.plotLinesAndBands, i11 = this.options, s11 = this.userOptions;
          if (e11) {
            let o11 = e11.length;
            for (; o11--; ) e11[o11].id === t11 && e11[o11].destroy();
            [i11.plotLines || [], s11.plotLines || [], i11.plotBands || [], s11.plotBands || []].forEach(function(e12) {
              for (o11 = e12.length; o11--; ) (e12[o11] || {}).id === t11 && s1(e12, e12[o11]);
            });
          }
        }
        function h10(t11) {
          this.removePlotBandOrLine(t11);
        }
        t10.compose = function(t11, l10) {
          let d10 = l10.prototype;
          return d10.addPlotBand || (e10 = t11, s2(d10, {
            addPlotBand: i10,
            addPlotLine: o10,
            addPlotBandOrLine: s10,
            getPlotBandPath: r10,
            removePlotBand: n10,
            removePlotLine: h10,
            removePlotBandOrLine: a10
          })), l10;
        };
      }(p || (p = {}));
      let s5 = p, {
        addEvent: s6,
        arrayMax: s9,
        arrayMin: s4,
        defined: s8,
        destroyObjectProperties: s7,
        erase: ot,
        fireEvent: oe,
        merge: oi,
        objectEach: os,
        pick: oo
      } = tt;
      class or {
        static compose(t10, e10) {
          return s6(t10, "afterInit", function() {
            this.labelCollectors.push(() => {
              let t11 = [];
              for (let e11 of this.axes) for (let {
                label: i10,
                options: s10
              } of e11.plotLinesAndBands) i10 && !s10?.label?.allowOverlap && t11.push(i10);
              return t11;
            });
          }), s5.compose(or, e10);
        }
        constructor(t10, e10) {
          this.axis = t10, this.options = e10, this.id = e10.id;
        }
        render() {
          oe(this, "render");
          let {
            axis: t10,
            options: e10
          } = this, {
            horiz: i10,
            logarithmic: s10
          } = t10, {
            color: o10,
            events: r10,
            zIndex: n10 = 0
          } = e10, {
            renderer: a10,
            time: h10
          } = t10.chart, l10 = {}, d10 = h10.parse(e10.to), c10 = h10.parse(e10.from), p10 = h10.parse(e10.value), u10 = e10.borderWidth, g2 = e10.label, {
            label: f2,
            svgElem: m2
          } = this, x2 = [], y2, b2 = s8(c10) && s8(d10), v2 = s8(p10), M2 = !m2, k2 = {
            class: "highcharts-plot-" + (b2 ? "band " : "line ") + (e10.className || "")
          }, w2 = b2 ? "bands" : "lines";
          if (!t10.chart.styledMode && (v2 ? (k2.stroke = o10 || "#999999", k2["stroke-width"] = oo(e10.width, 1), e10.dashStyle && (k2.dashstyle = e10.dashStyle)) : b2 && (k2.fill = o10 || "#e6e9ff", u10 && (k2.stroke = e10.borderColor, k2["stroke-width"] = u10))), l10.zIndex = n10, w2 += "-" + n10, (y2 = t10.plotLinesAndBandsGroups[w2]) || (t10.plotLinesAndBandsGroups[w2] = y2 = a10.g("plot-" + w2).attr(l10).add()), m2 || (this.svgElem = m2 = a10.path().attr(k2).add(y2)), s8(p10)) x2 = t10.getPlotLinePath({
            value: s10?.log2lin(p10) ?? p10,
            lineWidth: m2.strokeWidth(),
            acrossPanes: e10.acrossPanes
          });
          else {
            if (!(s8(c10) && s8(d10))) return;
            x2 = t10.getPlotBandPath(s10?.log2lin(c10) ?? c10, s10?.log2lin(d10) ?? d10, e10);
          }
          return !this.eventsAdded && r10 && (os(r10, (t11, e11) => {
            m2?.on(e11, (t12) => {
              r10[e11].apply(this, [t12]);
            });
          }), this.eventsAdded = true), (M2 || !m2.d) && x2?.length ? m2.attr({
            d: x2
          }) : m2 && (x2 ? (m2.show(), m2.animate({
            d: x2
          })) : m2.d && (m2.hide(), f2 && (this.label = f2 = f2.destroy()))), g2 && (s8(g2.text) || s8(g2.formatter)) && x2?.length && t10.width > 0 && t10.height > 0 && !x2.isFlat ? (g2 = oi(__spreadValues({
            align: i10 && b2 ? "center" : void 0,
            x: i10 ? !b2 && 4 : 10,
            verticalAlign: !i10 && b2 ? "middle" : void 0,
            y: i10 ? b2 ? 16 : 10 : b2 ? 6 : -4,
            rotation: i10 && !b2 ? 90 : 0
          }, b2 ? {
            inside: true
          } : {}), g2), this.renderLabel(g2, x2, b2, n10)) : f2 && f2.hide(), this;
        }
        renderLabel(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = o10.chart.renderer, n10 = t10.inside, a10 = this.label;
          a10 || (this.label = a10 = r10.text(this.getLabelText(t10), 0, 0, t10.useHTML).attr({
            align: t10.textAlign || t10.align,
            rotation: t10.rotation,
            class: "highcharts-plot-" + (i10 ? "band" : "line") + "-label " + (t10.className || ""),
            zIndex: s10
          }), o10.chart.styledMode || a10.css(oi({
            fontSize: "0.8em",
            textOverflow: i10 && !n10 ? "" : "ellipsis"
          }, t10.style)), a10.add());
          let h10 = e10.xBounds || [e10[0][1], e10[1][1], i10 ? e10[2][1] : e10[0][1]], l10 = e10.yBounds || [e10[0][2], e10[1][2], i10 ? e10[2][2] : e10[0][2]], d10 = s4(h10), c10 = s4(l10), p10 = s9(h10) - d10;
          a10.align(t10, false, {
            x: d10,
            y: c10,
            width: p10,
            height: s9(l10) - c10
          }), (!a10.alignValue || "left" === a10.alignValue || s8(n10)) && a10.css({
            width: (t10.style?.width || (i10 && n10 ? p10 : 90 === a10.rotation ? o10.height - (a10.alignAttr.y - o10.top) : (t10.clip ? o10.width : o10.chart.chartWidth) - (a10.alignAttr.x - o10.left))) + "px"
          }), a10.show(true);
        }
        getLabelText(t10) {
          return s8(t10.formatter) ? t10.formatter.call(this) : t10.text;
        }
        destroy() {
          ot(this.axis.plotLinesAndBands, this), delete this.axis, s7(this);
        }
      }
      let {
        animObject: on
      } = tU, {
        format: oa
      } = ep, {
        composed: oh,
        dateFormats: ol,
        doc: od,
        isSafari: oc
      } = O, {
        distribute: op
      } = ey, {
        addEvent: ou,
        clamp: og,
        css: of,
        discardElement: om,
        extend: ox,
        fireEvent: oy,
        isArray: ob,
        isNumber: ov,
        isObject: oM,
        isString: ok,
        merge: ow,
        pick: oS,
        pushUnique: oA,
        splat: oT,
        syncTimeout: oP
      } = tt;
      class oC {
        constructor(t10, e10, i10) {
          this.allowShared = true, this.crosshairs = [], this.distance = 0, this.isHidden = true, this.isSticky = false, this.options = {}, this.outside = false, this.chart = t10, this.init(t10, e10), this.pointer = i10;
        }
        bodyFormatter(t10) {
          return t10.map((t11) => {
            let e10 = t11.series.tooltipOptions, i10 = t11.formatPrefix || "point";
            return (e10[i10 + "Formatter"] || t11.tooltipFormatter).call(t11, e10[i10 + "Format"] || "");
          });
        }
        cleanSplit(t10) {
          this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.tt;
            i10 && (!i10.isActive || t10 ? e10.tt = i10.destroy() : i10.isActive = false);
          });
        }
        defaultFormatter(t10) {
          let e10;
          let i10 = this.points || oT(this);
          return (e10 = (e10 = [t10.headerFooterFormatter(i10[0])]).concat(t10.bodyFormatter(i10))).push(t10.headerFooterFormatter(i10[0], true)), e10;
        }
        destroy() {
          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), om(this.container)), tt.clearTimeout(this.hideTimer);
        }
        getAnchor(t10, e10) {
          let i10;
          let {
            chart: s10,
            pointer: o10
          } = this, r10 = s10.inverted, n10 = s10.plotTop, a10 = s10.plotLeft;
          if ((t10 = oT(t10))[0].series && t10[0].series.yAxis && !t10[0].series.yAxis.options.reversedStacks && (t10 = t10.slice().reverse()), this.followPointer && e10) void 0 === e10.chartX && (e10 = o10.normalize(e10)), i10 = [e10.chartX - a10, e10.chartY - n10];
          else if (t10[0].tooltipPos) i10 = t10[0].tooltipPos;
          else {
            let s11 = 0, o11 = 0;
            t10.forEach(function(t11) {
              let e11 = t11.pos(true);
              e11 && (s11 += e11[0], o11 += e11[1]);
            }), s11 /= t10.length, o11 /= t10.length, this.shared && t10.length > 1 && e10 && (r10 ? s11 = e10.chartX : o11 = e10.chartY), i10 = [s11 - a10, o11 - n10];
          }
          return i10.map(Math.round);
        }
        getClassName(t10, e10, i10) {
          let s10 = this.options, o10 = t10.series, r10 = o10.options;
          return [s10.className, "highcharts-label", i10 && "highcharts-tooltip-header", e10 ? "highcharts-tooltip-box" : "highcharts-tooltip", !i10 && "highcharts-color-" + oS(t10.colorIndex, o10.colorIndex), r10 && r10.className].filter(ok).join(" ");
        }
        getLabel({
          anchorX: t10,
          anchorY: e10
        } = {
          anchorX: 0,
          anchorY: 0
        }) {
          let i10 = this, s10 = this.chart.styledMode, o10 = this.options, r10 = this.split && this.allowShared, n10 = this.container, a10 = this.chart.renderer;
          if (this.label) {
            let t11 = !this.label.hasClass("highcharts-label");
            (!r10 && t11 || r10 && !t11) && this.destroy();
          }
          if (!this.label) {
            if (this.outside) {
              let t11 = this.chart, e11 = t11.options.chart.style, i11 = eu.getRendererType();
              this.container = n10 = O.doc.createElement("div"), n10.className = "highcharts-tooltip-container " + (t11.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), of(n10, {
                position: "absolute",
                top: "1px",
                pointerEvents: "none",
                zIndex: Math.max(this.options.style.zIndex || 0, (e11 && e11.zIndex || 0) + 3)
              }), this.renderer = a10 = new i11(n10, 0, 0, e11, void 0, void 0, a10.styledMode);
            }
            if (r10 ? this.label = a10.g("tooltip") : (this.label = a10.label("", t10, e10, o10.shape, void 0, void 0, o10.useHTML, void 0, "tooltip").attr({
              padding: o10.padding,
              r: o10.borderRadius
            }), s10 || this.label.attr({
              fill: o10.backgroundColor,
              "stroke-width": o10.borderWidth || 0
            }).css(o10.style).css({
              pointerEvents: o10.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
            })), i10.outside) {
              let t11 = this.label;
              [t11.xSetter, t11.ySetter].forEach((e11, s11) => {
                t11[s11 ? "ySetter" : "xSetter"] = (o11) => {
                  e11.call(t11, i10.distance), t11[s11 ? "y" : "x"] = o11, n10 && (n10.style[s11 ? "top" : "left"] = `${o11}px`);
                };
              });
            }
            this.label.attr({
              zIndex: 8
            }).shadow(o10.shadow).add();
          }
          return n10 && !n10.parentElement && O.doc.body.appendChild(n10), this.label;
        }
        getPlayingField() {
          let {
            body: t10,
            documentElement: e10
          } = od, {
            chart: i10,
            distance: s10,
            outside: o10
          } = this;
          return {
            width: o10 ? Math.max(t10.scrollWidth, e10.scrollWidth, t10.offsetWidth, e10.offsetWidth, e10.clientWidth) - 2 * s10 - 2 : i10.chartWidth,
            height: o10 ? Math.max(t10.scrollHeight, e10.scrollHeight, t10.offsetHeight, e10.offsetHeight, e10.clientHeight) : i10.chartHeight
          };
        }
        getPosition(t10, e10, i10) {
          let {
            distance: s10,
            chart: o10,
            outside: r10,
            pointer: n10
          } = this, {
            inverted: a10,
            plotLeft: h10,
            plotTop: l10,
            polar: d10
          } = o10, {
            plotX: c10 = 0,
            plotY: p10 = 0
          } = i10, u10 = {}, g2 = a10 && i10.h || 0, {
            height: f2,
            width: m2
          } = this.getPlayingField(), x2 = n10.getChartPosition(), y2 = (t11) => t11 * x2.scaleX, b2 = (t11) => t11 * x2.scaleY, v2 = (i11) => {
            let n11 = "x" === i11;
            return [i11, n11 ? m2 : f2, n11 ? t10 : e10].concat(r10 ? [n11 ? y2(t10) : b2(e10), n11 ? x2.left - s10 + y2(c10 + h10) : x2.top - s10 + b2(p10 + l10), 0, n11 ? m2 : f2] : [n11 ? t10 : e10, n11 ? c10 + h10 : p10 + l10, n11 ? h10 : l10, n11 ? h10 + o10.plotWidth : l10 + o10.plotHeight]);
          }, M2 = v2("y"), k2 = v2("x"), w2, S2 = !!i10.negative;
          !d10 && o10.hoverSeries?.yAxis?.reversed && (S2 = !S2);
          let A2 = !this.followPointer && oS(i10.ttBelow, !d10 && !a10 === S2), T2 = function(t11, e11, i11, o11, n11, a11, h11) {
            let l11 = r10 ? "y" === t11 ? b2(s10) : y2(s10) : s10, d11 = (i11 - o11) / 2, c11 = o11 < n11 - s10, p11 = n11 + s10 + o11 < e11, f3 = n11 - l11 - i11 + d11, m3 = n11 + l11 - d11;
            if (A2 && p11) u10[t11] = m3;
            else if (!A2 && c11) u10[t11] = f3;
            else if (c11) u10[t11] = Math.min(h11 - o11, f3 - g2 < 0 ? f3 : f3 - g2);
            else {
              if (!p11) return false;
              u10[t11] = Math.max(a11, m3 + g2 + i11 > e11 ? m3 : m3 + g2);
            }
          }, P2 = function(t11, e11, i11, o11, r11) {
            if (r11 < s10 || r11 > e11 - s10) return false;
            r11 < i11 / 2 ? u10[t11] = 1 : r11 > e11 - o11 / 2 ? u10[t11] = e11 - o11 - 2 : u10[t11] = r11 - i11 / 2;
          }, C2 = function(t11) {
            [M2, k2] = [k2, M2], w2 = t11;
          }, O2 = () => {
            false !== T2.apply(0, M2) ? false !== P2.apply(0, k2) || w2 || (C2(true), O2()) : w2 ? u10.x = u10.y = 0 : (C2(true), O2());
          };
          return (a10 && !d10 || this.len > 1) && C2(), O2(), u10;
        }
        hide(t10) {
          let e10 = this;
          tt.clearTimeout(this.hideTimer), t10 = oS(t10, this.options.hideDelay), this.isHidden || (this.hideTimer = oP(function() {
            let i10 = e10.getLabel();
            e10.getLabel().animate({
              opacity: 0
            }, {
              duration: t10 ? 150 : t10,
              complete: () => {
                i10.hide(), e10.container && e10.container.remove();
              }
            }), e10.isHidden = true;
          }, t10));
        }
        init(t10, e10) {
          this.chart = t10, this.options = e10, this.crosshairs = [], this.isHidden = true, this.split = e10.split && !t10.inverted && !t10.polar, this.shared = e10.shared || this.split, this.outside = oS(e10.outside, !!(t10.scrollablePixelsX || t10.scrollablePixelsY));
        }
        shouldStickOnContact(t10) {
          return !!(!this.followPointer && this.options.stickOnContact && (!t10 || this.pointer.inClass(t10.target, "highcharts-tooltip")));
        }
        move(t10, e10, i10, s10) {
          let o10 = this, r10 = on(!o10.isHidden && o10.options.animation), n10 = o10.followPointer || (o10.len || 0) > 1, a10 = {
            x: t10,
            y: e10
          };
          n10 || (a10.anchorX = i10, a10.anchorY = s10), r10.step = () => o10.drawTracker(), o10.getLabel().animate(a10, r10);
        }
        refresh(t10, e10) {
          let {
            chart: i10,
            options: s10,
            pointer: o10,
            shared: r10
          } = this, n10 = oT(t10), a10 = n10[0], h10 = s10.format, l10 = s10.formatter || this.defaultFormatter, d10 = i10.styledMode, c10 = this.allowShared;
          if (!s10.enabled || !a10.series) return;
          tt.clearTimeout(this.hideTimer), this.allowShared = !(!ob(t10) && t10.series && t10.series.noSharedTooltip), c10 = c10 && !this.allowShared, this.followPointer = !this.split && a10.series.tooltipOptions.followPointer;
          let p10 = this.getAnchor(t10, e10), u10 = p10[0], g2 = p10[1];
          r10 && this.allowShared && (o10.applyInactiveState(n10), n10.forEach((t11) => t11.setState("hover")), a10.points = n10), this.len = n10.length;
          let f2 = ok(h10) ? oa(h10, a10, i10) : l10.call(a10, this);
          a10.points = void 0;
          let m2 = a10.series;
          if (this.distance = oS(m2.tooltipOptions.distance, 16), false === f2) this.hide();
          else {
            if (this.split && this.allowShared) this.renderSplit(f2, n10);
            else {
              let t11 = u10, r11 = g2;
              if (e10 && o10.isDirectTouch && (t11 = e10.chartX - i10.plotLeft, r11 = e10.chartY - i10.plotTop), i10.polar || false === m2.options.clip || n10.some((e11) => o10.isDirectTouch || e11.series.shouldShowTooltip(t11, r11))) {
                let t12 = this.getLabel(c10 && this.tt || {});
                (!s10.style.width || d10) && t12.css({
                  width: (this.outside ? this.getPlayingField() : i10.spacingBox).width + "px"
                }), t12.attr({
                  class: this.getClassName(a10),
                  text: f2 && f2.join ? f2.join("") : f2
                }), this.outside && t12.attr({
                  x: og(t12.x || 0, 0, this.getPlayingField().width - (t12.width || 0) - 1)
                }), d10 || t12.attr({
                  stroke: s10.borderColor || a10.color || m2.color || "#666666"
                }), this.updatePosition({
                  plotX: u10,
                  plotY: g2,
                  negative: a10.negative,
                  ttBelow: a10.ttBelow,
                  h: p10[2] || 0
                });
              } else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show(), this.isHidden = false;
          }
          oy(this, "refresh");
        }
        renderSplit(t10, e10) {
          let i10 = this, {
            chart: s10,
            chart: {
              chartWidth: o10,
              chartHeight: r10,
              plotHeight: n10,
              plotLeft: a10,
              plotTop: h10,
              scrollablePixelsY: l10 = 0,
              scrollablePixelsX: d10,
              styledMode: c10
            },
            distance: p10,
            options: u10,
            options: {
              positioner: g2
            },
            pointer: f2
          } = i10, {
            scrollLeft: m2 = 0,
            scrollTop: x2 = 0
          } = s10.scrollablePlotArea?.scrollingContainer || {}, y2 = i10.outside && "number" != typeof d10 ? od.documentElement.getBoundingClientRect() : {
            left: m2,
            right: m2 + o10,
            top: x2,
            bottom: x2 + r10
          }, b2 = i10.getLabel(), v2 = this.renderer || s10.renderer, M2 = !!(s10.xAxis[0] && s10.xAxis[0].opposite), {
            left: k2,
            top: w2
          } = f2.getChartPosition(), S2 = h10 + x2, A2 = 0, T2 = n10 - l10;
          function P2(t11, e11, s11, o11, r11 = true) {
            let n11, a11;
            return s11 ? (n11 = M2 ? 0 : T2, a11 = og(t11 - o11 / 2, y2.left, y2.right - o11 - (i10.outside ? k2 : 0))) : (n11 = e11 - S2, a11 = og(a11 = r11 ? t11 - o11 - p10 : t11 + p10, r11 ? a11 : y2.left, y2.right)), {
              x: a11,
              y: n11
            };
          }
          ok(t10) && (t10 = [false, t10]);
          let C2 = t10.slice(0, e10.length + 1).reduce(function(t11, s11, o11) {
            if (false !== s11 && "" !== s11) {
              let r11 = e10[o11 - 1] || {
                isHeader: true,
                plotX: e10[0].plotX,
                plotY: n10,
                series: {}
              }, l11 = r11.isHeader, d11 = l11 ? i10 : r11.series, f3 = d11.tt = function(t12, e11, s12) {
                let o12 = t12, {
                  isHeader: r12,
                  series: n11
                } = e11;
                if (!o12) {
                  let t13 = {
                    padding: u10.padding,
                    r: u10.borderRadius
                  };
                  c10 || (t13.fill = u10.backgroundColor, t13["stroke-width"] = u10.borderWidth ?? 1), o12 = v2.label("", 0, 0, u10[r12 ? "headerShape" : "shape"], void 0, void 0, u10.useHTML).addClass(i10.getClassName(e11, true, r12)).attr(t13).add(b2);
                }
                return o12.isActive = true, o12.attr({
                  text: s12
                }), c10 || o12.css(u10.style).attr({
                  stroke: u10.borderColor || e11.color || n11.color || "#333333"
                }), o12;
              }(d11.tt, r11, s11.toString()), m3 = f3.getBBox(), x3 = m3.width + f3.strokeWidth();
              l11 && (A2 = m3.height, T2 += A2, M2 && (S2 -= A2));
              let {
                anchorX: k3,
                anchorY: w3
              } = function(t12) {
                let e11, i11;
                let {
                  isHeader: s12,
                  plotX: o12 = 0,
                  plotY: r12 = 0,
                  series: l12
                } = t12;
                if (s12) e11 = Math.max(a10 + o12, a10), i11 = h10 + n10 / 2;
                else {
                  let {
                    xAxis: t13,
                    yAxis: s13
                  } = l12;
                  e11 = t13.pos + og(o12, -p10, t13.len + p10), l12.shouldShowTooltip(0, s13.pos - h10 + r12, {
                    ignoreX: true
                  }) && (i11 = s13.pos + r12);
                }
                return {
                  anchorX: e11 = og(e11, y2.left - p10, y2.right + p10),
                  anchorY: i11
                };
              }(r11);
              if ("number" == typeof w3) {
                let e11 = m3.height + 1, s12 = g2 ? g2.call(i10, x3, e11, r11) : P2(k3, w3, l11, x3);
                t11.push({
                  align: g2 ? 0 : void 0,
                  anchorX: k3,
                  anchorY: w3,
                  boxWidth: x3,
                  point: r11,
                  rank: oS(s12.rank, l11 ? 1 : 0),
                  size: e11,
                  target: s12.y,
                  tt: f3,
                  x: s12.x
                });
              } else f3.isActive = false;
            }
            return t11;
          }, []);
          !g2 && C2.some((t11) => {
            let {
              outside: e11
            } = i10, s11 = (e11 ? k2 : 0) + t11.anchorX;
            return s11 < y2.left && s11 + t11.boxWidth < y2.right || s11 < k2 - y2.left + t11.boxWidth && y2.right - s11 > s11;
          }) && (C2 = C2.map((t11) => {
            let {
              x: e11,
              y: i11
            } = P2(t11.anchorX, t11.anchorY, t11.point.isHeader, t11.boxWidth, false);
            return ox(t11, {
              target: i11,
              x: e11
            });
          })), i10.cleanSplit(), op(C2, T2);
          let O2 = {
            left: k2,
            right: k2
          };
          C2.forEach(function(t11) {
            let {
              x: e11,
              boxWidth: s11,
              isHeader: o11
            } = t11;
            !o11 && (i10.outside && k2 + e11 < O2.left && (O2.left = k2 + e11), !o11 && i10.outside && O2.left + s11 > O2.right && (O2.right = k2 + e11));
          }), C2.forEach(function(t11) {
            let {
              x: e11,
              anchorX: s11,
              anchorY: o11,
              pos: r11,
              point: {
                isHeader: n11
              }
            } = t11, a11 = {
              visibility: void 0 === r11 ? "hidden" : "inherit",
              x: e11,
              y: (r11 || 0) + S2,
              anchorX: s11,
              anchorY: o11
            };
            if (i10.outside && e11 < s11) {
              let t12 = k2 - O2.left;
              t12 > 0 && (n11 || (a11.x = e11 + t12, a11.anchorX = s11 + t12), n11 && (a11.x = (O2.right - O2.left) / 2, a11.anchorX = s11 + t12));
            }
            t11.tt.attr(a11);
          });
          let {
            container: E2,
            outside: L2,
            renderer: B2
          } = i10;
          if (L2 && E2 && B2) {
            let {
              width: t11,
              height: e11,
              x: i11,
              y: s11
            } = b2.getBBox();
            B2.setSize(t11 + i11, e11 + s11, false), E2.style.left = O2.left + "px", E2.style.top = w2 + "px";
          }
          oc && b2.attr({
            opacity: 1 === b2.opacity ? 0.999 : 1
          });
        }
        drawTracker() {
          if (!this.shouldStickOnContact()) {
            this.tracker && (this.tracker = this.tracker.destroy());
            return;
          }
          let t10 = this.chart, e10 = this.label, i10 = this.shared ? t10.hoverPoints : t10.hoverPoint;
          if (!e10 || !i10) return;
          let s10 = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }, o10 = this.getAnchor(i10), r10 = e10.getBBox();
          o10[0] += t10.plotLeft - (e10.translateX || 0), o10[1] += t10.plotTop - (e10.translateY || 0), s10.x = Math.min(0, o10[0]), s10.y = Math.min(0, o10[1]), s10.width = o10[0] < 0 ? Math.max(Math.abs(o10[0]), r10.width - o10[0]) : Math.max(Math.abs(o10[0]), r10.width), s10.height = o10[1] < 0 ? Math.max(Math.abs(o10[1]), r10.height - Math.abs(o10[1])) : Math.max(Math.abs(o10[1]), r10.height), this.tracker ? this.tracker.attr(s10) : (this.tracker = e10.renderer.rect(s10).addClass("highcharts-tracker").add(e10), t10.styledMode || this.tracker.attr({
            fill: "rgba(0,0,0,0)"
          }));
        }
        styledModeFormat(t10) {
          return t10.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
        }
        headerFooterFormatter(t10, e10) {
          let i10 = t10.series, s10 = i10.tooltipOptions, o10 = i10.xAxis, r10 = o10 && o10.dateTime, n10 = {
            isFooter: e10,
            point: t10
          }, a10 = s10.xDateFormat || "", h10 = s10[e10 ? "footerFormat" : "headerFormat"];
          return oy(this, "headerFormatter", n10, function(e11) {
            if (r10 && !a10 && ov(t10.key) && (a10 = r10.getXDateFormat(t10.key, s10.dateTimeLabelFormats)), r10 && a10) {
              if (oM(a10)) {
                let t11 = a10;
                ol[0] = (e12) => i10.chart.time.dateFormat(t11, e12), a10 = "%0";
              }
              (t10.tooltipDateKeys || ["key"]).forEach((t11) => {
                h10 = h10.replace(RegExp("point\\." + t11 + "([ \\)}])", ""), `(point.${t11}:${a10})$1`);
              });
            }
            i10.chart.styledMode && (h10 = this.styledModeFormat(h10)), e11.text = oa(h10, t10, this.chart);
          }), n10.text || "";
        }
        update(t10) {
          this.destroy(), this.init(this.chart, ow(true, this.options, t10));
        }
        updatePosition(t10) {
          let {
            chart: e10,
            container: i10,
            distance: s10,
            options: o10,
            pointer: r10,
            renderer: n10
          } = this, {
            height: a10 = 0,
            width: h10 = 0
          } = this.getLabel(), {
            left: l10,
            top: d10,
            scaleX: c10,
            scaleY: p10
          } = r10.getChartPosition(), u10 = (o10.positioner || this.getPosition).call(this, h10, a10, t10), g2 = O.doc, f2 = (t10.plotX || 0) + e10.plotLeft, m2 = (t10.plotY || 0) + e10.plotTop, x2;
          n10 && i10 && (o10.positioner && (u10.x += l10 - s10, u10.y += d10 - s10), x2 = (o10.borderWidth || 0) + 2 * s10 + 2, n10.setSize(og(h10 + x2, 0, g2.documentElement.clientWidth) - 1, a10 + x2, false), (1 !== c10 || 1 !== p10) && (of(i10, {
            transform: `scale(${c10}, ${p10})`
          }), f2 *= c10, m2 *= p10), f2 += l10 - u10.x, m2 += d10 - u10.y), this.move(Math.round(u10.x), Math.round(u10.y || 0), f2, m2);
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          oA(oh, "Core.Tooltip") && ou(e10, "afterInit", function() {
            let e11 = this.chart;
            e11.options.tooltip && (e11.tooltip = new t10(e11, e11.options.tooltip, this));
          });
        };
      }(oC || (oC = {}));
      let oO = oC, {
        animObject: oE
      } = tU, {
        defaultOptions: oL
      } = tS, {
        format: oB
      } = ep, {
        addEvent: oI,
        crisp: oD,
        erase: oR,
        extend: oN,
        fireEvent: oz,
        getNestedProperty: oW,
        isArray: oG,
        isFunction: oH,
        isNumber: oF,
        isObject: oX,
        merge: oY,
        pick: oj,
        syncTimeout: oU,
        removeEvent: oV,
        uniqueKey: o$
      } = tt;
      class o_ {
        animateBeforeDestroy() {
          let t10 = this, e10 = {
            x: t10.startXPos,
            opacity: 0
          }, i10 = t10.getGraphicalProps();
          i10.singular.forEach(function(i11) {
            t10[i11] = t10[i11].animate("dataLabel" === i11 ? {
              x: t10[i11].startXPos,
              y: t10[i11].startYPos,
              opacity: 0
            } : e10);
          }), i10.plural.forEach(function(e11) {
            t10[e11].forEach(function(e12) {
              e12.element && e12.animate(oN({
                x: t10.startXPos
              }, e12.startYPos ? {
                x: e12.startXPos,
                y: e12.startYPos
              } : {}));
            });
          });
        }
        applyOptions(t10, e10) {
          let i10 = this.series, s10 = i10.options.pointValKey || i10.pointValKey;
          return oN(this, t10 = o_.prototype.optionsToObject.call(this, t10)), this.options = this.options ? oN(this.options, t10) : t10, t10.group && delete this.group, t10.dataLabels && delete this.dataLabels, s10 && (this.y = o_.prototype.getNestedProperty.call(this, s10)), this.selected && (this.state = "select"), "name" in this && void 0 === e10 && i10.xAxis && i10.xAxis.hasNames && (this.x = i10.xAxis.nameToX(this)), void 0 === this.x && i10 ? this.x = e10 ?? i10.autoIncrement() : oF(t10.x) && i10.options.relativeXValue ? this.x = i10.autoIncrement(t10.x) : "string" == typeof this.x && (e10 ?? (e10 = i10.chart.time.parse(this.x)), oF(e10) && (this.x = e10)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
        }
        destroy() {
          if (!this.destroyed) {
            let t10 = this, e10 = t10.series, i10 = e10.chart, s10 = e10.options.dataSorting, o10 = i10.hoverPoints, r10 = oE(t10.series.chart.renderer.globalAnimation), n10 = () => {
              for (let e11 in (t10.graphic || t10.graphics || t10.dataLabel || t10.dataLabels) && (oV(t10), t10.destroyElements()), t10) delete t10[e11];
            };
            t10.legendItem && i10.legend.destroyItem(t10), o10 && (t10.setState(), oR(o10, t10), o10.length || (i10.hoverPoints = null)), t10 === i10.hoverPoint && t10.onMouseOut(), s10 && s10.enabled ? (this.animateBeforeDestroy(), oU(n10, r10.duration)) : n10(), i10.pointCount--;
          }
          this.destroyed = true;
        }
        destroyElements(t10) {
          let e10 = this, i10 = e10.getGraphicalProps(t10);
          i10.singular.forEach(function(t11) {
            e10[t11] = e10[t11].destroy();
          }), i10.plural.forEach(function(t11) {
            e10[t11].forEach(function(t12) {
              t12 && t12.element && t12.destroy();
            }), delete e10[t11];
          });
        }
        firePointEvent(t10, e10, i10) {
          let s10 = this, o10 = this.series.options;
          s10.manageEvent(t10), "click" === t10 && o10.allowPointSelect && (i10 = function(t11) {
            !s10.destroyed && s10.select && s10.select(null, t11.ctrlKey || t11.metaKey || t11.shiftKey);
          }), oz(s10, t10, e10, i10);
        }
        getClassName() {
          return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
        }
        getGraphicalProps(t10) {
          let e10, i10;
          let s10 = this, o10 = [], r10 = {
            singular: [],
            plural: []
          };
          for ((t10 = t10 || {
            graphic: 1,
            dataLabel: 1
          }).graphic && o10.push("graphic", "connector"), t10.dataLabel && o10.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i10 = o10.length; i10--; ) s10[e10 = o10[i10]] && r10.singular.push(e10);
          return ["graphic", "dataLabel"].forEach(function(e11) {
            let i11 = e11 + "s";
            t10[e11] && s10[i11] && r10.plural.push(i11);
          }), r10;
        }
        getNestedProperty(t10) {
          return t10 ? 0 === t10.indexOf("custom.") ? oW(t10, this.options) : this[t10] : void 0;
        }
        getZone() {
          let t10 = this.series, e10 = t10.zones, i10 = t10.zoneAxis || "y", s10, o10 = 0;
          for (s10 = e10[0]; this[i10] >= s10.value; ) s10 = e10[++o10];
          return this.nonZonedColor || (this.nonZonedColor = this.color), s10 && s10.color && !this.options.color ? this.color = s10.color : this.color = this.nonZonedColor, s10;
        }
        hasNewShapeType() {
          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
        }
        constructor(t10, e10, i10) {
          this.formatPrefix = "point", this.visible = true, this.point = this, this.series = t10, this.applyOptions(e10, i10), this.id ?? (this.id = o$()), this.resolveColor(), t10.chart.pointCount++, oz(this, "afterInit");
        }
        isValid() {
          return (oF(this.x) || this.x instanceof Date) && oF(this.y);
        }
        optionsToObject(t10) {
          let e10 = this.series, i10 = e10.options.keys, s10 = i10 || e10.pointArrayMap || ["y"], o10 = s10.length, r10 = {}, n10, a10 = 0, h10 = 0;
          if (oF(t10) || null === t10) r10[s10[0]] = t10;
          else if (oG(t10)) for (!i10 && t10.length > o10 && ("string" == (n10 = typeof t10[0]) ? e10.xAxis?.dateTime ? r10.x = e10.chart.time.parse(t10[0]) : r10.name = t10[0] : "number" === n10 && (r10.x = t10[0]), a10++); h10 < o10; ) i10 && void 0 === t10[a10] || (s10[h10].indexOf(".") > 0 ? o_.prototype.setNestedProperty(r10, t10[a10], s10[h10]) : r10[s10[h10]] = t10[a10]), a10++, h10++;
          else "object" == typeof t10 && (r10 = t10, t10.dataLabels && (e10.hasDataLabels = () => true), t10.marker && (e10._hasPointMarkers = true));
          return r10;
        }
        pos(t10, e10 = this.plotY) {
          if (!this.destroyed) {
            let {
              plotX: i10,
              series: s10
            } = this, {
              chart: o10,
              xAxis: r10,
              yAxis: n10
            } = s10, a10 = 0, h10 = 0;
            if (oF(i10) && oF(e10)) return t10 && (a10 = r10 ? r10.pos : o10.plotLeft, h10 = n10 ? n10.pos : o10.plotTop), o10.inverted && r10 && n10 ? [n10.len - e10 + h10, r10.len - i10 + a10] : [i10 + a10, e10 + h10];
          }
        }
        resolveColor() {
          let t10 = this.series, e10 = t10.chart.options.chart, i10 = t10.chart.styledMode, s10, o10, r10 = e10.colorCount, n10;
          delete this.nonZonedColor, t10.options.colorByPoint ? (i10 || (s10 = (o10 = t10.options.colors || t10.chart.options.colors)[t10.colorCounter], r10 = o10.length), n10 = t10.colorCounter, t10.colorCounter++, t10.colorCounter === r10 && (t10.colorCounter = 0)) : (i10 || (s10 = t10.color), n10 = t10.colorIndex), this.colorIndex = oj(this.options.colorIndex, n10), this.color = oj(this.options.color, s10);
        }
        setNestedProperty(t10, e10, i10) {
          return i10.split(".").reduce(function(t11, i11, s10, o10) {
            let r10 = o10.length - 1 === s10;
            return t11[i11] = r10 ? e10 : oX(t11[i11], true) ? t11[i11] : {}, t11[i11];
          }, t10), t10;
        }
        shouldDraw() {
          return !this.isNull;
        }
        tooltipFormatter(t10) {
          let {
            chart: e10,
            pointArrayMap: i10 = ["y"],
            tooltipOptions: s10
          } = this.series, {
            valueDecimals: o10 = "",
            valuePrefix: r10 = "",
            valueSuffix: n10 = ""
          } = s10;
          return e10.styledMode && (t10 = e10.tooltip?.styledModeFormat(t10) || t10), i10.forEach((e11) => {
            e11 = "{point." + e11, (r10 || n10) && (t10 = t10.replace(RegExp(e11 + "}", "g"), r10 + e11 + "}" + n10)), t10 = t10.replace(RegExp(e11 + "}", "g"), e11 + ":,." + o10 + "f}");
          }), oB(t10, this, e10);
        }
        update(t10, e10, i10, s10) {
          let o10;
          let r10 = this, n10 = r10.series, a10 = r10.graphic, h10 = n10.chart, l10 = n10.options;
          function d10() {
            r10.applyOptions(t10);
            let s11 = a10 && r10.hasMockGraphic, d11 = null === r10.y ? !s11 : s11;
            a10 && d11 && (r10.graphic = a10.destroy(), delete r10.hasMockGraphic), oX(t10, true) && (a10 && a10.element && t10 && t10.marker && void 0 !== t10.marker.symbol && (r10.graphic = a10.destroy()), t10?.dataLabels && r10.dataLabel && (r10.dataLabel = r10.dataLabel.destroy())), o10 = r10.index;
            let c10 = {};
            for (let t11 of n10.dataColumnKeys()) c10[t11] = r10[t11];
            n10.dataTable.setRow(c10, o10), l10.data[o10] = oX(l10.data[o10], true) || oX(t10, true) ? r10.options : oj(t10, l10.data[o10]), n10.isDirty = n10.isDirtyData = true, !n10.fixedBox && n10.hasCartesianSeries && (h10.isDirtyBox = true), "point" === l10.legendType && (h10.isDirtyLegend = true), e10 && h10.redraw(i10);
          }
          e10 = oj(e10, true), false === s10 ? d10() : r10.firePointEvent("update", {
            options: t10
          }, d10);
        }
        remove(t10, e10) {
          this.series.removePoint(this.series.data.indexOf(this), t10, e10);
        }
        select(t10, e10) {
          let i10 = this, s10 = i10.series, o10 = s10.chart;
          t10 = oj(t10, !i10.selected), this.selectedStaging = t10, i10.firePointEvent(t10 ? "select" : "unselect", {
            accumulate: e10
          }, function() {
            i10.selected = i10.options.selected = t10, s10.options.data[s10.data.indexOf(i10)] = i10.options, i10.setState(t10 && "select"), e10 || o10.getSelectedPoints().forEach(function(t11) {
              let e11 = t11.series;
              t11.selected && t11 !== i10 && (t11.selected = t11.options.selected = false, e11.options.data[e11.data.indexOf(t11)] = t11.options, t11.setState(o10.hoverPoints && e11.options.inactiveOtherPoints ? "inactive" : ""), t11.firePointEvent("unselect"));
            });
          }), delete this.selectedStaging;
        }
        onMouseOver(t10) {
          let {
            inverted: e10,
            pointer: i10
          } = this.series.chart;
          i10 && (t10 = t10 ? i10.normalize(t10) : i10.getChartCoordinatesFromPoint(this, e10), i10.runPointActions(t10, this));
        }
        onMouseOut() {
          let t10 = this.series.chart;
          this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t10.hoverPoints || []).forEach(function(t11) {
            t11.setState();
          }), t10.hoverPoints = t10.hoverPoint = null;
        }
        manageEvent(t10) {
          let e10 = oY(this.series.options.point, this.options), i10 = e10.events?.[t10];
          oH(i10) && (!this.hcEvents?.[t10] || this.hcEvents?.[t10]?.map((t11) => t11.fn).indexOf(i10) === -1) ? (this.importedUserEvent?.(), this.importedUserEvent = oI(this, t10, i10), this.hcEvents && (this.hcEvents[t10].userEvent = true)) : this.importedUserEvent && !i10 && this.hcEvents?.[t10] && this.hcEvents?.[t10].userEvent && (oV(this, t10), delete this.hcEvents[t10], Object.keys(this.hcEvents) || delete this.importedUserEvent);
        }
        setState(t10, e10) {
          let i10 = this.series, s10 = this.state, o10 = i10.options.states[t10 || "normal"] || {}, r10 = oL.plotOptions[i10.type].marker && i10.options.marker, n10 = r10 && false === r10.enabled, a10 = r10 && r10.states && r10.states[t10 || "normal"] || {}, h10 = false === a10.enabled, l10 = this.marker || {}, d10 = i10.chart, c10 = r10 && i10.markerAttribs, p10 = i10.halo, u10, g2, f2, m2 = i10.stateMarkerGraphic, x2;
          if ((t10 = t10 || "") === this.state && !e10 || this.selected && "select" !== t10 || false === o10.enabled || t10 && (h10 || n10 && false === a10.enabled) || t10 && l10.states && l10.states[t10] && false === l10.states[t10].enabled) return;
          if (this.state = t10, c10 && (u10 = i10.markerAttribs(this, t10)), this.graphic && !this.hasMockGraphic) {
            if (s10 && this.graphic.removeClass("highcharts-point-" + s10), t10 && this.graphic.addClass("highcharts-point-" + t10), !d10.styledMode) {
              g2 = i10.pointAttribs(this, t10), f2 = oj(d10.options.chart.animation, o10.animation);
              let e11 = g2.opacity;
              i10.options.inactiveOtherPoints && oF(e11) && (this.dataLabels || []).forEach(function(t11) {
                t11 && !t11.hasClass("highcharts-data-label-hidden") && (t11.animate({
                  opacity: e11
                }, f2), t11.connector && t11.connector.animate({
                  opacity: e11
                }, f2));
              }), this.graphic.animate(g2, f2);
            }
            u10 && this.graphic.animate(u10, oj(d10.options.chart.animation, a10.animation, r10.animation)), m2 && m2.hide();
          } else t10 && a10 && (x2 = l10.symbol || i10.symbol, m2 && m2.currentSymbol !== x2 && (m2 = m2.destroy()), u10 && (m2 ? m2[e10 ? "animate" : "attr"]({
            x: u10.x,
            y: u10.y
          }) : x2 && (i10.stateMarkerGraphic = m2 = d10.renderer.symbol(x2, u10.x, u10.y, u10.width, u10.height, oY(r10, a10)).add(i10.markerGroup), m2.currentSymbol = x2)), !d10.styledMode && m2 && "inactive" !== this.state && m2.attr(i10.pointAttribs(this, t10))), m2 && (m2[t10 && this.isInside ? "show" : "hide"](), m2.element.point = this, m2.addClass(this.getClassName(), true));
          let y2 = o10.halo, b2 = this.graphic || m2, v2 = b2 && b2.visibility || "inherit";
          y2 && y2.size && b2 && "hidden" !== v2 && !this.isCluster ? (p10 || (i10.halo = p10 = d10.renderer.path().add(b2.parentGroup)), p10.show()[e10 ? "animate" : "attr"]({
            d: this.haloPath(y2.size)
          }), p10.attr({
            class: "highcharts-halo highcharts-color-" + oj(this.colorIndex, i10.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: v2,
            zIndex: -1
          }), p10.point = this, d10.styledMode || p10.attr(oN({
            fill: this.color || i10.color,
            "fill-opacity": y2.opacity
          }, t6.filterUserAttributes(y2.attributes || {})))) : p10?.point?.haloPath && !p10.point.destroyed && p10.animate({
            d: p10.point.haloPath(0)
          }, null, p10.hide), oz(this, "afterSetState", {
            state: t10
          });
        }
        haloPath(t10) {
          let e10 = this.pos();
          return e10 ? this.series.chart.renderer.symbols.circle(oD(e10[0], 1) - t10, e10[1] - t10, 2 * t10, 2 * t10) : [];
        }
      }
      let oq = o_, {
        parse: oZ
      } = tO, {
        charts: oK,
        composed: oJ,
        isTouchDevice: oQ
      } = O, {
        addEvent: o0,
        attr: o1,
        css: o2,
        extend: o3,
        find: o5,
        fireEvent: o6,
        isNumber: o9,
        isObject: o4,
        objectEach: o8,
        offset: o7,
        pick: rt,
        pushUnique: re,
        splat: ri
      } = tt;
      class rs {
        applyInactiveState(t10) {
          let e10 = [], i10;
          (t10 || []).forEach(function(t11) {
            i10 = t11.series, e10.push(i10), i10.linkedParent && e10.push(i10.linkedParent), i10.linkedSeries && (e10 = e10.concat(i10.linkedSeries)), i10.navigatorSeries && e10.push(i10.navigatorSeries);
          }), this.chart.series.forEach(function(t11) {
            -1 === e10.indexOf(t11) ? t11.setState("inactive", true) : t11.options.inactiveOtherPoints && t11.setAllPointsToState("inactive");
          });
        }
        destroy() {
          let t10 = this;
          this.eventsToUnbind.forEach((t11) => t11()), this.eventsToUnbind = [], !O.chartCount && (rs.unbindDocumentMouseUp.forEach((t11) => t11.unbind()), rs.unbindDocumentMouseUp.length = 0, rs.unbindDocumentTouchEnd && (rs.unbindDocumentTouchEnd = rs.unbindDocumentTouchEnd())), clearInterval(t10.tooltipTimeout), o8(t10, function(e10, i10) {
            t10[i10] = void 0;
          });
        }
        getSelectionMarkerAttrs(t10, e10) {
          let i10 = {
            args: {
              chartX: t10,
              chartY: e10
            },
            attrs: {},
            shapeType: "rect"
          };
          return o6(this, "getSelectionMarkerAttrs", i10, (i11) => {
            let s10;
            let {
              chart: o10,
              zoomHor: r10,
              zoomVert: n10
            } = this, {
              mouseDownX: a10 = 0,
              mouseDownY: h10 = 0
            } = o10, l10 = i11.attrs;
            l10.x = o10.plotLeft, l10.y = o10.plotTop, l10.width = r10 ? 1 : o10.plotWidth, l10.height = n10 ? 1 : o10.plotHeight, r10 && (s10 = t10 - a10, l10.width = Math.max(1, Math.abs(s10)), l10.x = (s10 > 0 ? 0 : s10) + a10), n10 && (s10 = e10 - h10, l10.height = Math.max(1, Math.abs(s10)), l10.y = (s10 > 0 ? 0 : s10) + h10);
          }), i10;
        }
        drag(t10) {
          let {
            chart: e10
          } = this, {
            mouseDownX: i10 = 0,
            mouseDownY: s10 = 0
          } = e10, {
            panning: o10,
            panKey: r10,
            selectionMarkerFill: n10
          } = e10.options.chart, a10 = e10.plotLeft, h10 = e10.plotTop, l10 = e10.plotWidth, d10 = e10.plotHeight, c10 = o4(o10) ? o10.enabled : o10, p10 = r10 && t10[`${r10}Key`], u10 = t10.chartX, g2 = t10.chartY, f2, m2 = this.selectionMarker;
          if ((!m2 || !m2.touch) && (u10 < a10 ? u10 = a10 : u10 > a10 + l10 && (u10 = a10 + l10), g2 < h10 ? g2 = h10 : g2 > h10 + d10 && (g2 = h10 + d10), this.hasDragged = Math.sqrt(Math.pow(i10 - u10, 2) + Math.pow(s10 - g2, 2)), this.hasDragged > 10)) {
            f2 = e10.isInsidePlot(i10 - a10, s10 - h10, {
              visiblePlotOnly: true
            });
            let {
              shapeType: r11,
              attrs: l11
            } = this.getSelectionMarkerAttrs(u10, g2);
            (e10.hasCartesianSeries || e10.mapView) && this.hasZoom && f2 && !p10 && !m2 && (this.selectionMarker = m2 = e10.renderer[r11](), m2.attr({
              class: "highcharts-selection-marker",
              zIndex: 7
            }).add(), e10.styledMode || m2.attr({
              fill: n10 || oZ("#334eff").setOpacity(0.25).get()
            })), m2 && m2.attr(l11), f2 && !m2 && c10 && e10.pan(t10, o10);
          }
        }
        dragStart(t10) {
          let e10 = this.chart;
          e10.mouseIsDown = t10.type, e10.cancelClick = false, e10.mouseDownX = t10.chartX, e10.mouseDownY = t10.chartY;
        }
        getSelectionBox(t10) {
          let e10 = {
            args: {
              marker: t10
            },
            result: t10.getBBox()
          };
          return o6(this, "getSelectionBox", e10), e10.result;
        }
        drop(t10) {
          let e10;
          let {
            chart: i10,
            selectionMarker: s10
          } = this;
          for (let t11 of i10.axes) t11.isPanning && (t11.isPanning = false, (t11.options.startOnTick || t11.options.endOnTick || t11.series.some((t12) => t12.boosted)) && (t11.forceRedraw = true, t11.setExtremes(t11.userMin, t11.userMax, false), e10 = true));
          if (e10 && i10.redraw(), s10 && t10) {
            if (this.hasDragged) {
              let e11 = this.getSelectionBox(s10);
              i10.transform({
                axes: i10.axes.filter((t11) => t11.zoomEnabled && ("xAxis" === t11.coll && this.zoomX || "yAxis" === t11.coll && this.zoomY)),
                selection: __spreadValues({
                  originalEvent: t10,
                  xAxis: [],
                  yAxis: []
                }, e11),
                from: e11
              });
            }
            o9(i10.index) && (this.selectionMarker = s10.destroy());
          }
          i10 && o9(i10.index) && (o2(i10.container, {
            cursor: i10._cursor
          }), i10.cancelClick = this.hasDragged > 10, i10.mouseIsDown = false, this.hasDragged = 0, this.pinchDown = []);
        }
        findNearestKDPoint(t10, e10, i10) {
          let s10;
          return t10.forEach(function(t11) {
            let o10 = !(t11.noSharedTooltip && e10) && 0 > t11.options.findNearestPointBy.indexOf("y"), r10 = t11.searchPoint(i10, o10);
            o4(r10, true) && r10.series && (!o4(s10, true) || function(t12, i11) {
              let s11 = t12.distX - i11.distX, o11 = t12.dist - i11.dist, r11 = i11.series.group?.zIndex - t12.series.group?.zIndex;
              return 0 !== s11 && e10 ? s11 : 0 !== o11 ? o11 : 0 !== r11 ? r11 : t12.series.index > i11.series.index ? -1 : 1;
            }(s10, r10) > 0) && (s10 = r10);
          }), s10;
        }
        getChartCoordinatesFromPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = t10.series, o10 = t10.shapeArgs;
          if (i10 && s10) {
            let r10 = t10.clientX ?? t10.plotX ?? 0, n10 = t10.plotY || 0;
            return t10.isNode && o10 && o9(o10.x) && o9(o10.y) && (r10 = o10.x, n10 = o10.y), e10 ? {
              chartX: s10.len + s10.pos - n10,
              chartY: i10.len + i10.pos - r10
            } : {
              chartX: r10 + i10.pos,
              chartY: n10 + s10.pos
            };
          }
          if (o10 && o10.x && o10.y) return {
            chartX: o10.x,
            chartY: o10.y
          };
        }
        getChartPosition() {
          if (this.chartPosition) return this.chartPosition;
          let {
            container: t10
          } = this.chart, e10 = o7(t10);
          this.chartPosition = {
            left: e10.left,
            top: e10.top,
            scaleX: 1,
            scaleY: 1
          };
          let {
            offsetHeight: i10,
            offsetWidth: s10
          } = t10;
          return s10 > 2 && i10 > 2 && (this.chartPosition.scaleX = e10.width / s10, this.chartPosition.scaleY = e10.height / i10), this.chartPosition;
        }
        getCoordinates(t10) {
          let e10 = {
            xAxis: [],
            yAxis: []
          };
          for (let i10 of this.chart.axes) e10[i10.isXAxis ? "xAxis" : "yAxis"].push({
            axis: i10,
            value: i10.toValue(t10[i10.horiz ? "chartX" : "chartY"])
          });
          return e10;
        }
        getHoverData(t10, e10, i10, s10, o10, r10) {
          let n10 = [], a10 = function(t11) {
            return t11.visible && !(!o10 && t11.directTouch) && rt(t11.options.enableMouseTracking, true);
          }, h10 = e10, l10, d10 = {
            chartX: r10 ? r10.chartX : void 0,
            chartY: r10 ? r10.chartY : void 0,
            shared: o10
          };
          o6(this, "beforeGetHoverData", d10), l10 = h10 && !h10.stickyTracking ? [h10] : i10.filter((t11) => t11.stickyTracking && (d10.filter || a10)(t11));
          let c10 = s10 && t10 || !r10 ? t10 : this.findNearestKDPoint(l10, o10, r10);
          return h10 = c10 && c10.series, c10 && (o10 && !h10.noSharedTooltip ? (l10 = i10.filter(function(t11) {
            return d10.filter ? d10.filter(t11) : a10(t11) && !t11.noSharedTooltip;
          })).forEach(function(t11) {
            let e11 = o5(t11.points, function(t12) {
              return t12.x === c10.x && !t12.isNull;
            });
            o4(e11) && (t11.boosted && t11.boost && (e11 = t11.boost.getPoint(e11)), n10.push(e11));
          }) : n10.push(c10)), o6(this, "afterGetHoverData", d10 = {
            hoverPoint: c10
          }), {
            hoverPoint: d10.hoverPoint,
            hoverSeries: h10,
            hoverPoints: n10
          };
        }
        getPointFromEvent(t10) {
          let e10 = t10.target, i10;
          for (; e10 && !i10; ) i10 = e10.point, e10 = e10.parentNode;
          return i10;
        }
        onTrackerMouseOut(t10) {
          let e10 = this.chart, i10 = t10.relatedTarget, s10 = e10.hoverSeries;
          this.isDirectTouch = false, !s10 || !i10 || s10.stickyTracking || this.inClass(i10, "highcharts-tooltip") || this.inClass(i10, "highcharts-series-" + s10.index) && this.inClass(i10, "highcharts-tracker") || s10.onMouseOut();
        }
        inClass(t10, e10) {
          let i10 = t10, s10;
          for (; i10; ) {
            if (s10 = o1(i10, "class")) {
              if (-1 !== s10.indexOf(e10)) return true;
              if (-1 !== s10.indexOf("highcharts-container")) return false;
            }
            i10 = i10.parentElement;
          }
        }
        constructor(t10, e10) {
          this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e10, this.chart = t10, this.runChartClick = !!e10.chart.events?.click, this.pinchDown = [], this.setDOMEvents(), o6(this, "afterInit");
        }
        normalize(t10, e10) {
          let i10 = t10.touches, s10 = i10 ? i10.length ? i10.item(0) : rt(i10.changedTouches, t10.changedTouches)[0] : t10;
          e10 || (e10 = this.getChartPosition());
          let o10 = s10.pageX - e10.left, r10 = s10.pageY - e10.top;
          return o3(t10, {
            chartX: Math.round(o10 /= e10.scaleX),
            chartY: Math.round(r10 /= e10.scaleY)
          });
        }
        onContainerClick(t10) {
          let e10 = this.chart, i10 = e10.hoverPoint, s10 = this.normalize(t10), o10 = e10.plotLeft, r10 = e10.plotTop;
          !e10.cancelClick && (i10 && this.inClass(s10.target, "highcharts-tracker") ? (o6(i10.series, "click", o3(s10, {
            point: i10
          })), e10.hoverPoint && i10.firePointEvent("click", s10)) : (o3(s10, this.getCoordinates(s10)), e10.isInsidePlot(s10.chartX - o10, s10.chartY - r10, {
            visiblePlotOnly: true
          }) && o6(e10, "click", s10)));
        }
        onContainerMouseDown(t10) {
          let e10 = (1 & (t10.buttons || t10.button)) == 1;
          t10 = this.normalize(t10), O.isFirefox && 0 !== t10.button && this.onContainerMouseMove(t10), (void 0 === t10.button || e10) && (this.zoomOption(t10), e10 && t10.preventDefault?.(), this.dragStart(t10));
        }
        onContainerMouseLeave(t10) {
          let {
            pointer: e10
          } = oK[rt(rs.hoverChartIndex, -1)] || {};
          t10 = this.normalize(t10), this.onContainerMouseMove(t10), e10 && !this.inClass(t10.relatedTarget, "highcharts-tooltip") && (e10.reset(), e10.chartPosition = void 0);
        }
        onContainerMouseEnter() {
          delete this.chartPosition;
        }
        onContainerMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.normalize(t10);
          this.setHoverChartIndex(t10), ("mousedown" === e10.mouseIsDown || this.touchSelect(s10)) && this.drag(s10), !e10.openMenu && (this.inClass(s10.target, "highcharts-tracker") || e10.isInsidePlot(s10.chartX - e10.plotLeft, s10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          })) && !(i10 && i10.shouldStickOnContact(s10)) && (this.inClass(s10.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(s10));
        }
        onDocumentTouchEnd(t10) {
          this.onDocumentMouseUp(t10);
        }
        onContainerTouchMove(t10) {
          this.touchSelect(t10) ? this.onContainerMouseMove(t10) : this.touch(t10);
        }
        onContainerTouchStart(t10) {
          this.touchSelect(t10) ? this.onContainerMouseDown(t10) : (this.zoomOption(t10), this.touch(t10, true));
        }
        onDocumentMouseMove(t10) {
          let e10 = this.chart, i10 = e10.tooltip, s10 = this.chartPosition, o10 = this.normalize(t10, s10);
          !s10 || e10.isInsidePlot(o10.chartX - e10.plotLeft, o10.chartY - e10.plotTop, {
            visiblePlotOnly: true
          }) || i10 && i10.shouldStickOnContact(o10) || o10.target !== e10.container.ownerDocument && this.inClass(o10.target, "highcharts-tracker") || this.reset();
        }
        onDocumentMouseUp(t10) {
          oK[rt(rs.hoverChartIndex, -1)]?.pointer?.drop(t10);
        }
        pinch(t10) {
          let e10 = this, {
            chart: i10,
            hasZoom: s10,
            lastTouches: o10
          } = e10, r10 = [].map.call(t10.touches || [], (t11) => e10.normalize(t11)), n10 = r10.length, a10 = 1 === n10 && (e10.inClass(t10.target, "highcharts-tracker") && i10.runTrackerClick || e10.runChartClick), h10 = i10.tooltip, l10 = 1 === n10 && rt(h10?.options.followTouchMove, true);
          n10 > 1 ? e10.initiated = true : l10 && (e10.initiated = false), s10 && e10.initiated && !a10 && false !== t10.cancelable && t10.preventDefault(), "touchstart" === t10.type ? (e10.pinchDown = r10, e10.res = true, i10.mouseDownX = t10.chartX) : l10 ? this.runPointActions(e10.normalize(t10)) : o10 && (o6(i10, "touchpan", {
            originalEvent: t10,
            touches: r10
          }, () => {
            let e11 = (t11) => {
              let e12 = t11[0], i11 = t11[1] || e12;
              return {
                x: e12.chartX,
                y: e12.chartY,
                width: i11.chartX - e12.chartX,
                height: i11.chartY - e12.chartY
              };
            };
            i10.transform({
              axes: i10.axes.filter((t11) => t11.zoomEnabled && (this.zoomHor && t11.horiz || this.zoomVert && !t11.horiz)),
              to: e11(r10),
              from: e11(o10),
              trigger: t10.type
            });
          }), e10.res && (e10.res = false, this.reset(false, 0))), e10.lastTouches = r10;
        }
        reset(t10, e10) {
          let i10 = this.chart, s10 = i10.hoverSeries, o10 = i10.hoverPoint, r10 = i10.hoverPoints, n10 = i10.tooltip, a10 = n10 && n10.shared ? r10 : o10;
          t10 && a10 && ri(a10).forEach(function(e11) {
            e11.series.isCartesian && void 0 === e11.plotX && (t10 = false);
          }), t10 ? n10 && a10 && ri(a10).length && (n10.refresh(a10), n10.shared && r10 ? r10.forEach(function(t11) {
            t11.setState(t11.state, true), t11.series.isCartesian && (t11.series.xAxis.crosshair && t11.series.xAxis.drawCrosshair(null, t11), t11.series.yAxis.crosshair && t11.series.yAxis.drawCrosshair(null, t11));
          }) : o10 && (o10.setState(o10.state, true), i10.axes.forEach(function(t11) {
            t11.crosshair && o10.series[t11.coll] === t11 && t11.drawCrosshair(null, o10);
          }))) : (o10 && o10.onMouseOut(), r10 && r10.forEach(function(t11) {
            t11.setState();
          }), s10 && s10.onMouseOut(), n10 && n10.hide(e10), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i10.axes.forEach(function(t11) {
            t11.hideCrosshair();
          }), i10.hoverPoints = i10.hoverPoint = void 0);
        }
        runPointActions(t10, e10, i10) {
          let s10 = this.chart, o10 = s10.series, r10 = s10.tooltip && s10.tooltip.options.enabled ? s10.tooltip : void 0, n10 = !!r10 && r10.shared, a10 = e10 || s10.hoverPoint, h10 = a10 && a10.series || s10.hoverSeries, l10 = (!t10 || "touchmove" !== t10.type) && (!!e10 || h10 && h10.directTouch && this.isDirectTouch), d10 = this.getHoverData(a10, h10, o10, l10, n10, t10);
          a10 = d10.hoverPoint, h10 = d10.hoverSeries;
          let c10 = d10.hoverPoints, p10 = h10 && h10.tooltipOptions.followPointer && !h10.tooltipOptions.split, u10 = n10 && h10 && !h10.noSharedTooltip;
          if (a10 && (i10 || a10 !== s10.hoverPoint || r10 && r10.isHidden)) {
            if ((s10.hoverPoints || []).forEach(function(t11) {
              -1 === c10.indexOf(t11) && t11.setState();
            }), s10.hoverSeries !== h10 && h10.onMouseOver(), this.applyInactiveState(c10), (c10 || []).forEach(function(t11) {
              t11.setState("hover");
            }), s10.hoverPoint && s10.hoverPoint.firePointEvent("mouseOut"), !a10.series) return;
            s10.hoverPoints = c10, s10.hoverPoint = a10, a10.firePointEvent("mouseOver", void 0, () => {
              r10 && a10 && r10.refresh(u10 ? c10 : a10, t10);
            });
          } else if (p10 && r10 && !r10.isHidden) {
            let e11 = r10.getAnchor([{}], t10);
            s10.isInsidePlot(e11[0], e11[1], {
              visiblePlotOnly: true
            }) && r10.updatePosition({
              plotX: e11[0],
              plotY: e11[1]
            });
          }
          this.unDocMouseMove || (this.unDocMouseMove = o0(s10.container.ownerDocument, "mousemove", (t11) => oK[rs.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(t11)), this.eventsToUnbind.push(this.unDocMouseMove)), s10.axes.forEach(function(e11) {
            let i11;
            let o11 = rt((e11.crosshair || {}).snap, true);
            !o11 || (i11 = s10.hoverPoint) && i11.series[e11.coll] === e11 || (i11 = o5(c10, (t11) => t11.series && t11.series[e11.coll] === e11)), i11 || !o11 ? e11.drawCrosshair(t10, i11) : e11.hideCrosshair();
          });
        }
        setDOMEvents() {
          let t10 = this.chart.container, e10 = t10.ownerDocument;
          t10.onmousedown = this.onContainerMouseDown.bind(this), t10.onmousemove = this.onContainerMouseMove.bind(this), t10.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(o0(t10, "mouseenter", this.onContainerMouseEnter.bind(this)), o0(t10, "mouseleave", this.onContainerMouseLeave.bind(this))), rs.unbindDocumentMouseUp.some((t11) => t11.doc === e10) || rs.unbindDocumentMouseUp.push({
            doc: e10,
            unbind: o0(e10, "mouseup", this.onDocumentMouseUp.bind(this))
          });
          let i10 = this.chart.renderTo.parentElement;
          for (; i10 && "BODY" !== i10.tagName; ) this.eventsToUnbind.push(o0(i10, "scroll", () => {
            delete this.chartPosition;
          })), i10 = i10.parentElement;
          this.eventsToUnbind.push(o0(t10, "touchstart", this.onContainerTouchStart.bind(this), {
            passive: false
          }), o0(t10, "touchmove", this.onContainerTouchMove.bind(this), {
            passive: false
          })), rs.unbindDocumentTouchEnd || (rs.unbindDocumentTouchEnd = o0(e10, "touchend", this.onDocumentTouchEnd.bind(this), {
            passive: false
          })), this.setPointerCapture(), o0(this.chart, "redraw", this.setPointerCapture.bind(this));
        }
        setPointerCapture() {
          if (!oQ) return;
          let t10 = this.pointerCaptureEventsToUnbind, e10 = this.chart, i10 = e10.container, s10 = rt(e10.options.tooltip?.followTouchMove, true) && e10.series.some((t11) => t11.options.findNearestPointBy.indexOf("y") > -1);
          !this.hasPointerCapture && s10 ? (t10.push(o0(i10, "pointerdown", (t11) => {
            t11.target?.hasPointerCapture(t11.pointerId) && t11.target?.releasePointerCapture(t11.pointerId);
          }), o0(i10, "pointermove", (t11) => {
            e10.pointer?.getPointFromEvent(t11)?.onMouseOver(t11);
          })), e10.styledMode || o2(i10, {
            "touch-action": "none"
          }), i10.className += " highcharts-no-touch-action", this.hasPointerCapture = true) : this.hasPointerCapture && !s10 && (t10.forEach((t11) => t11()), t10.length = 0, e10.styledMode || o2(i10, {
            "touch-action": rt(e10.options.chart.style?.["touch-action"], "manipulation")
          }), i10.className = i10.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = false);
        }
        setHoverChartIndex(t10) {
          let e10 = this.chart, i10 = O.charts[rt(rs.hoverChartIndex, -1)];
          if (i10 && i10 !== e10) {
            let s10 = {
              relatedTarget: e10.container
            };
            t10 && !t10?.relatedTarget && Object.assign({}, t10, s10), i10.pointer?.onContainerMouseLeave(t10 || s10);
          }
          i10 && i10.mouseIsDown || (rs.hoverChartIndex = e10.index);
        }
        touch(t10, e10) {
          let i10;
          let {
            chart: s10,
            pinchDown: o10 = []
          } = this;
          this.setHoverChartIndex(), 1 === (t10 = this.normalize(t10)).touches.length ? s10.isInsidePlot(t10.chartX - s10.plotLeft, t10.chartY - s10.plotTop, {
            visiblePlotOnly: true
          }) && !s10.openMenu ? (e10 && this.runPointActions(t10), "touchmove" === t10.type && (i10 = !!o10[0] && Math.pow(o10[0].chartX - t10.chartX, 2) + Math.pow(o10[0].chartY - t10.chartY, 2) >= 16), rt(i10, true) && this.pinch(t10)) : e10 && this.reset() : 2 === t10.touches.length && this.pinch(t10);
        }
        touchSelect(t10) {
          return !!(this.chart.zooming.singleTouch && t10.touches && 1 === t10.touches.length);
        }
        zoomOption(t10) {
          let e10 = this.chart, i10 = e10.inverted, s10 = e10.zooming.type || "", o10, r10;
          /touch/.test(t10.type) && (s10 = rt(e10.zooming.pinchType, s10)), this.zoomX = o10 = /x/.test(s10), this.zoomY = r10 = /y/.test(s10), this.zoomHor = o10 && !i10 || r10 && i10, this.zoomVert = r10 && !i10 || o10 && i10, this.hasZoom = o10 || r10;
        }
      }
      rs.unbindDocumentMouseUp = [], function(t10) {
        t10.compose = function(e10) {
          re(oJ, "Core.Pointer") && o0(e10, "beforeRender", function() {
            this.pointer = new t10(this, this.options);
          });
        };
      }(rs || (rs = {}));
      let ro = rs, {
        fireEvent: rr,
        isArray: rn,
        objectEach: ra,
        uniqueKey: rh
      } = tt, rl = class {
        constructor(t10 = {}) {
          this.autoId = !t10.id, this.columns = {}, this.id = t10.id || rh(), this.modified = this, this.rowCount = 0, this.versionTag = rh();
          let e10 = 0;
          ra(t10.columns || {}, (t11, i10) => {
            this.columns[i10] = t11.slice(), e10 = Math.max(e10, t11.length);
          }), this.applyRowCount(e10);
        }
        applyRowCount(t10) {
          this.rowCount = t10, ra(this.columns, (e10) => {
            rn(e10) && (e10.length = t10);
          });
        }
        getColumn(t10, e10) {
          return this.columns[t10];
        }
        getColumns(t10, e10) {
          return (t10 || Object.keys(this.columns)).reduce((t11, e11) => (t11[e11] = this.columns[e11], t11), {});
        }
        getRow(t10, e10) {
          return (e10 || Object.keys(this.columns)).map((e11) => this.columns[e11]?.[t10]);
        }
        setColumn(t10, e10 = [], i10 = 0, s10) {
          this.setColumns({
            [t10]: e10
          }, i10, s10);
        }
        setColumns(t10, e10, i10) {
          let s10 = this.rowCount;
          ra(t10, (t11, e11) => {
            this.columns[e11] = t11.slice(), s10 = t11.length;
          }), this.applyRowCount(s10), i10?.silent || (rr(this, "afterSetColumns"), this.versionTag = rh());
        }
        setRow(t10, e10 = this.rowCount, i10, s10) {
          let {
            columns: o10
          } = this, r10 = i10 ? this.rowCount + 1 : e10 + 1;
          ra(t10, (t11, n10) => {
            let a10 = o10[n10] || s10?.addColumns !== false && Array(r10);
            a10 && (i10 ? a10.splice(e10, 0, t11) : a10[e10] = t11, o10[n10] = a10);
          }), r10 > this.rowCount && this.applyRowCount(r10), s10?.silent || (rr(this, "afterSetRows"), this.versionTag = rh());
        }
      }, {
        extend: rd,
        merge: rc,
        pick: rp
      } = tt;
      !function(t10) {
        function e10(t11, e11, i10) {
          let s10 = this.legendItem = this.legendItem || {}, {
            chart: o10,
            options: r10
          } = this, {
            baseline: n10 = 0,
            symbolWidth: a10,
            symbolHeight: h10
          } = t11, l10 = this.symbol || "circle", d10 = h10 / 2, c10 = o10.renderer, p10 = s10.group, u10 = n10 - Math.round((t11.fontMetrics?.b || h10) * (i10 ? 0.4 : 0.3)), g2 = {}, f2, m2 = r10.marker, x2 = 0;
          if (o10.styledMode || (g2["stroke-width"] = Math.min(r10.lineWidth || 0, 24), r10.dashStyle ? g2.dashstyle = r10.dashStyle : "square" === r10.linecap || (g2["stroke-linecap"] = "round")), s10.line = c10.path().addClass("highcharts-graph").attr(g2).add(p10), i10 && (s10.area = c10.path().addClass("highcharts-area").add(p10)), g2["stroke-linecap"] && (x2 = Math.min(s10.line.strokeWidth(), a10) / 2), a10) {
            let t12 = [["M", x2, u10], ["L", a10 - x2, u10]];
            s10.line.attr({
              d: t12
            }), s10.area?.attr({
              d: [...t12, ["L", a10 - x2, n10], ["L", x2, n10]]
            });
          }
          if (m2 && false !== m2.enabled && a10) {
            let t12 = Math.min(rp(m2.radius, d10), d10);
            0 === l10.indexOf("url") && (m2 = rc(m2, {
              width: h10,
              height: h10
            }), t12 = 0), s10.symbol = f2 = c10.symbol(l10, a10 / 2 - t12, u10 - t12, 2 * t12, 2 * t12, rd({
              context: "legend"
            }, m2)).addClass("highcharts-point").add(p10), f2.isMarker = true;
          }
        }
        t10.areaMarker = function(t11, i10) {
          e10.call(this, t11, i10, true);
        }, t10.lineMarker = e10, t10.rectangle = function(t11, e11) {
          let i10 = e11.legendItem || {}, s10 = t11.options, o10 = t11.symbolHeight, r10 = s10.squareSymbol, n10 = r10 ? o10 : t11.symbolWidth;
          i10.symbol = this.chart.renderer.rect(r10 ? (t11.symbolWidth - o10) / 2 : 0, t11.baseline - o10 + 1, n10, o10, rp(t11.options.symbolRadius, o10 / 2)).addClass("highcharts-point").attr({
            zIndex: 3
          }).add(i10.group);
        };
      }(u || (u = {}));
      let ru = u, {
        defaultOptions: rg
      } = tS, {
        extend: rf,
        extendClass: rm,
        merge: rx
      } = tt;
      !function(t10) {
        function e10(e11, i10) {
          let s10 = rg.plotOptions || {}, o10 = i10.defaultOptions, r10 = i10.prototype;
          return r10.type = e11, r10.pointClass || (r10.pointClass = oq), !t10.seriesTypes[e11] && (o10 && (s10[e11] = o10), t10.seriesTypes[e11] = i10, true);
        }
        t10.seriesTypes = O.seriesTypes, t10.registerSeriesType = e10, t10.seriesType = function(i10, s10, o10, r10, n10) {
          let a10 = rg.plotOptions || {};
          if (s10 = s10 || "", a10[i10] = rx(a10[s10], o10), delete t10.seriesTypes[i10], e10(i10, rm(t10.seriesTypes[s10] || function() {
          }, r10)), t10.seriesTypes[i10].prototype.type = i10, n10) {
            class e11 extends oq {
            }
            rf(e11.prototype, n10), t10.seriesTypes[i10].prototype.pointClass = e11;
          }
          return t10.seriesTypes[i10];
        };
      }(g || (g = {}));
      let ry = g, {
        animObject: rb,
        setAnimation: rv
      } = tU, {
        defaultOptions: rM
      } = tS, {
        registerEventOptions: rk
      } = se, {
        svg: rw,
        win: rS
      } = O, {
        seriesTypes: rA
      } = ry, {
        arrayMax: rT,
        arrayMin: rP,
        clamp: rC,
        correctFloat: rO,
        crisp: rE,
        defined: rL,
        destroyObjectProperties: rB,
        diffObjects: rI,
        erase: rD,
        error: rR,
        extend: rN,
        find: rz,
        fireEvent: rW,
        getClosestDistance: rG,
        getNestedProperty: rH,
        insertItem: rF,
        isArray: rX,
        isNumber: rY,
        isString: rj,
        merge: rU,
        objectEach: rV,
        pick: r$,
        removeEvent: r_,
        syncTimeout: rq
      } = tt;
      class rZ {
        constructor() {
          this.zoneAxis = "y";
        }
        init(t10, e10) {
          let i10;
          rW(this, "init", {
            options: e10
          }), this.dataTable ?? (this.dataTable = new rl());
          let s10 = t10.series;
          this.eventsToUnbind = [], this.chart = t10, this.options = this.setOptions(e10);
          let o10 = this.options, r10 = false !== o10.visible;
          this.linkedSeries = [], this.bindAxes(), rN(this, {
            name: o10.name,
            state: "",
            visible: r10,
            selected: true === o10.selected
          }), rk(this, o10);
          let n10 = o10.events;
          (n10 && n10.click || o10.point && o10.point.events && o10.point.events.click || o10.allowPointSelect) && (t10.runTrackerClick = true), this.getColor(), this.getSymbol(), this.isCartesian && (t10.hasCartesianSeries = true), s10.length && (i10 = s10[s10.length - 1]), this._i = r$(i10 && i10._i, -1) + 1, this.opacity = this.options.opacity, t10.orderItems("series", rF(this, s10)), o10.dataSorting && o10.dataSorting.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o10.data, false), rW(this, "afterInit");
        }
        is(t10) {
          return rA[t10] && this instanceof rA[t10];
        }
        bindAxes() {
          let t10;
          let e10 = this, i10 = e10.options, s10 = e10.chart;
          rW(this, "bindAxes", null, function() {
            (e10.axisTypes || []).forEach(function(o10) {
              (s10[o10] || []).forEach(function(s11) {
                t10 = s11.options, (r$(i10[o10], 0) === s11.index || void 0 !== i10[o10] && i10[o10] === t10.id) && (rF(e10, s11.series), e10[o10] = s11, s11.isDirty = true);
              }), e10[o10] || e10.optionalAxis === o10 || rR(18, true, s10);
            });
          }), rW(this, "afterBindAxes");
        }
        hasData() {
          return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;
        }
        hasMarkerChanged(t10, e10) {
          let i10 = t10.marker, s10 = e10.marker || {};
          return i10 && (s10.enabled && !i10.enabled || s10.symbol !== i10.symbol || s10.height !== i10.height || s10.width !== i10.width);
        }
        autoIncrement(t10) {
          let e10;
          let i10 = this.options, {
            pointIntervalUnit: s10,
            relativeXValue: o10
          } = this.options, r10 = this.chart.time, n10 = this.xIncrement ?? r10.parse(i10.pointStart) ?? 0;
          if (this.pointInterval = e10 = r$(this.pointInterval, i10.pointInterval, 1), o10 && rY(t10) && (e10 *= t10), s10) {
            let t11 = r10.toParts(n10);
            "day" === s10 ? t11[2] += e10 : "month" === s10 ? t11[1] += e10 : "year" === s10 && (t11[0] += e10), e10 = r10.makeTime.apply(r10, t11) - n10;
          }
          return o10 && rY(t10) ? n10 + e10 : (this.xIncrement = n10 + e10, n10);
        }
        setDataSortingOptions() {
          let t10 = this.options;
          rN(this, {
            requireSorting: false,
            sorted: false,
            enabledDataSorting: true,
            allowDG: false
          }), rL(t10.pointRange) || (t10.pointRange = 1);
        }
        setOptions(t10) {
          let e10;
          let i10 = this.chart, s10 = i10.options.plotOptions, o10 = i10.userOptions || {}, r10 = rU(t10), n10 = i10.styledMode, a10 = {
            plotOptions: s10,
            userOptions: r10
          };
          rW(this, "setOptions", a10);
          let h10 = a10.plotOptions[this.type], l10 = o10.plotOptions || {}, d10 = l10.series || {}, c10 = rM.plotOptions[this.type] || {}, p10 = l10[this.type] || {};
          this.userOptions = a10.userOptions;
          let u10 = rU(h10, s10.series, p10, r10);
          this.tooltipOptions = rU(rM.tooltip, rM.plotOptions.series?.tooltip, c10?.tooltip, i10.userOptions.tooltip, l10.series?.tooltip, p10.tooltip, r10.tooltip), this.stickyTracking = r$(r10.stickyTracking, p10.stickyTracking, d10.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || u10.stickyTracking), null === h10.marker && delete u10.marker, this.zoneAxis = u10.zoneAxis || "y";
          let g2 = this.zones = (u10.zones || []).map((t11) => __spreadValues({}, t11));
          return (u10.negativeColor || u10.negativeFillColor) && !u10.zones && (e10 = {
            value: u10[this.zoneAxis + "Threshold"] || u10.threshold || 0,
            className: "highcharts-negative"
          }, n10 || (e10.color = u10.negativeColor, e10.fillColor = u10.negativeFillColor), g2.push(e10)), g2.length && rL(g2[g2.length - 1].value) && g2.push(n10 ? {} : {
            color: this.color,
            fillColor: this.fillColor
          }), rW(this, "afterSetOptions", {
            options: u10
          }), u10;
        }
        getName() {
          return r$(this.options.name, "Series " + (this.index + 1));
        }
        getCyclic(t10, e10, i10) {
          let s10, o10;
          let r10 = this.chart, n10 = `${t10}Index`, a10 = `${t10}Counter`, h10 = i10?.length || r10.options.chart.colorCount;
          !e10 && (rL(o10 = r$("color" === t10 ? this.options.colorIndex : void 0, this[n10])) ? s10 = o10 : (r10.series.length || (r10[a10] = 0), s10 = r10[a10] % h10, r10[a10] += 1), i10 && (e10 = i10[s10])), void 0 !== s10 && (this[n10] = s10), this[t10] = e10;
        }
        getColor() {
          this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || rM.plotOptions[this.type].color, this.chart.options.colors);
        }
        getPointsCollection() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        }
        getSymbol() {
          let t10 = this.options.marker;
          this.getCyclic("symbol", t10.symbol, this.chart.options.symbols);
        }
        getColumn(t10, e10) {
          return (e10 ? this.dataTable.modified : this.dataTable).getColumn(t10, true) || [];
        }
        findPointIndex(t10, e10) {
          let i10, s10, o10;
          let r10 = t10.id, n10 = t10.x, a10 = this.points, h10 = this.options.dataSorting;
          if (r10) {
            let t11 = this.chart.get(r10);
            t11 instanceof oq && (i10 = t11);
          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            let e11 = (e12) => !e12.touched && e12.index === t10.index;
            if (h10 && h10.matchByName ? e11 = (e12) => !e12.touched && e12.name === t10.name : this.options.relativeXValue && (e11 = (e12) => !e12.touched && e12.options.x === t10.x), !(i10 = rz(a10, e11))) return;
          }
          return i10 && void 0 !== (o10 = i10 && i10.index) && (s10 = true), void 0 === o10 && rY(n10) && (o10 = this.getColumn("x").indexOf(n10, e10)), -1 !== o10 && void 0 !== o10 && this.cropped && (o10 = o10 >= this.cropStart ? o10 - this.cropStart : o10), !s10 && rY(o10) && a10[o10] && a10[o10].touched && (o10 = void 0), o10;
        }
        updateData(t10, e10) {
          let i10 = this.options, s10 = i10.dataSorting, o10 = this.points, r10 = [], n10 = this.requireSorting, a10 = t10.length === o10.length, h10, l10, d10, c10, p10 = true;
          if (this.xIncrement = null, t10.forEach(function(t11, e11) {
            let l11;
            let d11 = rL(t11) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, t11) || {}, p11 = d11.x;
            d11.id || rY(p11) ? (-1 === (l11 = this.findPointIndex(d11, c10)) || void 0 === l11 ? r10.push(t11) : o10[l11] && t11 !== i10.data[l11] ? (o10[l11].update(t11, false, null, false), o10[l11].touched = true, n10 && (c10 = l11 + 1)) : o10[l11] && (o10[l11].touched = true), (!a10 || e11 !== l11 || s10 && s10.enabled || this.hasDerivedData) && (h10 = true)) : r10.push(t11);
          }, this), h10) for (l10 = o10.length; l10--; ) (d10 = o10[l10]) && !d10.touched && d10.remove && d10.remove(false, e10);
          else !a10 || s10 && s10.enabled ? p10 = false : (t10.forEach(function(t11, e11) {
            t11 === o10[e11].y || o10[e11].destroyed || o10[e11].update(t11, false, null, false);
          }), r10.length = 0);
          if (o10.forEach(function(t11) {
            t11 && (t11.touched = false);
          }), !p10) return false;
          r10.forEach(function(t11) {
            this.addPoint(t11, false, null, null, false);
          }, this);
          let u10 = this.getColumn("x");
          return null === this.xIncrement && u10.length && (this.xIncrement = rT(u10), this.autoIncrement()), true;
        }
        dataColumnKeys() {
          return ["x", ...this.pointArrayMap || ["y"]];
        }
        setData(t10, e10 = true, i10, s10) {
          let o10 = this.points, r10 = o10 && o10.length || 0, n10 = this.options, a10 = this.chart, h10 = n10.dataSorting, l10 = this.xAxis, d10 = n10.turboThreshold, c10 = this.dataTable, p10 = this.dataColumnKeys(), u10 = this.pointValKey || "y", g2 = (this.pointArrayMap || []).length, f2 = n10.keys, m2, x2, y2 = 0, b2 = 1, v2;
          a10.options.chart.allowMutatingData || (n10.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v2 = rU(true, t10));
          let M2 = (t10 = v2 || t10 || []).length;
          if (h10 && h10.enabled && (t10 = this.sortData(t10)), a10.options.chart.allowMutatingData && false !== s10 && M2 && r10 && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x2 = this.updateData(t10, i10)), !x2) {
            this.xIncrement = null, this.colorCounter = 0;
            let e11 = d10 && M2 > d10;
            if (e11) {
              let i11 = this.getFirstValidPoint(t10), s11 = this.getFirstValidPoint(t10, M2 - 1, -1), o11 = (t11) => !!(rX(t11) && (f2 || rY(t11[0])));
              if (rY(i11) && rY(s11)) {
                let e12 = [], i12 = [];
                for (let s12 of t10) e12.push(this.autoIncrement()), i12.push(s12);
                c10.setColumns({
                  x: e12,
                  [u10]: i12
                });
              } else if (o11(i11) && o11(s11)) {
                if (g2) {
                  let e12 = i11.length === g2 ? 1 : 0, s12 = Array(p10.length).fill(0).map(() => []);
                  for (let i12 of t10) {
                    e12 && s12[0].push(this.autoIncrement());
                    for (let t11 = e12; t11 <= g2; t11++) s12[t11]?.push(i12[t11 - e12]);
                  }
                  c10.setColumns(p10.reduce((t11, e13, i12) => (t11[e13] = s12[i12], t11), {}));
                } else {
                  f2 && (y2 = f2.indexOf("x"), b2 = f2.indexOf("y"), y2 = y2 >= 0 ? y2 : 0, b2 = b2 >= 0 ? b2 : 1), 1 === i11.length && (b2 = 0);
                  let e12 = [], s12 = [];
                  if (y2 === b2) for (let i12 of t10) e12.push(this.autoIncrement()), s12.push(i12[b2]);
                  else for (let i12 of t10) e12.push(i12[y2]), s12.push(i12[b2]);
                  c10.setColumns({
                    x: e12,
                    [u10]: s12
                  });
                }
              } else e11 = false;
            }
            if (!e11) {
              let e12 = p10.reduce((t11, e13) => (t11[e13] = [], t11), {});
              for (m2 = 0; m2 < M2; m2++) {
                let i11 = this.pointClass.prototype.applyOptions.apply({
                  series: this
                }, [t10[m2]]);
                for (let t11 of p10) e12[t11][m2] = i11[t11];
              }
              c10.setColumns(e12);
            }
            for (rj(this.getColumn("y")[0]) && rR(14, true, a10), this.data = [], this.options.data = this.userOptions.data = t10, m2 = r10; m2--; ) o10[m2]?.destroy();
            l10 && (l10.minRange = l10.userMinRange), this.isDirty = a10.isDirtyBox = true, this.isDirtyData = !!o10, i10 = false;
          }
          "point" === n10.legendType && (this.processData(), this.generatePoints()), e10 && a10.redraw(i10);
        }
        sortData(t10) {
          let e10 = this, i10 = e10.options.dataSorting.sortKey || "y", s10 = function(t11, e11) {
            return rL(e11) && t11.pointClass.prototype.optionsToObject.call({
              series: t11
            }, e11) || {};
          };
          return t10.forEach(function(i11, o10) {
            t10[o10] = s10(e10, i11), t10[o10].index = o10;
          }, this), t10.concat().sort((t11, e11) => {
            let s11 = rH(i10, t11), o10 = rH(i10, e11);
            return o10 < s11 ? -1 : o10 > s11 ? 1 : 0;
          }).forEach(function(t11, e11) {
            t11.x = e11;
          }, this), e10.linkedSeries && e10.linkedSeries.forEach(function(e11) {
            let i11 = e11.options, o10 = i11.data;
            i11.dataSorting && i11.dataSorting.enabled || !o10 || (o10.forEach(function(i12, r10) {
              o10[r10] = s10(e11, i12), t10[r10] && (o10[r10].x = t10[r10].x, o10[r10].index = r10);
            }), e11.setData(o10, false));
          }), t10;
        }
        getProcessedData(t10) {
          let e10 = this, {
            dataTable: i10,
            isCartesian: s10,
            options: o10,
            xAxis: r10
          } = e10, n10 = o10.cropThreshold, a10 = t10 || e10.getExtremesFromAll, h10 = r10?.logarithmic, l10 = i10.rowCount, d10, c10, p10 = 0, u10, g2, f2, m2 = e10.getColumn("x"), x2 = i10, y2 = false;
          return r10 && (g2 = (u10 = r10.getExtremes()).min, f2 = u10.max, y2 = !!(r10.categories && !r10.names.length), s10 && e10.sorted && !a10 && (!n10 || l10 > n10 || e10.forceCrop) && (m2[l10 - 1] < g2 || m2[0] > f2 ? x2 = new rl() : e10.getColumn(e10.pointValKey || "y").length && (m2[0] < g2 || m2[l10 - 1] > f2) && (x2 = (d10 = this.cropData(i10, g2, f2)).modified, p10 = d10.start, c10 = true))), m2 = x2.getColumn("x") || [], {
            modified: x2,
            cropped: c10,
            cropStart: p10,
            closestPointRange: rG([h10 ? m2.map(h10.log2lin) : m2], () => e10.requireSorting && !y2 && rR(15, false, e10.chart))
          };
        }
        processData(t10) {
          let e10 = this.xAxis, i10 = this.dataTable;
          if (this.isCartesian && !this.isDirty && !e10.isDirty && !this.yAxis.isDirty && !t10) return false;
          let s10 = this.getProcessedData();
          i10.modified = s10.modified, this.cropped = s10.cropped, this.cropStart = s10.cropStart, this.closestPointRange = this.basePointRange = s10.closestPointRange, rW(this, "afterProcessData");
        }
        cropData(t10, e10, i10) {
          let s10 = t10.getColumn("x", true) || [], o10 = s10.length, r10 = {}, n10, a10, h10 = 0, l10 = o10;
          for (n10 = 0; n10 < o10; n10++) if (s10[n10] >= e10) {
            h10 = Math.max(0, n10 - 1);
            break;
          }
          for (a10 = n10; a10 < o10; a10++) if (s10[a10] > i10) {
            l10 = a10 + 1;
            break;
          }
          for (let e11 of this.dataColumnKeys()) {
            let i11 = t10.getColumn(e11, true);
            i11 && (r10[e11] = i11.slice(h10, l10));
          }
          return {
            modified: new rl({
              columns: r10
            }),
            start: h10,
            end: l10
          };
        }
        generatePoints() {
          let t10 = this.options, e10 = this.processedData || t10.data, i10 = this.dataTable.modified, s10 = this.getColumn("x", true), o10 = this.pointClass, r10 = i10.rowCount, n10 = this.cropStart || 0, a10 = this.hasGroupedData, h10 = t10.keys, l10 = [], d10 = t10.dataGrouping && t10.dataGrouping.groupAll ? n10 : 0, c10 = this.xAxis?.categories, p10 = this.pointArrayMap || ["y"], u10 = this.dataColumnKeys(), g2, f2, m2, x2, y2 = this.data, b2;
          if (!y2 && !a10) {
            let t11 = [];
            t11.length = e10?.length || 0, y2 = this.data = t11;
          }
          for (h10 && a10 && (this.options.keys = false), x2 = 0; x2 < r10; x2++) f2 = n10 + x2, a10 ? ((m2 = new o10(this, i10.getRow(x2, u10) || [])).dataGroup = this.groupMap[d10 + x2], m2.dataGroup?.options && (m2.options = m2.dataGroup.options, rN(m2, m2.dataGroup.options), delete m2.dataLabels)) : (m2 = y2[f2], b2 = e10 ? e10[f2] : i10.getRow(x2, p10), m2 || void 0 === b2 || (y2[f2] = m2 = new o10(this, b2, s10[x2]))), m2 && (m2.index = a10 ? d10 + x2 : f2, l10[x2] = m2, m2.category = c10?.[m2.x] ?? m2.x, m2.key = m2.name ?? m2.category);
          if (this.options.keys = h10, y2 && (r10 !== (g2 = y2.length) || a10)) for (x2 = 0; x2 < g2; x2++) x2 !== n10 || a10 || (x2 += r10), y2[x2] && (y2[x2].destroyElements(), y2[x2].plotX = void 0);
          this.data = y2, this.points = l10, rW(this, "afterGeneratePoints");
        }
        getXExtremes(t10) {
          return {
            min: rP(t10),
            max: rT(t10)
          };
        }
        getExtremes(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = e10 || this.getExtremesFromAll || this.options.getExtremesFromAll, r10 = o10 && this.cropped ? this.dataTable : this.dataTable.modified, n10 = r10.rowCount, a10 = t10 || this.stackedYData, h10 = a10 ? [a10] : (this.keysAffectYAxis || this.pointArrayMap || ["y"])?.map((t11) => r10.getColumn(t11, true) || []) || [], l10 = this.getColumn("x", true), d10 = [], c10 = this.requireSorting && !this.is("column") ? 1 : 0, p10 = !!s10 && s10.positiveValuesOnly, u10 = o10 || this.cropped || !i10, g2, f2, m2, x2 = 0, y2 = 0;
          for (i10 && (x2 = (g2 = i10.getExtremes()).min, y2 = g2.max), m2 = 0; m2 < n10; m2++) if (f2 = l10[m2], u10 || (l10[m2 + c10] || f2) >= x2 && (l10[m2 - c10] || f2) <= y2) for (let t11 of h10) {
            let e11 = t11[m2];
            rY(e11) && (e11 > 0 || !p10) && d10.push(e11);
          }
          let b2 = {
            activeYData: d10,
            dataMin: rP(d10),
            dataMax: rT(d10)
          };
          return rW(this, "afterGetExtremes", {
            dataExtremes: b2
          }), b2;
        }
        applyExtremes() {
          let t10 = this.getExtremes();
          return this.dataMin = t10.dataMin, this.dataMax = t10.dataMax, t10;
        }
        getFirstValidPoint(t10, e10 = 0, i10 = 1) {
          let s10 = t10.length, o10 = e10;
          for (; o10 >= 0 && o10 < s10; ) {
            if (rL(t10[o10])) return t10[o10];
            o10 += i10;
          }
        }
        translate() {
          this.generatePoints();
          let t10 = this.options, e10 = t10.stacking, i10 = this.xAxis, s10 = this.enabledDataSorting, o10 = this.yAxis, r10 = this.points, n10 = r10.length, a10 = this.pointPlacementToXValue(), h10 = !!a10, l10 = t10.threshold, d10 = t10.startFromThreshold ? l10 : 0, c10, p10, u10, g2, f2 = Number.MAX_VALUE;
          function m2(t11) {
            return rC(t11, -1e9, 1e9);
          }
          for (c10 = 0; c10 < n10; c10++) {
            let t11;
            let n11 = r10[c10], x2 = n11.x, y2, b2, v2 = n11.y, M2 = n11.low, k2 = e10 && o10.stacking?.stacks[(this.negStacks && v2 < (d10 ? 0 : l10) ? "-" : "") + this.stackKey];
            p10 = i10.translate(x2, false, false, false, true, a10), n11.plotX = rY(p10) ? rO(m2(p10)) : void 0, e10 && this.visible && k2 && k2[x2] && (g2 = this.getStackIndicator(g2, x2, this.index), !n11.isNull && g2.key && (b2 = (y2 = k2[x2]).points[g2.key]), y2 && rX(b2) && (M2 = b2[0], v2 = b2[1], M2 === d10 && g2.key === k2[x2].base && (M2 = r$(rY(l10) ? l10 : o10.min)), o10.positiveValuesOnly && rL(M2) && M2 <= 0 && (M2 = void 0), n11.total = n11.stackTotal = r$(y2.total), n11.percentage = rL(n11.y) && y2.total ? n11.y / y2.total * 100 : void 0, n11.stackY = v2, this.irregularWidths || y2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), n11.yBottom = rL(M2) ? m2(o10.translate(M2, false, true, false, true)) : void 0, this.dataModify && (v2 = this.dataModify.modifyValue(v2, c10)), rY(v2) && void 0 !== n11.plotX && (t11 = rY(t11 = o10.translate(v2, false, true, false, true)) ? m2(t11) : void 0), n11.plotY = t11, n11.isInside = this.isPointInside(n11), n11.clientX = h10 ? rO(i10.translate(x2, false, false, false, true, a10)) : p10, n11.negative = (n11.y || 0) < (l10 || 0), n11.isNull || false === n11.visible || (void 0 !== u10 && (f2 = Math.min(f2, Math.abs(p10 - u10))), u10 = p10), n11.zone = this.zones.length ? n11.getZone() : void 0, !n11.graphic && this.group && s10 && (n11.isNew = true);
          }
          this.closestPointRangePx = f2, rW(this, "afterTranslate");
        }
        getValidPoints(t10, e10, i10) {
          let s10 = this.chart;
          return (t10 || this.points || []).filter(function(t11) {
            let {
              plotX: o10,
              plotY: r10
            } = t11;
            return !!((i10 || !t11.isNull && rY(r10)) && (!e10 || s10.isInsidePlot(o10, r10, {
              inverted: s10.inverted
            }))) && false !== t11.visible;
          });
        }
        getClipBox() {
          let {
            chart: t10,
            xAxis: e10,
            yAxis: i10
          } = this, {
            x: s10,
            y: o10,
            width: r10,
            height: n10
          } = rU(t10.clipBox);
          return e10 && e10.len !== t10.plotSizeX && (r10 = e10.len), i10 && i10.len !== t10.plotSizeY && (n10 = i10.len), t10.inverted && !this.invertible && ([r10, n10] = [n10, r10]), {
            x: s10,
            y: o10,
            width: r10,
            height: n10
          };
        }
        getSharedClipKey() {
          return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
        }
        setClip() {
          let {
            chart: t10,
            group: e10,
            markerGroup: i10
          } = this, s10 = t10.sharedClips, o10 = t10.renderer, r10 = this.getClipBox(), n10 = this.getSharedClipKey(), a10 = s10[n10];
          a10 ? a10.animate(r10) : s10[n10] = a10 = o10.clipRect(r10), e10 && e10.clip(false === this.options.clip ? void 0 : a10), i10 && i10.clip();
        }
        animate(t10) {
          let {
            chart: e10,
            group: i10,
            markerGroup: s10
          } = this, o10 = e10.inverted, r10 = rb(this.options.animation), n10 = [this.getSharedClipKey(), r10.duration, r10.easing, r10.defer].join(","), a10 = e10.sharedClips[n10], h10 = e10.sharedClips[n10 + "m"];
          if (t10 && i10) {
            let t11 = this.getClipBox();
            if (a10) a10.attr("height", t11.height);
            else {
              t11.width = 0, o10 && (t11.x = e10.plotHeight), a10 = e10.renderer.clipRect(t11), e10.sharedClips[n10] = a10;
              let i11 = {
                x: -99,
                y: -99,
                width: o10 ? e10.plotWidth + 199 : 99,
                height: o10 ? 99 : e10.plotHeight + 199
              };
              h10 = e10.renderer.clipRect(i11), e10.sharedClips[n10 + "m"] = h10;
            }
            i10.clip(a10), s10?.clip(h10);
          } else if (a10 && !a10.hasClass("highcharts-animating")) {
            let t11 = this.getClipBox(), i11 = r10.step;
            (s10?.element.childNodes.length || e10.series.length > 1) && (r10.step = function(t12, e11) {
              i11 && i11.apply(e11, arguments), "width" === e11.prop && h10?.element && h10.attr(o10 ? "height" : "width", t12 + 99);
            }), a10.addClass("highcharts-animating").animate(t11, r10);
          }
        }
        afterAnimate() {
          this.setClip(), rV(this.chart.sharedClips, (t10, e10, i10) => {
            t10 && !this.chart.container.querySelector(`[clip-path="url(#${t10.id})"]`) && (t10.destroy(), delete i10[e10]);
          }), this.finishedAnimating = true, rW(this, "afterAnimate");
        }
        drawPoints(t10 = this.points) {
          let e10, i10, s10, o10, r10, n10, a10;
          let h10 = this.chart, l10 = h10.styledMode, {
            colorAxis: d10,
            options: c10
          } = this, p10 = c10.marker, u10 = this[this.specialGroup || "markerGroup"], g2 = this.xAxis, f2 = r$(p10.enabled, !g2 || !!g2.isRadial || null, this.closestPointRangePx >= p10.enabledThreshold * p10.radius);
          if (false !== p10.enabled || this._hasPointMarkers) for (e10 = 0; e10 < t10.length; e10++) if (o10 = (s10 = (i10 = t10[e10]).graphic) ? "animate" : "attr", r10 = i10.marker || {}, n10 = !!i10.marker, (f2 && void 0 === r10.enabled || r10.enabled) && !i10.isNull && false !== i10.visible) {
            let t11 = r$(r10.symbol, this.symbol, "rect");
            a10 = this.markerAttribs(i10, i10.selected && "select"), this.enabledDataSorting && (i10.startXPos = g2.reversed ? -(a10.width || 0) : g2.width);
            let e11 = false !== i10.isInside;
            if (!s10 && e11 && ((a10.width || 0) > 0 || i10.hasImage) && (i10.graphic = s10 = h10.renderer.symbol(t11, a10.x, a10.y, a10.width, a10.height, n10 ? r10 : p10).add(u10), this.enabledDataSorting && h10.hasRendered && (s10.attr({
              x: i10.startXPos
            }), o10 = "animate")), s10 && "animate" === o10 && s10[e11 ? "show" : "hide"](e11).animate(a10), s10) {
              let t12 = this.pointAttribs(i10, l10 || !i10.selected ? void 0 : "select");
              l10 ? d10 && s10.css({
                fill: t12.fill
              }) : s10[o10](t12);
            }
            s10 && s10.addClass(i10.getClassName(), true);
          } else s10 && (i10.graphic = s10.destroy());
        }
        markerAttribs(t10, e10) {
          let i10 = this.options, s10 = i10.marker, o10 = t10.marker || {}, r10 = o10.symbol || s10.symbol, n10 = {}, a10, h10, l10 = r$(o10.radius, s10 && s10.radius);
          e10 && (a10 = s10.states[e10], l10 = r$((h10 = o10.states && o10.states[e10]) && h10.radius, a10 && a10.radius, l10 && l10 + (a10 && a10.radiusPlus || 0))), t10.hasImage = r10 && 0 === r10.indexOf("url"), t10.hasImage && (l10 = 0);
          let d10 = t10.pos();
          return rY(l10) && d10 && (i10.crisp && (d10[0] = rE(d10[0], t10.hasImage ? 0 : "rect" === r10 ? s10?.lineWidth || 0 : 1)), n10.x = d10[0] - l10, n10.y = d10[1] - l10), l10 && (n10.width = n10.height = 2 * l10), n10;
        }
        pointAttribs(t10, e10) {
          let i10 = this.options.marker, s10 = t10 && t10.options, o10 = s10 && s10.marker || {}, r10 = s10 && s10.color, n10 = t10 && t10.color, a10 = t10 && t10.zone && t10.zone.color, h10, l10, d10 = this.color, c10, p10, u10 = r$(o10.lineWidth, i10.lineWidth), g2 = 1;
          return d10 = r10 || a10 || n10 || d10, c10 = o10.fillColor || i10.fillColor || d10, p10 = o10.lineColor || i10.lineColor || d10, e10 = e10 || "normal", h10 = i10.states[e10] || {}, u10 = r$((l10 = o10.states && o10.states[e10] || {}).lineWidth, h10.lineWidth, u10 + r$(l10.lineWidthPlus, h10.lineWidthPlus, 0)), c10 = l10.fillColor || h10.fillColor || c10, {
            stroke: p10 = l10.lineColor || h10.lineColor || p10,
            "stroke-width": u10,
            fill: c10,
            opacity: g2 = r$(l10.opacity, h10.opacity, g2)
          };
        }
        destroy(t10) {
          let e10, i10, s10;
          let o10 = this, r10 = o10.chart, n10 = /AppleWebKit\/533/.test(rS.navigator.userAgent), a10 = o10.data || [];
          for (rW(o10, "destroy", {
            keepEventsForUpdate: t10
          }), this.removeEvents(t10), (o10.axisTypes || []).forEach(function(t11) {
            (s10 = o10[t11]) && s10.series && (rD(s10.series, o10), s10.isDirty = s10.forceRedraw = true);
          }), o10.legendItem && o10.chart.legend.destroyItem(o10), e10 = a10.length; e10--; ) (i10 = a10[e10]) && i10.destroy && i10.destroy();
          for (let t11 of o10.zones) rB(t11, void 0, true);
          tt.clearTimeout(o10.animationTimeout), rV(o10, function(t11, e11) {
            t11 instanceof eJ && !t11.survive && t11[n10 && "group" === e11 ? "hide" : "destroy"]();
          }), r10.hoverSeries === o10 && (r10.hoverSeries = void 0), rD(r10.series, o10), r10.orderItems("series"), rV(o10, function(e11, i11) {
            t10 && "hcEvents" === i11 || delete o10[i11];
          });
        }
        applyZones() {
          let {
            area: t10,
            chart: e10,
            graph: i10,
            zones: s10,
            points: o10,
            xAxis: r10,
            yAxis: n10,
            zoneAxis: a10
          } = this, {
            inverted: h10,
            renderer: l10
          } = e10, d10 = this[`${a10}Axis`], {
            isXAxis: c10,
            len: p10 = 0,
            minPointOffset: u10 = 0
          } = d10 || {}, g2 = (i10?.strokeWidth() || 0) / 2 + 1, f2 = (t11, e11 = 0, i11 = 0) => {
            h10 && (i11 = p10 - i11);
            let {
              translated: s11 = 0,
              lineClip: o11
            } = t11, r11 = i11 - s11;
            o11?.push(["L", e11, Math.abs(r11) < g2 ? i11 - g2 * (r11 <= 0 ? -1 : 1) : s11]);
          };
          if (s10.length && (i10 || t10) && d10 && rY(d10.min)) {
            let e11 = d10.getExtremes().max + u10, g3 = (t11) => {
              t11.forEach((e12, i11) => {
                ("M" === e12[0] || "L" === e12[0]) && (t11[i11] = [e12[0], c10 ? p10 - e12[1] : e12[1], c10 ? e12[2] : p10 - e12[2]]);
              });
            };
            if (s10.forEach((t11) => {
              t11.lineClip = [], t11.translated = rC(d10.toPixels(r$(t11.value, e11), true) || 0, 0, p10);
            }), i10 && !this.showLine && i10.hide(), t10 && t10.hide(), "y" === a10 && o10.length < r10.len) for (let t11 of o10) {
              let {
                plotX: e12,
                plotY: i11,
                zone: o11
              } = t11, r11 = o11 && s10[s10.indexOf(o11) - 1];
              o11 && f2(o11, e12, i11), r11 && f2(r11, e12, i11);
            }
            let m2 = [], x2 = d10.toPixels(d10.getExtremes().min - u10, true);
            s10.forEach((e12) => {
              let s11 = e12.lineClip || [], o11 = Math.round(e12.translated || 0);
              r10.reversed && s11.reverse();
              let {
                clip: a11,
                simpleClip: d11
              } = e12, p11 = 0, u11 = 0, f3 = r10.len, y2 = n10.len;
              c10 ? (p11 = o11, f3 = x2) : (u11 = o11, y2 = x2);
              let b2 = [["M", p11, u11], ["L", f3, u11], ["L", f3, y2], ["L", p11, y2], ["Z"]], v2 = [b2[0], ...s11, b2[1], b2[2], ...m2, b2[3], b2[4]];
              m2 = s11.reverse(), x2 = o11, h10 && (g3(v2), t10 && g3(b2)), a11 ? (a11.animate({
                d: v2
              }), d11?.animate({
                d: b2
              })) : (a11 = e12.clip = l10.path(v2), t10 && (d11 = e12.simpleClip = l10.path(b2))), i10 && e12.graph?.clip(a11), t10 && e12.area?.clip(d11);
            });
          } else this.visible && (i10 && i10.show(), t10 && t10.show());
        }
        plotGroup(t10, e10, i10, s10, o10) {
          let r10 = this[t10], n10 = !r10, a10 = {
            visibility: i10,
            zIndex: s10 || 0.1
          };
          return rL(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (a10.opacity = this.opacity), r10 || (this[t10] = r10 = this.chart.renderer.g().add(o10)), r10.addClass("highcharts-" + e10 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (rL(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r10.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true), r10.attr(a10)[n10 ? "attr" : "animate"](this.getPlotBox(e10)), r10;
        }
        getPlotBox(t10) {
          let e10 = this.xAxis, i10 = this.yAxis, s10 = this.chart, o10 = s10.inverted && !s10.polar && e10 && this.invertible && "series" === t10;
          return s10.inverted && (e10 = i10, i10 = this.xAxis), {
            translateX: e10 ? e10.left : s10.plotLeft,
            translateY: i10 ? i10.top : s10.plotTop,
            rotation: o10 ? 90 : 0,
            rotationOriginX: o10 ? (e10.len - i10.len) / 2 : 0,
            rotationOriginY: o10 ? (e10.len + i10.len) / 2 : 0,
            scaleX: o10 ? -1 : 1,
            scaleY: 1
          };
        }
        removeEvents(t10) {
          let {
            eventsToUnbind: e10
          } = this;
          t10 || r_(this), e10.length && (e10.forEach((t11) => {
            t11();
          }), e10.length = 0);
        }
        render() {
          let t10 = this, {
            chart: e10,
            options: i10,
            hasRendered: s10
          } = t10, o10 = rb(i10.animation), r10 = t10.visible ? "inherit" : "hidden", n10 = i10.zIndex, a10 = e10.seriesGroup, h10 = t10.finishedAnimating ? 0 : o10.duration;
          rW(this, "render"), t10.plotGroup("group", "series", r10, n10, a10), t10.markerGroup = t10.plotGroup("markerGroup", "markers", r10, n10, a10), false !== i10.clip && t10.setClip(), h10 && t10.animate?.(true), t10.drawGraph && (t10.drawGraph(), t10.applyZones()), t10.visible && t10.drawPoints(), t10.drawDataLabels?.(), t10.redrawPoints?.(), i10.enableMouseTracking && t10.drawTracker?.(), h10 && t10.animate?.(), s10 || (h10 && o10.defer && (h10 += o10.defer), t10.animationTimeout = rq(() => {
            t10.afterAnimate();
          }, h10 || 0)), t10.isDirty = false, t10.hasRendered = true, rW(t10, "afterRender");
        }
        redraw() {
          let t10 = this.isDirty || this.isDirtyData;
          this.translate(), this.render(), t10 && delete this.kdTree;
        }
        reserveSpace() {
          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
        }
        searchPoint(t10, e10) {
          let {
            xAxis: i10,
            yAxis: s10
          } = this, o10 = this.chart.inverted;
          return this.searchKDTree({
            clientX: o10 ? i10.len - t10.chartY + i10.pos : t10.chartX - i10.pos,
            plotY: o10 ? s10.len - t10.chartX + s10.pos : t10.chartY - s10.pos
          }, e10, t10);
        }
        buildKDTree(t10) {
          this.buildingKdTree = true;
          let e10 = this, i10 = e10.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          delete e10.kdTree, rq(function() {
            e10.kdTree = function t11(i11, s10, o10) {
              let r10, n10;
              let a10 = i11?.length;
              if (a10) return r10 = e10.kdAxisArray[s10 % o10], i11.sort((t12, e11) => (t12[r10] || 0) - (e11[r10] || 0)), {
                point: i11[n10 = Math.floor(a10 / 2)],
                left: t11(i11.slice(0, n10), s10 + 1, o10),
                right: t11(i11.slice(n10 + 1), s10 + 1, o10)
              };
            }(e10.getValidPoints(void 0, !e10.directTouch), i10, i10), e10.buildingKdTree = false;
          }, e10.options.kdNow || t10?.type === "touchstart" ? 0 : 1);
        }
        searchKDTree(t10, e10, i10, s10, o10) {
          let r10 = this, [n10, a10] = this.kdAxisArray, h10 = e10 ? "distX" : "dist", l10 = (r10.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d10 = !!r10.isBubble, c10 = s10 || ((t11, e11, i11) => [(t11[i11] || 0) < (e11[i11] || 0) ? t11 : e11, false]), p10 = o10 || ((t11, e11) => t11 < e11);
          if (this.kdTree || this.buildingKdTree || this.buildKDTree(i10), this.kdTree) return function t11(e11, i11, s11, o11) {
            let l11 = i11.point, u10 = r10.kdAxisArray[s11 % o11], g2 = l11, f2 = false;
            !function(t12, e12) {
              let i12 = t12[n10], s12 = e12[n10], o12 = rL(i12) && rL(s12) ? i12 - s12 : null, r11 = t12[a10], h11 = e12[a10], l12 = rL(r11) && rL(h11) ? r11 - h11 : 0, c11 = d10 && e12.marker?.radius || 0;
              e12.dist = Math.sqrt((o12 && o12 * o12 || 0) + l12 * l12) - c11, e12.distX = rL(o12) ? Math.abs(o12) - c11 : Number.MAX_VALUE;
            }(e11, l11);
            let m2 = (e11[u10] || 0) - (l11[u10] || 0) + (d10 && l11.marker?.radius || 0), x2 = m2 < 0 ? "left" : "right", y2 = m2 < 0 ? "right" : "left";
            return i11[x2] && ([g2, f2] = c10(l11, t11(e11, i11[x2], s11 + 1, o11), h10)), i11[y2] && p10(Math.sqrt(m2 * m2), g2[h10], f2) && (g2 = c10(g2, t11(e11, i11[y2], s11 + 1, o11), h10)[0]), g2;
          }(t10, this.kdTree, l10, l10);
        }
        pointPlacementToXValue() {
          let {
            options: t10,
            xAxis: e10
          } = this, i10 = t10.pointPlacement;
          return "between" === i10 && (i10 = e10.reversed ? -0.5 : 0.5), rY(i10) ? i10 * (t10.pointRange || e10.pointRange) : 0;
        }
        isPointInside(t10) {
          let {
            chart: e10,
            xAxis: i10,
            yAxis: s10
          } = this, {
            plotX: o10 = -1,
            plotY: r10 = -1
          } = t10;
          return r10 >= 0 && r10 <= (s10 ? s10.len : e10.plotHeight) && o10 >= 0 && o10 <= (i10 ? i10.len : e10.plotWidth);
        }
        drawTracker() {
          let t10 = this, e10 = t10.options, i10 = e10.trackByArea, s10 = [].concat((i10 ? t10.areaPath : t10.graphPath) || []), o10 = t10.chart, r10 = o10.pointer, n10 = o10.renderer, a10 = o10.options.tooltip?.snap || 0, h10 = () => {
            e10.enableMouseTracking && o10.hoverSeries !== t10 && t10.onMouseOver();
          }, l10 = "rgba(192,192,192," + (rw ? 1e-4 : 2e-3) + ")", d10 = t10.tracker;
          d10 ? d10.attr({
            d: s10
          }) : t10.graph && (t10.tracker = d10 = n10.path(s10).attr({
            visibility: t10.visible ? "inherit" : "hidden",
            zIndex: 2
          }).addClass(i10 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t10.group), o10.styledMode || d10.attr({
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            stroke: l10,
            fill: i10 ? l10 : "none",
            "stroke-width": t10.graph.strokeWidth() + (i10 ? 0 : 2 * a10)
          }), [t10.tracker, t10.markerGroup, t10.dataLabelsGroup].forEach((t11) => {
            t11 && (t11.addClass("highcharts-tracker").on("mouseover", h10).on("mouseout", (t12) => {
              r10?.onTrackerMouseOut(t12);
            }), e10.cursor && !o10.styledMode && t11.css({
              cursor: e10.cursor
            }), t11.on("touchstart", h10));
          })), rW(this, "afterDrawTracker");
        }
        addPoint(t10, e10, i10, s10, o10) {
          let r10, n10;
          let a10 = this.options, {
            chart: h10,
            data: l10,
            dataTable: d10,
            xAxis: c10
          } = this, p10 = c10 && c10.hasNames && c10.names, u10 = a10.data, g2 = this.getColumn("x");
          e10 = r$(e10, true);
          let f2 = {
            series: this
          };
          this.pointClass.prototype.applyOptions.apply(f2, [t10]);
          let m2 = f2.x;
          if (n10 = g2.length, this.requireSorting && m2 < g2[n10 - 1]) for (r10 = true; n10 && g2[n10 - 1] > m2; ) n10--;
          d10.setRow(f2, n10, true, {
            addColumns: false
          }), p10 && f2.name && (p10[m2] = f2.name), u10?.splice(n10, 0, t10), (r10 || this.processedData) && (this.data.splice(n10, 0, null), this.processData()), "point" === a10.legendType && this.generatePoints(), i10 && (l10[0] && l10[0].remove ? l10[0].remove(false) : ([l10, u10, ...Object.values(d10.getColumns())].filter(rL).forEach((t11) => {
            t11.shift();
          }), d10.rowCount -= 1, rW(d10, "afterDeleteRows"))), false !== o10 && rW(this, "addPoint", {
            point: f2
          }), this.isDirty = true, this.isDirtyData = true, e10 && h10.redraw(s10);
        }
        removePoint(t10, e10, i10) {
          let s10 = this, {
            chart: o10,
            data: r10,
            points: n10,
            dataTable: a10
          } = s10, h10 = r10[t10], l10 = function() {
            [n10?.length === r10.length ? n10 : void 0, r10, s10.options.data, ...Object.values(a10.getColumns())].filter(rL).forEach((e11) => {
              e11.splice(t10, 1);
            }), a10.rowCount -= 1, rW(a10, "afterDeleteRows"), h10?.destroy(), s10.isDirty = true, s10.isDirtyData = true, e10 && o10.redraw();
          };
          rv(i10, o10), e10 = r$(e10, true), h10 ? h10.firePointEvent("remove", null, l10) : l10();
        }
        remove(t10, e10, i10, s10) {
          let o10 = this, r10 = o10.chart;
          function n10() {
            o10.destroy(s10), r10.isDirtyLegend = r10.isDirtyBox = true, r10.linkSeries(s10), r$(t10, true) && r10.redraw(e10);
          }
          false !== i10 ? rW(o10, "remove", null, n10) : n10();
        }
        update(t10, e10) {
          rW(this, "update", {
            options: t10 = rI(t10, this.userOptions)
          });
          let i10 = this, s10 = i10.chart, o10 = i10.userOptions, r10 = i10.initialType || i10.type, n10 = s10.options.plotOptions, a10 = rA[r10].prototype, h10 = i10.finishedAnimating && {
            animation: false
          }, l10 = {}, d10, c10, p10 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], u10 = t10.type || o10.type || s10.options.chart.type, g2 = !(this.hasDerivedData || u10 && u10 !== this.type || void 0 !== t10.keys || void 0 !== t10.pointStart || void 0 !== t10.pointInterval || void 0 !== t10.relativeXValue || t10.joinBy || t10.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some((t11) => i10.hasOptionChanged(t11)));
          u10 = u10 || r10, g2 ? (p10.push("data", "isDirtyData", "isDirtyCanvas", "points", "dataTable", "processedData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), false !== t10.visible && p10.push("area", "graph"), i10.parallelArrays.forEach(function(t11) {
            p10.push(t11 + "Data");
          }), t10.data && (t10.dataSorting && rN(i10.options.dataSorting, t10.dataSorting), this.setData(t10.data, false))) : this.dataTable.modified = this.dataTable, t10 = rU(o10, {
            index: void 0 === o10.index ? i10.index : o10.index,
            pointStart: n10?.series?.pointStart ?? o10.pointStart ?? i10.getColumn("x")[0]
          }, !g2 && {
            data: i10.options.data
          }, t10, h10), g2 && t10.data && (t10.data = i10.options.data), (p10 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p10)).forEach(function(t11) {
            p10[t11] = i10[t11], delete i10[t11];
          });
          let f2 = false;
          if (rA[u10]) {
            if (f2 = u10 !== i10.type, i10.remove(false, false, false, true), f2) {
              if (s10.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i10, rA[u10].prototype);
              else {
                let t11 = Object.hasOwnProperty.call(i10, "hcEvents") && i10.hcEvents;
                for (c10 in a10) i10[c10] = void 0;
                rN(i10, rA[u10].prototype), t11 ? i10.hcEvents = t11 : delete i10.hcEvents;
              }
            }
          } else rR(17, true, s10, {
            missingModuleFor: u10
          });
          if (p10.forEach(function(t11) {
            i10[t11] = p10[t11];
          }), i10.init(s10, t10), g2 && this.points) for (let t11 of (false === (d10 = i10.options).visible ? (l10.graphic = 1, l10.dataLabel = 1) : (this.hasMarkerChanged(d10, o10) && (l10.graphic = 1), i10.hasDataLabels?.() || (l10.dataLabel = 1)), this.points)) t11 && t11.series && (t11.resolveColor(), Object.keys(l10).length && t11.destroyElements(l10), false === d10.showInLegend && t11.legendItem && s10.legend.destroyItem(t11));
          i10.initialType = r10, s10.linkSeries(), s10.setSortedData(), f2 && i10.linkedSeries.length && (i10.isDirtyData = true), rW(this, "afterUpdate"), r$(e10, true) && s10.redraw(!!g2 && void 0);
        }
        setName(t10) {
          this.name = this.options.name = this.userOptions.name = t10, this.chart.isDirtyLegend = true;
        }
        hasOptionChanged(t10) {
          let e10 = this.chart, i10 = this.options[t10], s10 = e10.options.plotOptions, o10 = this.userOptions[t10], r10 = r$(s10?.[this.type]?.[t10], s10?.series?.[t10]);
          return o10 && !rL(r10) ? i10 !== o10 : i10 !== r$(r10, i10);
        }
        onMouseOver() {
          let t10 = this.chart, e10 = t10.hoverSeries, i10 = t10.pointer;
          i10?.setHoverChartIndex(), e10 && e10 !== this && e10.onMouseOut(), this.options.events.mouseOver && rW(this, "mouseOver"), this.setState("hover"), t10.hoverSeries = this;
        }
        onMouseOut() {
          let t10 = this.options, e10 = this.chart, i10 = e10.tooltip, s10 = e10.hoverPoint;
          e10.hoverSeries = null, s10 && s10.onMouseOut(), this && t10.events.mouseOut && rW(this, "mouseOut"), i10 && !this.stickyTracking && (!i10.shared || this.noSharedTooltip) && i10.hide(), e10.series.forEach(function(t11) {
            t11.setState("", true);
          });
        }
        setState(t10, e10) {
          let i10 = this, s10 = i10.options, o10 = i10.graph, r10 = s10.inactiveOtherPoints, n10 = s10.states, a10 = r$(n10[t10 || "normal"] && n10[t10 || "normal"].animation, i10.chart.options.chart.animation), h10 = s10.lineWidth, l10 = s10.opacity;
          if (t10 = t10 || "", i10.state !== t10 && ([i10.group, i10.markerGroup, i10.dataLabelsGroup].forEach(function(e11) {
            e11 && (i10.state && e11.removeClass("highcharts-series-" + i10.state), t10 && e11.addClass("highcharts-series-" + t10));
          }), i10.state = t10, !i10.chart.styledMode)) {
            if (n10[t10] && false === n10[t10].enabled) return;
            if (t10 && (h10 = n10[t10].lineWidth || h10 + (n10[t10].lineWidthPlus || 0), l10 = r$(n10[t10].opacity, l10)), o10 && !o10.dashstyle && rY(h10)) for (let t11 of [o10, ...this.zones.map((t12) => t12.graph)]) t11?.animate({
              "stroke-width": h10
            }, a10);
            r10 || [i10.group, i10.markerGroup, i10.dataLabelsGroup, i10.labelBySeries].forEach(function(t11) {
              t11 && t11.animate({
                opacity: l10
              }, a10);
            });
          }
          e10 && r10 && i10.points && i10.setAllPointsToState(t10 || void 0);
        }
        setAllPointsToState(t10) {
          this.points.forEach(function(e10) {
            e10.setState && e10.setState(t10);
          });
        }
        setVisible(t10, e10) {
          let i10 = this, s10 = i10.chart, o10 = s10.options.chart.ignoreHiddenSeries, r10 = i10.visible;
          i10.visible = t10 = i10.options.visible = i10.userOptions.visible = void 0 === t10 ? !r10 : t10;
          let n10 = t10 ? "show" : "hide";
          ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach((t11) => {
            i10[t11]?.[n10]();
          }), (s10.hoverSeries === i10 || s10.hoverPoint?.series === i10) && i10.onMouseOut(), i10.legendItem && s10.legend.colorizeItem(i10, t10), i10.isDirty = true, i10.options.stacking && s10.series.forEach((t11) => {
            t11.options.stacking && t11.visible && (t11.isDirty = true);
          }), i10.linkedSeries.forEach((e11) => {
            e11.setVisible(t10, false);
          }), o10 && (s10.isDirtyBox = true), rW(i10, n10), false !== e10 && s10.redraw();
        }
        show() {
          this.setVisible(true);
        }
        hide() {
          this.setVisible(false);
        }
        select(t10) {
          this.selected = t10 = this.options.selected = void 0 === t10 ? !this.selected : t10, this.checkbox && (this.checkbox.checked = t10), rW(this, t10 ? "select" : "unselect");
        }
        shouldShowTooltip(t10, e10, i10 = {}) {
          return i10.series = this, i10.visiblePlotOnly = true, this.chart.isInsidePlot(t10, e10, i10);
        }
        drawLegendSymbol(t10, e10) {
          ru[this.options.legendSymbol || "rectangle"]?.call(this, t10, e10);
        }
      }
      rZ.defaultOptions = {
        lineWidth: 2,
        allowPointSelect: false,
        crisp: true,
        showCheckbox: false,
        animation: {
          duration: 1e3
        },
        enableMouseTracking: true,
        events: {},
        marker: {
          enabledThreshold: 2,
          lineColor: "#ffffff",
          lineWidth: 0,
          radius: 4,
          states: {
            normal: {
              animation: true
            },
            hover: {
              animation: {
                duration: 150
              },
              enabled: true,
              radiusPlus: 2,
              lineWidthPlus: 1
            },
            select: {
              fillColor: "#cccccc",
              lineColor: "#000000",
              lineWidth: 2
            }
          }
        },
        point: {
          events: {}
        },
        dataLabels: {
          animation: {},
          align: "center",
          borderWidth: 0,
          defer: true,
          formatter: function() {
            let {
              numberFormatter: t10
            } = this.series.chart;
            return "number" != typeof this.y ? "" : t10(this.y, -1);
          },
          padding: 5,
          style: {
            fontSize: "0.7em",
            fontWeight: "bold",
            color: "contrast",
            textOutline: "1px contrast"
          },
          verticalAlign: "bottom",
          x: 0,
          y: 0
        },
        cropThreshold: 300,
        opacity: 1,
        pointRange: 0,
        softThreshold: true,
        states: {
          normal: {
            animation: true
          },
          hover: {
            animation: {
              duration: 150
            },
            lineWidthPlus: 1,
            marker: {},
            halo: {
              size: 10,
              opacity: 0.25
            }
          },
          select: {
            animation: {
              duration: 0
            }
          },
          inactive: {
            animation: {
              duration: 150
            },
            opacity: 0.2
          }
        },
        stickyTracking: true,
        turboThreshold: 1e3,
        findNearestPointBy: "x"
      }, rZ.types = ry.seriesTypes, rZ.registerType = ry.registerSeriesType, rN(rZ.prototype, {
        axisTypes: ["xAxis", "yAxis"],
        coll: "series",
        colorCounter: 0,
        directTouch: false,
        invertible: true,
        isCartesian: true,
        kdAxisArray: ["clientX", "plotY"],
        parallelArrays: ["x", "y"],
        pointClass: oq,
        requireSorting: true,
        sorted: true
      }), ry.series = rZ;
      let rK = rZ, {
        animObject: rJ,
        setAnimation: rQ
      } = tU, {
        registerEventOptions: r0
      } = se, {
        composed: r1,
        marginNames: r2
      } = O, {
        distribute: r3
      } = ey, {
        format: r5
      } = ep, {
        addEvent: r6,
        createElement: r9,
        css: r4,
        defined: r8,
        discardElement: r7,
        find: nt,
        fireEvent: ne,
        isNumber: ni,
        merge: ns,
        pick: no,
        pushUnique: nr,
        relativeLength: nn,
        stableSort: na,
        syncTimeout: nh
      } = tt;
      class nl {
        constructor(t10, e10) {
          this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t10, this.setOptions(e10), e10.enabled && (this.render(), r0(this, e10), r6(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          })), r6(this.chart, "render", () => {
            this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
          });
        }
        setOptions(t10) {
          let e10 = no(t10.padding, 8);
          this.options = t10, this.chart.styledMode || (this.itemStyle = t10.itemStyle, this.itemHiddenStyle = ns(this.itemStyle, t10.itemHiddenStyle)), this.itemMarginTop = t10.itemMarginTop, this.itemMarginBottom = t10.itemMarginBottom, this.padding = e10, this.initialItemY = e10 - 5, this.symbolWidth = no(t10.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t10.layout && !this.chart.inverted, this.baseline = void 0;
        }
        update(t10, e10) {
          let i10 = this.chart;
          this.setOptions(ns(true, this.options, t10)), "events" in this.options && r0(this, this.options), this.destroy(), i10.isDirtyLegend = i10.isDirtyBox = true, no(e10, true) && i10.redraw(), ne(this, "afterUpdate", {
            redraw: e10
          });
        }
        colorizeItem(t10, e10) {
          let i10 = t10.color, {
            area: s10,
            group: o10,
            label: r10,
            line: n10,
            symbol: a10
          } = t10.legendItem || {};
          if ((t10 instanceof rK || t10 instanceof oq) && (t10.color = t10.options?.legendSymbolColor || i10), o10?.[e10 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
            let {
              itemHiddenStyle: i11 = {}
            } = this, o11 = i11.color, {
              fillColor: h10,
              fillOpacity: l10,
              lineColor: d10,
              marker: c10
            } = t10.options, p10 = (t11) => (!e10 && (t11.fill && (t11.fill = o11), t11.stroke && (t11.stroke = o11)), t11);
            r10?.css(ns(e10 ? this.itemStyle : i11)), n10?.attr(p10({
              stroke: d10 || t10.color
            })), a10 && a10.attr(p10(c10 && a10.isMarker ? t10.pointAttribs() : {
              fill: t10.color
            })), s10?.attr(p10({
              fill: h10 || t10.color,
              "fill-opacity": h10 ? 1 : l10 ?? 0.75
            }));
          }
          t10.color = i10, ne(this, "afterColorizeItem", {
            item: t10,
            visible: e10
          });
        }
        positionItems() {
          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
        }
        positionItem(t10) {
          let {
            group: e10,
            x: i10 = 0,
            y: s10 = 0
          } = t10.legendItem || {}, o10 = this.options, r10 = o10.symbolPadding, n10 = !o10.rtl, a10 = t10.checkbox;
          if (e10 && e10.element) {
            let o11 = {
              translateX: n10 ? i10 : this.legendWidth - i10 - 2 * r10 - 4,
              translateY: s10
            };
            e10[r8(e10.translateY) ? "animate" : "attr"](o11, void 0, () => {
              ne(this, "afterPositionItem", {
                item: t10
              });
            });
          }
          a10 && (a10.x = i10, a10.y = s10);
        }
        destroyItem(t10) {
          let e10 = t10.checkbox, i10 = t10.legendItem || {};
          for (let t11 of ["group", "label", "line", "symbol"]) i10[t11] && (i10[t11] = i10[t11].destroy());
          e10 && r7(e10), t10.legendItem = void 0;
        }
        destroy() {
          for (let t10 of this.getAllItems()) this.destroyItem(t10);
          for (let t10 of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t10] && (this[t10] = this[t10].destroy());
          this.display = null;
        }
        positionCheckboxes() {
          let t10;
          let e10 = this.group && this.group.alignAttr, i10 = this.clipHeight || this.legendHeight, s10 = this.titleHeight;
          e10 && (t10 = e10.translateY, this.allItems.forEach(function(o10) {
            let r10;
            let n10 = o10.checkbox;
            n10 && (r10 = t10 + s10 + n10.y + (this.scrollOffset || 0) + 3, r4(n10, {
              left: e10.translateX + o10.checkboxOffset + n10.x - 20 + "px",
              top: r10 + "px",
              display: this.proximate || r10 > t10 - 6 && r10 < t10 + i10 - 6 ? "" : "none"
            }));
          }, this));
        }
        renderTitle() {
          let t10 = this.options, e10 = this.padding, i10 = t10.title, s10, o10 = 0;
          i10.text && (this.title || (this.title = this.chart.renderer.label(i10.text, e10 - 3, e10 - 4, void 0, void 0, void 0, t10.useHTML, void 0, "legend-title").attr({
            zIndex: 1
          }), this.chart.styledMode || this.title.css(i10.style), this.title.add(this.group)), i10.width || this.title.css({
            width: this.maxLegendWidth + "px"
          }), o10 = (s10 = this.title.getBBox()).height, this.offsetWidth = s10.width, this.contentGroup.attr({
            translateY: o10
          })), this.titleHeight = o10;
        }
        setText(t10) {
          let e10 = this.options;
          t10.legendItem.label.attr({
            text: e10.labelFormat ? r5(e10.labelFormat, t10, this.chart) : e10.labelFormatter.call(t10)
          });
        }
        renderItem(t10) {
          let e10 = t10.legendItem = t10.legendItem || {}, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = "horizontal" === o10.layout, n10 = this.symbolWidth, a10 = o10.symbolPadding || 0, h10 = this.itemStyle, l10 = this.itemHiddenStyle, d10 = r10 ? no(o10.itemDistance, 20) : 0, c10 = !o10.rtl, p10 = !t10.series, u10 = !p10 && t10.series.drawLegendSymbol ? t10.series : t10, g2 = u10.options, f2 = !!this.createCheckboxForItem && g2 && g2.showCheckbox, m2 = o10.useHTML, x2 = t10.options.className, y2 = e10.label, b2 = n10 + a10 + d10 + (f2 ? 20 : 0);
          !y2 && (e10.group = s10.g("legend-item").addClass("highcharts-" + u10.type + "-series highcharts-color-" + t10.colorIndex + (x2 ? " " + x2 : "") + (p10 ? " highcharts-series-" + t10.index : "")).attr({
            zIndex: 1
          }).add(this.scrollGroup), e10.label = y2 = s10.text("", c10 ? n10 + a10 : -a10, this.baseline || 0, m2), i10.styledMode || y2.css(ns(t10.visible ? h10 : l10)), y2.attr({
            align: c10 ? "left" : "right",
            zIndex: 2
          }).add(e10.group), !this.baseline && (this.fontMetrics = s10.fontMetrics(y2), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y2.attr("y", this.baseline), this.symbolHeight = no(o10.symbolHeight, this.fontMetrics.f), o10.squareSymbol && (this.symbolWidth = no(o10.symbolWidth, Math.max(this.symbolHeight, 16)), b2 = this.symbolWidth + a10 + d10 + (f2 ? 20 : 0), c10 && y2.attr("x", this.symbolWidth + a10))), u10.drawLegendSymbol(this, t10), this.setItemEvents && this.setItemEvents(t10, y2, m2)), f2 && !t10.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t10), this.colorizeItem(t10, t10.visible), (i10.styledMode || !h10.width) && y2.css({
            width: (o10.itemWidth || this.widthOption || i10.spacingBox.width) - b2 + "px"
          }), this.setText(t10);
          let v2 = y2.getBBox(), M2 = this.fontMetrics && this.fontMetrics.h || 0;
          t10.itemWidth = t10.checkboxOffset = o10.itemWidth || e10.labelWidth || v2.width + b2, this.maxItemWidth = Math.max(this.maxItemWidth, t10.itemWidth), this.totalItemWidth += t10.itemWidth, this.itemHeight = t10.itemHeight = Math.round(e10.labelHeight || (v2.height > 1.5 * M2 ? v2.height : M2));
        }
        layoutItem(t10) {
          let e10 = this.options, i10 = this.padding, s10 = "horizontal" === e10.layout, o10 = t10.itemHeight, r10 = this.itemMarginBottom, n10 = this.itemMarginTop, a10 = s10 ? no(e10.itemDistance, 20) : 0, h10 = this.maxLegendWidth, l10 = e10.alignColumns && this.totalItemWidth > h10 ? this.maxItemWidth : t10.itemWidth, d10 = t10.legendItem || {};
          s10 && this.itemX - i10 + l10 > h10 && (this.itemX = i10, this.lastLineHeight && (this.itemY += n10 + this.lastLineHeight + r10), this.lastLineHeight = 0), this.lastItemY = n10 + this.itemY + r10, this.lastLineHeight = Math.max(o10, this.lastLineHeight), d10.x = this.itemX, d10.y = this.itemY, s10 ? this.itemX += l10 : (this.itemY += n10 + o10 + r10, this.lastLineHeight = o10), this.offsetWidth = this.widthOption || Math.max((s10 ? this.itemX - i10 - (t10.checkbox ? 0 : a10) : l10) + i10, this.offsetWidth);
        }
        getAllItems() {
          let t10 = [];
          return this.chart.series.forEach(function(e10) {
            let i10 = e10 && e10.options;
            e10 && no(i10.showInLegend, !r8(i10.linkedTo) && void 0, true) && (t10 = t10.concat((e10.legendItem || {}).labels || ("point" === i10.legendType ? e10.data : e10)));
          }), ne(this, "afterGetAllItems", {
            allItems: t10
          }), t10;
        }
        getAlignment() {
          let t10 = this.options;
          return this.proximate ? t10.align.charAt(0) + "tv" : t10.floating ? "" : t10.align.charAt(0) + t10.verticalAlign.charAt(0) + t10.layout.charAt(0);
        }
        adjustMargins(t10, e10) {
          let i10 = this.chart, s10 = this.options, o10 = this.getAlignment();
          o10 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(r10, n10) {
            r10.test(o10) && !r8(t10[n10]) && (i10[r2[n10]] = Math.max(i10[r2[n10]], i10.legend[(n10 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][n10] * s10[n10 % 2 ? "x" : "y"] + no(s10.margin, 12) + e10[n10] + (i10.titleOffset[n10] || 0)));
          });
        }
        proximatePositions() {
          let t10;
          let e10 = this.chart, i10 = [], s10 = "left" === this.options.align;
          for (let o10 of (this.allItems.forEach(function(t11) {
            let o11, r10, n10 = s10, a10, h10;
            t11.yAxis && (t11.xAxis.options.reversed && (n10 = !n10), t11.points && (o11 = nt(n10 ? t11.points : t11.points.slice(0).reverse(), function(t12) {
              return ni(t12.plotY);
            })), r10 = this.itemMarginTop + t11.legendItem.label.getBBox().height + this.itemMarginBottom, h10 = t11.yAxis.top - e10.plotTop, a10 = t11.visible ? (o11 ? o11.plotY : t11.yAxis.height) + (h10 - 0.3 * r10) : h10 + t11.yAxis.height, i10.push({
              target: a10,
              size: r10,
              item: t11
            }));
          }, this), r3(i10, e10.plotHeight))) t10 = o10.item.legendItem || {}, ni(o10.pos) && (t10.y = e10.plotTop - e10.spacing[0] + o10.pos);
        }
        render() {
          let t10 = this.chart, e10 = t10.renderer, i10 = this.options, s10 = this.padding, o10 = this.getAllItems(), r10, n10, a10, h10 = this.group, l10, d10 = this.box;
          this.itemX = s10, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = nn(i10.width, t10.spacingBox.width - s10), l10 = t10.spacingBox.width - 2 * s10 - i10.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l10 /= 2), this.maxLegendWidth = this.widthOption || l10, h10 || (this.group = h10 = e10.g("legend").addClass(i10.className || "").attr({
            zIndex: 7
          }).add(), this.contentGroup = e10.g().attr({
            zIndex: 1
          }).add(h10), this.scrollGroup = e10.g().add(this.contentGroup)), this.renderTitle(), na(o10, (t11, e11) => (t11.options && t11.options.legendIndex || 0) - (e11.options && e11.options.legendIndex || 0)), i10.reversed && o10.reverse(), this.allItems = o10, this.display = r10 = !!o10.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o10.forEach(this.renderItem, this), o10.forEach(this.layoutItem, this), n10 = (this.widthOption || this.offsetWidth) + s10, a10 = this.lastItemY + this.lastLineHeight + this.titleHeight, a10 = this.handleOverflow(a10) + s10, d10 || (this.box = d10 = e10.rect().addClass("highcharts-legend-box").attr({
            r: i10.borderRadius
          }).add(h10)), t10.styledMode || d10.attr({
            stroke: i10.borderColor,
            "stroke-width": i10.borderWidth || 0,
            fill: i10.backgroundColor || "none"
          }).shadow(i10.shadow), n10 > 0 && a10 > 0 && d10[d10.placed ? "animate" : "attr"](d10.crisp.call({}, {
            x: 0,
            y: 0,
            width: n10,
            height: a10
          }, d10.strokeWidth())), h10[r10 ? "show" : "hide"](), t10.styledMode && "none" === h10.getStyle("display") && (n10 = a10 = 0), this.legendWidth = n10, this.legendHeight = a10, r10 && this.align(), this.proximate || this.positionItems(), ne(this, "afterRender");
        }
        align(t10 = this.chart.spacingBox) {
          let e10 = this.chart, i10 = this.options, s10 = t10.y;
          /(lth|ct|rth)/.test(this.getAlignment()) && e10.titleOffset[0] > 0 ? s10 += e10.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e10.titleOffset[2] > 0 && (s10 -= e10.titleOffset[2]), s10 !== t10.y && (t10 = ns(t10, {
            y: s10
          })), e10.hasRendered || (this.group.placed = false), this.group.align(ns(i10, {
            width: this.legendWidth,
            height: this.legendHeight,
            verticalAlign: this.proximate ? "top" : i10.verticalAlign
          }), true, t10);
        }
        handleOverflow(t10) {
          let e10 = this, i10 = this.chart, s10 = i10.renderer, o10 = this.options, r10 = o10.y, n10 = "top" === o10.verticalAlign, a10 = this.padding, h10 = o10.maxHeight, l10 = o10.navigation, d10 = no(l10.animation, true), c10 = l10.arrowSize || 12, p10 = this.pages, u10 = this.allItems, g2 = function(t11) {
            "number" == typeof t11 ? M2.attr({
              height: t11
            }) : M2 && (e10.clipRect = M2.destroy(), e10.contentGroup.clip()), e10.contentGroup.div && (e10.contentGroup.div.style.clip = t11 ? "rect(" + a10 + "px,9999px," + (a10 + t11) + "px,0)" : "auto");
          }, f2 = function(t11) {
            return e10[t11] = s10.circle(0, 0, 1.3 * c10).translate(c10 / 2, c10 / 2).add(v2), i10.styledMode || e10[t11].attr("fill", "rgba(0,0,0,0.0001)"), e10[t11];
          }, m2, x2, y2, b2 = i10.spacingBox.height + (n10 ? -r10 : r10) - a10, v2 = this.nav, M2 = this.clipRect;
          return "horizontal" !== o10.layout || "middle" === o10.verticalAlign || o10.floating || (b2 /= 2), h10 && (b2 = Math.min(b2, h10)), p10.length = 0, t10 && b2 > 0 && t10 > b2 && false !== l10.enabled ? (this.clipHeight = m2 = Math.max(b2 - 20 - this.titleHeight - a10, 0), this.currentPage = no(this.currentPage, 1), this.fullHeight = t10, u10.forEach((t11, e11) => {
            let i11 = (y2 = t11.legendItem || {}).y || 0, s11 = Math.round(y2.label.getBBox().height), o11 = p10.length;
            (!o11 || i11 - p10[o11 - 1] > m2 && (x2 || i11) !== p10[o11 - 1]) && (p10.push(x2 || i11), o11++), y2.pageIx = o11 - 1, x2 && ((u10[e11 - 1].legendItem || {}).pageIx = o11 - 1), e11 === u10.length - 1 && i11 + s11 - p10[o11 - 1] > m2 && i11 > p10[o11 - 1] && (p10.push(i11), y2.pageIx = o11), i11 !== x2 && (x2 = i11);
          }), M2 || (M2 = e10.clipRect = s10.clipRect(0, a10 - 2, 9999, 0), e10.contentGroup.clip(M2)), g2(m2), v2 || (this.nav = v2 = s10.g().attr({
            zIndex: 1
          }).add(this.group), this.up = s10.symbol("triangle", 0, 0, c10, c10).add(v2), f2("upTracker").on("click", function() {
            e10.scroll(-1, d10);
          }), this.pager = s10.text("", 15, 10).addClass("highcharts-legend-navigation"), !i10.styledMode && l10.style && this.pager.css(l10.style), this.pager.add(v2), this.down = s10.symbol("triangle-down", 0, 0, c10, c10).add(v2), f2("downTracker").on("click", function() {
            e10.scroll(1, d10);
          })), e10.scroll(0), t10 = b2) : v2 && (g2(), this.nav = v2.destroy(), this.scrollGroup.attr({
            translateY: 1
          }), this.clipHeight = 0), t10;
        }
        scroll(t10, e10) {
          let i10 = this.chart, s10 = this.pages, o10 = s10.length, r10 = this.clipHeight, n10 = this.options.navigation, a10 = this.pager, h10 = this.padding, l10 = this.currentPage + t10;
          l10 > o10 && (l10 = o10), l10 > 0 && (void 0 !== e10 && rQ(e10, i10), this.nav.attr({
            translateX: h10,
            translateY: r10 + this.padding + 7 + this.titleHeight,
            visibility: "inherit"
          }), [this.up, this.upTracker].forEach(function(t11) {
            t11.attr({
              class: 1 === l10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }), a10.attr({
            text: l10 + "/" + o10
          }), [this.down, this.downTracker].forEach(function(t11) {
            t11.attr({
              x: 18 + this.pager.getBBox().width,
              class: l10 === o10 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
            });
          }, this), i10.styledMode || (this.up.attr({
            fill: 1 === l10 ? n10.inactiveColor : n10.activeColor
          }), this.upTracker.css({
            cursor: 1 === l10 ? "default" : "pointer"
          }), this.down.attr({
            fill: l10 === o10 ? n10.inactiveColor : n10.activeColor
          }), this.downTracker.css({
            cursor: l10 === o10 ? "default" : "pointer"
          })), this.scrollOffset = -s10[l10 - 1] + this.initialItemY, this.scrollGroup.animate({
            translateY: this.scrollOffset
          }), this.currentPage = l10, this.positionCheckboxes(), nh(() => {
            ne(this, "afterScroll", {
              currentPage: l10
            });
          }, rJ(no(e10, i10.renderer.globalAnimation, true)).duration));
        }
        setItemEvents(t10, e10, i10) {
          let s10 = this, o10 = t10.legendItem || {}, r10 = s10.chart.renderer.boxWrapper, n10 = t10 instanceof oq, a10 = t10 instanceof rK, h10 = "highcharts-legend-" + (n10 ? "point" : "series") + "-active", l10 = s10.chart.styledMode, d10 = i10 ? [e10, o10.symbol] : [o10.group], c10 = (e11) => {
            s10.allItems.forEach((i11) => {
              t10 !== i11 && [i11].concat(i11.linkedSeries || []).forEach((t11) => {
                t11.setState(e11, !n10);
              });
            });
          };
          for (let i11 of d10) i11 && i11.on("mouseover", function() {
            t10.visible && c10("inactive"), t10.setState("hover"), t10.visible && r10.addClass(h10), l10 || e10.css(s10.options.itemHoverStyle);
          }).on("mouseout", function() {
            s10.chart.styledMode || e10.css(ns(t10.visible ? s10.itemStyle : s10.itemHiddenStyle)), c10(""), r10.removeClass(h10), t10.setState();
          }).on("click", function(e11) {
            let i12 = function() {
              t10.setVisible && t10.setVisible(), c10(t10.visible ? "inactive" : "");
            };
            r10.removeClass(h10), ne(s10, "itemClick", {
              browserEvent: e11,
              legendItem: t10
            }, i12), n10 ? t10.firePointEvent("legendItemClick", {
              browserEvent: e11
            }) : a10 && ne(t10, "legendItemClick", {
              browserEvent: e11
            });
          });
        }
        createCheckboxForItem(t10) {
          t10.checkbox = r9("input", {
            type: "checkbox",
            className: "highcharts-legend-checkbox",
            checked: t10.selected,
            defaultChecked: t10.selected
          }, this.options.itemCheckboxStyle, this.chart.container), r6(t10.checkbox, "click", function(e10) {
            let i10 = e10.target;
            ne(t10.series || t10, "checkboxClick", {
              checked: i10.checked,
              item: t10
            }, function() {
              t10.select();
            });
          });
        }
      }
      !function(t10) {
        t10.compose = function(e10) {
          nr(r1, "Core.Legend") && r6(e10, "beforeMargins", function() {
            this.legend = new t10(this, this.options.legend);
          });
        };
      }(nl || (nl = {}));
      let nd = nl, {
        animate: nc,
        animObject: np,
        setAnimation: nu
      } = tU, {
        defaultOptions: ng
      } = tS, {
        numberFormat: nf
      } = ep, {
        registerEventOptions: nm
      } = se, {
        charts: nx,
        doc: ny,
        marginNames: nb,
        svg: nv,
        win: nM
      } = O, {
        seriesTypes: nk
      } = ry, {
        addEvent: nw,
        attr: nS,
        createElement: nA,
        css: nT,
        defined: nP,
        diffObjects: nC,
        discardElement: nO,
        erase: nE,
        error: nL,
        extend: nB,
        find: nI,
        fireEvent: nD,
        getAlignFactor: nR,
        getStyle: nN,
        isArray: nz,
        isNumber: nW,
        isObject: nG,
        isString: nH,
        merge: nF,
        objectEach: nX,
        pick: nY,
        pInt: nj,
        relativeLength: nU,
        removeEvent: nV,
        splat: n$,
        syncTimeout: n_,
        uniqueKey: nq
      } = tt;
      class nZ {
        static chart(t10, e10, i10) {
          return new nZ(t10, e10, i10);
        }
        constructor(t10, e10, i10) {
          this.sharedClips = {};
          let s10 = [...arguments];
          (nH(t10) || t10.nodeName) && (this.renderTo = s10.shift()), this.init(s10[0], s10[1]);
        }
        setZoomOptions() {
          let t10 = this.options.chart, e10 = t10.zooming;
          this.zooming = __spreadProps(__spreadValues({}, e10), {
            type: nY(t10.zoomType, e10.type),
            key: nY(t10.zoomKey, e10.key),
            pinchType: nY(t10.pinchType, e10.pinchType),
            singleTouch: nY(t10.zoomBySingleTouch, e10.singleTouch, false),
            resetButton: nF(e10.resetButton, t10.resetZoomButton)
          });
        }
        init(t10, e10) {
          nD(this, "init", {
            args: arguments
          }, function() {
            let i10 = nF(ng, t10), s10 = i10.chart, o10 = this.renderTo || s10.renderTo;
            this.userOptions = nB({}, t10), (this.renderTo = nH(o10) ? ny.getElementById(o10) : o10) || nL(13, true, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e10, this.isResizing = 0, this.options = i10, this.axes = [], this.series = [], this.locale = i10.lang.locale ?? this.renderTo.closest("[lang]")?.lang, this.time = new ty(nB(i10.time || {}, {
              locale: this.locale
            })), i10.time = this.time.options, this.numberFormatter = (s10.numberFormatter || nf).bind(this), this.styledMode = s10.styledMode, this.hasCartesianSeries = s10.showAxes, this.index = nx.length, nx.push(this), O.chartCount++, nm(this, s10), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), nD(this, "afterInit"), this.firstRender();
          });
        }
        initSeries(t10) {
          let e10 = this.options.chart, i10 = t10.type || e10.type, s10 = nk[i10];
          s10 || nL(17, true, this, {
            missingModuleFor: i10
          });
          let o10 = new s10();
          return "function" == typeof o10.init && o10.init(this, t10), o10;
        }
        setSortedData() {
          this.getSeriesOrderByLinks().forEach(function(t10) {
            t10.points || t10.data || !t10.enabledDataSorting || t10.setData(t10.options.data, false);
          });
        }
        getSeriesOrderByLinks() {
          return this.series.concat().sort(function(t10, e10) {
            return t10.linkedSeries.length || e10.linkedSeries.length ? e10.linkedSeries.length - t10.linkedSeries.length : 0;
          });
        }
        orderItems(t10, e10 = 0) {
          let i10 = this[t10], s10 = this.options[t10] = n$(this.options[t10]).slice(), o10 = this.userOptions[t10] = this.userOptions[t10] ? n$(this.userOptions[t10]).slice() : [];
          if (this.hasRendered && (s10.splice(e10), o10.splice(e10)), i10) for (let t11 = e10, r10 = i10.length; t11 < r10; ++t11) {
            let e11 = i10[t11];
            e11 && (e11.index = t11, e11 instanceof rK && (e11.name = e11.getName()), e11.options.isInternal || (s10[t11] = e11.options, o10[t11] = e11.userOptions));
          }
        }
        isInsidePlot(t10, e10, i10 = {}) {
          let {
            inverted: s10,
            plotBox: o10,
            plotLeft: r10,
            plotTop: n10,
            scrollablePlotBox: a10
          } = this, {
            scrollLeft: h10 = 0,
            scrollTop: l10 = 0
          } = i10.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, d10 = i10.series, c10 = i10.visiblePlotOnly && a10 || o10, p10 = i10.inverted ? e10 : t10, u10 = i10.inverted ? t10 : e10, g2 = {
            x: p10,
            y: u10,
            isInsidePlot: true,
            options: i10
          };
          if (!i10.ignoreX) {
            let t11 = d10 && (s10 && !this.polar ? d10.yAxis : d10.xAxis) || {
              pos: r10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + p10 : r10 + p10;
            e11 >= Math.max(h10 + r10, t11.pos) && e11 <= Math.min(h10 + r10 + c10.width, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          if (!i10.ignoreY && g2.isInsidePlot) {
            let t11 = !s10 && i10.axis && !i10.axis.isXAxis && i10.axis || d10 && (s10 ? d10.xAxis : d10.yAxis) || {
              pos: n10,
              len: 1 / 0
            }, e11 = i10.paneCoordinates ? t11.pos + u10 : n10 + u10;
            e11 >= Math.max(l10 + n10, t11.pos) && e11 <= Math.min(l10 + n10 + c10.height, t11.pos + t11.len) || (g2.isInsidePlot = false);
          }
          return nD(this, "afterIsInsidePlot", g2), g2.isInsidePlot;
        }
        redraw(t10) {
          nD(this, "beforeRedraw");
          let e10 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i10 = this.series, s10 = this.pointer, o10 = this.legend, r10 = this.userOptions.legend, n10 = this.renderer, a10 = n10.isHidden(), h10 = [], l10, d10, c10, p10 = this.isDirtyBox, u10 = this.isDirtyLegend, g2;
          for (n10.rootFontSize = n10.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(false), nu(!!this.hasRendered && t10, this), a10 && this.temporaryDisplay(), this.layOutTitles(false), c10 = i10.length; c10--; ) if (((g2 = i10[c10]).options.stacking || g2.options.centerInCategory) && (d10 = true, g2.isDirty)) {
            l10 = true;
            break;
          }
          if (l10) for (c10 = i10.length; c10--; ) (g2 = i10[c10]).options.stacking && (g2.isDirty = true);
          i10.forEach(function(t11) {
            t11.isDirty && ("point" === t11.options.legendType ? ("function" == typeof t11.updateTotals && t11.updateTotals(), u10 = true) : r10 && (r10.labelFormatter || r10.labelFormat) && (u10 = true)), t11.isDirtyData && nD(t11, "updatedData");
          }), u10 && o10 && o10.options.enabled && (o10.render(), this.isDirtyLegend = false), d10 && this.getStacks(), e10.forEach(function(t11) {
            t11.updateNames(), t11.setScale();
          }), this.getMargins(), e10.forEach(function(t11) {
            t11.isDirty && (p10 = true);
          }), e10.forEach(function(t11) {
            let e11 = t11.min + "," + t11.max;
            t11.extKey !== e11 && (t11.extKey = e11, h10.push(function() {
              nD(t11, "afterSetExtremes", nB(t11.eventArgs, t11.getExtremes())), delete t11.eventArgs;
            })), (p10 || d10) && t11.redraw();
          }), p10 && this.drawChartBox(), nD(this, "predraw"), i10.forEach(function(t11) {
            (p10 || t11.isDirty) && t11.visible && t11.redraw(), t11.isDirtyData = false;
          }), s10 && s10.reset(true), n10.draw(), nD(this, "redraw"), nD(this, "render"), a10 && this.temporaryDisplay(true), h10.forEach(function(t11) {
            t11.call();
          });
        }
        get(t10) {
          let e10 = this.series;
          function i10(e11) {
            return e11.id === t10 || e11.options && e11.options.id === t10;
          }
          let s10 = nI(this.axes, i10) || nI(this.series, i10);
          for (let t11 = 0; !s10 && t11 < e10.length; t11++) s10 = nI(e10[t11].points || [], i10);
          return s10;
        }
        createAxes() {
          let t10 = this.userOptions;
          for (let e10 of (nD(this, "createAxes"), ["xAxis", "yAxis"])) for (let i10 of t10[e10] = n$(t10[e10] || {})) new sU(this, i10, e10);
          nD(this, "afterCreateAxes");
        }
        getSelectedPoints() {
          return this.series.reduce((t10, e10) => (e10.getPointsCollection().forEach((e11) => {
            nY(e11.selectedStaging, e11.selected) && t10.push(e11);
          }), t10), []);
        }
        getSelectedSeries() {
          return this.series.filter((t10) => t10.selected);
        }
        setTitle(t10, e10, i10) {
          this.applyDescription("title", t10), this.applyDescription("subtitle", e10), this.applyDescription("caption", void 0), this.layOutTitles(i10);
        }
        applyDescription(t10, e10) {
          let i10 = this, s10 = this.options[t10] = nF(this.options[t10], e10), o10 = this[t10];
          o10 && e10 && (this[t10] = o10 = o10.destroy()), s10 && !o10 && ((o10 = this.renderer.text(s10.text, 0, 0, s10.useHTML).attr({
            align: s10.align,
            class: "highcharts-" + t10,
            zIndex: s10.zIndex || 4
          }).css({
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          }).add()).update = function(e11, s11) {
            i10.applyDescription(t10, e11), i10.layOutTitles(s11);
          }, this.styledMode || o10.css(nB("title" === t10 ? {
            fontSize: this.options.isStock ? "1em" : "1.2em"
          } : {}, s10.style)), o10.textPxLength = o10.getBBox().width, o10.css({
            whiteSpace: s10.style?.whiteSpace
          }), this[t10] = o10);
        }
        layOutTitles(t10 = true) {
          let e10 = [0, 0, 0], {
            options: i10,
            renderer: s10,
            spacingBox: o10
          } = this;
          ["title", "subtitle", "caption"].forEach((t11) => {
            let i11 = this[t11], r11 = this.options[t11], n10 = nF(o10), a10 = i11?.textPxLength || 0;
            if (i11 && r11) {
              nD(this, "layOutTitle", {
                alignTo: n10,
                key: t11,
                textPxLength: a10
              });
              let o11 = s10.fontMetrics(i11), h10 = o11.b, l10 = o11.h, d10 = r11.verticalAlign || "top", c10 = "top" === d10, p10 = c10 && r11.minScale || 1, u10 = "title" === t11 ? c10 ? -3 : 0 : c10 ? e10[0] + 2 : 0, g2 = Math.min(n10.width / a10, 1), f2 = Math.max(p10, g2), m2 = nF({
                y: "bottom" === d10 ? h10 : u10 + h10
              }, {
                align: "title" === t11 ? g2 < p10 ? "left" : "center" : this.title?.alignValue
              }, r11), x2 = r11.width || (g2 > p10 ? this.chartWidth : n10.width) / f2;
              i11.alignValue !== m2.align && (i11.placed = false);
              let y2 = Math.round(i11.css({
                width: `${x2}px`
              }).getBBox(r11.useHTML).height);
              if (m2.height = y2, i11.align(m2, false, n10).attr({
                align: m2.align,
                scaleX: f2,
                scaleY: f2,
                "transform-origin": `${n10.x + a10 * f2 * nR(m2.align)} ${l10}`
              }), !r11.floating) {
                let t12 = y2 * (y2 < 1.2 * l10 ? 1 : f2);
                "top" === d10 ? e10[0] = Math.ceil(e10[0] + t12) : "bottom" === d10 && (e10[2] = Math.ceil(e10[2] + t12));
              }
            }
          }, this), e10[0] && "top" === (i10.title?.verticalAlign || "top") && (e10[0] += i10.title?.margin || 0), e10[2] && i10.caption?.verticalAlign === "bottom" && (e10[2] += i10.caption?.margin || 0);
          let r10 = !this.titleOffset || this.titleOffset.join(",") !== e10.join(",");
          this.titleOffset = e10, nD(this, "afterLayOutTitles"), !this.isDirtyBox && r10 && (this.isDirtyBox = this.isDirtyLegend = r10, this.hasRendered && t10 && this.isDirtyBox && this.redraw());
        }
        getContainerBox() {
          let t10 = [].map.call(this.renderTo.children, (t11) => {
            if (t11 !== this.container) {
              let e11 = t11.style.display;
              return t11.style.display = "none", [t11, e11];
            }
          }), e10 = {
            width: nN(this.renderTo, "width", true) || 0,
            height: nN(this.renderTo, "height", true) || 0
          };
          return t10.filter(Boolean).forEach(([t11, e11]) => {
            t11.style.display = e11;
          }), e10;
        }
        getChartSize() {
          let t10 = this.options.chart, e10 = t10.width, i10 = t10.height, s10 = this.getContainerBox(), o10 = s10.height <= 1 || !this.renderTo.parentElement?.style.height && "100%" === this.renderTo.style.height;
          this.chartWidth = Math.max(0, e10 || s10.width || 600), this.chartHeight = Math.max(0, nU(i10, this.chartWidth) || (o10 ? 400 : s10.height)), this.containerBox = s10;
        }
        temporaryDisplay(t10) {
          let e10 = this.renderTo, i10;
          if (t10) for (; e10 && e10.style; ) e10.hcOrigStyle && (nT(e10, e10.hcOrigStyle), delete e10.hcOrigStyle), e10.hcOrigDetached && (ny.body.removeChild(e10), e10.hcOrigDetached = false), e10 = e10.parentNode;
          else for (; e10 && e10.style && (ny.body.contains(e10) || e10.parentNode || (e10.hcOrigDetached = true, ny.body.appendChild(e10)), ("none" === nN(e10, "display", false) || e10.hcOricDetached) && (e10.hcOrigStyle = {
            display: e10.style.display,
            height: e10.style.height,
            overflow: e10.style.overflow
          }, i10 = {
            display: "block",
            overflow: "hidden"
          }, e10 !== this.renderTo && (i10.height = 0), nT(e10, i10), e10.offsetWidth || e10.style.setProperty("display", "block", "important")), (e10 = e10.parentNode) !== ny.body); ) ;
        }
        setClassName(t10) {
          this.container.className = "highcharts-container " + (t10 || "");
        }
        getContainer() {
          let t10;
          let e10 = this.options, i10 = e10.chart, s10 = "data-highcharts-chart", o10 = nq(), r10 = this.renderTo, n10 = nj(nS(r10, s10));
          nW(n10) && nx[n10] && nx[n10].hasRendered && nx[n10].destroy(), nS(r10, s10, this.index), r10.innerHTML = t6.emptyHTML, i10.skipClone || r10.offsetWidth || this.temporaryDisplay(), this.getChartSize();
          let a10 = this.chartHeight, h10 = this.chartWidth;
          nT(r10, {
            overflow: "hidden"
          }), this.styledMode || (t10 = nB({
            position: "relative",
            overflow: "hidden",
            width: h10 + "px",
            height: a10 + "px",
            textAlign: "left",
            lineHeight: "normal",
            zIndex: 0,
            "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
            userSelect: "none",
            "touch-action": "manipulation",
            outline: "none",
            padding: "0px"
          }, i10.style || {}));
          let l10 = nA("div", {
            id: o10
          }, t10, r10);
          this.container = l10, this.getChartSize(), h10 === this.chartWidth || (h10 = this.chartWidth, this.styledMode || nT(l10, {
            width: nY(i10.style?.width, h10 + "px")
          })), this.containerBox = this.getContainerBox(), this._cursor = l10.style.cursor;
          let d10 = i10.renderer || !nv ? eu.getRendererType(i10.renderer) : iU;
          if (this.renderer = new d10(l10, h10, a10, void 0, i10.forExport, e10.exporting && e10.exporting.allowHTML, this.styledMode), nu(void 0, this), this.setClassName(i10.className), this.styledMode) for (let t11 in e10.defs) this.renderer.definition(e10.defs[t11]);
          else this.renderer.setStyle(i10.style);
          this.renderer.chartIndex = this.index, nD(this, "afterGetContainer");
        }
        getMargins(t10) {
          let {
            spacing: e10,
            margin: i10,
            titleOffset: s10
          } = this;
          this.resetMargins(), s10[0] && !nP(i10[0]) && (this.plotTop = Math.max(this.plotTop, s10[0] + e10[0])), s10[2] && !nP(i10[2]) && (this.marginBottom = Math.max(this.marginBottom, s10[2] + e10[2])), this.legend && this.legend.display && this.legend.adjustMargins(i10, e10), nD(this, "getMargins"), t10 || this.getAxisMargins();
        }
        getAxisMargins() {
          let t10 = this, e10 = t10.axisOffset = [0, 0, 0, 0], i10 = t10.colorAxis, s10 = t10.margin, o10 = function(t11) {
            t11.forEach(function(t12) {
              t12.visible && t12.getOffset();
            });
          };
          t10.hasCartesianSeries ? o10(t10.axes) : i10 && i10.length && o10(i10), nb.forEach(function(i11, o11) {
            nP(s10[o11]) || (t10[i11] += e10[o11]);
          }), t10.setChartSize();
        }
        getOptions() {
          return nC(this.userOptions, ng);
        }
        reflow(t10) {
          let e10 = this, i10 = e10.containerBox, s10 = e10.getContainerBox();
          delete e10.pointer?.chartPosition, !e10.isPrinting && !e10.isResizing && i10 && s10.width && ((s10.width !== i10.width || s10.height !== i10.height) && (tt.clearTimeout(e10.reflowTimeout), e10.reflowTimeout = n_(function() {
            e10.container && e10.setSize(void 0, void 0, false);
          }, t10 ? 100 : 0)), e10.containerBox = s10);
        }
        setReflow() {
          let t10 = this, e10 = (e11) => {
            t10.options?.chart.reflow && t10.hasLoaded && t10.reflow(e11);
          };
          if ("function" == typeof ResizeObserver) new ResizeObserver(e10).observe(t10.renderTo);
          else {
            let t11 = nw(nM, "resize", e10);
            nw(this, "destroy", t11);
          }
        }
        setSize(t10, e10, i10) {
          let s10 = this, o10 = s10.renderer;
          s10.isResizing += 1, nu(i10, s10);
          let r10 = o10.globalAnimation;
          s10.oldChartHeight = s10.chartHeight, s10.oldChartWidth = s10.chartWidth, void 0 !== t10 && (s10.options.chart.width = t10), void 0 !== e10 && (s10.options.chart.height = e10), s10.getChartSize();
          let {
            chartWidth: n10,
            chartHeight: a10,
            scrollablePixelsX: h10 = 0,
            scrollablePixelsY: l10 = 0
          } = s10;
          (s10.isDirtyBox || n10 !== s10.oldChartWidth || a10 !== s10.oldChartHeight) && (s10.styledMode || (r10 ? nc : nT)(s10.container, {
            width: `${n10 + h10}px`,
            height: `${a10 + l10}px`
          }, r10), s10.setChartSize(true), o10.setSize(n10, a10, r10), s10.axes.forEach(function(t11) {
            t11.isDirty = true, t11.setScale();
          }), s10.isDirtyLegend = true, s10.isDirtyBox = true, s10.layOutTitles(), s10.getMargins(), s10.redraw(r10), s10.oldChartHeight = void 0, nD(s10, "resize"), setTimeout(() => {
            s10 && nD(s10, "endResize");
          }, np(r10).duration)), s10.isResizing -= 1;
        }
        setChartSize(t10) {
          let e10, i10, s10, o10;
          let {
            chartHeight: r10,
            chartWidth: n10,
            inverted: a10,
            spacing: h10,
            renderer: l10
          } = this, d10 = this.clipOffset, c10 = Math[a10 ? "floor" : "round"];
          this.plotLeft = e10 = Math.round(this.plotLeft), this.plotTop = i10 = Math.round(this.plotTop), this.plotWidth = s10 = Math.max(0, Math.round(n10 - e10 - this.marginRight)), this.plotHeight = o10 = Math.max(0, Math.round(r10 - i10 - this.marginBottom)), this.plotSizeX = a10 ? o10 : s10, this.plotSizeY = a10 ? s10 : o10, this.spacingBox = l10.spacingBox = {
            x: h10[3],
            y: h10[0],
            width: n10 - h10[3] - h10[1],
            height: r10 - h10[0] - h10[2]
          }, this.plotBox = l10.plotBox = {
            x: e10,
            y: i10,
            width: s10,
            height: o10
          }, d10 && (this.clipBox = {
            x: c10(d10[3]),
            y: c10(d10[0]),
            width: c10(this.plotSizeX - d10[1] - d10[3]),
            height: c10(this.plotSizeY - d10[0] - d10[2])
          }), t10 || (this.axes.forEach(function(t11) {
            t11.setAxisSize(), t11.setAxisTranslation();
          }), l10.alignElements()), nD(this, "afterSetChartSize", {
            skipAxes: t10
          });
        }
        resetMargins() {
          nD(this, "resetMargins");
          let t10 = this, e10 = t10.options.chart, i10 = e10.plotBorderWidth || 0, s10 = i10 / 2;
          ["margin", "spacing"].forEach(function(i11) {
            let s11 = e10[i11], o10 = nG(s11) ? s11 : [s11, s11, s11, s11];
            ["Top", "Right", "Bottom", "Left"].forEach(function(s12, r10) {
              t10[i11][r10] = nY(e10[i11 + s12], o10[r10]);
            });
          }), nb.forEach(function(e11, i11) {
            t10[e11] = nY(t10.margin[i11], t10.spacing[i11]);
          }), t10.axisOffset = [0, 0, 0, 0], t10.clipOffset = [s10, s10, s10, s10], t10.plotBorderWidth = i10;
        }
        drawChartBox() {
          let t10 = this.options.chart, e10 = this.renderer, i10 = this.chartWidth, s10 = this.chartHeight, o10 = this.styledMode, r10 = this.plotBGImage, n10 = t10.backgroundColor, a10 = t10.plotBackgroundColor, h10 = t10.plotBackgroundImage, l10 = this.plotLeft, d10 = this.plotTop, c10 = this.plotWidth, p10 = this.plotHeight, u10 = this.plotBox, g2 = this.clipRect, f2 = this.clipBox, m2 = this.chartBackground, x2 = this.plotBackground, y2 = this.plotBorder, b2, v2, M2, k2 = "animate";
          m2 || (this.chartBackground = m2 = e10.rect().addClass("highcharts-background").add(), k2 = "attr"), o10 ? b2 = v2 = m2.strokeWidth() : (v2 = (b2 = t10.borderWidth || 0) + (t10.shadow ? 8 : 0), M2 = {
            fill: n10 || "none"
          }, (b2 || m2["stroke-width"]) && (M2.stroke = t10.borderColor, M2["stroke-width"] = b2), m2.attr(M2).shadow(t10.shadow)), m2[k2]({
            x: v2 / 2,
            y: v2 / 2,
            width: i10 - v2 - b2 % 2,
            height: s10 - v2 - b2 % 2,
            r: t10.borderRadius
          }), k2 = "animate", x2 || (k2 = "attr", this.plotBackground = x2 = e10.rect().addClass("highcharts-plot-background").add()), x2[k2](u10), !o10 && (x2.attr({
            fill: a10 || "none"
          }).shadow(t10.plotShadow), h10 && (r10 ? (h10 !== r10.attr("href") && r10.attr("href", h10), r10.animate(u10)) : this.plotBGImage = e10.image(h10, l10, d10, c10, p10).add())), g2 ? g2.animate({
            width: f2.width,
            height: f2.height
          }) : this.clipRect = e10.clipRect(f2), k2 = "animate", y2 || (k2 = "attr", this.plotBorder = y2 = e10.rect().addClass("highcharts-plot-border").attr({
            zIndex: 1
          }).add()), o10 || y2.attr({
            stroke: t10.plotBorderColor,
            "stroke-width": t10.plotBorderWidth || 0,
            fill: "none"
          }), y2[k2](y2.crisp({
            x: l10,
            y: d10,
            width: c10,
            height: p10
          }, -y2.strokeWidth())), this.isDirtyBox = false, nD(this, "afterDrawChartBox");
        }
        propFromSeries() {
          let t10, e10, i10;
          let s10 = this, o10 = s10.options.chart, r10 = s10.options.series;
          ["inverted", "angular", "polar"].forEach(function(n10) {
            for (e10 = nk[o10.type], i10 = o10[n10] || e10 && e10.prototype[n10], t10 = r10 && r10.length; !i10 && t10--; ) (e10 = nk[r10[t10].type]) && e10.prototype[n10] && (i10 = true);
            s10[n10] = i10;
          });
        }
        linkSeries(t10) {
          let e10 = this, i10 = e10.series;
          i10.forEach(function(t11) {
            t11.linkedSeries.length = 0;
          }), i10.forEach(function(t11) {
            let {
              linkedTo: i11
            } = t11.options;
            if (nH(i11)) {
              let s10;
              (s10 = ":previous" === i11 ? e10.series[t11.index - 1] : e10.get(i11)) && s10.linkedParent !== t11 && (s10.linkedSeries.push(t11), t11.linkedParent = s10, s10.enabledDataSorting && t11.setDataSortingOptions(), t11.visible = nY(t11.options.visible, s10.options.visible, t11.visible));
            }
          }), nD(this, "afterLinkSeries", {
            isUpdating: t10
          });
        }
        renderSeries() {
          this.series.forEach(function(t10) {
            t10.translate(), t10.render();
          });
        }
        render() {
          let t10 = this.axes, e10 = this.colorAxis, i10 = this.renderer, s10 = this.options.chart.axisLayoutRuns || 2, o10 = (t11) => {
            t11.forEach((t12) => {
              t12.visible && t12.render();
            });
          }, r10 = 0, n10 = true, a10, h10 = 0;
          for (let e11 of (this.setTitle(), nD(this, "beforeMargins"), this.getStacks?.(), this.getMargins(true), this.setChartSize(), t10)) {
            let {
              options: t11
            } = e11, {
              labels: i11
            } = t11;
            if (this.hasCartesianSeries && e11.horiz && e11.visible && i11.enabled && e11.series.length && "colorAxis" !== e11.coll && !this.polar) {
              r10 = t11.tickLength, e11.createGroups();
              let s11 = new sg(e11, 0, "", true), o11 = s11.createLabel("x", i11);
              if (s11.destroy(), o11 && nY(i11.reserveSpace, !nW(t11.crossing)) && (r10 = o11.getBBox().height + i11.distance + Math.max(t11.offset || 0, 0)), r10) {
                o11?.destroy();
                break;
              }
            }
          }
          for (this.plotHeight = Math.max(this.plotHeight - r10, 0); (n10 || a10 || s10 > 1) && h10 < s10; ) {
            let e11 = this.plotWidth, i11 = this.plotHeight;
            for (let e12 of t10) 0 === h10 ? e12.setScale() : (e12.horiz && n10 || !e12.horiz && a10) && e12.setTickInterval(true);
            0 === h10 ? this.getAxisMargins() : this.getMargins(), n10 = e11 / this.plotWidth > (h10 ? 1 : 1.1), a10 = i11 / this.plotHeight > (h10 ? 1 : 1.05), h10++;
          }
          this.drawChartBox(), this.hasCartesianSeries ? o10(t10) : e10 && e10.length && o10(e10), this.seriesGroup || (this.seriesGroup = i10.g("series-group").attr({
            zIndex: 3
          }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = true;
        }
        addCredits(t10) {
          let e10 = this, i10 = nF(true, this.options.credits, t10);
          i10.enabled && !this.credits && (this.credits = this.renderer.text(i10.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
            i10.href && (nM.location.href = i10.href);
          }).attr({
            align: i10.position.align,
            zIndex: 8
          }), e10.styledMode || this.credits.css(i10.style), this.credits.add().align(i10.position), this.credits.update = function(t11) {
            e10.credits = e10.credits.destroy(), e10.addCredits(t11);
          });
        }
        destroy() {
          let t10;
          let e10 = this, i10 = e10.axes, s10 = e10.series, o10 = e10.container, r10 = o10 && o10.parentNode;
          for (nD(e10, "destroy"), e10.renderer.forExport ? nE(nx, e10) : nx[e10.index] = void 0, O.chartCount--, e10.renderTo.removeAttribute("data-highcharts-chart"), nV(e10), t10 = i10.length; t10--; ) i10[t10] = i10[t10].destroy();
          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t10 = s10.length; t10--; ) s10[t10] = s10[t10].destroy();
          ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(t11) {
            let i11 = e10[t11];
            i11 && i11.destroy && (e10[t11] = i11.destroy());
          }), o10 && (o10.innerHTML = t6.emptyHTML, nV(o10), r10 && nO(o10)), nX(e10, function(t11, i11) {
            delete e10[i11];
          });
        }
        firstRender() {
          let t10 = this, e10 = t10.options;
          t10.getContainer(), t10.resetMargins(), t10.setChartSize(), t10.propFromSeries(), t10.createAxes();
          let i10 = nz(e10.series) ? e10.series : [];
          e10.series = [], i10.forEach(function(e11) {
            t10.initSeries(e11);
          }), t10.linkSeries(), t10.setSortedData(), nD(t10, "beforeRender"), t10.render(), t10.pointer?.getChartPosition(), t10.renderer.imgCount || t10.hasLoaded || t10.onload(), t10.temporaryDisplay(true);
        }
        onload() {
          this.callbacks.concat([this.callback]).forEach(function(t10) {
            t10 && void 0 !== this.index && t10.apply(this, [this]);
          }, this), nD(this, "load"), nD(this, "render"), nP(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = true;
        }
        warnIfA11yModuleNotLoaded() {
          let {
            options: t10,
            title: e10
          } = this;
          !t10 || this.accessibility || (this.renderer.boxWrapper.attr({
            role: "img",
            "aria-label": (e10 && e10.element.textContent || "").replace(/</g, "&lt;")
          }), t10.accessibility && false === t10.accessibility.enabled || nL('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this));
        }
        addSeries(t10, e10, i10) {
          let s10;
          let o10 = this;
          return t10 && (e10 = nY(e10, true), nD(o10, "addSeries", {
            options: t10
          }, function() {
            s10 = o10.initSeries(t10), o10.isDirtyLegend = true, o10.linkSeries(), s10.enabledDataSorting && s10.setData(t10.data, false), nD(o10, "afterAddSeries", {
              series: s10
            }), e10 && o10.redraw(i10);
          })), s10;
        }
        addAxis(t10, e10, i10, s10) {
          return this.createAxis(e10 ? "xAxis" : "yAxis", {
            axis: t10,
            redraw: i10,
            animation: s10
          });
        }
        addColorAxis(t10, e10, i10) {
          return this.createAxis("colorAxis", {
            axis: t10,
            redraw: e10,
            animation: i10
          });
        }
        createAxis(t10, e10) {
          let i10 = new sU(this, e10.axis, t10);
          return nY(e10.redraw, true) && this.redraw(e10.animation), i10;
        }
        showLoading(t10) {
          let e10 = this, i10 = e10.options, s10 = i10.loading, o10 = function() {
            r10 && nT(r10, {
              left: e10.plotLeft + "px",
              top: e10.plotTop + "px",
              width: e10.plotWidth + "px",
              height: e10.plotHeight + "px"
            });
          }, r10 = e10.loadingDiv, n10 = e10.loadingSpan;
          r10 || (e10.loadingDiv = r10 = nA("div", {
            className: "highcharts-loading highcharts-loading-hidden"
          }, null, e10.container)), n10 || (e10.loadingSpan = n10 = nA("span", {
            className: "highcharts-loading-inner"
          }, null, r10), nw(e10, "redraw", o10)), r10.className = "highcharts-loading", t6.setElementHTML(n10, nY(t10, i10.lang.loading, "")), e10.styledMode || (nT(r10, nB(s10.style, {
            zIndex: 10
          })), nT(n10, s10.labelStyle), e10.loadingShown || (nT(r10, {
            opacity: 0,
            display: ""
          }), nc(r10, {
            opacity: s10.style.opacity || 0.5
          }, {
            duration: s10.showDuration || 0
          }))), e10.loadingShown = true, o10();
        }
        hideLoading() {
          let t10 = this.options, e10 = this.loadingDiv;
          e10 && (e10.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || nc(e10, {
            opacity: 0
          }, {
            duration: t10.loading.hideDuration || 100,
            complete: function() {
              nT(e10, {
                display: "none"
              });
            }
          })), this.loadingShown = false;
        }
        update(t10, e10, i10, s10) {
          let o10, r10, n10;
          let a10 = this, h10 = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }, l10 = t10.isResponsiveOptions, d10 = [];
          nD(a10, "update", {
            options: t10
          }), l10 || a10.setResponsive(false, true), t10 = nC(t10, a10.options), a10.userOptions = nF(a10.userOptions, t10);
          let c10 = t10.chart;
          c10 && (nF(true, a10.options.chart, c10), this.setZoomOptions(), "className" in c10 && a10.setClassName(c10.className), ("inverted" in c10 || "polar" in c10 || "type" in c10) && (a10.propFromSeries(), o10 = true), "alignTicks" in c10 && (o10 = true), "events" in c10 && nm(this, c10), nX(c10, function(t11, e11) {
            -1 !== a10.propsRequireUpdateSeries.indexOf("chart." + e11) && (r10 = true), -1 !== a10.propsRequireDirtyBox.indexOf(e11) && (a10.isDirtyBox = true), -1 === a10.propsRequireReflow.indexOf(e11) || (a10.isDirtyBox = true, l10 || (n10 = true));
          }), !a10.styledMode && c10.style && a10.renderer.setStyle(a10.options.chart.style || {})), !a10.styledMode && t10.colors && (this.options.colors = t10.colors), nX(t10, function(e11, i11) {
            a10[i11] && "function" == typeof a10[i11].update ? a10[i11].update(e11, false) : "function" == typeof a10[h10[i11]] ? a10[h10[i11]](e11) : "colors" !== i11 && -1 === a10.collectionsWithUpdate.indexOf(i11) && nF(true, a10.options[i11], t10[i11]), "chart" !== i11 && -1 !== a10.propsRequireUpdateSeries.indexOf(i11) && (r10 = true);
          }), this.collectionsWithUpdate.forEach(function(e11) {
            t10[e11] && (n$(t10[e11]).forEach(function(t11, s11) {
              let o11;
              let r11 = nP(t11.id);
              r11 && (o11 = a10.get(t11.id)), !o11 && a10[e11] && (o11 = a10[e11][nY(t11.index, s11)]) && (r11 && nP(o11.options.id) || o11.options.isInternal) && (o11 = void 0), o11 && o11.coll === e11 && (o11.update(t11, false), i10 && (o11.touched = true)), !o11 && i10 && a10.collectionsWithInit[e11] && (a10.collectionsWithInit[e11][0].apply(a10, [t11].concat(a10.collectionsWithInit[e11][1] || []).concat([false])).touched = true);
            }), i10 && a10[e11].forEach(function(t11) {
              t11.touched || t11.options.isInternal ? delete t11.touched : d10.push(t11);
            }));
          }), d10.forEach(function(t11) {
            t11.chart && t11.remove && t11.remove(false);
          }), o10 && a10.axes.forEach(function(t11) {
            t11.update({}, false);
          }), r10 && a10.getSeriesOrderByLinks().forEach(function(t11) {
            t11.chart && t11.update({}, false);
          }, this);
          let p10 = c10 && c10.width, u10 = c10 && (nH(c10.height) ? nU(c10.height, p10 || a10.chartWidth) : c10.height);
          n10 || nW(p10) && p10 !== a10.chartWidth || nW(u10) && u10 !== a10.chartHeight ? a10.setSize(p10, u10, s10) : nY(e10, true) && a10.redraw(s10), nD(a10, "afterUpdate", {
            options: t10,
            redraw: e10,
            animation: s10
          });
        }
        setSubtitle(t10, e10) {
          this.applyDescription("subtitle", t10), this.layOutTitles(e10);
        }
        setCaption(t10, e10) {
          this.applyDescription("caption", t10), this.layOutTitles(e10);
        }
        showResetZoom() {
          let t10 = this, e10 = ng.lang, i10 = t10.zooming.resetButton, s10 = i10.theme, o10 = "chart" === i10.relativeTo || "spacingBox" === i10.relativeTo ? null : "plotBox";
          function r10() {
            t10.zoomOut();
          }
          nD(this, "beforeShowResetZoom", null, function() {
            t10.resetZoomButton = t10.renderer.button(e10.resetZoom, null, null, r10, s10).attr({
              align: i10.position.align,
              title: e10.resetZoomTitle
            }).addClass("highcharts-reset-zoom").add().align(i10.position, false, o10);
          }), nD(this, "afterShowResetZoom");
        }
        zoomOut() {
          nD(this, "selection", {
            resetSelection: true
          }, () => this.transform({
            reset: true,
            trigger: "zoom"
          }));
        }
        pan(t10, e10) {
          let i10 = this, s10 = "object" == typeof e10 ? e10 : {
            enabled: e10,
            type: "x"
          }, o10 = s10.type, r10 = o10 && i10[{
            x: "xAxis",
            xy: "axes",
            y: "yAxis"
          }[o10]].filter((t11) => t11.options.panningEnabled && !t11.options.isInternal), n10 = i10.options.chart;
          n10?.panning && (n10.panning = s10), nD(this, "pan", {
            originalEvent: t10
          }, () => {
            i10.transform({
              axes: r10,
              event: t10,
              to: {
                x: t10.chartX - (i10.mouseDownX || 0),
                y: t10.chartY - (i10.mouseDownY || 0)
              },
              trigger: "pan"
            }), nT(i10.container, {
              cursor: "move"
            });
          });
        }
        transform(t10) {
          let {
            axes: e10 = this.axes,
            event: i10,
            from: s10 = {},
            reset: o10,
            selection: r10,
            to: n10 = {},
            trigger: a10
          } = t10, {
            inverted: h10,
            time: l10
          } = this, d10 = false, c10, p10;
          for (let t11 of (this.hoverPoints?.forEach((t12) => t12.setState()), e10)) {
            let {
              horiz: e11,
              len: u10,
              minPointOffset: g2 = 0,
              options: f2,
              reversed: m2
            } = t11, x2 = e11 ? "width" : "height", y2 = e11 ? "x" : "y", b2 = nY(n10[x2], t11.len), v2 = nY(s10[x2], t11.len), M2 = 10 > Math.abs(b2) ? 1 : b2 / v2, k2 = (s10[y2] || 0) + v2 / 2 - t11.pos, w2 = k2 - ((n10[y2] ?? t11.pos) + b2 / 2 - t11.pos) / M2, S2 = m2 && !h10 || !m2 && h10 ? -1 : 1;
            if (!o10 && (k2 < 0 || k2 > t11.len)) continue;
            let A2 = t11.toValue(w2, true) + (r10 || t11.isOrdinal ? 0 : g2 * S2), T2 = t11.toValue(w2 + u10 / M2, true) - (r10 || t11.isOrdinal ? 0 : g2 * S2 || 0), P2 = t11.allExtremes;
            if (A2 > T2 && ([A2, T2] = [T2, A2]), 1 === M2 && !o10 && "yAxis" === t11.coll && !P2) {
              for (let e12 of t11.series) {
                let t12 = e12.getExtremes(e12.getProcessedData(true).modified.getColumn("y") || [], true);
                P2 ?? (P2 = {
                  dataMin: Number.MAX_VALUE,
                  dataMax: -Number.MAX_VALUE
                }), nW(t12.dataMin) && nW(t12.dataMax) && (P2.dataMin = Math.min(t12.dataMin, P2.dataMin), P2.dataMax = Math.max(t12.dataMax, P2.dataMax));
              }
              t11.allExtremes = P2;
            }
            let {
              dataMin: C2,
              dataMax: O2,
              min: E2,
              max: L2
            } = nB(t11.getExtremes(), P2 || {}), B2 = l10.parse(f2.min), I2 = l10.parse(f2.max), D2 = C2 ?? B2, R2 = O2 ?? I2, N2 = T2 - A2, z2 = t11.categories ? 0 : Math.min(N2, R2 - D2), W2 = D2 - z2 * (nP(B2) ? 0 : f2.minPadding), G2 = R2 + z2 * (nP(I2) ? 0 : f2.maxPadding), H2 = t11.allowZoomOutside || 1 === M2 || "zoom" !== a10 && M2 > 1, F2 = Math.min(B2 ?? W2, W2, H2 ? E2 : W2), X2 = Math.max(I2 ?? G2, G2, H2 ? L2 : G2);
            (!t11.isOrdinal || t11.options.overscroll || 1 !== M2 || o10) && (A2 < F2 && (A2 = F2, M2 >= 1 && (T2 = A2 + N2)), T2 > X2 && (T2 = X2, M2 >= 1 && (A2 = T2 - N2)), (o10 || t11.series.length && (A2 !== E2 || T2 !== L2) && A2 >= F2 && T2 <= X2) && (r10 ? r10[t11.coll].push({
              axis: t11,
              min: A2,
              max: T2
            }) : (t11.isPanning = "zoom" !== a10, t11.isPanning && (p10 = true), t11.setExtremes(o10 ? void 0 : A2, o10 ? void 0 : T2, false, false, {
              move: w2,
              trigger: a10,
              scale: M2
            }), !o10 && (A2 > F2 || T2 < X2) && "mousewheel" !== a10 && (c10 = true)), d10 = true), i10 && (this[e11 ? "mouseDownX" : "mouseDownY"] = i10[e11 ? "chartX" : "chartY"]));
          }
          return d10 && (r10 ? nD(this, "selection", r10, () => {
            delete t10.selection, t10.trigger = "zoom", this.transform(t10);
          }) : (!c10 || p10 || this.resetZoomButton ? !c10 && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw("zoom" === a10 && (this.options.chart.animation ?? this.pointCount < 100)))), d10;
        }
      }
      nB(nZ.prototype, {
        callbacks: [],
        collectionsWithInit: {
          xAxis: [nZ.prototype.addAxis, [true]],
          yAxis: [nZ.prototype.addAxis, [false]],
          series: [nZ.prototype.addSeries]
        },
        collectionsWithUpdate: ["xAxis", "yAxis", "series"],
        propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],
        propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],
        propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]
      });
      let nK = nZ, {
        stop: nJ
      } = tU, {
        composed: nQ
      } = O, {
        addEvent: n0,
        createElement: n1,
        css: n2,
        defined: n3,
        erase: n5,
        merge: n6,
        pushUnique: n9
      } = tt;
      function n4() {
        let t10 = this.scrollablePlotArea;
        (this.scrollablePixelsX || this.scrollablePixelsY) && !t10 && (this.scrollablePlotArea = t10 = new n7(this)), t10?.applyFixed();
      }
      function n8() {
        this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = true);
      }
      class n7 {
        static compose(t10, e10, i10) {
          n9(nQ, this.compose) && (n0(t10, "afterInit", n8), n0(e10, "afterSetChartSize", (t11) => this.afterSetSize(t11.target, t11)), n0(e10, "render", n4), n0(i10, "show", n8));
        }
        static afterSetSize(t10, e10) {
          let i10, s10, o10;
          let {
            minWidth: r10,
            minHeight: n10
          } = t10.options.chart.scrollablePlotArea || {}, {
            clipBox: a10,
            plotBox: h10,
            inverted: l10,
            renderer: d10
          } = t10;
          if (!d10.forExport && (r10 ? (t10.scrollablePixelsX = i10 = Math.max(0, r10 - t10.chartWidth), i10 && (t10.scrollablePlotBox = n6(t10.plotBox), h10.width = t10.plotWidth += i10, a10[l10 ? "height" : "width"] += i10, o10 = true)) : n10 && (t10.scrollablePixelsY = s10 = Math.max(0, n10 - t10.chartHeight), n3(s10) && (t10.scrollablePlotBox = n6(t10.plotBox), h10.height = t10.plotHeight += s10, a10[l10 ? "width" : "height"] += s10, o10 = false)), n3(o10) && !e10.skipAxes)) for (let e11 of t10.axes) (e11.horiz === o10 || t10.hasParallelCoordinates && "yAxis" === e11.coll) && (e11.setAxisSize(), e11.setAxisTranslation());
        }
        constructor(t10) {
          let e10;
          let i10 = t10.options.chart, s10 = eu.getRendererType(), o10 = i10.scrollablePlotArea || {}, r10 = this.moveFixedElements.bind(this), n10 = {
            WebkitOverflowScrolling: "touch",
            overflowX: "hidden",
            overflowY: "hidden"
          };
          t10.scrollablePixelsX && (n10.overflowX = "auto"), t10.scrollablePixelsY && (n10.overflowY = "auto"), this.chart = t10;
          let a10 = this.parentDiv = n1("div", {
            className: "highcharts-scrolling-parent"
          }, {
            position: "relative"
          }, t10.renderTo), h10 = this.scrollingContainer = n1("div", {
            className: "highcharts-scrolling"
          }, n10, a10), l10 = this.innerContainer = n1("div", {
            className: "highcharts-inner-container"
          }, void 0, h10), d10 = this.fixedDiv = n1("div", {
            className: "highcharts-fixed"
          }, {
            position: "absolute",
            overflow: "hidden",
            pointerEvents: "none",
            zIndex: (i10.style?.zIndex || 0) + 2,
            top: 0
          }, void 0, true), c10 = this.fixedRenderer = new s10(d10, t10.chartWidth, t10.chartHeight, i10.style);
          this.mask = c10.path().attr({
            fill: i10.backgroundColor || "#fff",
            "fill-opacity": o10.opacity ?? 0.85,
            zIndex: -1
          }).addClass("highcharts-scrollable-mask").add(), h10.parentNode.insertBefore(d10, h10), n2(t10.renderTo, {
            overflow: "visible"
          }), n0(t10, "afterShowResetZoom", r10), n0(t10, "afterApplyDrilldown", r10), n0(t10, "afterLayOutTitles", r10), n0(h10, "scroll", () => {
            let {
              pointer: i11,
              hoverPoint: s11
            } = t10;
            i11 && (delete i11.chartPosition, s11 && (e10 = s11), i11.runPointActions(void 0, e10, true));
          }), l10.appendChild(t10.container);
        }
        applyFixed() {
          let {
            chart: t10,
            fixedRenderer: e10,
            isDirty: i10,
            scrollingContainer: s10
          } = this, {
            axisOffset: o10,
            chartWidth: r10,
            chartHeight: n10,
            container: a10,
            plotHeight: h10,
            plotLeft: l10,
            plotTop: d10,
            plotWidth: c10,
            scrollablePixelsX: p10 = 0,
            scrollablePixelsY: u10 = 0
          } = t10, {
            scrollPositionX: g2 = 0,
            scrollPositionY: f2 = 0
          } = t10.options.chart.scrollablePlotArea || {}, m2 = r10 + p10, x2 = n10 + u10;
          e10.setSize(r10, n10), (i10 ?? true) && (this.isDirty = false, this.moveFixedElements()), nJ(t10.container), n2(a10, {
            width: `${m2}px`,
            height: `${x2}px`
          }), t10.renderer.boxWrapper.attr({
            width: m2,
            height: x2,
            viewBox: [0, 0, m2, x2].join(" ")
          }), t10.chartBackground?.attr({
            width: m2,
            height: x2
          }), n2(s10, {
            width: `${r10}px`,
            height: `${n10}px`
          }), n3(i10) || (s10.scrollLeft = p10 * g2, s10.scrollTop = u10 * f2);
          let y2 = d10 - o10[0] - 1, b2 = l10 - o10[3] - 1, v2 = d10 + h10 + o10[2] + 1, M2 = l10 + c10 + o10[1] + 1, k2 = l10 + c10 - p10, w2 = d10 + h10 - u10, S2 = [["M", 0, 0]];
          p10 ? S2 = [["M", 0, y2], ["L", l10 - 1, y2], ["L", l10 - 1, v2], ["L", 0, v2], ["Z"], ["M", k2, y2], ["L", r10, y2], ["L", r10, v2], ["L", k2, v2], ["Z"]] : u10 && (S2 = [["M", b2, 0], ["L", b2, d10 - 1], ["L", M2, d10 - 1], ["L", M2, 0], ["Z"], ["M", b2, w2], ["L", b2, n10], ["L", M2, n10], ["L", M2, w2], ["Z"]]), "adjustHeight" !== t10.redrawTrigger && this.mask.attr({
            d: S2
          });
        }
        moveFixedElements() {
          let t10;
          let {
            container: e10,
            inverted: i10,
            scrollablePixelsX: s10,
            scrollablePixelsY: o10
          } = this.chart, r10 = this.fixedRenderer, n10 = n7.fixedSelectors;
          if (s10 && !i10 ? t10 = ".highcharts-yaxis" : s10 && i10 ? t10 = ".highcharts-xaxis" : o10 && !i10 ? t10 = ".highcharts-xaxis" : o10 && i10 && (t10 = ".highcharts-yaxis"), t10 && !(this.chart.hasParallelCoordinates && ".highcharts-yaxis" === t10)) for (let e11 of [`${t10}:not(.highcharts-radial-axis)`, `${t10}-labels:not(.highcharts-radial-axis-labels)`]) n9(n10, e11);
          else for (let t11 of [".highcharts-xaxis", ".highcharts-yaxis"]) for (let e11 of [`${t11}:not(.highcharts-radial-axis)`, `${t11}-labels:not(.highcharts-radial-axis-labels)`]) n5(n10, e11);
          for (let t11 of n10) [].forEach.call(e10.querySelectorAll(t11), (t12) => {
            (t12.namespaceURI === r10.SVG_NS ? r10.box : r10.box.parentNode).appendChild(t12), t12.style.pointerEvents = "auto";
          });
        }
      }
      n7.fixedSelectors = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-drillup-button", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-range-selector-group", ".highcharts-reset-zoom", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];
      let {
        format: at
      } = ep, {
        series: ae
      } = ry, {
        destroyObjectProperties: ai,
        fireEvent: as,
        getAlignFactor: ao,
        isNumber: ar,
        pick: an
      } = tt, aa = class {
        constructor(t10, e10, i10, s10, o10) {
          let r10 = t10.chart.inverted, n10 = t10.reversed;
          this.axis = t10;
          let a10 = this.isNegative = !!i10 != !!n10;
          this.options = e10 = e10 || {}, this.x = s10, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = false, this.stack = o10, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
            align: e10.align || (r10 ? a10 ? "left" : "right" : "center"),
            verticalAlign: e10.verticalAlign || (r10 ? "middle" : a10 ? "bottom" : "top"),
            y: e10.y,
            x: e10.x
          }, this.textAlign = e10.textAlign || (r10 ? a10 ? "right" : "left" : "center");
        }
        destroy() {
          ai(this, this.axis);
        }
        render(t10) {
          let e10 = this.axis.chart, i10 = this.options, s10 = i10.format, o10 = s10 ? at(s10, this, e10) : i10.formatter.call(this);
          if (this.label) this.label.attr({
            text: o10,
            visibility: "hidden"
          });
          else {
            this.label = e10.renderer.label(o10, null, void 0, i10.shape, void 0, void 0, i10.useHTML, false, "stack-labels");
            let s11 = {
              r: i10.borderRadius || 0,
              text: o10,
              padding: an(i10.padding, 5),
              visibility: "hidden"
            };
            e10.styledMode || (s11.fill = i10.backgroundColor, s11.stroke = i10.borderColor, s11["stroke-width"] = i10.borderWidth, this.label.css(i10.style || {})), this.label.attr(s11), this.label.added || this.label.add(t10);
          }
          this.label.labelrank = e10.plotSizeY, as(this, "afterRender");
        }
        setOffset(t10, e10, i10, s10, o10, r10) {
          let {
            alignOptions: n10,
            axis: a10,
            label: h10,
            options: l10,
            textAlign: d10
          } = this, c10 = a10.chart, p10 = this.getStackBox({
            xOffset: t10,
            width: e10,
            boxBottom: i10,
            boxTop: s10,
            defaultX: o10,
            xAxis: r10
          }), {
            verticalAlign: u10
          } = n10;
          if (h10 && p10) {
            let t11 = h10.getBBox(void 0, 0), e11 = h10.padding, i11 = "justify" === an(l10.overflow, "justify"), s11;
            n10.x = l10.x || 0, n10.y = l10.y || 0;
            let {
              x: o11,
              y: r11
            } = this.adjustStackPosition({
              labelBox: t11,
              verticalAlign: u10,
              textAlign: d10
            });
            p10.x -= o11, p10.y -= r11, h10.align(n10, false, p10), (s11 = c10.isInsidePlot(h10.alignAttr.x + n10.x + o11, h10.alignAttr.y + n10.y + r11)) || (i11 = false), i11 && ae.prototype.justifyDataLabel.call(a10, h10, n10, h10.alignAttr, t11, p10), h10.attr({
              x: h10.alignAttr.x,
              y: h10.alignAttr.y,
              rotation: l10.rotation,
              rotationOriginX: t11.width * ao(l10.textAlign || "center"),
              rotationOriginY: t11.height / 2
            }), an(!i11 && l10.crop, true) && (s11 = ar(h10.x) && ar(h10.y) && c10.isInsidePlot(h10.x - e11 + (h10.width || 0), h10.y) && c10.isInsidePlot(h10.x + e11, h10.y)), h10[s11 ? "show" : "hide"]();
          }
          as(this, "afterSetOffset", {
            xOffset: t10,
            width: e10
          });
        }
        adjustStackPosition({
          labelBox: t10,
          verticalAlign: e10,
          textAlign: i10
        }) {
          return {
            x: t10.width / 2 + t10.width / 2 * (2 * ao(i10) - 1),
            y: t10.height / 2 * 2 * (1 - ao(e10))
          };
        }
        getStackBox(t10) {
          let e10 = this.axis, i10 = e10.chart, {
            boxTop: s10,
            defaultX: o10,
            xOffset: r10,
            width: n10,
            boxBottom: a10
          } = t10, h10 = e10.stacking.usePercentage ? 100 : an(s10, this.total, 0), l10 = e10.toPixels(h10), d10 = t10.xAxis || i10.xAxis[0], c10 = an(o10, d10.translate(this.x)) + r10, p10 = Math.abs(l10 - e10.toPixels(a10 || ar(e10.min) && e10.logarithmic && e10.logarithmic.lin2log(e10.min) || 0)), u10 = i10.inverted, g2 = this.isNegative;
          return u10 ? {
            x: (g2 ? l10 : l10 - p10) - i10.plotLeft,
            y: d10.height - c10 - n10 + d10.top - i10.plotTop,
            width: p10,
            height: n10
          } : {
            x: c10 + d10.transB - i10.plotLeft,
            y: (g2 ? l10 - p10 : l10) - i10.plotTop,
            width: n10,
            height: p10
          };
        }
      }, {
        getDeferredAnimation: ah
      } = tU, {
        series: {
          prototype: al
        }
      } = ry, {
        addEvent: ad,
        correctFloat: ac,
        defined: ap,
        destroyObjectProperties: au,
        fireEvent: ag,
        isNumber: af,
        objectEach: am,
        pick: ax
      } = tt;
      function ay() {
        let t10 = this.inverted;
        this.axes.forEach((t11) => {
          t11.stacking && t11.stacking.stacks && t11.hasVisibleSeries && (t11.stacking.oldStacks = t11.stacking.stacks);
        }), this.series.forEach((e10) => {
          let i10 = e10.xAxis && e10.xAxis.options || {};
          e10.options.stacking && e10.reserveSpace() && (e10.stackKey = [e10.type, ax(e10.options.stack, ""), t10 ? i10.top : i10.left, t10 ? i10.height : i10.width].join(","));
        });
      }
      function ab() {
        let t10 = this.stacking;
        if (t10) {
          let e10 = t10.stacks;
          am(e10, (t11, i10) => {
            au(t11), delete e10[i10];
          }), t10.stackTotalGroup?.destroy();
        }
      }
      function av() {
        this.stacking || (this.stacking = new aT(this));
      }
      function aM(t10, e10, i10, s10) {
        return !ap(t10) || t10.x !== e10 || s10 && t10.stackKey !== s10 ? t10 = {
          x: e10,
          index: 0,
          key: s10,
          stackKey: s10
        } : t10.index++, t10.key = [i10, e10, t10.index].join(","), t10;
      }
      function ak() {
        let t10;
        let e10 = this, i10 = e10.yAxis, s10 = e10.stackKey || "", o10 = i10.stacking.stacks, r10 = e10.getColumn("x", true), n10 = e10.options.stacking, a10 = e10[n10 + "Stacker"];
        a10 && [s10, "-" + s10].forEach((i11) => {
          let s11 = r10.length, n11, h10, l10;
          for (; s11--; ) n11 = r10[s11], t10 = e10.getStackIndicator(t10, n11, e10.index, i11), h10 = o10[i11]?.[n11], (l10 = h10?.points[t10.key || ""]) && a10.call(e10, l10, h10, s11);
        });
      }
      function aw(t10, e10, i10) {
        let s10 = e10.total ? 100 / e10.total : 0;
        t10[0] = ac(t10[0] * s10), t10[1] = ac(t10[1] * s10), this.stackedYData[i10] = t10[1];
      }
      function aS(t10) {
        (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? al.setStackedPoints.call(this, t10, "group") : t10.stacking.resetStacks());
      }
      function aA(t10, e10) {
        let i10, s10, o10, r10, n10, a10, h10;
        let l10 = e10 || this.options.stacking;
        if (!l10 || !this.reserveSpace() || ({
          group: "xAxis"
        }[l10] || "yAxis") !== t10.coll) return;
        let d10 = this.getColumn("x", true), c10 = this.getColumn(this.pointValKey || "y", true), p10 = [], u10 = c10.length, g2 = this.options, f2 = g2.threshold || 0, m2 = g2.startFromThreshold ? f2 : 0, x2 = g2.stack, y2 = e10 ? `${this.type},${l10}` : this.stackKey || "", b2 = "-" + y2, v2 = this.negStacks, M2 = t10.stacking, k2 = M2.stacks, w2 = M2.oldStacks;
        for (M2.stacksTouched += 1, h10 = 0; h10 < u10; h10++) {
          let e11 = d10[h10] || 0, u11 = c10[h10], g3 = af(u11) && u11 || 0;
          a10 = (i10 = this.getStackIndicator(i10, e11, this.index)).key || "", k2[n10 = (s10 = v2 && g3 < (m2 ? 0 : f2)) ? b2 : y2] || (k2[n10] = {}), k2[n10][e11] || (w2[n10]?.[e11] ? (k2[n10][e11] = w2[n10][e11], k2[n10][e11].total = null) : k2[n10][e11] = new aa(t10, t10.options.stackLabels, !!s10, e11, x2)), o10 = k2[n10][e11], null !== u11 ? (o10.points[a10] = o10.points[this.index] = [ax(o10.cumulative, m2)], ap(o10.cumulative) || (o10.base = a10), o10.touched = M2.stacksTouched, i10.index > 0 && false === this.singleStacks && (o10.points[a10][0] = o10.points[this.index + "," + e11 + ",0"][0])) : (delete o10.points[a10], delete o10.points[this.index]);
          let S2 = o10.total || 0;
          "percent" === l10 ? (r10 = s10 ? y2 : b2, S2 = v2 && k2[r10]?.[e11] ? (r10 = k2[r10][e11]).total = Math.max(r10.total || 0, S2) + Math.abs(g3) : ac(S2 + Math.abs(g3))) : "group" === l10 ? af(u11) && S2++ : S2 = ac(S2 + g3), "group" === l10 ? o10.cumulative = (S2 || 1) - 1 : o10.cumulative = ac(ax(o10.cumulative, m2) + g3), o10.total = S2, null !== u11 && (o10.points[a10].push(o10.cumulative), p10[h10] = o10.cumulative, o10.hasValidPoints = true);
        }
        "percent" === l10 && (M2.usePercentage = true), "group" !== l10 && (this.stackedYData = p10), M2.oldStacks = {};
      }
      class aT {
        constructor(t10) {
          this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t10;
        }
        buildStacks() {
          let t10, e10;
          let i10 = this.axis, s10 = i10.series, o10 = "xAxis" === i10.coll, r10 = i10.options.reversedStacks, n10 = s10.length;
          for (this.resetStacks(), this.usePercentage = false, e10 = n10; e10--; ) t10 = s10[r10 ? e10 : n10 - e10 - 1], o10 && t10.setGroupedPoints(i10), t10.setStackedPoints(i10);
          if (!o10) for (e10 = 0; e10 < n10; e10++) s10[e10].modifyStacks();
          ag(i10, "afterBuildStacks");
        }
        cleanStacks() {
          this.oldStacks && (this.stacks = this.oldStacks, am(this.stacks, (t10) => {
            am(t10, (t11) => {
              t11.cumulative = t11.total;
            });
          }));
        }
        resetStacks() {
          am(this.stacks, (t10) => {
            am(t10, (e10, i10) => {
              af(e10.touched) && e10.touched < this.stacksTouched ? (e10.destroy(), delete t10[i10]) : (e10.total = null, e10.cumulative = null);
            });
          });
        }
        renderStackTotals() {
          let t10 = this.axis, e10 = t10.chart, i10 = e10.renderer, s10 = this.stacks, o10 = ah(e10, t10.options.stackLabels?.animation || false), r10 = this.stackTotalGroup = this.stackTotalGroup || i10.g("stack-labels").attr({
            zIndex: 6,
            opacity: 0
          }).add();
          r10.translate(e10.plotLeft, e10.plotTop), am(s10, (t11) => {
            am(t11, (t12) => {
              t12.render(r10);
            });
          }), r10.animate({
            opacity: 1
          }, o10);
        }
      }
      (f || (f = {})).compose = function(t10, e10, i10) {
        let s10 = e10.prototype, o10 = i10.prototype;
        s10.getStacks || (ad(t10, "init", av), ad(t10, "destroy", ab), s10.getStacks = ay, o10.getStackIndicator = aM, o10.modifyStacks = ak, o10.percentStacker = aw, o10.setGroupedPoints = aS, o10.setStackedPoints = aA);
      };
      let aP = f, {
        defined: aC,
        merge: aO,
        isObject: aE
      } = tt;
      class aL extends rK {
        drawGraph() {
          let t10 = this.options, e10 = (this.gappedPath || this.getGraphPath).call(this), i10 = this.chart.styledMode;
          [this, ...this.zones].forEach((s10, o10) => {
            let r10, n10 = s10.graph, a10 = n10 ? "animate" : "attr", h10 = s10.dashStyle || t10.dashStyle;
            n10 ? (n10.endX = this.preventGraphAnimation ? null : e10.xMap, n10.animate({
              d: e10
            })) : e10.length && (s10.graph = n10 = this.chart.renderer.path(e10).addClass("highcharts-graph" + (o10 ? ` highcharts-zone-graph-${o10 - 1} ` : " ") + (o10 && s10.className || "")).attr({
              zIndex: 1
            }).add(this.group)), n10 && !i10 && (r10 = {
              stroke: !o10 && t10.lineColor || s10.color || this.color || "#cccccc",
              "stroke-width": t10.lineWidth || 0,
              fill: this.fillGraph && this.color || "none"
            }, h10 ? r10.dashstyle = h10 : "square" !== t10.linecap && (r10["stroke-linecap"] = r10["stroke-linejoin"] = "round"), n10[a10](r10).shadow(t10.shadow && aO({
              filterUnits: "userSpaceOnUse"
            }, aE(t10.shadow) ? t10.shadow : {}))), n10 && (n10.startX = e10.xMap, n10.isArea = e10.isArea);
          });
        }
        getGraphPath(t10, e10, i10) {
          let s10 = this, o10 = s10.options, r10 = [], n10 = [], a10, h10 = o10.step, l10 = (t10 = t10 || s10.points).reversed;
          return l10 && t10.reverse(), (h10 = {
            right: 1,
            center: 2
          }[h10] || h10 && 3) && l10 && (h10 = 4 - h10), (t10 = this.getValidPoints(t10, false, !(o10.connectNulls && !e10 && !i10))).forEach(function(l11, d10) {
            let c10;
            let p10 = l11.plotX, u10 = l11.plotY, g2 = t10[d10 - 1], f2 = l11.isNull || "number" != typeof u10;
            (l11.leftCliff || g2 && g2.rightCliff) && !i10 && (a10 = true), f2 && !aC(e10) && d10 > 0 ? a10 = !o10.connectNulls : f2 && !e10 ? a10 = true : (0 === d10 || a10 ? c10 = [["M", l11.plotX, l11.plotY]] : s10.getPointSpline ? c10 = [s10.getPointSpline(t10, l11, d10)] : h10 ? (c10 = 1 === h10 ? [["L", g2.plotX, u10]] : 2 === h10 ? [["L", (g2.plotX + p10) / 2, g2.plotY], ["L", (g2.plotX + p10) / 2, u10]] : [["L", p10, g2.plotY]]).push(["L", p10, u10]) : c10 = [["L", p10, u10]], n10.push(l11.x), h10 && (n10.push(l11.x), 2 === h10 && n10.push(l11.x)), r10.push.apply(r10, c10), a10 = false);
          }), r10.xMap = n10, s10.graphPath = r10, r10;
        }
      }
      aL.defaultOptions = aO(rK.defaultOptions, {
        legendSymbol: "lineMarker"
      }), ry.registerSeriesType("line", aL);
      let {
        seriesTypes: {
          line: aB
        }
      } = ry, {
        extend: aI,
        merge: aD,
        objectEach: aR,
        pick: aN
      } = tt;
      class az extends aB {
        drawGraph() {
          this.areaPath = [], super.drawGraph.apply(this);
          let {
            areaPath: t10,
            options: e10
          } = this;
          [this, ...this.zones].forEach((i10, s10) => {
            let o10 = {}, r10 = i10.fillColor || e10.fillColor, n10 = i10.area, a10 = n10 ? "animate" : "attr";
            n10 ? (n10.endX = this.preventGraphAnimation ? null : t10.xMap, n10.animate({
              d: t10
            })) : (o10.zIndex = 0, (n10 = i10.area = this.chart.renderer.path(t10).addClass("highcharts-area" + (s10 ? ` highcharts-zone-area-${s10 - 1} ` : " ") + (s10 && i10.className || "")).add(this.group)).isArea = true), this.chart.styledMode || (o10.fill = r10 || i10.color || this.color, o10["fill-opacity"] = r10 ? 1 : e10.fillOpacity ?? 0.75, n10.css({
              pointerEvents: this.stickyTracking ? "none" : "auto"
            })), n10[a10](o10), n10.startX = t10.xMap, n10.shiftUnit = e10.step ? 2 : 1;
          });
        }
        getGraphPath(t10) {
          let e10, i10, s10;
          let o10 = aB.prototype.getGraphPath, r10 = this.options, n10 = r10.stacking, a10 = this.yAxis, h10 = [], l10 = [], d10 = this.index, c10 = a10.stacking.stacks[this.stackKey], p10 = r10.threshold, u10 = Math.round(a10.getThreshold(r10.threshold)), g2 = aN(r10.connectNulls, "percent" === n10), f2 = function(i11, s11, o11) {
            let r11 = t10[i11], g3 = n10 && c10[r11.x].points[d10], f3 = r11[o11 + "Null"] || 0, m3 = r11[o11 + "Cliff"] || 0, x3, y3, b3 = true;
            m3 || f3 ? (x3 = (f3 ? g3[0] : g3[1]) + m3, y3 = g3[0] + m3, b3 = !!f3) : !n10 && t10[s11] && t10[s11].isNull && (x3 = y3 = p10), void 0 !== x3 && (l10.push({
              plotX: e10,
              plotY: null === x3 ? u10 : a10.getThreshold(x3),
              isNull: b3,
              isCliff: true
            }), h10.push({
              plotX: e10,
              plotY: null === y3 ? u10 : a10.getThreshold(y3),
              doCurve: false
            }));
          };
          t10 = t10 || this.points, n10 && (t10 = this.getStackPoints(t10));
          for (let o11 = 0, r11 = t10.length; o11 < r11; ++o11) n10 || (t10[o11].leftCliff = t10[o11].rightCliff = t10[o11].leftNull = t10[o11].rightNull = void 0), i10 = t10[o11].isNull, e10 = aN(t10[o11].rectPlotX, t10[o11].plotX), s10 = n10 ? aN(t10[o11].yBottom, u10) : u10, i10 && !g2 || (g2 || f2(o11, o11 - 1, "left"), i10 && !n10 && g2 || (l10.push(t10[o11]), h10.push({
            x: o11,
            plotX: e10,
            plotY: s10
          })), g2 || f2(o11, o11 + 1, "right"));
          let m2 = o10.call(this, l10, true, true);
          h10.reversed = true;
          let x2 = o10.call(this, h10, true, true), y2 = x2[0];
          y2 && "M" === y2[0] && (x2[0] = ["L", y2[1], y2[2]]);
          let b2 = m2.concat(x2);
          b2.length && b2.push(["Z"]);
          let v2 = o10.call(this, l10, false, g2);
          return this.chart.series.length > 1 && n10 && l10.some((t11) => t11.isCliff) && (b2.hasStackedCliffs = v2.hasStackedCliffs = true), b2.xMap = m2.xMap, this.areaPath = b2, v2;
        }
        getStackPoints(t10) {
          let e10 = this, i10 = [], s10 = [], o10 = this.xAxis, r10 = this.yAxis, n10 = r10.stacking.stacks[this.stackKey], a10 = {}, h10 = r10.series, l10 = h10.length, d10 = r10.options.reversedStacks ? 1 : -1, c10 = h10.indexOf(e10);
          if (t10 = t10 || this.points, this.options.stacking) {
            for (let e11 = 0; e11 < t10.length; e11++) t10[e11].leftNull = t10[e11].rightNull = void 0, a10[t10[e11].x] = t10[e11];
            aR(n10, function(t11, e11) {
              null !== t11.total && s10.push(e11);
            }), s10.sort(function(t11, e11) {
              return t11 - e11;
            });
            let p10 = h10.map((t11) => t11.visible);
            s10.forEach(function(t11, u10) {
              let g2 = 0, f2, m2;
              if (a10[t11] && !a10[t11].isNull) i10.push(a10[t11]), [-1, 1].forEach(function(i11) {
                let o11 = 1 === i11 ? "rightNull" : "leftNull", r11 = n10[s10[u10 + i11]], g3 = 0;
                if (r11) {
                  let i12 = c10;
                  for (; i12 >= 0 && i12 < l10; ) {
                    let s11 = h10[i12].index;
                    !(f2 = r11.points[s11]) && (s11 === e10.index ? a10[t11][o11] = true : p10[i12] && (m2 = n10[t11].points[s11]) && (g3 -= m2[1] - m2[0])), i12 += d10;
                  }
                }
                a10[t11][1 === i11 ? "rightCliff" : "leftCliff"] = g3;
              });
              else {
                let e11 = c10;
                for (; e11 >= 0 && e11 < l10; ) {
                  let i11 = h10[e11].index;
                  if (f2 = n10[t11].points[i11]) {
                    g2 = f2[1];
                    break;
                  }
                  e11 += d10;
                }
                g2 = aN(g2, 0), g2 = r10.translate(g2, 0, 1, 0, 1), i10.push({
                  isNull: true,
                  plotX: o10.translate(t11, 0, 0, 0, 1),
                  x: t11,
                  plotY: g2,
                  yBottom: g2
                });
              }
            });
          }
          return i10;
        }
      }
      az.defaultOptions = aD(aB.defaultOptions, {
        threshold: 0,
        legendSymbol: "areaMarker"
      }), aI(az.prototype, {
        singleStacks: false
      }), ry.registerSeriesType("area", az);
      let {
        line: aW
      } = ry.seriesTypes, {
        merge: aG,
        pick: aH
      } = tt;
      class aF extends aW {
        getPointSpline(t10, e10, i10) {
          let s10, o10, r10, n10;
          let a10 = e10.plotX || 0, h10 = e10.plotY || 0, l10 = t10[i10 - 1], d10 = t10[i10 + 1];
          function c10(t11) {
            return t11 && !t11.isNull && false !== t11.doCurve && !e10.isCliff;
          }
          if (c10(l10) && c10(d10)) {
            let t11 = l10.plotX || 0, i11 = l10.plotY || 0, c11 = d10.plotX || 0, p11 = d10.plotY || 0, u10 = 0;
            s10 = (1.5 * a10 + t11) / 2.5, o10 = (1.5 * h10 + i11) / 2.5, r10 = (1.5 * a10 + c11) / 2.5, n10 = (1.5 * h10 + p11) / 2.5, r10 !== s10 && (u10 = (n10 - o10) * (r10 - a10) / (r10 - s10) + h10 - n10), o10 += u10, n10 += u10, o10 > i11 && o10 > h10 ? (o10 = Math.max(i11, h10), n10 = 2 * h10 - o10) : o10 < i11 && o10 < h10 && (o10 = Math.min(i11, h10), n10 = 2 * h10 - o10), n10 > p11 && n10 > h10 ? (n10 = Math.max(p11, h10), o10 = 2 * h10 - n10) : n10 < p11 && n10 < h10 && (n10 = Math.min(p11, h10), o10 = 2 * h10 - n10), e10.rightContX = r10, e10.rightContY = n10, e10.controlPoints = {
              low: [s10, o10],
              high: [r10, n10]
            };
          }
          let p10 = ["C", aH(l10.rightContX, l10.plotX, 0), aH(l10.rightContY, l10.plotY, 0), aH(s10, a10, 0), aH(o10, h10, 0), a10, h10];
          return l10.rightContX = l10.rightContY = void 0, p10;
        }
      }
      aF.defaultOptions = aG(aW.defaultOptions), ry.registerSeriesType("spline", aF);
      let aX = aF, {
        area: aY,
        area: {
          prototype: aj
        }
      } = ry.seriesTypes, {
        extend: aU,
        merge: aV
      } = tt;
      class a$ extends aX {
      }
      a$.defaultOptions = aV(aX.defaultOptions, aY.defaultOptions), aU(a$.prototype, {
        getGraphPath: aj.getGraphPath,
        getStackPoints: aj.getStackPoints,
        drawGraph: aj.drawGraph
      }), ry.registerSeriesType("areaspline", a$);
      let {
        animObject: a_
      } = tU, {
        parse: aq
      } = tO, {
        noop: aZ
      } = O, {
        clamp: aK,
        crisp: aJ,
        defined: aQ,
        extend: a0,
        fireEvent: a1,
        isArray: a2,
        isNumber: a3,
        merge: a5,
        pick: a6,
        objectEach: a9
      } = tt;
      class a4 extends rK {
        animate(t10) {
          let e10, i10;
          let s10 = this, o10 = this.yAxis, r10 = o10.pos, n10 = o10.reversed, a10 = s10.options, {
            clipOffset: h10,
            inverted: l10
          } = this.chart, d10 = {}, c10 = l10 ? "translateX" : "translateY";
          t10 && h10 ? (d10.scaleY = 1e-3, i10 = aK(o10.toPixels(a10.threshold || 0), r10, r10 + o10.len), l10 ? (i10 += n10 ? -Math.floor(h10[0]) : Math.ceil(h10[2]), d10.translateX = i10 - o10.len) : (i10 += n10 ? Math.ceil(h10[0]) : -Math.floor(h10[2]), d10.translateY = i10), s10.clipBox && s10.setClip(), s10.group.attr(d10)) : (e10 = Number(s10.group.attr(c10)), s10.group.animate({
            scaleY: 1
          }, a0(a_(s10.options.animation), {
            step: function(t11, i11) {
              s10.group && (d10[c10] = e10 + i11.pos * (r10 - e10), s10.group.attr(d10));
            }
          })));
        }
        init(t10, e10) {
          super.init.apply(this, arguments);
          let i10 = this;
          (t10 = i10.chart).hasRendered && t10.series.forEach(function(t11) {
            t11.type === i10.type && (t11.isDirty = true);
          });
        }
        getColumnMetrics() {
          let t10 = this, e10 = t10.options, i10 = t10.xAxis, s10 = t10.yAxis, o10 = i10.options.reversedStacks, r10 = i10.reversed && !o10 || !i10.reversed && o10, n10 = {}, a10, h10 = 0;
          false === e10.grouping ? h10 = 1 : t10.chart.series.forEach(function(e11) {
            let i11;
            let o11 = e11.yAxis, r11 = e11.options;
            e11.type === t10.type && e11.reserveSpace() && s10.len === o11.len && s10.pos === o11.pos && (r11.stacking && "group" !== r11.stacking ? (void 0 === n10[a10 = e11.stackKey] && (n10[a10] = h10++), i11 = n10[a10]) : false !== r11.grouping && (i11 = h10++), e11.columnIndex = i11);
          });
          let l10 = Math.min(Math.abs(i10.transA) * (!i10.brokenAxis?.hasBreaks && i10.ordinal?.slope || e10.pointRange || i10.closestPointRange || i10.tickInterval || 1), i10.len), d10 = l10 * e10.groupPadding, c10 = (l10 - 2 * d10) / (h10 || 1), p10 = Math.min(e10.maxPointWidth || i10.len, a6(e10.pointWidth, c10 * (1 - 2 * e10.pointPadding))), u10 = (t10.columnIndex || 0) + (r10 ? 1 : 0);
          return t10.columnMetrics = {
            width: p10,
            offset: (c10 - p10) / 2 + (d10 + u10 * c10 - l10 / 2) * (r10 ? -1 : 1),
            paddedWidth: c10,
            columnCount: h10
          }, t10.columnMetrics;
        }
        crispCol(t10, e10, i10, s10) {
          let o10 = this.borderWidth, r10 = this.chart.inverted;
          return s10 = aJ(e10 + s10, o10, r10) - (e10 = aJ(e10, o10, r10)), this.options.crisp && (i10 = aJ(t10 + i10, o10) - (t10 = aJ(t10, o10))), {
            x: t10,
            y: e10,
            width: i10,
            height: s10
          };
        }
        adjustForMissingColumns(t10, e10, i10, s10) {
          if (!i10.isNull && s10.columnCount > 1) {
            let o10 = this.xAxis.series.filter((t11) => t11.visible).map((t11) => t11.index), r10 = 0, n10 = 0;
            a9(this.xAxis.stacking?.stacks, (t11) => {
              let e11 = "number" == typeof i10.x ? t11[i10.x.toString()]?.points : void 0, s11 = e11?.[this.index], a11 = {};
              if (e11 && a2(s11)) {
                let t12 = this.index, i11 = Object.keys(e11).filter((t13) => !t13.match(",") && e11[t13] && e11[t13].length > 1).map(parseFloat).filter((t13) => -1 !== o10.indexOf(t13)).filter((e12) => {
                  let i12 = this.chart.series[e12].options, s12 = i12.stacking && i12.stack;
                  if (aQ(s12)) {
                    if (a3(a11[s12])) return t12 === e12 && (t12 = a11[s12]), false;
                    a11[s12] = e12;
                  }
                  return true;
                }).sort((t13, e12) => e12 - t13);
                r10 = i11.indexOf(t12), n10 = i11.length;
              }
            }), r10 = this.xAxis.reversed ? n10 - 1 - r10 : r10;
            let a10 = (n10 - 1) * s10.paddedWidth + e10;
            t10 = (i10.plotX || 0) + a10 / 2 - e10 - r10 * s10.paddedWidth;
          }
          return t10;
        }
        translate() {
          let t10 = this, e10 = t10.chart, i10 = t10.options, s10 = t10.dense = t10.closestPointRange * t10.xAxis.transA < 2, o10 = t10.borderWidth = a6(i10.borderWidth, s10 ? 0 : 1), r10 = t10.xAxis, n10 = t10.yAxis, a10 = i10.threshold, h10 = a6(i10.minPointLength, 5), l10 = t10.getColumnMetrics(), d10 = l10.width, c10 = t10.pointXOffset = l10.offset, p10 = t10.dataMin, u10 = t10.dataMax, g2 = t10.translatedThreshold = n10.getThreshold(a10), f2 = t10.barW = Math.max(d10, 1 + 2 * o10);
          i10.pointPadding && i10.crisp && (f2 = Math.ceil(f2)), rK.prototype.translate.apply(t10), t10.points.forEach(function(s11) {
            let o11 = a6(s11.yBottom, g2), m2 = 999 + Math.abs(o11), x2 = s11.plotX || 0, y2 = aK(s11.plotY, -m2, n10.len + m2), b2, v2 = Math.min(y2, o11), M2 = Math.max(y2, o11) - v2, k2 = d10, w2 = x2 + c10, S2 = f2;
            h10 && Math.abs(M2) < h10 && (M2 = h10, b2 = !n10.reversed && !s11.negative || n10.reversed && s11.negative, a3(a10) && a3(u10) && s11.y === a10 && u10 <= a10 && (n10.min || 0) < a10 && (p10 !== u10 || (n10.max || 0) <= a10) && (b2 = !b2, s11.negative = !s11.negative), v2 = Math.abs(v2 - g2) > h10 ? o11 - h10 : g2 - (b2 ? h10 : 0)), aQ(s11.options.pointWidth) && (w2 -= Math.round(((k2 = S2 = Math.ceil(s11.options.pointWidth)) - d10) / 2)), i10.centerInCategory && (w2 = t10.adjustForMissingColumns(w2, k2, s11, l10)), s11.barX = w2, s11.pointWidth = k2, s11.tooltipPos = e10.inverted ? [aK(n10.len + n10.pos - e10.plotLeft - y2, n10.pos - e10.plotLeft, n10.len + n10.pos - e10.plotLeft), r10.len + r10.pos - e10.plotTop - w2 - S2 / 2, M2] : [r10.left - e10.plotLeft + w2 + S2 / 2, aK(y2 + n10.pos - e10.plotTop, n10.pos - e10.plotTop, n10.len + n10.pos - e10.plotTop), M2], s11.shapeType = t10.pointClass.prototype.shapeType || "roundedRect", s11.shapeArgs = t10.crispCol(w2, s11.isNull ? g2 : v2, S2, s11.isNull ? 0 : M2);
          }), a1(this, "afterColumnTranslate");
        }
        drawGraph() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        }
        pointAttribs(t10, e10) {
          let i10 = this.options, s10 = this.pointAttrToOptions || {}, o10 = s10.stroke || "borderColor", r10 = s10["stroke-width"] || "borderWidth", n10, a10, h10, l10 = t10 && t10.color || this.color, d10 = t10 && t10[o10] || i10[o10] || l10, c10 = t10 && t10.options.dashStyle || i10.dashStyle, p10 = t10 && t10[r10] || i10[r10] || this[r10] || 0, u10 = a6(t10 && t10.opacity, i10.opacity, 1);
          t10 && this.zones.length && (a10 = t10.getZone(), l10 = t10.options.color || a10 && (a10.color || t10.nonZonedColor) || this.color, a10 && (d10 = a10.borderColor || d10, c10 = a10.dashStyle || c10, p10 = a10.borderWidth || p10)), e10 && t10 && (h10 = (n10 = a5(i10.states[e10], t10.options.states && t10.options.states[e10] || {})).brightness, l10 = n10.color || void 0 !== h10 && aq(l10).brighten(n10.brightness).get() || l10, d10 = n10[o10] || d10, p10 = n10[r10] || p10, c10 = n10.dashStyle || c10, u10 = a6(n10.opacity, u10));
          let g2 = {
            fill: l10,
            stroke: d10,
            "stroke-width": p10,
            opacity: u10
          };
          return c10 && (g2.dashstyle = c10), g2;
        }
        drawPoints(t10 = this.points) {
          let e10;
          let i10 = this, s10 = this.chart, o10 = i10.options, r10 = s10.renderer, n10 = o10.animationLimit || 250;
          t10.forEach(function(t11) {
            let a10 = t11.plotY, h10 = t11.graphic, l10 = !!h10, d10 = h10 && s10.pointCount < n10 ? "animate" : "attr";
            a3(a10) && null !== t11.y ? (e10 = t11.shapeArgs, h10 && t11.hasNewShapeType() && (h10 = h10.destroy()), i10.enabledDataSorting && (t11.startXPos = i10.xAxis.reversed ? -(e10 && e10.width || 0) : i10.xAxis.width), !h10 && (t11.graphic = h10 = r10[t11.shapeType](e10).add(t11.group || i10.group), h10 && i10.enabledDataSorting && s10.hasRendered && s10.pointCount < n10 && (h10.attr({
              x: t11.startXPos
            }), l10 = true, d10 = "animate")), h10 && l10 && h10[d10](a5(e10)), s10.styledMode || h10[d10](i10.pointAttribs(t11, t11.selected && "select")).shadow(false !== t11.allowShadow && o10.shadow), h10 && (h10.addClass(t11.getClassName(), true), h10.attr({
              visibility: t11.visible ? "inherit" : "hidden"
            }))) : h10 && (t11.graphic = h10.destroy());
          });
        }
        drawTracker(t10 = this.points) {
          let e10;
          let i10 = this, s10 = i10.chart, o10 = s10.pointer, r10 = function(t11) {
            o10?.normalize(t11);
            let e11 = o10?.getPointFromEvent(t11), r11 = !s10.scrollablePlotArea || s10.isInsidePlot(t11.chartX - s10.plotLeft, t11.chartY - s10.plotTop, {
              visiblePlotOnly: true
            });
            o10 && e11 && i10.options.enableMouseTracking && r11 && (o10.isDirectTouch = true, e11.onMouseOver(t11));
          };
          t10.forEach(function(t11) {
            e10 = a2(t11.dataLabels) ? t11.dataLabels : t11.dataLabel ? [t11.dataLabel] : [], t11.graphic && (t11.graphic.element.point = t11), e10.forEach(function(e11) {
              (e11.div || e11.element).point = t11;
            });
          }), i10._hasTracking || (i10.trackerGroups.forEach(function(t11) {
            i10[t11] && (i10[t11].addClass("highcharts-tracker").on("mouseover", r10).on("mouseout", function(t12) {
              o10?.onTrackerMouseOut(t12);
            }).on("touchstart", r10), !s10.styledMode && i10.options.cursor && i10[t11].css({
              cursor: i10.options.cursor
            }));
          }), i10._hasTracking = true), a1(this, "afterDrawTracker");
        }
        remove() {
          let t10 = this, e10 = t10.chart;
          e10.hasRendered && e10.series.forEach(function(e11) {
            e11.type === t10.type && (e11.isDirty = true);
          }), rK.prototype.remove.apply(t10, arguments);
        }
      }
      a4.defaultOptions = a5(rK.defaultOptions, {
        borderRadius: 3,
        centerInCategory: false,
        groupPadding: 0.2,
        marker: null,
        pointPadding: 0.1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
          hover: {
            halo: false,
            brightness: 0.1
          },
          select: {
            color: "#cccccc",
            borderColor: "#000000"
          }
        },
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          y: void 0
        },
        startFromThreshold: true,
        stickyTracking: false,
        tooltip: {
          distance: 6
        },
        threshold: 0,
        borderColor: "#ffffff"
      }), a0(a4.prototype, {
        directTouch: true,
        getSymbol: aZ,
        negStacks: true,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), ry.registerSeriesType("column", a4);
      let a8 = a4, {
        getDeferredAnimation: a7
      } = tU, {
        format: ht
      } = ep, {
        defined: he,
        extend: hi,
        fireEvent: hs,
        getAlignFactor: ho,
        isArray: hr,
        isString: hn,
        merge: ha,
        objectEach: hh,
        pick: hl,
        pInt: hd,
        splat: hc
      } = tt;
      !function(t10) {
        function e10() {
          return h10(this).some((t11) => t11?.enabled);
        }
        function i10(t11, e11, i11, s11, o11) {
          let {
            chart: r11,
            enabledDataSorting: n11
          } = this, a11 = this.isCartesian && r11.inverted, h11 = t11.plotX, l11 = t11.plotY, d10 = i11.rotation || 0, c10 = he(h11) && he(l11) && r11.isInsidePlot(h11, Math.round(l11), {
            inverted: a11,
            paneCoordinates: true,
            series: this
          }), p10 = 0 === d10 && "justify" === hl(i11.overflow, n11 ? "none" : "justify"), u10 = this.visible && false !== t11.visible && he(h11) && (t11.series.forceDL || n11 && !p10 || c10 || hl(i11.inside, !!this.options.stacking) && s11 && r11.isInsidePlot(h11, a11 ? s11.x + 1 : s11.y + s11.height - 1, {
            inverted: a11,
            paneCoordinates: true,
            series: this
          })), g2 = t11.pos();
          if (u10 && g2) {
            var f2;
            let h12 = e11.getBBox(), l12 = e11.getBBox(void 0, 0);
            if (s11 = hi({
              x: g2[0],
              y: Math.round(g2[1]),
              width: 0,
              height: 0
            }, s11 || {}), "plotEdges" === i11.alignTo && this.isCartesian && (s11[a11 ? "x" : "y"] = 0, s11[a11 ? "width" : "height"] = this.yAxis?.len || 0), hi(i11, {
              width: h12.width,
              height: h12.height
            }), f2 = s11, n11 && this.xAxis && !p10 && this.setDataLabelStartPos(t11, e11, o11, c10, f2), e11.align(ha(i11, {
              width: l12.width,
              height: l12.height
            }), false, s11, false), e11.alignAttr.x += ho(i11.align) * (l12.width - h12.width), e11.alignAttr.y += ho(i11.verticalAlign) * (l12.height - h12.height), e11[e11.placed ? "animate" : "attr"]({
              "text-align": e11.alignAttr["text-align"] || "center",
              x: e11.alignAttr.x + (h12.width - l12.width) / 2,
              y: e11.alignAttr.y + (h12.height - l12.height) / 2,
              rotationOriginX: (e11.width || 0) / 2,
              rotationOriginY: (e11.height || 0) / 2
            }), p10 && s11.height >= 0) this.justifyDataLabel(e11, i11, e11.alignAttr, h12, s11, o11);
            else if (hl(i11.crop, true)) {
              let {
                x: t12,
                y: i12
              } = e11.alignAttr;
              u10 = r11.isInsidePlot(t12, i12, {
                paneCoordinates: true,
                series: this
              }) && r11.isInsidePlot(t12 + h12.width - 1, i12 + h12.height - 1, {
                paneCoordinates: true,
                series: this
              });
            }
            i11.shape && !d10 && e11[o11 ? "attr" : "animate"]({
              anchorX: g2[0],
              anchorY: g2[1]
            });
          }
          o11 && n11 && (e11.placed = false), u10 || n11 && !p10 ? (e11.show(), e11.placed = true) : (e11.hide(), e11.placed = false);
        }
        function s10() {
          return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
        }
        function o10(t11) {
          let e11 = this.hasRendered || 0, i11 = this.initDataLabelsGroup().attr({
            opacity: +e11
          });
          return !e11 && i11 && (this.visible && i11.show(), this.options.animation ? i11.animate({
            opacity: 1
          }, t11) : i11.attr({
            opacity: 1
          })), i11;
        }
        function r10(t11) {
          let e11;
          t11 = t11 || this.points;
          let i11 = this, s11 = i11.chart, o11 = i11.options, r11 = s11.renderer, {
            backgroundColor: n11,
            plotBackgroundColor: l11
          } = s11.options.chart, d10 = r11.getContrast(hn(l11) && l11 || hn(n11) && n11 || "#000000"), c10 = h10(i11), {
            animation: p10,
            defer: u10
          } = c10[0], g2 = u10 ? a7(s11, p10, i11) : {
            defer: 0,
            duration: 0
          };
          hs(this, "drawDataLabels"), i11.hasDataLabels?.() && (e11 = this.initDataLabels(g2), t11.forEach((t12) => {
            let n12 = t12.dataLabels || [];
            hc(a10(c10, t12.dlOptions || t12.options?.dataLabels)).forEach((a11, h12) => {
              let l12 = a11.enabled && (t12.visible || t12.dataLabelOnHidden) && (!t12.isNull || t12.dataLabelOnNull) && function(t13, e12) {
                let i12 = e12.filter;
                if (i12) {
                  let e13 = i12.operator, s12 = t13[i12.property], o12 = i12.value;
                  return ">" === e13 && s12 > o12 || "<" === e13 && s12 < o12 || ">=" === e13 && s12 >= o12 || "<=" === e13 && s12 <= o12 || "==" === e13 && s12 == o12 || "===" === e13 && s12 === o12 || "!=" === e13 && s12 != o12 || "!==" === e13 && s12 !== o12;
                }
                return true;
              }(t12, a11), {
                backgroundColor: c11,
                borderColor: p11,
                distance: u11,
                style: g3 = {}
              } = a11, f2, m2, x2, y2 = {}, b2 = n12[h12], v2 = !b2, M2;
              l12 && (m2 = he(f2 = hl(a11[t12.formatPrefix + "Format"], a11.format)) ? ht(f2, t12, s11) : (a11[t12.formatPrefix + "Formatter"] || a11.formatter).call(t12, a11), x2 = a11.rotation, !s11.styledMode && (g3.color = hl(a11.color, g3.color, hn(i11.color) ? i11.color : void 0, "#000000"), "contrast" === g3.color ? ("none" !== c11 && (M2 = c11), t12.contrastColor = r11.getContrast("auto" !== M2 && M2 || t12.color || i11.color), g3.color = M2 || !he(u11) && a11.inside || 0 > hd(u11 || 0) || o11.stacking ? t12.contrastColor : d10) : delete t12.contrastColor, o11.cursor && (g3.cursor = o11.cursor)), y2 = {
                r: a11.borderRadius || 0,
                rotation: x2,
                padding: a11.padding,
                zIndex: 1
              }, s11.styledMode || (y2.fill = "auto" === c11 ? t12.color : c11, y2.stroke = "auto" === p11 ? t12.color : p11, y2["stroke-width"] = a11.borderWidth), hh(y2, (t13, e12) => {
                void 0 === t13 && delete y2[e12];
              })), !b2 || l12 && he(m2) && !!b2.div == !!a11.useHTML && (b2.rotation && a11.rotation || b2.rotation === a11.rotation) || (b2 = void 0, v2 = true), l12 && he(m2) && (b2 ? y2.text = m2 : (b2 = r11.label(m2, 0, 0, a11.shape, void 0, void 0, a11.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + t12.colorIndex + " " + (a11.className || "") + (a11.useHTML ? " highcharts-tracker" : "")), b2 && (b2.options = a11, b2.attr(y2), s11.styledMode ? g3.width && b2.css({
                width: g3.width,
                textOverflow: g3.textOverflow,
                whiteSpace: g3.whiteSpace
              }) : b2.css(g3).shadow(a11.shadow), hs(b2, "beforeAddingDataLabel", {
                labelOptions: a11,
                point: t12
              }), b2.added || b2.add(e11), i11.alignDataLabel(t12, b2, a11, void 0, v2), b2.isActive = true, n12[h12] && n12[h12] !== b2 && n12[h12].destroy(), n12[h12] = b2));
            });
            let h11 = n12.length;
            for (; h11--; ) n12[h11] && n12[h11].isActive ? n12[h11].isActive = false : (n12[h11]?.destroy(), n12.splice(h11, 1));
            t12.dataLabel = n12[0], t12.dataLabels = n12;
          })), hs(this, "afterDrawDataLabels");
        }
        function n10(t11, e11, i11, s11, o11, r11) {
          let n11 = this.chart, a11 = e11.align, h11 = e11.verticalAlign, l11 = t11.box ? 0 : t11.padding || 0, d10 = n11.inverted ? this.yAxis : this.xAxis, c10 = d10 ? d10.left - n11.plotLeft : 0, p10 = n11.inverted ? this.xAxis : this.yAxis, u10 = p10 ? p10.top - n11.plotTop : 0, {
            x: g2 = 0,
            y: f2 = 0
          } = e11, m2, x2;
          return (m2 = (i11.x || 0) + l11 + c10) < 0 && ("right" === a11 && g2 >= 0 ? (e11.align = "left", e11.inside = true) : g2 -= m2, x2 = true), (m2 = (i11.x || 0) + s11.width - l11 + c10) > n11.plotWidth && ("left" === a11 && g2 <= 0 ? (e11.align = "right", e11.inside = true) : g2 += n11.plotWidth - m2, x2 = true), (m2 = i11.y + l11 + u10) < 0 && ("bottom" === h11 && f2 >= 0 ? (e11.verticalAlign = "top", e11.inside = true) : f2 -= m2, x2 = true), (m2 = (i11.y || 0) + s11.height - l11 + u10) > n11.plotHeight && ("top" === h11 && f2 <= 0 ? (e11.verticalAlign = "bottom", e11.inside = true) : f2 += n11.plotHeight - m2, x2 = true), x2 && (e11.x = g2, e11.y = f2, t11.placed = !r11, t11.align(e11, void 0, o11)), x2;
        }
        function a10(t11, e11) {
          let i11 = [], s11;
          if (hr(t11) && !hr(e11)) i11 = t11.map(function(t12) {
            return ha(t12, e11);
          });
          else if (hr(e11) && !hr(t11)) i11 = e11.map(function(e12) {
            return ha(t11, e12);
          });
          else if (hr(t11) || hr(e11)) {
            if (hr(t11) && hr(e11)) for (s11 = Math.max(t11.length, e11.length); s11--; ) i11[s11] = ha(t11[s11], e11[s11]);
          } else i11 = ha(t11, e11);
          return i11;
        }
        function h10(t11) {
          let e11 = t11.chart.options.plotOptions;
          return hc(a10(a10(e11?.series?.dataLabels, e11?.[t11.type]?.dataLabels), t11.options.dataLabels));
        }
        function l10(t11, e11, i11, s11, o11) {
          let r11 = this.chart, n11 = r11.inverted, a11 = this.xAxis, h11 = a11.reversed, l11 = ((n11 ? e11.height : e11.width) || 0) / 2, d10 = t11.pointWidth, c10 = d10 ? d10 / 2 : 0;
          e11.startXPos = n11 ? o11.x : h11 ? -l11 - c10 : a11.width - l11 + c10, e11.startYPos = n11 ? h11 ? this.yAxis.height - l11 + c10 : -l11 - c10 : o11.y, s11 ? "hidden" === e11.visibility && (e11.show(), e11.attr({
            opacity: 0
          }).animate({
            opacity: 1
          })) : e11.attr({
            opacity: 1
          }).animate({
            opacity: 0
          }, void 0, e11.hide), r11.hasRendered && (i11 && e11.attr({
            x: e11.startXPos,
            y: e11.startYPos
          }), e11.placed = true);
        }
        t10.compose = function(t11) {
          let a11 = t11.prototype;
          a11.initDataLabels || (a11.initDataLabels = o10, a11.initDataLabelsGroup = s10, a11.alignDataLabel = i10, a11.drawDataLabels = r10, a11.justifyDataLabel = n10, a11.setDataLabelStartPos = l10, a11.hasDataLabels = e10);
        };
      }(m || (m = {}));
      let hp = m, {
        composed: hu
      } = O, {
        series: hg
      } = ry, {
        merge: hf,
        pick: hm,
        pushUnique: hx
      } = tt;
      !function(t10) {
        function e10(t11, e11, i10, s10, o10) {
          let r10 = this.chart.inverted, n10 = t11.series, a10 = (n10.xAxis ? n10.xAxis.len : this.chart.plotSizeX) || 0, h10 = (n10.yAxis ? n10.yAxis.len : this.chart.plotSizeY) || 0, l10 = t11.dlBox || t11.shapeArgs, d10 = hm(t11.below, t11.plotY > hm(this.translatedThreshold, h10)), c10 = hm(i10.inside, !!this.options.stacking);
          if (l10) {
            if (s10 = hf(l10), !("allow" === i10.overflow && false === i10.crop)) {
              s10.y < 0 && (s10.height += s10.y, s10.y = 0);
              let t12 = s10.y + s10.height - h10;
              t12 > 0 && t12 < s10.height - 1 && (s10.height -= t12);
            }
            r10 && (s10 = {
              x: h10 - s10.y - s10.height,
              y: a10 - s10.x - s10.width,
              width: s10.height,
              height: s10.width
            }), c10 || (r10 ? (s10.x += d10 ? 0 : s10.width, s10.width = 0) : (s10.y += d10 ? s10.height : 0, s10.height = 0));
          }
          i10.align = hm(i10.align, !r10 || c10 ? "center" : d10 ? "right" : "left"), i10.verticalAlign = hm(i10.verticalAlign, r10 || c10 ? "middle" : d10 ? "top" : "bottom"), hg.prototype.alignDataLabel.call(this, t11, e11, i10, s10, o10), i10.inside && t11.contrastColor && e11.css({
            color: t11.contrastColor
          });
        }
        t10.compose = function(t11) {
          hp.compose(hg), hx(hu, "ColumnDataLabel") && (t11.prototype.alignDataLabel = e10);
        };
      }(x || (x = {}));
      let hy = x, {
        extend: hb,
        merge: hv
      } = tt;
      class hM extends a8 {
      }
      hM.defaultOptions = hv(a8.defaultOptions, {}), hb(hM.prototype, {
        inverted: true
      }), ry.registerSeriesType("bar", hM);
      let {
        column: hk,
        line: hw
      } = ry.seriesTypes, {
        addEvent: hS,
        extend: hA,
        merge: hT
      } = tt;
      class hP extends hw {
        applyJitter() {
          let t10 = this, e10 = this.options.jitter, i10 = this.points.length;
          e10 && this.points.forEach(function(s10, o10) {
            ["x", "y"].forEach(function(r10, n10) {
              if (e10[r10] && !s10.isNull) {
                let a10 = `plot${r10.toUpperCase()}`, h10 = t10[`${r10}Axis`], l10 = e10[r10] * h10.transA;
                if (h10 && !h10.logarithmic) {
                  let t11 = Math.max(0, (s10[a10] || 0) - l10), e11 = Math.min(h10.len, (s10[a10] || 0) + l10);
                  s10[a10] = t11 + (e11 - t11) * function(t12) {
                    let e12 = 1e4 * Math.sin(t12);
                    return e12 - Math.floor(e12);
                  }(o10 + n10 * i10), "x" === r10 && (s10.clientX = s10.plotX);
                }
              }
            });
          });
        }
        drawGraph() {
          this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
        }
      }
      hP.defaultOptions = hT(hw.defaultOptions, {
        lineWidth: 0,
        findNearestPointBy: "xy",
        jitter: {
          x: 0,
          y: 0
        },
        marker: {
          enabled: true
        },
        tooltip: {
          headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        }
      }), hA(hP.prototype, {
        drawTracker: hk.prototype.drawTracker,
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]
      }), hS(hP, "afterTranslate", function() {
        this.applyJitter();
      }), ry.registerSeriesType("scatter", hP);
      let {
        deg2rad: hC
      } = O, {
        fireEvent: hO,
        isNumber: hE,
        pick: hL,
        relativeLength: hB
      } = tt;
      !function(t10) {
        t10.getCenter = function() {
          let t11 = this.options, e10 = this.chart, i10 = 2 * (t11.slicedOffset || 0), s10 = e10.plotWidth - 2 * i10, o10 = e10.plotHeight - 2 * i10, r10 = t11.center, n10 = Math.min(s10, o10), a10 = t11.thickness, h10, l10 = t11.size, d10 = t11.innerSize || 0, c10, p10;
          "string" == typeof l10 && (l10 = parseFloat(l10)), "string" == typeof d10 && (d10 = parseFloat(d10));
          let u10 = [hL(r10?.[0], "50%"), hL(r10?.[1], "50%"), hL(l10 && l10 < 0 ? void 0 : t11.size, "100%"), hL(d10 && d10 < 0 ? void 0 : t11.innerSize || 0, "0%")];
          for (!e10.angular || this instanceof rK || (u10[3] = 0), c10 = 0; c10 < 4; ++c10) p10 = u10[c10], h10 = c10 < 2 || 2 === c10 && /%$/.test(p10), u10[c10] = hB(p10, [s10, o10, n10, u10[2]][c10]) + (h10 ? i10 : 0);
          return u10[3] > u10[2] && (u10[3] = u10[2]), hE(a10) && 2 * a10 < u10[2] && a10 > 0 && (u10[3] = u10[2] - 2 * a10), hO(this, "afterGetCenter", {
            positions: u10
          }), u10;
        }, t10.getStartAndEndRadians = function(t11, e10) {
          let i10 = hE(t11) ? t11 : 0, s10 = hE(e10) && e10 > i10 && e10 - i10 < 360 ? e10 : i10 + 360;
          return {
            start: hC * (i10 + -90),
            end: hC * (s10 + -90)
          };
        };
      }(y || (y = {}));
      let hI = y, {
        setAnimation: hD
      } = tU, {
        addEvent: hR,
        defined: hN,
        extend: hz,
        isNumber: hW,
        pick: hG,
        relativeLength: hH
      } = tt;
      class hF extends oq {
        getConnectorPath(t10) {
          let e10 = t10.dataLabelPosition, i10 = t10.options || {}, s10 = i10.connectorShape, o10 = this.connectorShapes[s10] || s10;
          return e10 && o10.call(this, __spreadProps(__spreadValues({}, e10.computed), {
            alignment: e10.alignment
          }), e10.connectorPosition, i10) || [];
        }
        getTranslate() {
          return this.sliced && this.slicedTranslation || {
            translateX: 0,
            translateY: 0
          };
        }
        haloPath(t10) {
          let e10 = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e10.x, e10.y, e10.r + t10, e10.r + t10, {
            innerR: e10.r - 1,
            start: e10.start,
            end: e10.end,
            borderRadius: e10.borderRadius
          });
        }
        constructor(t10, e10, i10) {
          super(t10, e10, i10), this.half = 0, this.name ?? (this.name = "Slice");
          let s10 = (t11) => {
            this.slice("select" === t11.type);
          };
          hR(this, "select", s10), hR(this, "unselect", s10);
        }
        isValid() {
          return hW(this.y) && this.y >= 0;
        }
        setVisible(t10, e10 = true) {
          t10 !== this.visible && this.update({
            visible: t10 ?? !this.visible
          }, e10, void 0, false);
        }
        slice(t10, e10, i10) {
          let s10 = this.series;
          hD(i10, s10.chart), e10 = hG(e10, true), this.sliced = this.options.sliced = t10 = hN(t10) ? t10 : !this.sliced, s10.options.data[s10.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
        }
      }
      hz(hF.prototype, {
        connectorShapes: {
          fixedOffset: function(t10, e10, i10) {
            let s10 = e10.breakAt, o10 = e10.touchingSliceAt, r10 = i10.softConnector ? ["C", t10.x + ("left" === t10.alignment ? -5 : 5), t10.y, 2 * s10.x - o10.x, 2 * s10.y - o10.y, s10.x, s10.y] : ["L", s10.x, s10.y];
            return [["M", t10.x, t10.y], r10, ["L", o10.x, o10.y]];
          },
          straight: function(t10, e10) {
            let i10 = e10.touchingSliceAt;
            return [["M", t10.x, t10.y], ["L", i10.x, i10.y]];
          },
          crookedLine: function(t10, e10, i10) {
            let {
              angle: s10 = this.angle || 0,
              breakAt: o10,
              touchingSliceAt: r10
            } = e10, {
              series: n10
            } = this, [a10, h10, l10] = n10.center, d10 = l10 / 2, {
              plotLeft: c10,
              plotWidth: p10
            } = n10.chart, u10 = "left" === t10.alignment, {
              x: g2,
              y: f2
            } = t10, m2 = o10.x;
            if (i10.crookDistance) {
              let t11 = hH(i10.crookDistance, 1);
              m2 = u10 ? a10 + d10 + (p10 + c10 - a10 - d10) * (1 - t11) : c10 + (a10 - d10) * t11;
            } else m2 = a10 + (h10 - f2) * Math.tan(s10 - Math.PI / 2);
            let x2 = [["M", g2, f2]];
            return (u10 ? m2 <= g2 && m2 >= o10.x : m2 >= g2 && m2 <= o10.x) && x2.push(["L", m2, f2]), x2.push(["L", o10.x, o10.y], ["L", r10.x, r10.y]), x2;
          }
        }
      });
      let {
        getStartAndEndRadians: hX
      } = hI, {
        noop: hY
      } = O, {
        clamp: hj,
        extend: hU,
        fireEvent: hV,
        merge: h$,
        pick: h_
      } = tt;
      class hq extends rK {
        animate(t10) {
          let e10 = this, i10 = e10.points, s10 = e10.startAngleRad;
          t10 || i10.forEach(function(t11) {
            let i11 = t11.graphic, o10 = t11.shapeArgs;
            i11 && o10 && (i11.attr({
              r: h_(t11.startR, e10.center && e10.center[3] / 2),
              start: s10,
              end: s10
            }), i11.animate({
              r: o10.r,
              start: o10.start,
              end: o10.end
            }, e10.options.animation));
          });
        }
        drawEmpty() {
          let t10, e10;
          let i10 = this.startAngleRad, s10 = this.endAngleRad, o10 = this.options;
          0 === this.total && this.center ? (t10 = this.center[0], e10 = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t10, e10, this.center[1] / 2, 0, i10, s10).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
            d: is.arc(t10, e10, this.center[2] / 2, 0, {
              start: i10,
              end: s10,
              innerR: this.center[3] / 2
            })
          }), this.chart.styledMode || this.graph.attr({
            "stroke-width": o10.borderWidth,
            fill: o10.fillColor || "none",
            stroke: o10.color || "#cccccc"
          })) : this.graph && (this.graph = this.graph.destroy());
        }
        drawPoints() {
          let t10 = this.chart.renderer;
          this.points.forEach(function(e10) {
            e10.graphic && e10.hasNewShapeType() && (e10.graphic = e10.graphic.destroy()), e10.graphic || (e10.graphic = t10[e10.shapeType](e10.shapeArgs).add(e10.series.group), e10.delayedRendering = true);
          });
        }
        generatePoints() {
          super.generatePoints(), this.updateTotals();
        }
        getX(t10, e10, i10, s10) {
          let o10 = this.center, r10 = this.radii ? this.radii[i10.index] || 0 : o10[2] / 2, n10 = s10.dataLabelPosition, a10 = n10?.distance || 0, h10 = Math.asin(hj((t10 - o10[1]) / (r10 + a10), -1, 1));
          return o10[0] + Math.cos(h10) * (r10 + a10) * (e10 ? -1 : 1) + (a10 > 0 ? (e10 ? -1 : 1) * (s10.padding || 0) : 0);
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        redrawPoints() {
          let t10, e10, i10, s10;
          let o10 = this, r10 = o10.chart;
          this.drawEmpty(), o10.group && !r10.styledMode && o10.group.shadow(o10.options.shadow), o10.points.forEach(function(n10) {
            let a10 = {};
            e10 = n10.graphic, !n10.isNull && e10 ? (s10 = n10.shapeArgs, t10 = n10.getTranslate(), r10.styledMode || (i10 = o10.pointAttribs(n10, n10.selected && "select")), n10.delayedRendering ? (e10.setRadialReference(o10.center).attr(s10).attr(t10), r10.styledMode || e10.attr(i10).attr({
              "stroke-linejoin": "round"
            }), n10.delayedRendering = false) : (e10.setRadialReference(o10.center), r10.styledMode || h$(true, a10, i10), h$(true, a10, s10, t10), e10.animate(a10)), e10.attr({
              visibility: n10.visible ? "inherit" : "hidden"
            }), e10.addClass(n10.getClassName(), true)) : e10 && (n10.graphic = e10.destroy());
          });
        }
        sortByAngle(t10, e10) {
          t10.sort(function(t11, i10) {
            return void 0 !== t11.angle && (i10.angle - t11.angle) * e10;
          });
        }
        translate(t10) {
          hV(this, "translate"), this.generatePoints();
          let e10 = this.options, i10 = e10.slicedOffset, s10 = hX(e10.startAngle, e10.endAngle), o10 = this.startAngleRad = s10.start, r10 = (this.endAngleRad = s10.end) - o10, n10 = this.points, a10 = e10.ignoreHiddenPoint, h10 = n10.length, l10, d10, c10, p10, u10, g2, f2, m2 = 0;
          for (t10 || (this.center = t10 = this.getCenter()), g2 = 0; g2 < h10; g2++) {
            f2 = n10[g2], l10 = o10 + m2 * r10, f2.isValid() && (!a10 || f2.visible) && (m2 += f2.percentage / 100), d10 = o10 + m2 * r10;
            let e11 = {
              x: t10[0],
              y: t10[1],
              r: t10[2] / 2,
              innerR: t10[3] / 2,
              start: Math.round(1e3 * l10) / 1e3,
              end: Math.round(1e3 * d10) / 1e3
            };
            f2.shapeType = "arc", f2.shapeArgs = e11, (c10 = (d10 + l10) / 2) > 1.5 * Math.PI ? c10 -= 2 * Math.PI : c10 < -Math.PI / 2 && (c10 += 2 * Math.PI), f2.slicedTranslation = {
              translateX: Math.round(Math.cos(c10) * i10),
              translateY: Math.round(Math.sin(c10) * i10)
            }, p10 = Math.cos(c10) * t10[2] / 2, u10 = Math.sin(c10) * t10[2] / 2, f2.tooltipPos = [t10[0] + 0.7 * p10, t10[1] + 0.7 * u10], f2.half = c10 < -Math.PI / 2 || c10 > Math.PI / 2 ? 1 : 0, f2.angle = c10;
          }
          hV(this, "afterTranslate");
        }
        updateTotals() {
          let t10 = this.points, e10 = t10.length, i10 = this.options.ignoreHiddenPoint, s10, o10, r10 = 0;
          for (s10 = 0; s10 < e10; s10++) (o10 = t10[s10]).isValid() && (!i10 || o10.visible) && (r10 += o10.y);
          for (s10 = 0, this.total = r10; s10 < e10; s10++) (o10 = t10[s10]).percentage = r10 > 0 && (o10.visible || !i10) ? o10.y / r10 * 100 : 0, o10.total = r10;
        }
      }
      hq.defaultOptions = h$(rK.defaultOptions, {
        borderRadius: 3,
        center: [null, null],
        clip: false,
        colorByPoint: true,
        dataLabels: {
          connectorPadding: 5,
          connectorShape: "crookedLine",
          crookDistance: void 0,
          distance: 30,
          enabled: true,
          formatter: function() {
            return this.isNull ? void 0 : this.name;
          },
          softConnector: true,
          x: 0
        },
        fillColor: void 0,
        ignoreHiddenPoint: true,
        inactiveOtherPoints: true,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: false,
        slicedOffset: 10,
        stickyTracking: false,
        tooltip: {
          followPointer: true
        },
        borderColor: "#ffffff",
        borderWidth: 1,
        lineWidth: void 0,
        states: {
          hover: {
            brightness: 0.1
          }
        }
      }), hU(hq.prototype, {
        axisTypes: [],
        directTouch: true,
        drawGraph: void 0,
        drawTracker: a8.prototype.drawTracker,
        getCenter: hI.getCenter,
        getSymbol: hY,
        invertible: false,
        isCartesian: false,
        noSharedTooltip: true,
        pointAttribs: a8.prototype.pointAttribs,
        pointClass: hF,
        requireSorting: false,
        searchPoint: hY,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), ry.registerSeriesType("pie", hq);
      let {
        composed: hZ,
        noop: hK
      } = O, {
        distribute: hJ
      } = ey, {
        series: hQ
      } = ry, {
        arrayMax: h0,
        clamp: h1,
        defined: h2,
        pick: h3,
        pushUnique: h5,
        relativeLength: h6
      } = tt;
      !function(t10) {
        let e10 = {
          radialDistributionY: function(t11, e11) {
            return (e11.dataLabelPosition?.top || 0) + t11.distributeBox.pos;
          },
          radialDistributionX: function(t11, e11, i11, s11, o11) {
            let r11 = o11.dataLabelPosition;
            return t11.getX(i11 < (r11?.top || 0) + 2 || i11 > (r11?.bottom || 0) - 2 ? s11 : i11, e11.half, e11, o11);
          },
          justify: function(t11, e11, i11, s11) {
            return s11[0] + (t11.half ? -1 : 1) * (i11 + (e11.dataLabelPosition?.distance || 0));
          },
          alignToPlotEdges: function(t11, e11, i11, s11) {
            let o11 = t11.getBBox().width;
            return e11 ? o11 + s11 : i11 - o11 - s11;
          },
          alignToConnectors: function(t11, e11, i11, s11) {
            let o11 = 0, r11;
            return t11.forEach(function(t12) {
              (r11 = t12.dataLabel.getBBox().width) > o11 && (o11 = r11);
            }), e11 ? o11 + s11 : i11 - o11 - s11;
          }
        };
        function i10(t11, e11) {
          let i11 = Math.PI / 2, {
            start: s11 = 0,
            end: o11 = 0
          } = t11.shapeArgs || {}, r11 = t11.angle || 0;
          e11 > 0 && s11 < i11 && o11 > i11 && r11 > i11 / 2 && r11 < 1.5 * i11 && (r11 = r11 <= i11 ? Math.max(i11 / 2, (s11 + i11) / 2) : Math.min(1.5 * i11, (i11 + o11) / 2));
          let {
            center: n10,
            options: a10
          } = this, h10 = n10[2] / 2, l10 = Math.cos(r11), d10 = Math.sin(r11), c10 = n10[0] + l10 * h10, p10 = n10[1] + d10 * h10, u10 = Math.min((a10.slicedOffset || 0) + (a10.borderWidth || 0), e11 / 5);
          return {
            natural: {
              x: c10 + l10 * e11,
              y: p10 + d10 * e11
            },
            computed: {},
            alignment: e11 < 0 ? "center" : t11.half ? "right" : "left",
            connectorPosition: {
              angle: r11,
              breakAt: {
                x: c10 + l10 * u10,
                y: p10 + d10 * u10
              },
              touchingSliceAt: {
                x: c10,
                y: p10
              }
            },
            distance: e11
          };
        }
        function s10() {
          let t11 = this, e11 = t11.points, i11 = t11.chart, s11 = i11.plotWidth, o11 = i11.plotHeight, r11 = i11.plotLeft, n10 = Math.round(i11.chartWidth / 3), a10 = t11.center, h10 = a10[2] / 2, l10 = a10[1], d10 = [[], []], c10 = [0, 0, 0, 0], p10 = t11.dataLabelPositioners, u10, g2, f2, m2 = 0;
          t11.visible && t11.hasDataLabels?.() && (e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((t13) => {
              t13.shortened && (t13.attr({
                width: "auto"
              }).css({
                width: "auto",
                textOverflow: "clip"
              }), t13.shortened = false);
            });
          }), hQ.prototype.drawDataLabels.apply(t11), e11.forEach((t12) => {
            (t12.dataLabels || []).forEach((e12, i12) => {
              let s12 = a10[2] / 2, o12 = e12.options, r12 = h6(o12?.distance || 0, s12);
              0 === i12 && d10[t12.half].push(t12), !h2(o12?.style?.width) && e12.getBBox().width > n10 && (e12.css({
                width: Math.round(0.7 * n10) + "px"
              }), e12.shortened = true), e12.dataLabelPosition = this.getDataLabelPosition(t12, r12), m2 = Math.max(m2, r12);
            });
          }), d10.forEach((e12, n11) => {
            let d11 = e12.length, u11 = [], x2, y2, b2 = 0, v2;
            d11 && (t11.sortByAngle(e12, n11 - 0.5), m2 > 0 && (x2 = Math.max(0, l10 - h10 - m2), y2 = Math.min(l10 + h10 + m2, i11.plotHeight), e12.forEach((t12) => {
              (t12.dataLabels || []).forEach((e13) => {
                let s12 = e13.dataLabelPosition;
                s12 && s12.distance > 0 && (s12.top = Math.max(0, l10 - h10 - s12.distance), s12.bottom = Math.min(l10 + h10 + s12.distance, i11.plotHeight), b2 = e13.getBBox().height || 21, e13.lineHeight = i11.renderer.fontMetrics(e13.text || e13).h + 2 * e13.padding, t12.distributeBox = {
                  target: (e13.dataLabelPosition?.natural.y || 0) - s12.top + e13.lineHeight / 2,
                  size: b2,
                  rank: t12.y
                }, u11.push(t12.distributeBox));
              });
            }), hJ(u11, v2 = y2 + b2 - x2, v2 / 5)), e12.forEach((i12) => {
              (i12.dataLabels || []).forEach((l11) => {
                let d12 = l11.options || {}, m3 = i12.distributeBox, x3 = l11.dataLabelPosition, y3 = x3?.natural.y || 0, b3 = d12.connectorPadding || 0, v3 = l11.lineHeight || 21, M2 = (v3 - l11.getBBox().height) / 2, k2 = 0, w2 = y3, S2 = "inherit";
                if (x3) {
                  if (u11 && h2(m3) && x3.distance > 0 && (void 0 === m3.pos ? S2 = "hidden" : (f2 = m3.size, w2 = p10.radialDistributionY(i12, l11))), d12.justify) k2 = p10.justify(i12, l11, h10, a10);
                  else switch (d12.alignTo) {
                    case "connectors":
                      k2 = p10.alignToConnectors(e12, n11, s11, r11);
                      break;
                    case "plotEdges":
                      k2 = p10.alignToPlotEdges(l11, n11, s11, r11);
                      break;
                    default:
                      k2 = p10.radialDistributionX(t11, i12, w2 - M2, y3, l11);
                  }
                  if (x3.attribs = {
                    visibility: S2,
                    align: x3.alignment
                  }, x3.posAttribs = {
                    x: k2 + (d12.x || 0) + ({
                      left: b3,
                      right: -b3
                    }[x3.alignment] || 0),
                    y: w2 + (d12.y || 0) - v3 / 2
                  }, x3.computed.x = k2, x3.computed.y = w2 - M2, h3(d12.crop, true)) {
                    let t12;
                    k2 - (g2 = l11.getBBox().width) < b3 && 1 === n11 ? (t12 = Math.round(g2 - k2 + b3), c10[3] = Math.max(t12, c10[3])) : k2 + g2 > s11 - b3 && 0 === n11 && (t12 = Math.round(k2 + g2 - s11 + b3), c10[1] = Math.max(t12, c10[1])), w2 - f2 / 2 < 0 ? c10[0] = Math.max(Math.round(-w2 + f2 / 2), c10[0]) : w2 + f2 / 2 > o11 && (c10[2] = Math.max(Math.round(w2 + f2 / 2 - o11), c10[2])), x3.sideOverflow = t12;
                  }
                }
              });
            }));
          }), (0 === h0(c10) || this.verifyDataLabelOverflow(c10)) && (this.placeDataLabels(), this.points.forEach((e12) => {
            (e12.dataLabels || []).forEach((s12) => {
              let {
                connectorColor: o12,
                connectorWidth: r12 = 1
              } = s12.options || {}, n11 = s12.dataLabelPosition;
              if (r12) {
                let a11;
                u10 = s12.connector, n11 && n11.distance > 0 ? (a11 = !u10, u10 || (s12.connector = u10 = i11.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e12.colorIndex + (e12.className ? " " + e12.className : "")).add(t11.dataLabelsGroup)), i11.styledMode || u10.attr({
                  "stroke-width": r12,
                  stroke: o12 || e12.color || "#666666"
                }), u10[a11 ? "attr" : "animate"]({
                  d: e12.getConnectorPath(s12)
                }), u10.attr({
                  visibility: n11.attribs?.visibility
                })) : u10 && (s12.connector = u10.destroy());
              }
            });
          })));
        }
        function o10() {
          this.points.forEach((t11) => {
            (t11.dataLabels || []).forEach((t12) => {
              let e11 = t12.dataLabelPosition;
              e11 ? (e11.sideOverflow && (t12.css({
                width: Math.max(t12.getBBox().width - e11.sideOverflow, 0) + "px",
                textOverflow: (t12.options?.style || {}).textOverflow || "ellipsis"
              }), t12.shortened = true), t12.attr(e11.attribs), t12[t12.moved ? "animate" : "attr"](e11.posAttribs), t12.moved = true) : t12 && t12.attr({
                y: -9999
              });
            }), delete t11.distributeBox;
          }, this);
        }
        function r10(t11) {
          let e11 = this.center, i11 = this.options, s11 = i11.center, o11 = i11.minSize || 80, r11 = o11, n10 = null !== i11.size;
          return !n10 && (null !== s11[0] ? r11 = Math.max(e11[2] - Math.max(t11[1], t11[3]), o11) : (r11 = Math.max(e11[2] - t11[1] - t11[3], o11), e11[0] += (t11[3] - t11[1]) / 2), null !== s11[1] ? r11 = h1(r11, o11, e11[2] - Math.max(t11[0], t11[2])) : (r11 = h1(r11, o11, e11[2] - t11[0] - t11[2]), e11[1] += (t11[0] - t11[2]) / 2), r11 < e11[2] ? (e11[2] = r11, e11[3] = Math.min(i11.thickness ? Math.max(0, r11 - 2 * i11.thickness) : Math.max(0, h6(i11.innerSize || 0, r11)), r11), this.translate(e11), this.drawDataLabels && this.drawDataLabels()) : n10 = true), n10;
        }
        t10.compose = function(t11) {
          if (hp.compose(hQ), h5(hZ, "PieDataLabel")) {
            let n10 = t11.prototype;
            n10.dataLabelPositioners = e10, n10.alignDataLabel = hK, n10.drawDataLabels = s10, n10.getDataLabelPosition = i10, n10.placeDataLabels = o10, n10.verifyDataLabelOverflow = r10;
          }
        };
      }(b || (b = {}));
      let h9 = b;
      !function(t10) {
        t10.getCenterOfPoints = function(t11) {
          let e10 = t11.reduce((t12, e11) => (t12.x += e11.x, t12.y += e11.y, t12), {
            x: 0,
            y: 0
          });
          return {
            x: e10.x / t11.length,
            y: e10.y / t11.length
          };
        }, t10.getDistanceBetweenPoints = function(t11, e10) {
          return Math.sqrt(Math.pow(e10.x - t11.x, 2) + Math.pow(e10.y - t11.y, 2));
        }, t10.getAngleBetweenPoints = function(t11, e10) {
          return Math.atan2(e10.x - t11.x, e10.y - t11.y);
        }, t10.pointInPolygon = function({
          x: t11,
          y: e10
        }, i10) {
          let s10 = i10.length, o10, r10, n10 = false;
          for (o10 = 0, r10 = s10 - 1; o10 < s10; r10 = o10++) {
            let [s11, a10] = i10[o10], [h10, l10] = i10[r10];
            a10 > e10 != l10 > e10 && t11 < (h10 - s11) * (e10 - a10) / (l10 - a10) + s11 && (n10 = !n10);
          }
          return n10;
        };
      }(v || (v = {}));
      let {
        pointInPolygon: h4
      } = v, {
        addEvent: h8,
        fireEvent: h7,
        objectEach: lt,
        pick: le
      } = tt;
      function li(t10) {
        let e10 = t10.length, i10 = (t11, e11) => !(e11.x >= t11.x + t11.width || e11.x + e11.width <= t11.x || e11.y >= t11.y + t11.height || e11.y + e11.height <= t11.y), s10 = (t11, e11) => {
          for (let i11 of t11) if (h4({
            x: i11[0],
            y: i11[1]
          }, e11)) return true;
          return false;
        }, o10, r10, n10, a10, h10, l10 = false;
        for (let i11 = 0; i11 < e10; i11++) (o10 = t10[i11]) && (o10.oldOpacity = o10.opacity, o10.newOpacity = 1, o10.absoluteBox = function(t11) {
          if (t11 && (!t11.alignAttr || t11.placed)) {
            let e11 = t11.box ? 0 : t11.padding || 0, i12 = t11.alignAttr || {
              x: t11.attr("x"),
              y: t11.attr("y")
            }, s11 = t11.getBBox();
            return t11.width = s11.width, t11.height = s11.height, {
              x: i12.x + (t11.parentGroup?.translateX || 0) + e11,
              y: i12.y + (t11.parentGroup?.translateY || 0) + e11,
              width: (t11.width || 0) - 2 * e11,
              height: (t11.height || 0) - 2 * e11,
              polygon: s11?.polygon
            };
          }
        }(o10));
        t10.sort((t11, e11) => (e11.labelrank || 0) - (t11.labelrank || 0));
        for (let o11 = 0; o11 < e10; ++o11) {
          a10 = (r10 = t10[o11]) && r10.absoluteBox;
          let l11 = a10?.polygon;
          for (let d10 = o11 + 1; d10 < e10; ++d10) {
            h10 = (n10 = t10[d10]) && n10.absoluteBox;
            let e11 = false;
            if (a10 && h10 && r10 !== n10 && 0 !== r10.newOpacity && 0 !== n10.newOpacity && "hidden" !== r10.visibility && "hidden" !== n10.visibility) {
              let t11 = h10.polygon;
              if (l11 && t11 && l11 !== t11 ? s10(l11, t11) && (e11 = true) : i10(a10, h10) && (e11 = true), e11) {
                let t12 = r10.labelrank < n10.labelrank ? r10 : n10, e12 = t12.text;
                t12.newOpacity = 0, e12?.element.querySelector("textPath") && e12.hide();
              }
            }
          }
        }
        for (let e11 of t10) ls(e11, this) && (l10 = true);
        l10 && h7(this, "afterHideAllOverlappingLabels");
      }
      function ls(t10, e10) {
        let i10, s10, o10 = false;
        return t10 && (s10 = t10.newOpacity, t10.oldOpacity !== s10 && (t10.hasClass("highcharts-data-label") ? (t10[s10 ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), i10 = function() {
          e10.styledMode || t10.css({
            pointerEvents: s10 ? "auto" : "none"
          });
        }, o10 = true, t10[t10.isOld ? "animate" : "attr"]({
          opacity: s10
        }, void 0, i10), h7(e10, "afterHideOverlappingLabel")) : t10.attr({
          opacity: s10
        })), t10.isOld = true), o10;
      }
      function lo() {
        let t10 = this, e10 = [];
        for (let i10 of t10.labelCollectors || []) e10 = e10.concat(i10());
        for (let i10 of t10.yAxis || []) i10.stacking && i10.options.stackLabels && !i10.options.stackLabels.allowOverlap && lt(i10.stacking.stacks, (t11) => {
          lt(t11, (t12) => {
            t12.label && e10.push(t12.label);
          });
        });
        for (let i10 of t10.series || []) if (i10.visible && i10.hasDataLabels?.()) {
          let s10 = (i11) => {
            for (let s11 of i11) s11.visible && (s11.dataLabels || []).forEach((i12) => {
              let o10 = i12.options || {};
              i12.labelrank = le(o10.labelrank, s11.labelrank, s11.shapeArgs?.height), o10.allowOverlap ?? Number(o10.distance) > 0 ? (i12.oldOpacity = i12.opacity, i12.newOpacity = 1, ls(i12, t10)) : e10.push(i12);
            });
          };
          s10(i10.nodes || []), s10(i10.points);
        }
        this.hideOverlappingLabels(e10);
      }
      let lr = {
        compose: function(t10) {
          let e10 = t10.prototype;
          e10.hideOverlappingLabels || (e10.hideOverlappingLabels = li, h8(t10, "render", lo));
        }
      }, {
        defaultOptions: ln
      } = tS, {
        noop: la
      } = O, {
        addEvent: lh,
        extend: ll,
        isObject: ld,
        merge: lc,
        relativeLength: lp
      } = tt, lu = {
        radius: 0,
        scope: "stack",
        where: void 0
      }, lg = la, lf = la;
      function lm(t10, e10, i10, s10, o10 = {}) {
        let r10 = lg(t10, e10, i10, s10, o10), {
          innerR: n10 = 0,
          r: a10 = i10,
          start: h10 = 0,
          end: l10 = 0
        } = o10;
        if (o10.open || !o10.borderRadius) return r10;
        let d10 = l10 - h10, c10 = Math.sin(d10 / 2), p10 = Math.max(Math.min(lp(o10.borderRadius || 0, a10 - n10), (a10 - n10) / 2, a10 * c10 / (1 + c10)), 0), u10 = Math.min(p10, d10 / Math.PI * 2 * n10), g2 = r10.length - 1;
        for (; g2--; ) !function(t11, e11, i11) {
          let s11, o11, r11;
          let n11 = t11[e11], a11 = t11[e11 + 1];
          if ("Z" === a11[0] && (a11 = t11[0]), ("M" === n11[0] || "L" === n11[0]) && "A" === a11[0] ? (s11 = n11, o11 = a11, r11 = true) : "A" === n11[0] && ("M" === a11[0] || "L" === a11[0]) && (s11 = a11, o11 = n11), s11 && o11 && o11.params) {
            let n12 = o11[1], a12 = o11[5], h11 = o11.params, {
              start: l11,
              end: d11,
              cx: c11,
              cy: p11
            } = h11, u11 = a12 ? n12 - i11 : n12 + i11, g3 = u11 ? Math.asin(i11 / u11) : 0, f2 = a12 ? g3 : -g3, m2 = Math.cos(g3) * u11;
            r11 ? (h11.start = l11 + f2, s11[1] = c11 + m2 * Math.cos(l11), s11[2] = p11 + m2 * Math.sin(l11), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + n12 * Math.cos(h11.start), p11 + n12 * Math.sin(h11.start)])) : (h11.end = d11 - f2, o11[6] = c11 + n12 * Math.cos(h11.end), o11[7] = p11 + n12 * Math.sin(h11.end), t11.splice(e11 + 1, 0, ["A", i11, i11, 0, 0, 1, c11 + m2 * Math.cos(d11), p11 + m2 * Math.sin(d11)])), o11[4] = Math.abs(h11.end - h11.start) < Math.PI ? 0 : 1;
          }
        }(r10, g2, g2 > 1 ? u10 : p10);
        return r10;
      }
      function lx() {
        if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
          let {
            options: t10,
            yAxis: e10
          } = this, i10 = "percent" === t10.stacking, s10 = ln.plotOptions?.[this.type]?.borderRadius, o10 = ly(t10.borderRadius, ld(s10) ? s10 : {}), r10 = e10.options.reversed;
          for (let s11 of this.points) {
            let {
              shapeArgs: n10
            } = s11;
            if ("roundedRect" === s11.shapeType && n10) {
              let {
                width: a10 = 0,
                height: h10 = 0,
                y: l10 = 0
              } = n10, d10 = l10, c10 = h10;
              if ("stack" === o10.scope && s11.stackTotal) {
                let o11 = e10.translate(i10 ? 100 : s11.stackTotal, false, true, false, true), r11 = e10.translate(t10.threshold || 0, false, true, false, true), n11 = this.crispCol(0, Math.min(o11, r11), 0, Math.abs(o11 - r11));
                d10 = n11.y, c10 = n11.height;
              }
              let p10 = (s11.negative ? -1 : 1) * (r10 ? -1 : 1) == -1, u10 = o10.where;
              !u10 && this.is("waterfall") && Math.abs((s11.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (u10 = "all"), u10 || (u10 = "end");
              let g2 = Math.min(lp(o10.radius, a10), a10 / 2, "all" === u10 ? h10 / 2 : 1 / 0) || 0;
              "end" === u10 && (p10 && (d10 -= g2), c10 += g2), ll(n10, {
                brBoxHeight: c10,
                brBoxY: d10,
                r: g2
              });
            }
          }
        }
      }
      function ly(t10, e10) {
        return ld(t10) || (t10 = {
          radius: t10 || 0
        }), lc(lu, e10, t10);
      }
      function lb() {
        let t10 = ly(this.options.borderRadius);
        for (let e10 of this.points) {
          let i10 = e10.shapeArgs;
          i10 && (i10.borderRadius = lp(t10.radius, (i10.r || 0) - (i10.innerR || 0)));
        }
      }
      function lv(t10, e10, i10, s10, o10 = {}) {
        let r10 = lf(t10, e10, i10, s10, o10), {
          r: n10 = 0,
          brBoxHeight: a10 = s10,
          brBoxY: h10 = e10
        } = o10, l10 = e10 - h10, d10 = h10 + a10 - (e10 + s10), c10 = l10 - n10 > -0.1 ? 0 : n10, p10 = d10 - n10 > -0.1 ? 0 : n10, u10 = Math.max(c10 && l10, 0), g2 = Math.max(p10 && d10, 0), f2 = [t10 + c10, e10], m2 = [t10 + i10 - c10, e10], x2 = [t10 + i10, e10 + c10], y2 = [t10 + i10, e10 + s10 - p10], b2 = [t10 + i10 - p10, e10 + s10], v2 = [t10 + p10, e10 + s10], M2 = [t10, e10 + s10 - p10], k2 = [t10, e10 + c10], w2 = (t11, e11) => Math.sqrt(Math.pow(t11, 2) - Math.pow(e11, 2));
        if (u10) {
          let t11 = w2(c10, c10 - u10);
          f2[0] -= t11, m2[0] += t11, x2[1] = k2[1] = e10 + c10 - u10;
        }
        if (s10 < c10 - u10) {
          let o11 = w2(c10, c10 - u10 - s10);
          x2[0] = y2[0] = t10 + i10 - c10 + o11, b2[0] = Math.min(x2[0], b2[0]), v2[0] = Math.max(y2[0], v2[0]), M2[0] = k2[0] = t10 + c10 - o11, x2[1] = k2[1] = e10 + s10;
        }
        if (g2) {
          let t11 = w2(p10, p10 - g2);
          b2[0] += t11, v2[0] -= t11, y2[1] = M2[1] = e10 + s10 - p10 + g2;
        }
        if (s10 < p10 - g2) {
          let o11 = w2(p10, p10 - g2 - s10);
          x2[0] = y2[0] = t10 + i10 - p10 + o11, m2[0] = Math.min(x2[0], m2[0]), f2[0] = Math.max(y2[0], f2[0]), M2[0] = k2[0] = t10 + p10 - o11, y2[1] = M2[1] = e10;
        }
        return r10.length = 0, r10.push(["M", ...f2], ["L", ...m2], ["A", c10, c10, 0, 0, 1, ...x2], ["L", ...y2], ["A", p10, p10, 0, 0, 1, ...b2], ["L", ...v2], ["A", p10, p10, 0, 0, 1, ...M2], ["L", ...k2], ["A", c10, c10, 0, 0, 1, ...f2], ["Z"]), r10;
      }
      let {
        diffObjects: lM,
        extend: lk,
        find: lw,
        merge: lS,
        pick: lA,
        uniqueKey: lT
      } = tt;
      !function(t10) {
        function e10(t11, e11) {
          let i11 = t11.condition;
          (i11.callback || function() {
            return this.chartWidth <= lA(i11.maxWidth, Number.MAX_VALUE) && this.chartHeight <= lA(i11.maxHeight, Number.MAX_VALUE) && this.chartWidth >= lA(i11.minWidth, 0) && this.chartHeight >= lA(i11.minHeight, 0);
          }).call(this) && e11.push(t11._id);
        }
        function i10(t11, e11) {
          let i11 = this.options.responsive, s10 = this.currentResponsive, o10 = [], r10;
          !e11 && i11 && i11.rules && i11.rules.forEach((t12) => {
            void 0 === t12._id && (t12._id = lT()), this.matchResponsiveRule(t12, o10);
          }, this);
          let n10 = lS(...o10.map((t12) => lw((i11 || {}).rules || [], (e12) => e12._id === t12)).map((t12) => t12 && t12.chartOptions));
          n10.isResponsiveOptions = true, o10 = o10.toString() || void 0;
          let a10 = s10 && s10.ruleIds;
          o10 === a10 || (s10 && (this.currentResponsive = void 0, this.updatingResponsive = true, this.update(s10.undoOptions, t11, true), this.updatingResponsive = false), o10 ? ((r10 = lM(n10, this.options, true, this.collectionsWithUpdate)).isResponsiveOptions = true, this.currentResponsive = {
            ruleIds: o10,
            mergedOptions: n10,
            undoOptions: r10
          }, this.updatingResponsive || this.update(n10, t11, true)) : this.currentResponsive = void 0);
        }
        t10.compose = function(t11) {
          let s10 = t11.prototype;
          return s10.matchResponsiveRule || lk(s10, {
            matchResponsiveRule: e10,
            setResponsive: i10
          }), t11;
        };
      }(M || (M = {}));
      let lP = M;
      function lC(t10, e10, i10, s10) {
        return [["M", t10, e10 + s10 / 2], ["L", t10 + i10, e10], ["L", t10, e10 + s10 / 2], ["L", t10 + i10, e10 + s10]];
      }
      function lO(t10, e10, i10, s10) {
        return lC(t10, e10, i10 / 2, s10);
      }
      function lE(t10, e10, i10, s10) {
        return [["M", t10 + i10, e10], ["L", t10, e10 + s10 / 2], ["L", t10 + i10, e10 + s10], ["Z"]];
      }
      function lL(t10, e10, i10, s10) {
        return lE(t10, e10, i10 / 2, s10);
      }
      O.AST = t6, O.Axis = sU, O.Chart = nK, O.Color = tO, O.DataLabel = hp, O.DataTableCore = rl, O.Fx = tD, O.HTMLElement = i5, O.Legend = nd, O.LegendSymbol = ru, O.OverlappingDataLabels = O.OverlappingDataLabels || lr, O.PlotLineOrBand = or, O.Point = oq, O.Pointer = ro, O.RendererRegistry = eu, O.Series = rK, O.SeriesRegistry = ry, O.StackItem = aa, O.SVGElement = eJ, O.SVGRenderer = iU, O.Templating = ep, O.Tick = sg, O.Time = ty, O.Tooltip = oO, O.animate = tU.animate, O.animObject = tU.animObject, O.chart = nK.chart, O.color = tO.parse, O.dateFormat = ep.dateFormat, O.defaultOptions = tS.defaultOptions, O.distribute = ey.distribute, O.format = ep.format, O.getDeferredAnimation = tU.getDeferredAnimation, O.getOptions = tS.getOptions, O.numberFormat = ep.numberFormat, O.seriesType = ry.seriesType, O.setAnimation = tU.setAnimation, O.setOptions = tS.setOptions, O.stop = tU.stop, O.time = tS.defaultTime, O.timers = tD.timers, {
        compose: function(t10, e10, i10) {
          let s10 = t10.types.pie;
          if (!e10.symbolCustomAttribs.includes("borderRadius")) {
            let o10 = i10.prototype.symbols;
            lh(t10, "afterColumnTranslate", lx, {
              order: 9
            }), lh(s10, "afterTranslate", lb), e10.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), lg = o10.arc, lf = o10.roundedRect, o10.arc = lm, o10.roundedRect = lv;
          }
        },
        optionsToObject: ly
      }.compose(O.Series, O.SVGElement, O.SVGRenderer), hy.compose(O.Series.types.column), hp.compose(O.Series), sZ.compose(O.Axis), i5.compose(O.SVGRenderer), nd.compose(O.Chart), s0.compose(O.Axis), lr.compose(O.Chart), h9.compose(O.Series.types.pie), or.compose(O.Chart, O.Axis), ro.compose(O.Chart), lP.compose(O.Chart), n7.compose(O.Axis, O.Chart, O.Series), aP.compose(O.Axis, O.Chart, O.Series), oO.compose(O.Pointer), tt.extend(O, tt);
      let lB = {
        compose: function(t10) {
          let e10 = t10.prototype.symbols;
          e10.arrow = lC, e10["arrow-filled"] = lE, e10["arrow-filled-half"] = lL, e10["arrow-half"] = lO, e10["triangle-left"] = lE, e10["triangle-left-half"] = lL;
        }
      }, {
        defined: lI,
        error: lD,
        merge: lR,
        objectEach: lN
      } = tt, lz = O.deg2rad, lW = Math.max, lG = Math.min, lH = class {
        constructor(t10, e10, i10) {
          this.init(t10, e10, i10);
        }
        init(t10, e10, i10) {
          this.fromPoint = t10, this.toPoint = e10, this.options = i10, this.chart = t10.series.chart, this.pathfinder = this.chart.pathfinder;
        }
        renderPath(t10, e10) {
          let i10 = this.chart, s10 = i10.styledMode, o10 = this.pathfinder, r10 = {}, n10 = this.graphics && this.graphics.path;
          o10.group || (o10.group = i10.renderer.g().addClass("highcharts-pathfinder-group").attr({
            zIndex: -1
          }).add(i10.seriesGroup)), o10.group.translate(i10.plotLeft, i10.plotTop), n10 && n10.renderer || (n10 = i10.renderer.path().add(o10.group), s10 || n10.attr({
            opacity: 0
          })), n10.attr(e10), r10.d = t10, s10 || (r10.opacity = 1), n10.animate(r10), this.graphics = this.graphics || {}, this.graphics.path = n10;
        }
        addMarker(t10, e10, i10) {
          let s10, o10, r10, n10, a10, h10, l10, d10;
          let c10 = this.fromPoint.series.chart, p10 = c10.pathfinder, u10 = c10.renderer, g2 = "start" === t10 ? this.fromPoint : this.toPoint, f2 = g2.getPathfinderAnchorPoint(e10);
          e10.enabled && ((d10 = "start" === t10 ? i10[1] : i10[i10.length - 2]) && "M" === d10[0] || "L" === d10[0]) && (l10 = {
            x: d10[1],
            y: d10[2]
          }, o10 = g2.getRadiansToVector(l10, f2), s10 = g2.getMarkerVector(o10, e10.radius, f2), r10 = -o10 / lz, e10.width && e10.height ? (a10 = e10.width, h10 = e10.height) : a10 = h10 = 2 * e10.radius, this.graphics = this.graphics || {}, n10 = {
            x: s10.x - a10 / 2,
            y: s10.y - h10 / 2,
            width: a10,
            height: h10,
            rotation: r10,
            rotationOriginX: s10.x,
            rotationOriginY: s10.y
          }, this.graphics[t10] ? this.graphics[t10].animate(n10) : (this.graphics[t10] = u10.symbol(e10.symbol).addClass("highcharts-point-connecting-path-" + t10 + "-marker highcharts-color-" + this.fromPoint.colorIndex).attr(n10).add(p10.group), u10.styledMode || this.graphics[t10].attr({
            fill: e10.color || this.fromPoint.color,
            stroke: e10.lineColor,
            "stroke-width": e10.lineWidth,
            opacity: 0
          }).animate({
            opacity: 1
          }, g2.series.options.animation)));
        }
        getPath(t10) {
          let e10 = this.pathfinder, i10 = this.chart, s10 = e10.algorithms[t10.type], o10 = e10.chartObstacles;
          return "function" != typeof s10 ? (lD('"' + t10.type + '" is not a Pathfinder algorithm.'), {
            path: [],
            obstacles: []
          }) : (s10.requiresObstacles && !o10 && (o10 = e10.chartObstacles = e10.getChartObstacles(t10), i10.options.connectors.algorithmMargin = t10.algorithmMargin, e10.chartObstacleMetrics = e10.getObstacleMetrics(o10)), s10(this.fromPoint.getPathfinderAnchorPoint(t10.startMarker), this.toPoint.getPathfinderAnchorPoint(t10.endMarker), lR({
            chartObstacles: o10,
            lineObstacles: e10.lineObstacles || [],
            obstacleMetrics: e10.chartObstacleMetrics,
            hardBounds: {
              xMin: 0,
              xMax: i10.plotWidth,
              yMin: 0,
              yMax: i10.plotHeight
            },
            obstacleOptions: {
              margin: t10.algorithmMargin
            },
            startDirectionX: e10.getAlgorithmStartDirection(t10.startMarker)
          }, t10)));
        }
        render() {
          let t10 = this.fromPoint, e10 = t10.series, i10 = e10.chart, s10 = i10.pathfinder, o10 = {}, r10 = lR(i10.options.connectors, e10.options.connectors, t10.options.connectors, this.options);
          !i10.styledMode && (o10.stroke = r10.lineColor || t10.color, o10["stroke-width"] = r10.lineWidth, r10.dashStyle && (o10.dashstyle = r10.dashStyle)), o10.class = "highcharts-point-connecting-path highcharts-color-" + t10.colorIndex, lI((r10 = lR(o10, r10)).marker.radius) || (r10.marker.radius = lG(lW(Math.ceil((r10.algorithmMargin || 8) / 2) - 1, 1), 5));
          let n10 = this.getPath(r10), a10 = n10.path;
          n10.obstacles && (s10.lineObstacles = s10.lineObstacles || [], s10.lineObstacles = s10.lineObstacles.concat(n10.obstacles)), this.renderPath(a10, o10), this.addMarker("start", lR(r10.marker, r10.startMarker), a10), this.addMarker("end", lR(r10.marker, r10.endMarker), a10);
        }
        destroy() {
          this.graphics && (lN(this.graphics, function(t10) {
            t10.destroy();
          }), delete this.graphics);
        }
      }, {
        composed: lF
      } = O, {
        addEvent: lX,
        merge: lY,
        pushUnique: lj,
        wrap: lU
      } = tt, lV = {
        color: "#ccd3ff",
        width: 2,
        label: {
          format: "%[abdYHM]",
          formatter: function(t10, e10) {
            return this.axis.chart.time.dateFormat(e10 || "", t10, true);
          },
          rotation: 0,
          style: {
            fontSize: "0.7em"
          }
        }
      };
      function l$() {
        let t10 = this.options, e10 = t10.currentDateIndicator;
        if (e10) {
          let i10 = "object" == typeof e10 ? lY(lV, e10) : lY(lV);
          i10.value = Date.now(), i10.className = "highcharts-current-date-indicator", t10.plotLines || (t10.plotLines = []), t10.plotLines.push(i10);
        }
      }
      function l_() {
        this.label && this.label.attr({
          text: this.getLabelText(this.options.label)
        });
      }
      function lq(t10, e10) {
        let i10 = this.options;
        return i10 && i10.className && -1 !== i10.className.indexOf("highcharts-current-date-indicator") && i10.label && "function" == typeof i10.label.formatter ? (i10.value = Date.now(), i10.label.formatter.call(this, i10.value, i10.label.format)) : t10.call(this, e10);
      }
      let {
        defaultOptions: lZ
      } = tS, {
        isArray: lK,
        merge: lJ,
        splat: lQ
      } = tt;
      class l0 extends nK {
        init(t10, e10) {
          let i10;
          let s10 = t10.xAxis, o10 = t10.yAxis;
          t10.xAxis = t10.yAxis = void 0;
          let r10 = lJ(true, {
            chart: {
              type: "gantt"
            },
            title: {
              text: ""
            },
            legend: {
              enabled: false
            },
            navigator: {
              series: {
                type: "gantt"
              },
              yAxis: {
                type: "category"
              }
            }
          }, t10, {
            isGantt: true
          });
          t10.xAxis = s10, t10.yAxis = o10, r10.xAxis = (lK(t10.xAxis) ? t10.xAxis : [t10.xAxis || {}, {}]).map((t11, e11) => (1 === e11 && (i10 = 0), lJ({
            grid: {
              borderColor: "#cccccc",
              enabled: true
            },
            opposite: lZ.xAxis?.opposite ?? t11.opposite ?? true,
            linkedTo: i10
          }, t11, {
            type: "datetime"
          }))), r10.yAxis = lQ(t10.yAxis || {}).map((t11) => lJ({
            grid: {
              borderColor: "#cccccc",
              enabled: true
            },
            staticScale: 50,
            reversed: true,
            type: t11.categories ? t11.type : "treegrid"
          }, t11)), super.init(r10, e10);
        }
      }
      !function(t10) {
        t10.ganttChart = function(e10, i10, s10) {
          return new t10(e10, i10, s10);
        };
      }(l0 || (l0 = {}));
      let l1 = l0, {
        isTouchDevice: l2
      } = O, {
        addEvent: l3,
        merge: l5,
        pick: l6
      } = tt, l9 = [];
      function l4() {
        this.navigator && this.navigator.setBaseSeries(null, false);
      }
      function l8() {
        let t10, e10, i10;
        let s10 = this.legend, o10 = this.navigator;
        if (o10) {
          t10 = s10 && s10.options, e10 = o10.xAxis, i10 = o10.yAxis;
          let {
            scrollbarHeight: r10,
            scrollButtonSize: n10
          } = o10;
          this.inverted ? (o10.left = o10.opposite ? this.chartWidth - r10 - o10.height : this.spacing[3] + r10, o10.top = this.plotTop + n10) : (o10.left = l6(e10.left, this.plotLeft + n10), o10.top = o10.navigatorOptions.top || this.chartHeight - o10.height - r10 - (this.scrollbar?.options.margin || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t10 && "bottom" === t10.verticalAlign && "proximate" !== t10.layout && t10.enabled && !t10.floating ? s10.legendHeight + l6(t10.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e10 && i10 && (this.inverted ? e10.options.left = i10.options.left = o10.left : e10.options.top = i10.options.top = o10.top, e10.setAxisSize(), i10.setAxisSize());
        }
      }
      function l7(t10) {
        !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new i(this), l6(t10.redraw, true) && this.redraw(t10.animation));
      }
      function dt() {
        let t10 = this.options;
        (t10.navigator.enabled || t10.scrollbar.enabled) && (this.scroller = this.navigator = new i(this));
      }
      function de() {
        let t10 = this.options, e10 = t10.navigator, i10 = t10.rangeSelector;
        if ((e10 && e10.enabled || i10 && i10.enabled) && (!l2 && "x" === this.zooming.type || l2 && "x" === this.zooming.pinchType)) return false;
      }
      function di(t10) {
        let e10 = t10.navigator;
        if (e10 && t10.xAxis[0]) {
          let i10 = t10.xAxis[0].getExtremes();
          e10.render(i10.min, i10.max);
        }
      }
      function ds(t10) {
        let e10 = t10.options.navigator || {}, i10 = t10.options.scrollbar || {};
        !this.navigator && !this.scroller && (e10.enabled || i10.enabled) && (l5(true, this.options.navigator, e10), l5(true, this.options.scrollbar, i10), delete t10.options.navigator, delete t10.options.scrollbar);
      }
      let dr = {
        compose: function(t10, e10) {
          if (tt.pushUnique(l9, t10)) {
            let s10 = t10.prototype;
            i = e10, s10.callbacks.push(di), l3(t10, "afterAddSeries", l4), l3(t10, "afterSetChartSize", l8), l3(t10, "afterUpdate", l7), l3(t10, "beforeRender", dt), l3(t10, "beforeShowResetZoom", de), l3(t10, "update", ds);
          }
        }
      }, {
        isTouchDevice: dn
      } = O, {
        addEvent: da,
        correctFloat: dh,
        defined: dl,
        isNumber: dd,
        pick: dc
      } = tt;
      function dp() {
        this.navigatorAxis || (this.navigatorAxis = new dg(this));
      }
      function du(t10) {
        let e10;
        let i10 = this.chart, s10 = i10.options, o10 = s10.navigator, r10 = this.navigatorAxis, n10 = i10.zooming.pinchType, a10 = s10.rangeSelector, h10 = i10.zooming.type;
        if (this.isXAxis && (o10?.enabled || a10?.enabled)) {
          if ("y" === h10 && "zoom" === t10.trigger) e10 = false;
          else if (("zoom" === t10.trigger && "xy" === h10 || dn && "xy" === n10) && this.options.range) {
            let e11 = r10.previousZoom;
            dl(t10.min) ? r10.previousZoom = [this.min, this.max] : e11 && (t10.min = e11[0], t10.max = e11[1], r10.previousZoom = void 0);
          }
        }
        void 0 !== e10 && t10.preventDefault();
      }
      class dg {
        static compose(t10) {
          t10.keepProps.includes("navigatorAxis") || (t10.keepProps.push("navigatorAxis"), da(t10, "init", dp), da(t10, "setExtremes", du));
        }
        constructor(t10) {
          this.axis = t10;
        }
        destroy() {
          this.axis = void 0;
        }
        toFixedRange(t10, e10, i10, s10) {
          let o10 = this.axis, r10 = (o10.pointRange || 0) / 2, n10 = dc(i10, o10.translate(t10, true, !o10.horiz)), a10 = dc(s10, o10.translate(e10, true, !o10.horiz));
          return dl(i10) || (n10 = dh(n10 + r10)), dl(s10) || (a10 = dh(a10 - r10)), dd(n10) && dd(a10) || (n10 = a10 = void 0), {
            min: n10,
            max: a10
          };
        }
      }
      let {
        parse: df
      } = tO, {
        seriesTypes: dm
      } = ry, dx = {
        height: 40,
        margin: 25,
        maskInside: true,
        handles: {
          width: 7,
          borderRadius: 0,
          height: 15,
          symbols: ["navigator-handle", "navigator-handle"],
          enabled: true,
          lineWidth: 1,
          backgroundColor: "#f2f2f2",
          borderColor: "#999999"
        },
        maskFill: df("#667aff").setOpacity(0.3).get(),
        outlineColor: "#999999",
        outlineWidth: 1,
        series: {
          type: void 0 === dm.areaspline ? "line" : "areaspline",
          fillOpacity: 0.05,
          lineWidth: 1,
          compare: null,
          sonification: {
            enabled: false
          },
          dataGrouping: {
            approximation: "average",
            enabled: true,
            groupPixelWidth: 2,
            firstAnchor: "firstPoint",
            anchor: "middle",
            lastAnchor: "lastPoint",
            units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
          },
          dataLabels: {
            enabled: false,
            zIndex: 2
          },
          id: "highcharts-navigator-series",
          className: "highcharts-navigator-series",
          lineColor: null,
          marker: {
            enabled: false
          },
          threshold: null
        },
        xAxis: {
          className: "highcharts-navigator-xaxis",
          tickLength: 0,
          lineWidth: 0,
          gridLineColor: "#e6e6e6",
          id: "navigator-x-axis",
          gridLineWidth: 1,
          tickPixelInterval: 200,
          labels: {
            align: "left",
            style: {
              color: "#000000",
              fontSize: "0.7em",
              opacity: 0.6,
              textOutline: "2px contrast"
            },
            x: 3,
            y: -4
          },
          crosshair: false
        },
        yAxis: {
          className: "highcharts-navigator-yaxis",
          gridLineWidth: 0,
          startOnTick: false,
          endOnTick: false,
          minPadding: 0.1,
          id: "navigator-y-axis",
          maxPadding: 0.1,
          labels: {
            enabled: false
          },
          crosshair: false,
          title: {
            text: null
          },
          tickLength: 0,
          tickWidth: 0
        }
      }, {
        relativeLength: dy
      } = tt, db = {
        "navigator-handle": function(t10, e10, i10, s10, o10 = {}) {
          let r10 = o10.width ? o10.width / 2 : i10, n10 = dy(o10.borderRadius || 0, Math.min(2 * r10, s10));
          return [["M", -1.5, (s10 = o10.height || s10) / 2 - 3.5], ["L", -1.5, s10 / 2 + 4.5], ["M", 0.5, s10 / 2 - 3.5], ["L", 0.5, s10 / 2 + 4.5], ...is.rect(-r10 - 1, 0.5, 2 * r10 + 1, s10, {
            r: n10
          })];
        }
      }, {
        defined: dv
      } = tt, {
        setOptions: dM
      } = tS, {
        composed: dk
      } = O, {
        getRendererType: dw
      } = eu, {
        setFixedRange: dS
      } = {
        setFixedRange: function(t10) {
          let e10 = this.xAxis[0];
          dv(e10.dataMax) && dv(e10.dataMin) && t10 ? this.fixedRange = Math.min(t10, e10.dataMax - e10.dataMin) : this.fixedRange = t10;
        }
      }, {
        addEvent: dA,
        extend: dT,
        pushUnique: dP
      } = tt;
      function dC() {
        this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
      }
      let dO = {
        compose: function(t10, e10, i10) {
          dg.compose(e10), dP(dk, "Navigator") && (t10.prototype.setFixedRange = dS, dT(dw().prototype.symbols, db), dA(i10, "afterUpdate", dC), dM({
            navigator: dx
          }));
        }
      }, {
        composed: dE
      } = O, {
        addEvent: dL,
        defined: dB,
        pick: dI,
        pushUnique: dD
      } = tt;
      !function(t10) {
        let e10;
        function i10(t11) {
          let e11 = dI(t11.options && t11.options.min, t11.min), i11 = dI(t11.options && t11.options.max, t11.max);
          return {
            axisMin: e11,
            axisMax: i11,
            scrollMin: dB(t11.dataMin) ? Math.min(e11, t11.min, t11.dataMin, dI(t11.threshold, 1 / 0)) : e11,
            scrollMax: dB(t11.dataMax) ? Math.max(i11, t11.max, t11.dataMax, dI(t11.threshold, -1 / 0)) : i11
          };
        }
        function s10() {
          let t11 = this.scrollbar, e11 = t11 && !t11.options.opposite, i11 = this.horiz ? 2 : e11 ? 3 : 1;
          t11 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i11] += t11.size + (t11.options.margin || 0));
        }
        function o10() {
          let t11 = this;
          t11.options && t11.options.scrollbar && t11.options.scrollbar.enabled && (t11.options.scrollbar.vertical = !t11.horiz, t11.options.startOnTick = t11.options.endOnTick = false, t11.scrollbar = new e10(t11.chart.renderer, t11.options.scrollbar, t11.chart), dL(t11.scrollbar, "changed", function(e11) {
            let s11, o11;
            let {
              axisMin: r11,
              axisMax: n10,
              scrollMin: a10,
              scrollMax: h10
            } = i10(t11), l10 = h10 - a10;
            if (dB(r11) && dB(n10)) {
              if (t11.horiz && !t11.reversed || !t11.horiz && t11.reversed ? (s11 = a10 + l10 * this.to, o11 = a10 + l10 * this.from) : (s11 = a10 + l10 * (1 - this.from), o11 = a10 + l10 * (1 - this.to)), this.shouldUpdateExtremes(e11.DOMType)) {
                let i11 = "mousemove" !== e11.DOMType && "touchmove" !== e11.DOMType && void 0;
                t11.setExtremes(o11, s11, true, i11, e11);
              } else this.setRange(this.from, this.to);
            }
          }));
        }
        function r10() {
          let t11, e11, s11;
          let {
            scrollMin: o11,
            scrollMax: r11
          } = i10(this), n10 = this.scrollbar, a10 = this.axisTitleMargin + (this.titleOffset || 0), h10 = this.chart.scrollbarsOffsets, l10 = this.options.margin || 0;
          if (n10 && h10) {
            if (this.horiz) this.opposite || (h10[1] += a10), n10.position(this.left, this.top + this.height + 2 + h10[1] - (this.opposite ? l10 : 0), this.width, this.height), this.opposite || (h10[1] += l10), t11 = 1;
            else {
              let e12;
              this.opposite && (h10[0] += a10), e12 = n10.options.opposite ? this.left + this.width + 2 + h10[0] - (this.opposite ? 0 : l10) : this.opposite ? 0 : l10, n10.position(e12, this.top, this.width, this.height), this.opposite && (h10[0] += l10), t11 = 0;
            }
            if (h10[t11] += n10.size + (n10.options.margin || 0), isNaN(o11) || isNaN(r11) || !dB(this.min) || !dB(this.max) || this.dataMin === this.dataMax) n10.setRange(0, 1);
            else if (this.min === this.max) {
              let t12 = this.pointRange / (this.dataMax + 1);
              e11 = t12 * this.min, s11 = t12 * (this.max + 1), n10.setRange(e11, s11);
            } else e11 = (this.min - o11) / (r11 - o11), s11 = (this.max - o11) / (r11 - o11), this.horiz && !this.reversed || !this.horiz && this.reversed ? n10.setRange(e11, s11) : n10.setRange(1 - s11, 1 - e11);
          }
        }
        t10.compose = function(t11, i11) {
          dD(dE, "Axis.Scrollbar") && (e10 = i11, dL(t11, "afterGetOffset", s10), dL(t11, "afterInit", o10), dL(t11, "afterRender", r10));
        };
      }(k || (k = {}));
      let dR = k, dN = {
        height: 10,
        barBorderRadius: 5,
        buttonBorderRadius: 0,
        buttonsEnabled: false,
        liveRedraw: void 0,
        margin: void 0,
        minWidth: 6,
        opposite: true,
        step: 0.2,
        zIndex: 3,
        barBackgroundColor: "#cccccc",
        barBorderWidth: 0,
        barBorderColor: "#cccccc",
        buttonArrowColor: "#333333",
        buttonBackgroundColor: "#e6e6e6",
        buttonBorderColor: "#cccccc",
        buttonBorderWidth: 1,
        rifleColor: "none",
        trackBackgroundColor: "rgba(255, 255, 255, 0.001)",
        trackBorderColor: "#cccccc",
        trackBorderRadius: 5,
        trackBorderWidth: 1
      }, {
        defaultOptions: dz
      } = tS, {
        addEvent: dW,
        correctFloat: dG,
        crisp: dH,
        defined: dF,
        destroyObjectProperties: dX,
        fireEvent: dY,
        merge: dj,
        pick: dU,
        removeEvent: dV
      } = tt;
      class d$ {
        static compose(t10) {
          dR.compose(t10, d$);
        }
        static swapXY(t10, e10) {
          return e10 && t10.forEach((t11) => {
            let e11;
            let i10 = t11.length;
            for (let s10 = 0; s10 < i10; s10 += 2) "number" == typeof (e11 = t11[s10 + 1]) && (t11[s10 + 1] = t11[s10 + 2], t11[s10 + 2] = e11);
          }), t10;
        }
        constructor(t10, e10, i10) {
          this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t10, e10, i10);
        }
        addEvents() {
          let t10 = this.options.inverted ? [1, 0] : [0, 1], e10 = this.scrollbarButtons, i10 = this.scrollbarGroup.element, s10 = this.track.element, o10 = this.mouseDownHandler.bind(this), r10 = this.mouseMoveHandler.bind(this), n10 = this.mouseUpHandler.bind(this), a10 = [[e10[t10[0]].element, "click", this.buttonToMinClick.bind(this)], [e10[t10[1]].element, "click", this.buttonToMaxClick.bind(this)], [s10, "click", this.trackClick.bind(this)], [i10, "mousedown", o10], [i10.ownerDocument, "mousemove", r10], [i10.ownerDocument, "mouseup", n10], [i10, "touchstart", o10], [i10.ownerDocument, "touchmove", r10], [i10.ownerDocument, "touchend", n10]];
          a10.forEach(function(t11) {
            dW.apply(null, t11);
          }), this._events = a10;
        }
        buttonToMaxClick(t10) {
          let e10 = (this.to - this.from) * dU(this.options.step, 0.2);
          this.updatePosition(this.from + e10, this.to + e10), dY(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMEvent: t10
          });
        }
        buttonToMinClick(t10) {
          let e10 = dG(this.to - this.from) * dU(this.options.step, 0.2);
          this.updatePosition(dG(this.from - e10), dG(this.to - e10)), dY(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMEvent: t10
          });
        }
        cursorToScrollbarPosition(t10) {
          let e10 = this.options, i10 = e10.minWidth > this.calculatedWidth ? e10.minWidth : 0;
          return {
            chartX: (t10.chartX - this.x - this.xOffset) / (this.barWidth - i10),
            chartY: (t10.chartY - this.y - this.yOffset) / (this.barWidth - i10)
          };
        }
        destroy() {
          let t10 = this, e10 = t10.chart.scroller;
          t10.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(e11) {
            t10[e11] && t10[e11].destroy && (t10[e11] = t10[e11].destroy());
          }), e10 && t10 === e10.scrollbar && (e10.scrollbar = null, dX(e10.scrollbarButtons));
        }
        drawScrollbarButton(t10) {
          let e10 = this.renderer, i10 = this.scrollbarButtons, s10 = this.options, o10 = this.size, r10 = e10.g().add(this.group);
          if (i10.push(r10), s10.buttonsEnabled) {
            let n10 = e10.rect().addClass("highcharts-scrollbar-button").add(r10);
            this.chart.styledMode || n10.attr({
              stroke: s10.buttonBorderColor,
              "stroke-width": s10.buttonBorderWidth,
              fill: s10.buttonBackgroundColor
            }), n10.attr(n10.crisp({
              x: -0.5,
              y: -0.5,
              width: o10,
              height: o10,
              r: s10.buttonBorderRadius
            }, n10.strokeWidth()));
            let a10 = e10.path(d$.swapXY([["M", o10 / 2 + (t10 ? -1 : 1), o10 / 2 - 3], ["L", o10 / 2 + (t10 ? -1 : 1), o10 / 2 + 3], ["L", o10 / 2 + (t10 ? 2 : -2), o10 / 2]], s10.vertical)).addClass("highcharts-scrollbar-arrow").add(i10[t10]);
            this.chart.styledMode || a10.attr({
              fill: s10.buttonArrowColor
            });
          }
        }
        init(t10, e10, i10) {
          this.scrollbarButtons = [], this.renderer = t10, this.userOptions = e10, this.options = dj(dN, dz.scrollbar, e10), this.options.margin = dU(this.options.margin, 10), this.chart = i10, this.size = dU(this.options.size, this.options.height), e10.enabled && (this.render(), this.addEvents());
        }
        mouseDownHandler(t10) {
          let e10 = this.chart.pointer?.normalize(t10) || t10, i10 = this.cursorToScrollbarPosition(e10);
          this.chartX = i10.chartX, this.chartY = i10.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = true;
        }
        mouseMoveHandler(t10) {
          let e10;
          let i10 = this.chart.pointer?.normalize(t10) || t10, s10 = this.options.vertical ? "chartY" : "chartX", o10 = this.initPositions || [];
          this.grabbedCenter && (!t10.touches || 0 !== t10.touches[0][s10]) && (e10 = this.cursorToScrollbarPosition(i10)[s10] - this[s10], this.hasDragged = true, this.updatePosition(o10[0] + e10, o10[1] + e10), this.hasDragged && dY(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMType: t10.type,
            DOMEvent: t10
          }));
        }
        mouseUpHandler(t10) {
          this.hasDragged && dY(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMType: t10.type,
            DOMEvent: t10
          }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
        }
        position(t10, e10, i10, s10) {
          let {
            buttonsEnabled: o10,
            margin: r10 = 0,
            vertical: n10
          } = this.options, a10 = this.rendered ? "animate" : "attr", h10 = s10, l10 = 0;
          this.group.show(), this.x = t10, this.y = e10 + this.trackBorderWidth, this.width = i10, this.height = s10, this.xOffset = h10, this.yOffset = l10, n10 ? (this.width = this.yOffset = i10 = l10 = this.size, this.xOffset = h10 = 0, this.yOffset = l10 = o10 ? this.size : 0, this.barWidth = s10 - (o10 ? 2 * i10 : 0), this.x = t10 += r10) : (this.height = s10 = this.size, this.xOffset = h10 = o10 ? this.size : 0, this.barWidth = i10 - (o10 ? 2 * s10 : 0), this.y = this.y + r10), this.group[a10]({
            translateX: t10,
            translateY: this.y
          }), this.track[a10]({
            width: i10,
            height: s10
          }), this.scrollbarButtons[1][a10]({
            translateX: n10 ? 0 : i10 - h10,
            translateY: n10 ? s10 - l10 : 0
          });
        }
        removeEvents() {
          this._events.forEach(function(t10) {
            dV.apply(null, t10);
          }), this._events.length = 0;
        }
        render() {
          let t10 = this.renderer, e10 = this.options, i10 = this.size, s10 = this.chart.styledMode, o10 = t10.g("scrollbar").attr({
            zIndex: e10.zIndex
          }).hide().add();
          this.group = o10, this.track = t10.rect().addClass("highcharts-scrollbar-track").attr({
            r: e10.trackBorderRadius || 0,
            height: i10,
            width: i10
          }).add(o10), s10 || this.track.attr({
            fill: e10.trackBackgroundColor,
            stroke: e10.trackBorderColor,
            "stroke-width": e10.trackBorderWidth
          });
          let r10 = this.trackBorderWidth = this.track.strokeWidth();
          this.track.attr({
            x: -dH(0, r10),
            y: -dH(0, r10)
          }), this.scrollbarGroup = t10.g().add(o10), this.scrollbar = t10.rect().addClass("highcharts-scrollbar-thumb").attr({
            height: i10 - r10,
            width: i10 - r10,
            r: e10.barBorderRadius || 0
          }).add(this.scrollbarGroup), this.scrollbarRifles = t10.path(d$.swapXY([["M", -3, i10 / 4], ["L", -3, 2 * i10 / 3], ["M", 0, i10 / 4], ["L", 0, 2 * i10 / 3], ["M", 3, i10 / 4], ["L", 3, 2 * i10 / 3]], e10.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s10 || (this.scrollbar.attr({
            fill: e10.barBackgroundColor,
            stroke: e10.barBorderColor,
            "stroke-width": e10.barBorderWidth
          }), this.scrollbarRifles.attr({
            stroke: e10.rifleColor,
            "stroke-width": 1
          })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-dH(0, this.scrollbarStrokeWidth), -dH(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
        }
        setRange(t10, e10) {
          let i10, s10;
          let o10 = this.options, r10 = o10.vertical, n10 = o10.minWidth, a10 = this.barWidth, h10 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
          if (!dF(a10)) return;
          let l10 = a10 * Math.min(e10, 1);
          i10 = Math.ceil(a10 * (t10 = Math.max(t10, 0))), this.calculatedWidth = s10 = dG(l10 - i10), s10 < n10 && (i10 = (a10 - n10 + s10) * t10, s10 = n10);
          let d10 = Math.floor(i10 + this.xOffset + this.yOffset), c10 = s10 / 2 - 0.5;
          this.from = t10, this.to = e10, r10 ? (this.scrollbarGroup[h10]({
            translateY: d10
          }), this.scrollbar[h10]({
            height: s10
          }), this.scrollbarRifles[h10]({
            translateY: c10
          }), this.scrollbarTop = d10, this.scrollbarLeft = 0) : (this.scrollbarGroup[h10]({
            translateX: d10
          }), this.scrollbar[h10]({
            width: s10
          }), this.scrollbarRifles[h10]({
            translateX: c10
          }), this.scrollbarLeft = d10, this.scrollbarTop = 0), s10 <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), false === o10.showFull && (t10 <= 0 && e10 >= 1 ? this.group.hide() : this.group.show()), this.rendered = true;
        }
        shouldUpdateExtremes(t10) {
          return dU(this.options.liveRedraw, O.svg && !O.isTouchDevice && !this.chart.boosted) || "mouseup" === t10 || "touchend" === t10 || !dF(t10);
        }
        trackClick(t10) {
          let e10 = this.chart.pointer?.normalize(t10) || t10, i10 = this.to - this.from, s10 = this.y + this.scrollbarTop, o10 = this.x + this.scrollbarLeft;
          this.options.vertical && e10.chartY > s10 || !this.options.vertical && e10.chartX > o10 ? this.updatePosition(this.from + i10, this.to + i10) : this.updatePosition(this.from - i10, this.to - i10), dY(this, "changed", {
            from: this.from,
            to: this.to,
            trigger: "scrollbar",
            DOMEvent: t10
          });
        }
        update(t10) {
          this.destroy(), this.init(this.chart.renderer, dj(true, this.options, t10), this.chart);
        }
        updatePosition(t10, e10) {
          e10 > 1 && (t10 = dG(1 - dG(e10 - t10)), e10 = 1), t10 < 0 && (e10 = dG(e10 - t10), t10 = 0), this.from = t10, this.to = e10;
        }
      }
      d$.defaultOptions = dN, dz.scrollbar = dj(true, d$.defaultOptions, dz.scrollbar);
      let {
        defaultOptions: d_
      } = tS, {
        isTouchDevice: dq
      } = O, {
        prototype: {
          symbols: dZ
        }
      } = iU, {
        addEvent: dK,
        clamp: dJ,
        correctFloat: dQ,
        defined: d0,
        destroyObjectProperties: d1,
        erase: d2,
        extend: d3,
        find: d5,
        fireEvent: d6,
        isArray: d9,
        isNumber: d4,
        merge: d8,
        pick: d7,
        removeEvent: ct,
        splat: ce
      } = tt;
      function ci(t10, ...e10) {
        let i10 = [].filter.call(e10, d4);
        if (i10.length) return Math[t10].apply(0, i10);
      }
      class cs {
        static compose(t10, e10, i10) {
          dr.compose(t10, cs), dO.compose(t10, e10, i10);
        }
        constructor(t10) {
          this.isDirty = false, this.scrollbarHeight = 0, this.init(t10);
        }
        drawHandle(t10, e10, i10, s10) {
          let o10 = this.navigatorOptions.handles.height;
          this.handles[e10][s10](i10 ? {
            translateX: Math.round(this.left + this.height / 2),
            translateY: Math.round(this.top + parseInt(t10, 10) + 0.5 - o10)
          } : {
            translateX: Math.round(this.left + parseInt(t10, 10)),
            translateY: Math.round(this.top + this.height / 2 - o10 / 2 - 1)
          });
        }
        drawOutline(t10, e10, i10, s10) {
          let o10 = this.navigatorOptions.maskInside, r10 = this.outline.strokeWidth(), n10 = r10 / 2, a10 = r10 % 2 / 2, h10 = this.scrollButtonSize, l10 = this.size, d10 = this.top, c10 = this.height, p10 = d10 - n10, u10 = d10 + c10, g2 = this.left, f2, m2;
          i10 ? (f2 = d10 + e10 + a10, e10 = d10 + t10 + a10, m2 = [["M", g2 + c10, d10 - h10 - a10], ["L", g2 + c10, f2], ["L", g2, f2], ["M", g2, e10], ["L", g2 + c10, e10], ["L", g2 + c10, d10 + l10 + h10]], o10 && m2.push(["M", g2 + c10, f2 - n10], ["L", g2 + c10, e10 + n10])) : (g2 -= h10, t10 += g2 + h10 - a10, e10 += g2 + h10 - a10, m2 = [["M", g2, p10], ["L", t10, p10], ["L", t10, u10], ["M", e10, u10], ["L", e10, p10], ["L", g2 + l10 + 2 * h10, p10]], o10 && m2.push(["M", t10 - n10, p10], ["L", e10 + n10, p10])), this.outline[s10]({
            d: m2
          });
        }
        drawMasks(t10, e10, i10, s10) {
          let o10, r10, n10, a10;
          let h10 = this.left, l10 = this.top, d10 = this.height;
          i10 ? (n10 = [h10, h10, h10], a10 = [l10, l10 + t10, l10 + e10], r10 = [d10, d10, d10], o10 = [t10, e10 - t10, this.size - e10]) : (n10 = [h10, h10 + t10, h10 + e10], a10 = [l10, l10, l10], r10 = [t10, e10 - t10, this.size - e10], o10 = [d10, d10, d10]), this.shades.forEach((t11, e11) => {
            t11[s10]({
              x: n10[e11],
              y: a10[e11],
              width: r10[e11],
              height: o10[e11]
            });
          });
        }
        renderElements() {
          let t10 = this, e10 = t10.navigatorOptions, i10 = e10.maskInside, s10 = t10.chart, o10 = s10.inverted, r10 = s10.renderer, n10 = {
            cursor: o10 ? "ns-resize" : "ew-resize"
          }, a10 = t10.navigatorGroup ?? (t10.navigatorGroup = r10.g("navigator").attr({
            zIndex: 8,
            visibility: "hidden"
          }).add());
          if ([!i10, i10, !i10].forEach((i11, o11) => {
            let h10 = t10.shades[o11] ?? (t10.shades[o11] = r10.rect().addClass("highcharts-navigator-mask" + (1 === o11 ? "-inside" : "-outside")).add(a10));
            s10.styledMode || (h10.attr({
              fill: i11 ? e10.maskFill : "rgba(0,0,0,0)"
            }), 1 === o11 && h10.css(n10));
          }), t10.outline || (t10.outline = r10.path().addClass("highcharts-navigator-outline").add(a10)), s10.styledMode || t10.outline.attr({
            "stroke-width": e10.outlineWidth,
            stroke: e10.outlineColor
          }), e10.handles?.enabled) {
            let i11 = e10.handles, {
              height: o11,
              width: h10
            } = i11;
            [0, 1].forEach((e11) => {
              let l10 = i11.symbols[e11];
              if (t10.handles[e11] && t10.handles[e11].symbolUrl === l10) {
                if (!t10.handles[e11].isImg && t10.handles[e11].symbolName !== l10) {
                  let i12 = dZ[l10].call(dZ, -h10 / 2 - 1, 0, h10, o11);
                  t10.handles[e11].attr({
                    d: i12
                  }), t10.handles[e11].symbolName = l10;
                }
              } else t10.handles[e11]?.destroy(), t10.handles[e11] = r10.symbol(l10, -h10 / 2 - 1, 0, h10, o11, i11), t10.handles[e11].attr({
                zIndex: 7 - e11
              }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][e11]).add(a10), t10.addMouseEvents();
              s10.inverted && t10.handles[e11].attr({
                rotation: 90,
                rotationOriginX: Math.floor(-h10 / 2),
                rotationOriginY: (o11 + h10) / 2
              }), s10.styledMode || t10.handles[e11].attr({
                fill: i11.backgroundColor,
                stroke: i11.borderColor,
                "stroke-width": i11.lineWidth,
                width: i11.width,
                height: i11.height,
                x: -h10 / 2 - 1,
                y: 0
              }).css(n10);
            });
          }
        }
        update(t10, e10 = false) {
          let i10 = this.chart, s10 = i10.options.chart.inverted !== i10.scrollbar?.options.vertical;
          if (d8(true, i10.options.navigator, t10), this.navigatorOptions = i10.options.navigator || {}, this.setOpposite(), d0(t10.enabled) || s10) return this.destroy(), this.navigatorEnabled = t10.enabled || this.navigatorEnabled, this.init(i10);
          if (this.navigatorEnabled && (this.isDirty = true, false === t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            ct(t11, "updatedData", this.updatedDataHandler);
          }, this), t10.adaptToUpdatedData && this.baseSeries.forEach((t11) => {
            t11.eventsToUnbind.push(dK(t11, "updatedData", this.updatedDataHandler));
          }, this), (t10.series || t10.baseSeries) && this.setBaseSeries(void 0, false), t10.height || t10.xAxis || t10.yAxis)) {
            this.height = t10.height ?? this.height;
            let e11 = this.getXAxisOffsets();
            this.xAxis.update(__spreadProps(__spreadValues({}, t10.xAxis), {
              offsets: e11,
              [i10.inverted ? "width" : "height"]: this.height,
              [i10.inverted ? "height" : "width"]: void 0
            }), false), this.yAxis.update(__spreadProps(__spreadValues({}, t10.yAxis), {
              [i10.inverted ? "width" : "height"]: this.height
            }), false);
          }
          e10 && i10.redraw();
        }
        render(t10, e10, i10, s10) {
          let o10 = this.chart, r10 = this.xAxis, n10 = r10.pointRange || 0, a10 = r10.navigatorAxis.fake ? o10.xAxis[0] : r10, h10 = this.navigatorEnabled, l10 = this.rendered, d10 = o10.inverted, c10 = o10.xAxis[0].minRange, p10 = o10.xAxis[0].options.maxRange, u10 = this.scrollButtonSize, g2, f2, m2, x2 = this.scrollbarHeight, y2, b2;
          if (this.hasDragged && !d0(i10)) return;
          if (this.isDirty && this.renderElements(), t10 = dQ(t10 - n10 / 2), e10 = dQ(e10 + n10 / 2), !d4(t10) || !d4(e10)) {
            if (!l10) return;
            i10 = 0, s10 = d7(r10.width, a10.width);
          }
          this.left = d7(r10.left, o10.plotLeft + u10 + (d10 ? o10.plotWidth : 0));
          let v2 = this.size = y2 = d7(r10.len, (d10 ? o10.plotHeight : o10.plotWidth) - 2 * u10);
          g2 = d10 ? x2 : y2 + 2 * u10, i10 = d7(i10, r10.toPixels(t10, true)), s10 = d7(s10, r10.toPixels(e10, true)), d4(i10) && Math.abs(i10) !== 1 / 0 || (i10 = 0, s10 = g2);
          let M2 = r10.toValue(i10, true), k2 = r10.toValue(s10, true), w2 = Math.abs(dQ(k2 - M2));
          w2 < c10 ? this.grabbedLeft ? i10 = r10.toPixels(k2 - c10 - n10, true) : this.grabbedRight && (s10 = r10.toPixels(M2 + c10 + n10, true)) : d0(p10) && dQ(w2 - n10) > p10 && (this.grabbedLeft ? i10 = r10.toPixels(k2 - p10 - n10, true) : this.grabbedRight && (s10 = r10.toPixels(M2 + p10 + n10, true))), this.zoomedMax = dJ(Math.max(i10, s10), 0, v2), this.zoomedMin = dJ(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i10, s10), 0, v2), this.range = this.zoomedMax - this.zoomedMin, v2 = Math.round(this.zoomedMax);
          let S2 = Math.round(this.zoomedMin);
          h10 && (this.navigatorGroup.attr({
            visibility: "inherit"
          }), b2 = l10 && !this.hasDragged ? "animate" : "attr", this.drawMasks(S2, v2, d10, b2), this.drawOutline(S2, v2, d10, b2), this.navigatorOptions.handles.enabled && (this.drawHandle(S2, 0, d10, b2), this.drawHandle(v2, 1, d10, b2))), this.scrollbar && (d10 ? (m2 = this.top - u10, f2 = this.left - x2 + (h10 || !a10.opposite ? 0 : (a10.titleOffset || 0) + a10.axisTitleMargin), x2 = y2 + 2 * u10) : (m2 = this.top + (h10 ? this.height : -x2), f2 = this.left - u10), this.scrollbar.position(f2, m2, g2, x2), this.scrollbar.setRange(this.zoomedMin / (y2 || 1), this.zoomedMax / (y2 || 1))), this.rendered = true, this.isDirty = false, d6(this, "afterRender");
        }
        addMouseEvents() {
          let t10 = this, e10 = t10.chart, i10 = e10.container, s10 = [], o10, r10;
          t10.mouseMoveHandler = o10 = function(e11) {
            t10.onMouseMove(e11);
          }, t10.mouseUpHandler = r10 = function(e11) {
            t10.onMouseUp(e11);
          }, (s10 = t10.getPartsEvents("mousedown")).push(dK(e10.renderTo, "mousemove", o10), dK(i10.ownerDocument, "mouseup", r10), dK(e10.renderTo, "touchmove", o10), dK(i10.ownerDocument, "touchend", r10)), s10.concat(t10.getPartsEvents("touchstart")), t10.eventsToUnbind = s10, t10.series && t10.series[0] && s10.push(dK(t10.series[0].xAxis, "foundExtremes", function() {
            e10.navigator.modifyNavigatorAxisExtremes();
          }));
        }
        getPartsEvents(t10) {
          let e10 = this, i10 = [];
          return ["shades", "handles"].forEach(function(s10) {
            e10[s10].forEach(function(o10, r10) {
              i10.push(dK(o10.element, t10, function(t11) {
                e10[s10 + "Mousedown"](t11, r10);
              }));
            });
          }), i10;
        }
        shadesMousedown(t10, e10) {
          t10 = this.chart.pointer?.normalize(t10) || t10;
          let i10 = this.chart, s10 = this.xAxis, o10 = this.zoomedMin, r10 = this.size, n10 = this.range, a10 = this.left, h10 = t10.chartX, l10, d10, c10, p10;
          i10.inverted && (h10 = t10.chartY, a10 = this.top), 1 === e10 ? (this.grabbedCenter = h10, this.fixedWidth = n10, this.dragOffset = h10 - o10) : (p10 = h10 - a10 - n10 / 2, 0 === e10 ? p10 = Math.max(0, p10) : 2 === e10 && p10 + n10 >= r10 && (p10 = r10 - n10, this.reversedExtremes ? (p10 -= n10, d10 = this.getUnionExtremes().dataMin) : l10 = this.getUnionExtremes().dataMax), p10 !== o10 && (this.fixedWidth = n10, d0((c10 = s10.navigatorAxis.toFixedRange(p10, p10 + n10, d10, l10)).min) && d6(this, "setRange", {
            min: Math.min(c10.min, c10.max),
            max: Math.max(c10.min, c10.max),
            redraw: true,
            eventArguments: {
              trigger: "navigator"
            }
          })));
        }
        handlesMousedown(t10, e10) {
          t10 = this.chart.pointer?.normalize(t10) || t10;
          let i10 = this.chart, s10 = i10.xAxis[0], o10 = this.reversedExtremes;
          0 === e10 ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o10 ? s10.min : s10.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o10 ? s10.max : s10.min), i10.setFixedRange(void 0);
        }
        onMouseMove(t10) {
          let e10 = this, i10 = e10.chart, s10 = e10.navigatorSize, o10 = e10.range, r10 = e10.dragOffset, n10 = i10.inverted, a10 = e10.left, h10;
          (!t10.touches || 0 !== t10.touches[0].pageX) && (h10 = (t10 = i10.pointer?.normalize(t10) || t10).chartX, n10 && (a10 = e10.top, h10 = t10.chartY), e10.grabbedLeft ? (e10.hasDragged = true, e10.render(0, 0, h10 - a10, e10.otherHandlePos)) : e10.grabbedRight ? (e10.hasDragged = true, e10.render(0, 0, e10.otherHandlePos, h10 - a10)) : e10.grabbedCenter && (e10.hasDragged = true, h10 < r10 ? h10 = r10 : h10 > s10 + r10 - o10 && (h10 = s10 + r10 - o10), e10.render(0, 0, h10 - r10, h10 - r10 + o10)), e10.hasDragged && e10.scrollbar && d7(e10.scrollbar.options.liveRedraw, !dq && !this.chart.boosted) && (t10.DOMType = t10.type, setTimeout(function() {
            e10.onMouseUp(t10);
          }, 0)));
        }
        onMouseUp(t10) {
          let e10, i10, s10, o10, r10, n10;
          let a10 = this.chart, h10 = this.xAxis, l10 = this.scrollbar, d10 = t10.DOMEvent || t10, c10 = a10.inverted, p10 = this.rendered && !this.hasDragged ? "animate" : "attr";
          (this.hasDragged && (!l10 || !l10.hasDragged) || "scrollbar" === t10.trigger) && (s10 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o10 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r10 = this.fixedExtreme), this.zoomedMax === this.size && (r10 = this.reversedExtremes ? s10.dataMin : s10.dataMax), 0 === this.zoomedMin && (o10 = this.reversedExtremes ? s10.dataMax : s10.dataMin), d0((n10 = h10.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o10, r10)).min) && d6(this, "setRange", {
            min: Math.min(n10.min, n10.max),
            max: Math.max(n10.min, n10.max),
            redraw: true,
            animation: !this.hasDragged && null,
            eventArguments: {
              trigger: "navigator",
              triggerOp: "navigator-drag",
              DOMEvent: d10
            }
          })), "mousemove" !== t10.DOMType && "touchmove" !== t10.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && d4(this.zoomedMin) && d4(this.zoomedMax) && (i10 = Math.round(this.zoomedMin), e10 = Math.round(this.zoomedMax), this.shades && this.drawMasks(i10, e10, c10, p10), this.outline && this.drawOutline(i10, e10, c10, p10), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i10, 0, c10, p10), this.drawHandle(e10, 1, c10, p10)));
        }
        removeEvents() {
          this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t10) {
            t10();
          }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
        }
        removeBaseSeriesEvents() {
          let t10 = this.baseSeries || [];
          this.navigatorEnabled && t10[0] && (false !== this.navigatorOptions.adaptToUpdatedData && t10.forEach(function(t11) {
            ct(t11, "updatedData", this.updatedDataHandler);
          }, this), t10[0].xAxis && ct(t10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
        }
        getXAxisOffsets() {
          return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];
        }
        init(t10) {
          let e10 = t10.options, i10 = e10.navigator || {}, s10 = i10.enabled, o10 = e10.scrollbar || {}, r10 = o10.enabled, n10 = s10 && i10.height || 0, a10 = r10 && o10.height || 0, h10 = o10.buttonsEnabled && a10 || 0;
          this.handles = [], this.shades = [], this.chart = t10, this.setBaseSeries(), this.height = n10, this.scrollbarHeight = a10, this.scrollButtonSize = h10, this.scrollbarEnabled = r10, this.navigatorEnabled = s10, this.navigatorOptions = i10, this.scrollbarOptions = o10, this.setOpposite();
          let l10 = this, d10 = l10.baseSeries, c10 = t10.xAxis.length, p10 = t10.yAxis.length, u10 = d10 && d10[0] && d10[0].xAxis || t10.xAxis[0] || {
            options: {}
          };
          if (t10.isDirtyBox = true, l10.navigatorEnabled) {
            let e11 = this.getXAxisOffsets();
            l10.xAxis = new sU(t10, d8({
              breaks: u10.options.breaks,
              ordinal: u10.options.ordinal,
              overscroll: u10.options.overscroll
            }, i10.xAxis, {
              type: "datetime",
              yAxis: i10.yAxis?.id,
              index: c10,
              isInternal: true,
              offset: 0,
              keepOrdinalPadding: true,
              startOnTick: false,
              endOnTick: false,
              minPadding: u10.options.ordinal ? 0 : u10.options.minPadding,
              maxPadding: u10.options.ordinal ? 0 : u10.options.maxPadding,
              zoomEnabled: false
            }, t10.inverted ? {
              offsets: e11,
              width: n10
            } : {
              offsets: e11,
              height: n10
            }), "xAxis"), l10.yAxis = new sU(t10, d8(i10.yAxis, {
              alignTicks: false,
              offset: 0,
              index: p10,
              isInternal: true,
              reversed: d7(i10.yAxis && i10.yAxis.reversed, t10.yAxis[0] && t10.yAxis[0].reversed, false),
              zoomEnabled: false
            }, t10.inverted ? {
              width: n10
            } : {
              height: n10
            }), "yAxis"), d10 || i10.series.data ? l10.updateNavigatorSeries(false) : 0 === t10.series.length && (l10.unbindRedraw = dK(t10, "beforeRedraw", function() {
              t10.series.length > 0 && !l10.series && (l10.setBaseSeries(), l10.unbindRedraw());
            })), l10.reversedExtremes = t10.inverted && !l10.xAxis.reversed || !t10.inverted && l10.xAxis.reversed, l10.renderElements(), l10.addMouseEvents();
          } else l10.xAxis = {
            chart: t10,
            navigatorAxis: {
              fake: true
            },
            translate: function(e11, i11) {
              let s11 = t10.xAxis[0], o11 = s11.getExtremes(), r11 = s11.len - 2 * h10, n11 = ci("min", s11.options.min, o11.dataMin), a11 = ci("max", s11.options.max, o11.dataMax) - n11;
              return i11 ? e11 * a11 / r11 + n11 : r11 * (e11 - n11) / a11;
            },
            toPixels: function(t11) {
              return this.translate(t11);
            },
            toValue: function(t11) {
              return this.translate(t11, true);
            }
          }, l10.xAxis.navigatorAxis.axis = l10.xAxis, l10.xAxis.navigatorAxis.toFixedRange = dg.prototype.toFixedRange.bind(l10.xAxis.navigatorAxis);
          if (t10.options.scrollbar.enabled) {
            let e11 = d8(t10.options.scrollbar, {
              vertical: t10.inverted
            });
            !d4(e11.margin) && l10.navigatorEnabled && (e11.margin = t10.inverted ? -3 : 3), t10.scrollbar = l10.scrollbar = new d$(t10.renderer, e11, t10), dK(l10.scrollbar, "changed", function(t11) {
              let e12 = l10.size, i11 = e12 * this.to, s11 = e12 * this.from;
              l10.hasDragged = l10.scrollbar.hasDragged, l10.render(0, 0, s11, i11), this.shouldUpdateExtremes(t11.DOMType) && setTimeout(function() {
                l10.onMouseUp(t11);
              });
            });
          }
          l10.addBaseSeriesEvents(), l10.addChartEvents();
        }
        setOpposite() {
          let t10 = this.navigatorOptions, e10 = this.navigatorEnabled, i10 = this.chart;
          this.opposite = d7(t10.opposite, !!(!e10 && i10.inverted));
        }
        getUnionExtremes(t10) {
          let e10;
          let i10 = this.chart.xAxis[0], s10 = this.chart.time, o10 = this.xAxis, r10 = o10.options, n10 = i10.options;
          return t10 && null === i10.dataMin || (e10 = {
            dataMin: d7(s10.parse(r10?.min), ci("min", s10.parse(n10.min), i10.dataMin, o10.dataMin, o10.min)),
            dataMax: d7(s10.parse(r10?.max), ci("max", s10.parse(n10.max), i10.dataMax, o10.dataMax, o10.max))
          }), e10;
        }
        setBaseSeries(t10, e10) {
          let i10 = this.chart, s10 = this.baseSeries = [];
          t10 = t10 || i10.options && i10.options.navigator.baseSeries || (i10.series.length ? d5(i10.series, (t11) => !t11.options.isInternal).index : 0), (i10.series || []).forEach((e11, i11) => {
            !e11.options.isInternal && (e11.options.showInNavigator || (i11 === t10 || e11.options.id === t10) && false !== e11.options.showInNavigator) && s10.push(e11);
          }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, e10);
        }
        updateNavigatorSeries(t10, e10) {
          let i10 = this, s10 = i10.chart, o10 = i10.baseSeries, r10 = {
            enableMouseTracking: false,
            index: null,
            linkedTo: null,
            group: "nav",
            padXAxis: false,
            xAxis: this.navigatorOptions.xAxis?.id,
            yAxis: this.navigatorOptions.yAxis?.id,
            showInLegend: false,
            stacking: void 0,
            isInternal: true,
            states: {
              inactive: {
                opacity: 1
              }
            }
          }, n10 = i10.series = (i10.series || []).filter((t11) => {
            let e11 = t11.baseSeries;
            return !(0 > o10.indexOf(e11)) || (e11 && (ct(e11, "updatedData", i10.updatedDataHandler), delete e11.navigatorSeries), t11.chart && t11.destroy(), false);
          }), a10, h10, l10 = i10.navigatorOptions.series, d10;
          o10 && o10.length && o10.forEach((t11) => {
            let c10 = t11.navigatorSeries, p10 = d3({
              color: t11.color,
              visible: t11.visible
            }, d9(l10) ? d_.navigator.series : l10);
            if (c10 && false === i10.navigatorOptions.adaptToUpdatedData) return;
            r10.name = "Navigator " + o10.length, d10 = (a10 = t11.options || {}).navigatorOptions || {}, p10.dataLabels = ce(p10.dataLabels), (h10 = d8(a10, r10, p10, d10)).pointRange = d7(p10.pointRange, d10.pointRange, d_.plotOptions[h10.type || "line"].pointRange);
            let u10 = d10.data || p10.data;
            i10.hasNavigatorData = i10.hasNavigatorData || !!u10, h10.data = u10 || a10.data?.slice(0), c10 && c10.options ? c10.update(h10, e10) : (t11.navigatorSeries = s10.initSeries(h10), s10.setSortedData(), t11.navigatorSeries.baseSeries = t11, n10.push(t11.navigatorSeries));
          }), (l10.data && !(o10 && o10.length) || d9(l10)) && (i10.hasNavigatorData = false, (l10 = ce(l10)).forEach((t11, e11) => {
            r10.name = "Navigator " + (n10.length + 1), (h10 = d8(d_.navigator.series, {
              color: s10.series[e11] && !s10.series[e11].options.isInternal && s10.series[e11].color || s10.options.colors[e11] || s10.options.colors[0]
            }, r10, t11)).data = t11.data, h10.data && (i10.hasNavigatorData = true, n10.push(s10.initSeries(h10)));
          })), t10 && this.addBaseSeriesEvents();
        }
        addBaseSeriesEvents() {
          let t10 = this, e10 = t10.baseSeries || [];
          e10[0] && e10[0].xAxis && e10[0].eventsToUnbind.push(dK(e10[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e10.forEach((i10) => {
            i10.eventsToUnbind.push(dK(i10, "show", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
            })), i10.eventsToUnbind.push(dK(i10, "hide", function() {
              this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
            })), false !== this.navigatorOptions.adaptToUpdatedData && i10.xAxis && i10.eventsToUnbind.push(dK(i10, "updatedData", this.updatedDataHandler)), i10.eventsToUnbind.push(dK(i10, "remove", function() {
              e10 && d2(e10, i10), this.navigatorSeries && t10.series && (d2(t10.series, this.navigatorSeries), d0(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
            }));
          });
        }
        getBaseSeriesMin(t10) {
          return this.baseSeries.reduce(function(t11, e10) {
            return Math.min(t11, e10.getColumn("x")[0] ?? t11);
          }, t10);
        }
        modifyNavigatorAxisExtremes() {
          let t10 = this.xAxis;
          if (void 0 !== t10.getExtremes) {
            let e10 = this.getUnionExtremes(true);
            e10 && (e10.dataMin !== t10.min || e10.dataMax !== t10.max) && (t10.min = e10.dataMin, t10.max = e10.dataMax);
          }
        }
        modifyBaseAxisExtremes() {
          let t10, e10;
          let i10 = this.chart.navigator, s10 = this.getExtremes(), o10 = s10.min, r10 = s10.max, n10 = s10.dataMin, a10 = s10.dataMax, h10 = r10 - o10, l10 = i10.stickToMin, d10 = i10.stickToMax, c10 = d7(this.ordinal?.convertOverscroll(this.options.overscroll), 0), p10 = i10.series && i10.series[0], u10 = !!this.setExtremes;
          !(this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger) && (l10 && (t10 = (e10 = n10) + h10), d10 && (t10 = a10 + c10, l10 || (e10 = Math.max(n10, t10 - h10, i10.getBaseSeriesMin(p10 && p10.xData ? p10.xData[0] : -Number.MAX_VALUE)))), u10 && (l10 || d10) && d4(e10) && (this.min = this.userMin = e10, this.max = this.userMax = t10)), i10.stickToMin = i10.stickToMax = null;
        }
        updatedDataHandler() {
          let t10 = this.chart.navigator, e10 = this.navigatorSeries, i10 = t10.reversedExtremes ? 0 === Math.round(t10.zoomedMin) : Math.round(t10.zoomedMax) >= Math.round(t10.size);
          t10.stickToMax = d7(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i10), t10.stickToMin = t10.shouldStickToMin(this, t10), e10 && !t10.hasNavigatorData && (e10.options.pointStart = this.getColumn("x")[0], e10.setData(this.options.data, false, null, false));
        }
        shouldStickToMin(t10, e10) {
          let i10 = e10.getBaseSeriesMin(t10.getColumn("x")[0]), s10 = t10.xAxis, o10 = s10.max, r10 = s10.min, n10 = s10.options.range;
          return !!(d4(o10) && d4(r10)) && (n10 && o10 - i10 > 0 ? o10 - i10 < n10 : r10 <= i10);
        }
        addChartEvents() {
          this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(dK(this.chart, "redraw", function() {
            let t10 = this.navigator, e10 = t10 && (t10.baseSeries && t10.baseSeries[0] && t10.baseSeries[0].xAxis || this.xAxis[0]);
            e10 && t10.render(e10.min, e10.max);
          }), dK(this.chart, "getMargins", function() {
            let t10 = this.navigator, e10 = t10.opposite ? "plotTop" : "marginBottom";
            this.inverted && (e10 = t10.opposite ? "marginRight" : "plotLeft"), this[e10] = (this[e10] || 0) + (t10.navigatorEnabled || !this.inverted ? t10.height + t10.scrollbarHeight : 0) + t10.navigatorOptions.margin;
          }), dK(cs, "setRange", function(t10) {
            this.chart.xAxis[0].setExtremes(t10.min, t10.max, t10.redraw, t10.animation, t10.eventArguments);
          }));
        }
        destroy() {
          this.removeEvents(), this.xAxis && (d2(this.chart.xAxis, this.xAxis), d2(this.chart.axes, this.xAxis)), this.yAxis && (d2(this.chart.yAxis, this.yAxis), d2(this.chart.axes, this.yAxis)), (this.series || []).forEach((t10) => {
            t10.destroy && t10.destroy();
          }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach((t10) => {
            this[t10] && this[t10].destroy && this[t10].destroy(), this[t10] = null;
          }), [this.handles].forEach((t10) => {
            d1(t10);
          }), this.navigatorEnabled = false;
        }
      }
      let co = {
        lang: {
          rangeSelectorZoom: "Zoom",
          rangeSelectorFrom: "",
          rangeSelectorTo: "→"
        },
        rangeSelector: {
          allButtonsEnabled: false,
          buttons: [{
            type: "month",
            count: 1,
            text: "1m",
            title: "View 1 month"
          }, {
            type: "month",
            count: 3,
            text: "3m",
            title: "View 3 months"
          }, {
            type: "month",
            count: 6,
            text: "6m",
            title: "View 6 months"
          }, {
            type: "ytd",
            text: "YTD",
            title: "View year to date"
          }, {
            type: "year",
            count: 1,
            text: "1y",
            title: "View 1 year"
          }, {
            type: "all",
            text: "All",
            title: "View all"
          }],
          buttonSpacing: 5,
          dropdown: "responsive",
          enabled: void 0,
          verticalAlign: "top",
          buttonTheme: {
            width: 28,
            height: 18,
            padding: 2,
            zIndex: 7
          },
          floating: false,
          x: 0,
          y: 0,
          height: void 0,
          inputBoxBorderColor: "none",
          inputBoxHeight: 17,
          inputBoxWidth: void 0,
          inputDateFormat: "%[ebY]",
          inputDateParser: void 0,
          inputEditDateFormat: "%Y-%m-%d",
          inputEnabled: true,
          inputPosition: {
            align: "right",
            x: 0,
            y: 0
          },
          inputSpacing: 5,
          selected: void 0,
          buttonPosition: {
            align: "left",
            x: 0,
            y: 0
          },
          inputStyle: {
            color: "#334eff",
            cursor: "pointer",
            fontSize: "0.8em"
          },
          labelStyle: {
            color: "#666666",
            fontSize: "0.8em"
          }
        }
      }, {
        defaultOptions: cr
      } = tS, {
        composed: cn
      } = O, {
        addEvent: ca,
        defined: ch,
        extend: cl,
        isNumber: cd,
        merge: cc,
        pick: cp,
        pushUnique: cu
      } = tt, cg = [];
      function cf() {
        let t10, e10;
        let i10 = this.range, s10 = i10.type, o10 = this.max, r10 = this.chart.time, n10 = function(t11, e11) {
          let i11 = r10.toParts(t11), o11 = i11.slice();
          "year" === s10 ? o11[0] += e11 : o11[1] += e11;
          let n11 = r10.makeTime.apply(r10, o11), a11 = r10.toParts(n11);
          return "month" === s10 && i11[1] === a11[1] && 1 === Math.abs(e11) && (o11[0] = i11[0], o11[1] = i11[1], o11[2] = 0), (n11 = r10.makeTime.apply(r10, o11)) - t11;
        };
        cd(i10) ? (t10 = o10 - i10, e10 = i10) : i10 && (t10 = o10 + n10(o10, -(i10.count || 1)), this.chart && this.chart.setFixedRange(o10 - t10));
        let a10 = cp(this.dataMin, Number.MIN_VALUE);
        return cd(t10) || (t10 = a10), t10 <= a10 && (t10 = a10, void 0 === e10 && (e10 = n10(t10, i10.count)), this.newMax = Math.min(t10 + e10, cp(this.dataMax, Number.MAX_VALUE))), cd(o10) ? !cd(i10) && i10 && i10._offsetMin && (t10 += i10._offsetMin) : t10 = void 0, t10;
      }
      function cm() {
        this.rangeSelector?.redrawElements();
      }
      function cx() {
        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new s(this));
      }
      function cy() {
        let t10 = this.rangeSelector;
        if (t10) {
          cd(t10.deferredYTDClick) && (t10.clickButton(t10.deferredYTDClick), delete t10.deferredYTDClick);
          let e10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === e10 ? this.extraBottomMargin = true : "top" !== e10 || (this.extraTopMargin = true));
        }
      }
      function cb() {
        let t10;
        let e10 = this.rangeSelector;
        if (!e10) return;
        let i10 = this.xAxis[0].getExtremes(), s10 = this.legend, o10 = e10 && e10.options.verticalAlign;
        cd(i10.min) && e10.render(i10.min, i10.max), s10.display && "top" === o10 && o10 === s10.options.verticalAlign && (t10 = cc(this.spacingBox), "vertical" === s10.options.layout ? t10.y = this.plotTop : t10.y += e10.getHeight(), s10.group.placed = false, s10.align(t10));
      }
      function cv() {
        for (let t10 = 0, e10 = cg.length; t10 < e10; ++t10) {
          let e11 = cg[t10];
          if (e11[0] === this) {
            e11[1].forEach((t11) => t11()), cg.splice(t10, 1);
            return;
          }
        }
      }
      function cM() {
        let t10 = this.rangeSelector;
        if (t10?.options?.enabled) {
          let e10 = t10.getHeight(), i10 = t10.options.verticalAlign;
          t10.options.floating || ("bottom" === i10 ? this.marginBottom += e10 : "middle" === i10 || (this.plotTop += e10));
        }
      }
      function ck(t10) {
        let e10 = t10.options.rangeSelector, i10 = this.extraBottomMargin, o10 = this.extraTopMargin, r10 = this.rangeSelector;
        if (e10 && e10.enabled && !ch(r10) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = r10 = new s(this)), this.extraBottomMargin = false, this.extraTopMargin = false, r10) {
          let t11 = e10 && e10.verticalAlign || r10.options && r10.options.verticalAlign;
          r10.options.floating || ("bottom" === t11 ? this.extraBottomMargin = true : "middle" === t11 || (this.extraTopMargin = true)), (this.extraBottomMargin !== i10 || this.extraTopMargin !== o10) && (this.isDirtyBox = true);
        }
      }
      let cw = {
        compose: function(t10, e10, i10) {
          if (s = i10, cu(cn, "RangeSelector")) {
            let i11 = e10.prototype;
            t10.prototype.minFromRange = cf, ca(e10, "afterGetContainer", cx), ca(e10, "beforeRender", cy), ca(e10, "destroy", cv), ca(e10, "getMargins", cM), ca(e10, "redraw", cb), ca(e10, "update", ck), ca(e10, "beforeRedraw", cm), i11.callbacks.push(cb), cl(cr, {
              rangeSelector: co.rangeSelector
            }), cl(cr.lang, co.lang);
          }
        }
      }, {
        addEvent: cS,
        correctFloat: cA,
        css: cT,
        defined: cP,
        error: cC,
        isNumber: cO,
        pick: cE,
        timeUnits: cL,
        isString: cB
      } = tt;
      !function(t10) {
        function e10(t11, i11, s11, o11, r11 = [], n11 = 0, a11) {
          let h11 = {}, l11 = this.options.tickPixelInterval, d11 = this.chart.time, c11 = [], p10, u10, g2, f2, m2, x2 = 0, y2 = [], b2 = -Number.MAX_VALUE;
          if (!this.options.ordinal && !this.options.breaks || !r11 || r11.length < 3 || void 0 === i11) return d11.getTimeTicks.apply(d11, arguments);
          let v2 = r11.length;
          for (p10 = 0; p10 < v2; p10++) {
            if (m2 = p10 && r11[p10 - 1] > s11, r11[p10] < i11 && (x2 = p10), p10 === v2 - 1 || r11[p10 + 1] - r11[p10] > 5 * n11 || m2) {
              if (r11[p10] > b2) {
                for (u10 = d11.getTimeTicks(t11, r11[x2], r11[p10], o11); u10.length && u10[0] <= b2; ) u10.shift();
                u10.length && (b2 = u10[u10.length - 1]), c11.push(y2.length), y2 = y2.concat(u10);
              }
              x2 = p10 + 1;
            }
            if (m2) break;
          }
          if (u10) {
            if (f2 = u10.info, a11 && f2.unitRange <= cL.hour) {
              for (x2 = 1, p10 = y2.length - 1; x2 < p10; x2++) d11.dateFormat("%d", y2[x2]) !== d11.dateFormat("%d", y2[x2 - 1]) && (h11[y2[x2]] = "day", g2 = true);
              g2 && (h11[y2[0]] = "day"), f2.higherRanks = h11;
            }
            f2.segmentStarts = c11, y2.info = f2;
          } else cC(12, false, this.chart);
          if (a11 && cP(l11)) {
            let t12 = y2.length, e11 = [], i12 = [], o12, r12, n12, a12, d12, c12 = t12;
            for (; c12--; ) r12 = this.translate(y2[c12]), n12 && (i12[c12] = n12 - r12), e11[c12] = n12 = r12;
            for (i12.sort((t13, e12) => t13 - e12), (a12 = i12[Math.floor(i12.length / 2)]) < 0.6 * l11 && (a12 = null), c12 = y2[t12 - 1] > s11 ? t12 - 1 : t12, n12 = void 0; c12--; ) d12 = Math.abs(n12 - (r12 = e11[c12])), n12 && d12 < 0.8 * l11 && (null === a12 || d12 < 0.8 * a12) ? (h11[y2[c12]] && !h11[y2[c12 + 1]] ? (o12 = c12 + 1, n12 = r12) : o12 = c12, y2.splice(o12, 1)) : n12 = r12;
          }
          return y2;
        }
        function i10(t11) {
          let e11 = this.ordinal.positions;
          if (!e11) return t11;
          let i11 = e11.length - 1, s11;
          return (t11 < 0 ? t11 = e11[0] : t11 > i11 ? t11 = e11[i11] : (i11 = Math.floor(t11), s11 = t11 - i11), void 0 !== s11 && void 0 !== e11[i11]) ? e11[i11] + (s11 ? s11 * (e11[i11 + 1] - e11[i11]) : 0) : t11;
        }
        function s10(t11) {
          let e11 = this.ordinal, i11 = this.old ? this.old.min : this.min, s11 = this.old ? this.old.transA : this.transA, o11 = e11.getExtendedPositions();
          if (o11?.length) {
            let r11 = cA((t11 - i11) * s11 + this.minPixelPadding), n11 = cA(e11.getIndexOfPoint(r11, o11)), a11 = cA(n11 % 1);
            if (n11 >= 0 && n11 <= o11.length - 1) {
              let t12 = o11[Math.floor(n11)], e12 = o11[Math.ceil(n11)];
              return o11[Math.floor(n11)] + a11 * (e12 - t12);
            }
          }
          return t11;
        }
        function o10(e11, i11) {
          let s11 = t10.Additions.findIndexOf(e11, i11, true);
          if (e11[s11] === i11) return s11;
          let o11 = (i11 - e11[s11]) / (e11[s11 + 1] - e11[s11]);
          return s11 + o11;
        }
        function r10() {
          this.ordinal || (this.ordinal = new t10.Additions(this));
        }
        function n10() {
          let {
            eventArgs: t11,
            options: e11
          } = this;
          if (this.isXAxis && cP(e11.overscroll) && 0 !== e11.overscroll && cO(this.max) && cO(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(false), this.max === this.dataMax && (t11?.trigger !== "pan" || this.isInternal) && t11?.trigger !== "navigator")) {
            let i11 = this.ordinal.convertOverscroll(e11.overscroll);
            this.max += i11, !this.isInternal && cP(this.userMin) && t11?.trigger !== "mousewheel" && (this.min += i11);
          }
        }
        function a10() {
          this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
        }
        function h10() {
          this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
        }
        function l10(t11) {
          let e11 = this.xAxis[0], i11 = e11.ordinal.convertOverscroll(e11.options.overscroll), s11 = t11.originalEvent.chartX, o11 = this.options.chart.panning, r11 = false;
          if (o11 && "y" !== o11.type && e11.options.ordinal && e11.series.length && (!t11.touches || t11.touches.length <= 1)) {
            let t12, o12;
            let n11 = this.mouseDownX, a11 = e11.getExtremes(), h11 = a11.dataMin, l11 = a11.dataMax, d11 = a11.min, c11 = a11.max, p10 = this.hoverPoints, u10 = e11.closestPointRange || e11.ordinal && e11.ordinal.overscrollPointsRange, g2 = Math.round((n11 - s11) / (e11.translationSlope * (e11.ordinal.slope || u10))), f2 = e11.ordinal.getExtendedPositions(), m2 = {
              ordinal: {
                positions: f2,
                extendedOrdinalPositions: f2
              }
            }, x2 = e11.index2val, y2 = e11.val2lin;
            if (d11 <= h11 && g2 < 0 || c11 + i11 >= l11 && g2 > 0) return;
            m2.ordinal.positions ? Math.abs(g2) > 1 && (p10 && p10.forEach(function(t13) {
              t13.setState();
            }), l11 > (o12 = m2.ordinal.positions)[o12.length - 1] && o12.push(l11), this.setFixedRange(c11 - d11), (t12 = e11.navigatorAxis.toFixedRange(void 0, void 0, x2.apply(m2, [y2.apply(m2, [d11, true]) + g2]), x2.apply(m2, [y2.apply(m2, [c11, true]) + g2]))).min >= Math.min(o12[0], d11) && t12.max <= Math.max(o12[o12.length - 1], c11) + i11 && e11.setExtremes(t12.min, t12.max, true, false, {
              trigger: "pan"
            }), this.mouseDownX = s11, cT(this.container, {
              cursor: "move"
            })) : r11 = true;
          } else r11 = true;
          r11 || o11 && /y/.test(o11.type) ? i11 && (e11.max = e11.dataMax + i11) : t11.preventDefault();
        }
        function d10() {
          let t11 = this.xAxis;
          t11 && t11.options.ordinal && (delete t11.ordinal.index, delete t11.ordinal.originalOrdinalRange);
        }
        function c10(t11, e11) {
          let i11;
          let s11 = this.ordinal, r11 = s11.positions, n11 = s11.slope, a11;
          if (!r11) return t11;
          let h11 = r11.length;
          if (r11[0] <= t11 && r11[h11 - 1] >= t11) i11 = o10(r11, t11);
          else {
            if (!((a11 = s11.getExtendedPositions && s11.getExtendedPositions()) && a11.length)) return t11;
            let h12 = a11.length;
            n11 || (n11 = (a11[h12 - 1] - a11[0]) / h12);
            let l11 = o10(a11, r11[0]);
            if (t11 >= a11[0] && t11 <= a11[h12 - 1]) i11 = o10(a11, t11) - l11;
            else {
              if (!e11) return t11;
              i11 = t11 < a11[0] ? -l11 - (a11[0] - t11) / n11 : (t11 - a11[h12 - 1]) / n11 + h12 - l11;
            }
          }
          return e11 ? i11 : n11 * (i11 || 0) + s11.offset;
        }
        t10.compose = function(t11, o11, p10) {
          let u10 = t11.prototype;
          return u10.ordinal2lin || (u10.getTimeTicks = e10, u10.index2val = i10, u10.lin2val = s10, u10.val2lin = c10, u10.ordinal2lin = u10.val2lin, cS(t11, "afterInit", r10), cS(t11, "foundExtremes", n10), cS(t11, "afterSetScale", a10), cS(t11, "initialAxisTranslation", h10), cS(p10, "pan", l10), cS(p10, "touchpan", l10), cS(o11, "updatedData", d10)), t11;
        }, t10.Additions = class {
          constructor(t11) {
            this.index = {}, this.axis = t11;
          }
          beforeSetTickPositions() {
            let t11 = this.axis, e11 = t11.ordinal, i11 = t11.getExtremes(), s11 = i11.min, o11 = i11.max, r11 = t11.brokenAxis?.hasBreaks, n11 = t11.options.ordinal, a11, h11, l11, d11, c11, p10, u10, g2 = [], f2 = Number.MAX_VALUE, m2 = false, x2 = false, y2 = false;
            if (n11 || r11) {
              let i12 = 0;
              if (t11.series.forEach(function(t12, e12) {
                let s12 = t12.getColumn("x", true);
                if (h11 = [], e12 > 0 && "highcharts-navigator-series" !== t12.options.id && s12.length > 1 && (x2 = i12 !== s12[1] - s12[0]), i12 = s12[1] - s12[0], t12.boosted && (y2 = t12.boosted), t12.reserveSpace() && (false !== t12.takeOrdinalPosition || r11) && (a11 = (g2 = g2.concat(s12)).length, g2.sort(function(t13, e13) {
                  return t13 - e13;
                }), f2 = Math.min(f2, cE(t12.closestPointRange, f2)), a11)) {
                  for (e12 = 0; e12 < a11 - 1; ) g2[e12] !== g2[e12 + 1] && h11.push(g2[e12 + 1]), e12++;
                  h11[0] !== g2[0] && h11.unshift(g2[0]), g2 = h11;
                }
              }), t11.ordinal.originalOrdinalRange || (t11.ordinal.originalOrdinalRange = (g2.length - 1) * f2), x2 && y2 && (g2.pop(), g2.shift()), (a11 = g2.length) > 2) {
                for (l11 = g2[1] - g2[0], u10 = a11 - 1; u10-- && !m2; ) g2[u10 + 1] - g2[u10] !== l11 && (m2 = true);
                !t11.options.keepOrdinalPadding && (g2[0] - s11 > l11 || o11 - g2[g2.length - 1] > l11) && (m2 = true);
              } else t11.options.overscroll && (2 === a11 ? f2 = g2[1] - g2[0] : 1 === a11 ? (f2 = t11.ordinal.convertOverscroll(t11.options.overscroll), g2 = [g2[0], g2[0] + f2]) : f2 = e11.overscrollPointsRange);
              m2 || t11.forceOrdinal ? (t11.options.overscroll && (e11.overscrollPointsRange = f2, g2 = g2.concat(e11.getOverscrollPositions())), e11.positions = g2, d11 = t11.ordinal2lin(Math.max(s11, g2[0]), true), c11 = Math.max(t11.ordinal2lin(Math.min(o11, g2[g2.length - 1]), true), 1), e11.slope = p10 = (o11 - s11) / (c11 - d11), e11.offset = s11 - d11 * p10) : (e11.overscrollPointsRange = cE(t11.closestPointRange, e11.overscrollPointsRange), e11.positions = t11.ordinal.slope = e11.offset = void 0);
            }
            t11.isOrdinal = n11 && m2, e11.groupIntervalFactor = null;
          }
          static findIndexOf(t11, e11, i11) {
            let s11 = 0, o11 = t11.length - 1, r11;
            for (; s11 < o11; ) t11[r11 = Math.ceil((s11 + o11) / 2)] <= e11 ? s11 = r11 : o11 = r11 - 1;
            return t11[s11] === e11 ? s11 : i11 ? s11 : -1;
          }
          getExtendedPositions(t11 = true) {
            let e11 = this, i11 = e11.axis, s11 = i11.constructor.prototype, o11 = i11.chart, r11 = i11.series.reduce((t12, e12) => {
              let i12 = e12.currentDataGrouping;
              return t12 + (i12 ? i12.count + i12.unitName : "raw");
            }, ""), n11 = t11 ? i11.ordinal.convertOverscroll(i11.options.overscroll) : 0, a11 = i11.getExtremes(), h11, l11, d11 = e11.index;
            return d11 || (d11 = e11.index = {}), !d11[r11] && ((h11 = {
              series: [],
              chart: o11,
              forceOrdinal: false,
              getExtremes: function() {
                return {
                  min: a11.dataMin,
                  max: a11.dataMax + n11
                };
              },
              applyGrouping: s11.applyGrouping,
              getGroupPixelWidth: s11.getGroupPixelWidth,
              getTimeTicks: s11.getTimeTicks,
              options: {
                ordinal: true
              },
              ordinal: {
                getGroupIntervalFactor: this.getGroupIntervalFactor
              },
              ordinal2lin: s11.ordinal2lin,
              getIndexOfPoint: s11.getIndexOfPoint,
              val2lin: s11.val2lin
            }).ordinal.axis = h11, i11.series.forEach((i12) => {
              l11 = {
                xAxis: h11,
                chart: o11,
                groupPixelWidth: i12.groupPixelWidth,
                destroyGroupedData: O.noop,
                getColumn: i12.getColumn,
                applyGrouping: i12.applyGrouping,
                getProcessedData: i12.getProcessedData,
                reserveSpace: i12.reserveSpace,
                visible: i12.visible
              };
              let s12 = i12.getColumn("x").concat(t11 ? e11.getOverscrollPositions() : []);
              l11.dataTable = new rl({
                columns: {
                  x: s12
                }
              }), l11.options = __spreadProps(__spreadValues({}, i12.options), {
                dataGrouping: i12.currentDataGrouping ? {
                  firstAnchor: i12.options.dataGrouping?.firstAnchor,
                  anchor: i12.options.dataGrouping?.anchor,
                  lastAnchor: i12.options.dataGrouping?.firstAnchor,
                  enabled: true,
                  forced: true,
                  approximation: "open",
                  units: [[i12.currentDataGrouping.unitName, [i12.currentDataGrouping.count]]]
                } : {
                  enabled: false
                }
              }), h11.series.push(l11), i12.processData.apply(l11);
            }), h11.applyGrouping({
              hasExtremesChanged: true
            }), l11?.closestPointRange !== l11?.basePointRange && l11.currentDataGrouping && (h11.forceOrdinal = true), i11.ordinal.beforeSetTickPositions.apply({
              axis: h11
            }), !i11.ordinal.originalOrdinalRange && h11.ordinal.originalOrdinalRange && (i11.ordinal.originalOrdinalRange = h11.ordinal.originalOrdinalRange), h11.ordinal.positions && (d11[r11] = h11.ordinal.positions)), d11[r11];
          }
          getGroupIntervalFactor(t11, e11, i11) {
            let s11 = i11.getColumn("x", true), o11 = s11.length, r11 = [], n11, a11, h11 = this.groupIntervalFactor;
            if (!h11) {
              for (a11 = 0; a11 < o11 - 1; a11++) r11[a11] = s11[a11 + 1] - s11[a11];
              r11.sort(function(t12, e12) {
                return t12 - e12;
              }), n11 = r11[Math.floor(o11 / 2)], t11 = Math.max(t11, s11[0]), e11 = Math.min(e11, s11[o11 - 1]), this.groupIntervalFactor = h11 = o11 * n11 / (e11 - t11);
            }
            return h11;
          }
          getIndexOfPoint(t11, e11) {
            let i11 = this.axis, s11 = i11.min, r11 = i11.minPixelPadding;
            return o10(e11, s11) + cA((t11 - r11) / (i11.translationSlope * (this.slope || i11.closestPointRange || this.overscrollPointsRange)));
          }
          getOverscrollPositions() {
            let t11 = this.axis, e11 = this.convertOverscroll(t11.options.overscroll), i11 = this.overscrollPointsRange, s11 = [], o11 = t11.dataMax;
            if (cP(i11)) for (; o11 < t11.dataMax + e11; ) s11.push(o11 += i11);
            return s11;
          }
          postProcessTickInterval(t11) {
            let e11 = this.axis, i11 = this.slope, s11 = e11.closestPointRange;
            return i11 && s11 ? e11.options.breaks ? s11 || t11 : t11 / (i11 / s11) : t11;
          }
          convertOverscroll(t11 = 0) {
            let e11 = this, i11 = e11.axis, s11 = function(t12) {
              return cE(e11.originalOrdinalRange, cP(i11.dataMax) && cP(i11.dataMin) ? i11.dataMax - i11.dataMin : 0) * t12;
            };
            if (cB(t11)) {
              let e12 = parseInt(t11, 10);
              if (/%$/.test(t11)) return s11(e12 / 100);
              if (/px/.test(t11)) {
                let t12 = Math.min(e12, 0.9 * i11.len) / i11.len;
                return s11(t12 / (1 - t12));
              }
              return 0;
            }
            return t11;
          }
        };
      }(w || (w = {}));
      let cI = w, {
        defaultOptions: cD
      } = tS, {
        addEvent: cR,
        createElement: cN,
        css: cz,
        defined: cW,
        destroyObjectProperties: cG,
        diffObjects: cH,
        discardElement: cF,
        extend: cX,
        fireEvent: cY,
        isNumber: cj,
        isString: cU,
        merge: cV,
        objectEach: c$,
        pick: c_,
        splat: cq
      } = tt;
      function cZ(t10) {
        let e10 = (e11) => RegExp(`%[[a-zA-Z]*${e11}`).test(t10);
        if (cU(t10) ? -1 !== t10.indexOf("%L") : t10.fractionalSecondDigits) return "text";
        let i10 = cU(t10) ? ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(e10) : t10.dateStyle || t10.day || t10.month || t10.year, s10 = cU(t10) ? ["H", "k", "I", "l", "M", "S"].some(e10) : t10.timeStyle || t10.hour || t10.minute || t10.second;
        return i10 && s10 ? "datetime-local" : i10 ? "date" : s10 ? "time" : "text";
      }
      class cK {
        static compose(t10, e10) {
          cw.compose(t10, e10, cK);
        }
        constructor(t10) {
          this.isDirty = false, this.buttonOptions = cK.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.maxButtonWidth = () => {
            let t11 = 0;
            return this.buttons.forEach((e10) => {
              let i10 = e10.getBBox();
              i10.width > t11 && (t11 = i10.width);
            }), t11;
          }, this.init(t10);
        }
        clickButton(t10, e10) {
          let i10 = this.chart, s10 = this.buttonOptions[t10], o10 = i10.xAxis[0], r10 = i10.scroller && i10.scroller.getUnionExtremes() || o10 || {}, n10 = s10.type, a10 = s10.dataGrouping, h10 = r10.dataMin, l10 = r10.dataMax, d10, c10 = cj(o10?.max) ? Math.round(Math.min(o10.max, l10 ?? o10.max)) : void 0, p10, u10 = s10._range, g2, f2, m2, x2 = true;
          if (null !== h10 && null !== l10) {
            if (this.setSelected(t10), a10 && (this.forcedDataGrouping = true, sU.prototype.setDataGrouping.call(o10 || {
              chart: this.chart
            }, a10, false), this.frozenStates = s10.preserveDataGrouping), "month" === n10 || "year" === n10) o10 ? (f2 = {
              range: s10,
              max: c10,
              chart: i10,
              dataMin: h10,
              dataMax: l10
            }, d10 = o10.minFromRange.call(f2), cj(f2.newMax) && (c10 = f2.newMax), x2 = false) : u10 = s10;
            else if (u10) cj(c10) && (c10 = Math.min((d10 = Math.max(c10 - u10, h10)) + u10, l10), x2 = false);
            else if ("ytd" === n10) {
              if (o10) !o10.hasData() || cj(l10) && cj(h10) || (h10 = Number.MAX_VALUE, l10 = -Number.MAX_VALUE, i10.series.forEach((t11) => {
                let e11 = t11.getColumn("x");
                e11.length && (h10 = Math.min(e11[0], h10), l10 = Math.max(e11[e11.length - 1], l10));
              }), e10 = false), cj(l10) && cj(h10) && (d10 = g2 = (m2 = this.getYTDExtremes(l10, h10)).min, c10 = m2.max);
              else {
                this.deferredYTDClick = t10;
                return;
              }
            } else "all" === n10 && o10 && (i10.navigator && i10.navigator.baseSeries[0] && (i10.navigator.baseSeries[0].xAxis.options.range = void 0), d10 = h10, c10 = l10);
            if (x2 && s10._offsetMin && cW(d10) && (d10 += s10._offsetMin), s10._offsetMax && cW(c10) && (c10 += s10._offsetMax), this.dropdown && (this.dropdown.selectedIndex = t10 + 1), o10) cj(d10) && cj(c10) && (o10.setExtremes(d10, c10, c_(e10, true), void 0, {
              trigger: "rangeSelectorButton",
              rangeSelectorButton: s10
            }), i10.setFixedRange(s10._range));
            else {
              p10 = cq(i10.options.xAxis || {})[0];
              let t11 = cR(i10, "afterCreateAxes", function() {
                let t12 = i10.xAxis[0];
                t12.range = t12.options.range = u10, t12.min = t12.options.min = g2;
              });
              cR(i10, "load", function() {
                let e11 = i10.xAxis[0];
                i10.setFixedRange(s10._range), e11.options.range = p10.range, e11.options.min = p10.min, t11();
              });
            }
            cY(this, "afterBtnClick");
          }
        }
        setSelected(t10) {
          this.selected = this.options.selected = t10;
        }
        init(t10) {
          let e10 = this, i10 = t10.options.rangeSelector, s10 = i10.buttons, o10 = i10.selected, r10 = function() {
            let t11 = e10.minInput, i11 = e10.maxInput;
            t11 && t11.blur && cY(t11, "blur"), i11 && i11.blur && cY(i11, "blur");
          };
          e10.chart = t10, e10.options = i10, e10.buttons = [], e10.buttonOptions = s10, this.eventsToUnbind = [], this.eventsToUnbind.push(cR(t10.container, "mousedown", r10)), this.eventsToUnbind.push(cR(t10, "resize", r10)), s10.forEach(e10.computeButtonRange), void 0 !== o10 && s10[o10] && this.clickButton(o10, false), this.eventsToUnbind.push(cR(t10, "load", function() {
            t10.xAxis && t10.xAxis[0] && cR(t10.xAxis[0], "setExtremes", function(i11) {
              cj(this.max) && cj(this.min) && this.max - this.min !== t10.fixedRange && "rangeSelectorButton" !== i11.trigger && "updatedData" !== i11.trigger && e10.forcedDataGrouping && !e10.frozenStates && this.setDataGrouping(false, false);
            });
          })), this.createElements();
        }
        updateButtonStates() {
          let t10 = this, e10 = this.chart, i10 = this.dropdown, s10 = this.dropdownLabel, o10 = e10.xAxis[0], r10 = Math.round(o10.max - o10.min), n10 = !o10.hasVisibleSeries, a10 = 24 * 36e5, h10 = e10.scroller && e10.scroller.getUnionExtremes() || o10, l10 = h10.dataMin, d10 = h10.dataMax, c10 = t10.getYTDExtremes(d10, l10), p10 = c10.min, u10 = c10.max, g2 = t10.selected, f2 = t10.options.allButtonsEnabled, m2 = Array(t10.buttonOptions.length).fill(0), x2 = cj(g2), y2 = t10.buttons, b2 = false, v2 = null;
          t10.buttonOptions.forEach((e11, i11) => {
            let s11 = e11._range, h11 = e11.type, c11 = e11.count || 1, y3 = e11._offsetMax - e11._offsetMin, M2 = i11 === g2, k2 = s11 > d10 - l10, w2 = s11 < o10.minRange, S2 = false, A2 = s11 === r10;
            if (M2 && k2 && (b2 = true), o10.isOrdinal && o10.ordinal?.positions && s11 && r10 < s11) {
              let t11 = o10.ordinal.positions, e12 = cI.Additions.findIndexOf(t11, o10.min, true), i12 = Math.min(cI.Additions.findIndexOf(t11, o10.max, true) + 1, t11.length - 1);
              t11[i12] - t11[e12] > s11 && (A2 = true);
            } else ("month" === h11 || "year" === h11) && r10 + 36e5 >= {
              month: 28,
              year: 365
            }[h11] * a10 * c11 - y3 && r10 - 36e5 <= {
              month: 31,
              year: 366
            }[h11] * a10 * c11 + y3 ? A2 = true : "ytd" === h11 ? (A2 = u10 - p10 + y3 === r10, S2 = !M2) : "all" === h11 && (A2 = o10.max - o10.min >= d10 - l10);
            let T2 = !f2 && !(b2 && "all" === h11) && (k2 || w2 || n10), P2 = b2 && "all" === h11 || !S2 && A2 || M2 && t10.frozenStates;
            T2 ? m2[i11] = 3 : P2 && (!x2 || i11 === g2) && (v2 = i11);
          }), null !== v2 ? (m2[v2] = 2, t10.setSelected(v2), this.dropdown && (this.dropdown.selectedIndex = v2 + 1)) : (t10.setSelected(), this.dropdown && (this.dropdown.selectedIndex = -1), s10 && (s10.setState(0), s10.attr({
            text: (cD.lang.rangeSelectorZoom || "") + " ▾"
          })));
          for (let e11 = 0; e11 < m2.length; e11++) {
            let o11 = m2[e11], r11 = y2[e11];
            if (r11.state !== o11 && (r11.setState(o11), i10)) {
              i10.options[e11 + 1].disabled = 3 === o11, 2 === o11 && (s10 && (s10.setState(2), s10.attr({
                text: t10.buttonOptions[e11].text + " ▾"
              })), i10.selectedIndex = e11 + 1);
              let r12 = s10.getBBox();
              cz(i10, {
                width: `${r12.width}px`,
                height: `${r12.height}px`
              });
            }
          }
        }
        computeButtonRange(t10) {
          let e10 = t10.type, i10 = t10.count || 1, s10 = {
            millisecond: 1,
            second: 1e3,
            minute: 6e4,
            hour: 36e5,
            day: 864e5,
            week: 6048e5
          };
          s10[e10] ? t10._range = s10[e10] * i10 : ("month" === e10 || "year" === e10) && (t10._range = 24 * {
            month: 30,
            year: 365
          }[e10] * 36e5 * i10), t10._offsetMin = c_(t10.offsetMin, 0), t10._offsetMax = c_(t10.offsetMax, 0), t10._range += t10._offsetMax - t10._offsetMin;
        }
        getInputValue(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput, i10 = this.chart.options.rangeSelector, s10 = this.chart.time;
          return e10 ? ("text" === e10.type && i10.inputDateParser || this.defaultInputDateParser)(e10.value, "UTC" === s10.timezone, s10) : 0;
        }
        setInputValue(t10, e10) {
          let i10 = this.options, s10 = this.chart.time, o10 = "min" === t10 ? this.minInput : this.maxInput, r10 = "min" === t10 ? this.minDateBox : this.maxDateBox;
          if (o10) {
            o10.setAttribute("type", cZ(i10.inputDateFormat || "%e %b %Y"));
            let t11 = o10.getAttribute("data-hc-time"), n10 = cW(t11) ? Number(t11) : void 0;
            if (cW(e10)) {
              let t12 = n10;
              cW(t12) && o10.setAttribute("data-hc-time-previous", t12), o10.setAttribute("data-hc-time", e10), n10 = e10;
            }
            o10.value = s10.dateFormat(this.inputTypeFormats[o10.type] || i10.inputEditDateFormat, n10), r10 && r10.attr({
              text: s10.dateFormat(i10.inputDateFormat, n10)
            });
          }
        }
        setInputExtremes(t10, e10, i10) {
          let s10 = "min" === t10 ? this.minInput : this.maxInput;
          if (s10) {
            let t11 = this.inputTypeFormats[s10.type], o10 = this.chart.time;
            if (t11) {
              let r10 = o10.dateFormat(t11, e10);
              s10.min !== r10 && (s10.min = r10);
              let n10 = o10.dateFormat(t11, i10);
              s10.max !== n10 && (s10.max = n10);
            }
          }
        }
        showInput(t10) {
          let e10 = "min" === t10 ? this.minDateBox : this.maxDateBox, i10 = "min" === t10 ? this.minInput : this.maxInput;
          if (i10 && e10 && this.inputGroup) {
            let t11 = "text" === i10.type, {
              translateX: s10 = 0,
              translateY: o10 = 0
            } = this.inputGroup, {
              x: r10 = 0,
              width: n10 = 0,
              height: a10 = 0
            } = e10, {
              inputBoxWidth: h10
            } = this.options;
            cz(i10, {
              width: t11 ? n10 + (h10 ? -2 : 20) + "px" : "auto",
              height: a10 - 2 + "px",
              border: "2px solid silver"
            }), t11 && h10 ? cz(i10, {
              left: s10 + r10 + "px",
              top: o10 + "px"
            }) : cz(i10, {
              left: Math.min(Math.round(r10 + s10 - (i10.offsetWidth - n10) / 2), this.chart.chartWidth - i10.offsetWidth) + "px",
              top: o10 - (i10.offsetHeight - a10) / 2 + "px"
            });
          }
        }
        hideInput(t10) {
          let e10 = "min" === t10 ? this.minInput : this.maxInput;
          e10 && cz(e10, {
            top: "-9999em",
            border: 0,
            width: "1px",
            height: "1px"
          });
        }
        defaultInputDateParser(t10, e10, i10) {
          return i10?.parse(t10) || 0;
        }
        drawInput(t10) {
          let {
            chart: e10,
            div: i10,
            inputGroup: s10
          } = this, o10 = this, r10 = e10.renderer.style || {}, n10 = e10.renderer, a10 = e10.options.rangeSelector, h10 = cD.lang, l10 = "min" === t10;
          function d10(t11) {
            let {
              maxInput: i11,
              minInput: s11
            } = o10, r11 = e10.xAxis[0], n11 = e10.scroller?.getUnionExtremes() || r11, a11 = n11.dataMin, h11 = n11.dataMax, d11 = e10.xAxis[0].getExtremes()[t11], c11 = o10.getInputValue(t11);
            cj(c11) && c11 !== d11 && (l10 && i11 && cj(a11) ? c11 > Number(i11.getAttribute("data-hc-time")) ? c11 = void 0 : c11 < a11 && (c11 = a11) : s11 && cj(h11) && (c11 < Number(s11.getAttribute("data-hc-time")) ? c11 = void 0 : c11 > h11 && (c11 = h11)), void 0 !== c11 && r11.setExtremes(l10 ? c11 : r11.min, l10 ? r11.max : c11, void 0, void 0, {
              trigger: "rangeSelectorInput"
            }));
          }
          let c10 = h10[l10 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "", p10 = n10.label(c10, 0).addClass("highcharts-range-label").attr({
            padding: c10 ? 2 : 0,
            height: c10 ? a10.inputBoxHeight : 0
          }).add(s10), u10 = n10.label("", 0).addClass("highcharts-range-input").attr({
            padding: 2,
            width: a10.inputBoxWidth,
            height: a10.inputBoxHeight,
            "text-align": "center"
          }).on("click", function() {
            o10.showInput(t10), o10[t10 + "Input"].focus();
          });
          e10.styledMode || u10.attr({
            stroke: a10.inputBoxBorderColor,
            "stroke-width": 1
          }), u10.add(s10);
          let g2 = cN("input", {
            name: t10,
            className: "highcharts-range-selector"
          }, void 0, i10);
          g2.setAttribute("type", cZ(a10.inputDateFormat || "%e %b %Y")), e10.styledMode || (p10.css(cV(r10, a10.labelStyle)), u10.css(cV({
            color: "#333333"
          }, r10, a10.inputStyle)), cz(g2, cX({
            position: "absolute",
            border: 0,
            boxShadow: "0 0 15px rgba(0,0,0,0.3)",
            width: "1px",
            height: "1px",
            padding: 0,
            textAlign: "center",
            fontSize: r10.fontSize,
            fontFamily: r10.fontFamily,
            top: "-9999em"
          }, a10.inputStyle))), g2.onfocus = () => {
            o10.showInput(t10);
          }, g2.onblur = () => {
            g2 === O.doc.activeElement && d10(t10), o10.hideInput(t10), o10.setInputValue(t10), g2.blur();
          };
          let f2 = false;
          return g2.onchange = () => {
            f2 || (d10(t10), o10.hideInput(t10), g2.blur());
          }, g2.onkeypress = (e11) => {
            13 === e11.keyCode && d10(t10);
          }, g2.onkeydown = (e11) => {
            f2 = true, ("ArrowUp" === e11.key || "ArrowDown" === e11.key || "Tab" === e11.key) && d10(t10);
          }, g2.onkeyup = () => {
            f2 = false;
          }, {
            dateBox: u10,
            input: g2,
            label: p10
          };
        }
        getPosition() {
          let t10 = this.chart, e10 = t10.options.rangeSelector, i10 = "top" === e10.verticalAlign ? t10.plotTop - t10.axisOffset[0] : 0;
          return {
            buttonTop: i10 + e10.buttonPosition.y,
            inputTop: i10 + e10.inputPosition.y - 10
          };
        }
        getYTDExtremes(t10, e10) {
          let i10 = this.chart.time, s10 = i10.toParts(t10)[0];
          return {
            max: t10,
            min: Math.max(e10, i10.makeTime(s10, 0))
          };
        }
        createElements() {
          let t10 = this.chart, e10 = t10.renderer, i10 = t10.container, s10 = t10.options, o10 = s10.rangeSelector, r10 = o10.inputEnabled, n10 = c_(s10.chart.style?.zIndex, 0) + 1;
          false !== o10.enabled && (this.group = e10.g("range-selector-group").attr({
            zIndex: 7
          }).add(), this.div = cN("div", void 0, {
            position: "relative",
            height: 0,
            zIndex: n10
          }), this.buttonOptions.length && this.renderButtons(), i10.parentNode && i10.parentNode.insertBefore(this.div, i10), r10 && this.createInputs());
        }
        createInputs() {
          this.inputGroup = this.chart.renderer.g("input-group").add(this.group);
          let t10 = this.drawInput("min");
          this.minDateBox = t10.dateBox, this.minLabel = t10.label, this.minInput = t10.input;
          let e10 = this.drawInput("max");
          this.maxDateBox = e10.dateBox, this.maxLabel = e10.label, this.maxInput = e10.input;
        }
        render(t10, e10) {
          if (false === this.options.enabled) return;
          let i10 = this.chart, s10 = i10.options.rangeSelector;
          if (s10.inputEnabled) {
            this.inputGroup || this.createInputs(), this.setInputValue("min", t10), this.setInputValue("max", e10), this.chart.styledMode || (this.maxLabel?.css(s10.labelStyle), this.minLabel?.css(s10.labelStyle));
            let o10 = i10.scroller && i10.scroller.getUnionExtremes() || i10.xAxis[0] || {};
            if (cW(o10.dataMin) && cW(o10.dataMax)) {
              let t11 = i10.xAxis[0].minRange || 0;
              this.setInputExtremes("min", o10.dataMin, Math.min(o10.dataMax, this.getInputValue("max")) - t11), this.setInputExtremes("max", Math.max(o10.dataMin, this.getInputValue("min")) + t11, o10.dataMax);
            }
            if (this.inputGroup) {
              let t11 = 0;
              [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach((e11) => {
                if (e11) {
                  let {
                    width: i11
                  } = e11.getBBox();
                  i11 && (e11.attr({
                    x: t11
                  }), t11 += i11 + s10.inputSpacing);
                }
              });
            }
          } else this.inputGroup && (this.inputGroup.destroy(), delete this.inputGroup);
          !this.chart.styledMode && this.zoomText && this.zoomText.css(s10.labelStyle), this.alignElements(), this.updateButtonStates();
        }
        renderButtons() {
          var t10;
          let {
            chart: e10,
            options: i10
          } = this, s10 = cD.lang, o10 = e10.renderer, r10 = cV(i10.buttonTheme), n10 = r10 && r10.states;
          delete r10.width, delete r10.states, this.buttonGroup = o10.g("range-selector-buttons").add(this.group);
          let a10 = this.dropdown = cN("select", void 0, {
            position: "absolute",
            padding: 0,
            border: 0,
            cursor: "pointer",
            opacity: 1e-4
          }, this.div), h10 = e10.userOptions.rangeSelector?.buttonTheme;
          this.dropdownLabel = o10.button("", 0, 0, () => {
          }, cV(r10, {
            "stroke-width": c_(r10["stroke-width"], 0),
            width: "auto",
            paddingLeft: c_(i10.buttonTheme.paddingLeft, h10?.padding, 8),
            paddingRight: c_(i10.buttonTheme.paddingRight, h10?.padding, 8)
          }), n10 && n10.hover, n10 && n10.select, n10 && n10.disabled).hide().add(this.group), cR(a10, "touchstart", () => {
            a10.style.fontSize = "16px";
          });
          let l10 = O.isMS ? "mouseover" : "mouseenter", d10 = O.isMS ? "mouseout" : "mouseleave";
          cR(a10, l10, () => {
            cY(this.dropdownLabel.element, l10);
          }), cR(a10, d10, () => {
            cY(this.dropdownLabel.element, d10);
          }), cR(a10, "change", () => {
            cY(this.buttons[a10.selectedIndex - 1].element, "click");
          }), this.zoomText = o10.label(s10.rangeSelectorZoom || "", 0).attr({
            padding: i10.buttonTheme.padding,
            height: i10.buttonTheme.height,
            paddingLeft: 0,
            paddingRight: 0
          }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(i10.labelStyle), (t10 = i10.buttonTheme)["stroke-width"] ?? (t10["stroke-width"] = 0)), cN("option", {
            textContent: this.zoomText.textStr,
            disabled: true
          }, void 0, a10), this.createButtons();
        }
        createButtons() {
          let {
            options: t10
          } = this, e10 = cV(t10.buttonTheme), i10 = e10 && e10.states, s10 = e10.width || 28;
          delete e10.width, delete e10.states, this.buttonOptions.forEach((t11, e11) => {
            this.createButton(t11, e11, s10, i10);
          });
        }
        createButton(t10, e10, i10, s10) {
          let {
            dropdown: o10,
            buttons: r10,
            chart: n10,
            options: a10
          } = this, h10 = n10.renderer, l10 = cV(a10.buttonTheme);
          o10?.add(cN("option", {
            textContent: t10.title || t10.text
          }), e10 + 2), r10[e10] = h10.button(t10.text, 0, 0, (i11) => {
            let s11;
            let o11 = t10.events && t10.events.click;
            o11 && (s11 = o11.call(t10, i11)), false !== s11 && this.clickButton(e10), this.isActive = true;
          }, l10, s10 && s10.hover, s10 && s10.select, s10 && s10.disabled).attr({
            "text-align": "center",
            width: i10
          }).add(this.buttonGroup), t10.title && r10[e10].attr("title", t10.title);
        }
        alignElements() {
          let {
            buttonGroup: t10,
            buttons: e10,
            chart: i10,
            group: s10,
            inputGroup: o10,
            options: r10,
            zoomText: n10
          } = this, a10 = i10.options, h10 = a10.exporting && false !== a10.exporting.enabled && a10.navigation && a10.navigation.buttonOptions, {
            buttonPosition: l10,
            inputPosition: d10,
            verticalAlign: c10
          } = r10, p10 = (t11, e11, s11) => h10 && this.titleCollision(i10) && "top" === c10 && s11 && e11.y - t11.getBBox().height - 12 < (h10.y || 0) + (h10.height || 0) + i10.spacing[0] ? -40 : 0, u10 = i10.plotLeft;
          if (s10 && l10 && d10) {
            let a11 = l10.x - i10.spacing[3];
            if (t10) {
              if (this.positionButtons(), !this.initialButtonGroupWidth) {
                let t11 = 0;
                n10 && (t11 += n10.getBBox().width + 5), e10.forEach((i11, s11) => {
                  t11 += i11.width || 0, s11 !== e10.length - 1 && (t11 += r10.buttonSpacing);
                }), this.initialButtonGroupWidth = t11;
              }
              u10 -= i10.spacing[3];
              let o11 = p10(t10, l10, "right" === l10.align || "right" === d10.align);
              this.alignButtonGroup(o11), this.buttonGroup?.translateY && this.dropdownLabel.attr({
                y: this.buttonGroup.translateY
              }), s10.placed = t10.placed = i10.hasLoaded;
            }
            let h11 = 0;
            r10.inputEnabled && o10 && (h11 = p10(o10, d10, "right" === l10.align || "right" === d10.align), "left" === d10.align ? a11 = u10 : "right" === d10.align && (a11 = -Math.max(i10.axisOffset[1], -h11)), o10.align({
              y: d10.y,
              width: o10.getBBox().width,
              align: d10.align,
              x: d10.x + a11 - 2
            }, true, i10.spacingBox), o10.placed = i10.hasLoaded), this.handleCollision(h11), s10.align({
              verticalAlign: c10
            }, true, i10.spacingBox);
            let g2 = s10.alignAttr.translateY, f2 = s10.getBBox().height + 20, m2 = 0;
            if ("bottom" === c10) {
              let t11 = i10.legend && i10.legend.options;
              m2 = g2 - (f2 = f2 + (t11 && "bottom" === t11.verticalAlign && t11.enabled && !t11.floating ? i10.legend.legendHeight + c_(t11.margin, 10) : 0) - 20) - (r10.floating ? 0 : r10.y) - (i10.titleOffset ? i10.titleOffset[2] : 0) - 10;
            }
            "top" === c10 ? (r10.floating && (m2 = 0), i10.titleOffset && i10.titleOffset[0] && (m2 = i10.titleOffset[0]), m2 += i10.margin[0] - i10.spacing[0] || 0) : "middle" === c10 && (d10.y === l10.y ? m2 = g2 : (d10.y || l10.y) && (d10.y < 0 || l10.y < 0 ? m2 -= Math.min(d10.y, l10.y) : m2 = g2 - f2)), s10.translate(r10.x, r10.y + Math.floor(m2));
            let {
              minInput: x2,
              maxInput: y2,
              dropdown: b2
            } = this;
            r10.inputEnabled && x2 && y2 && (x2.style.marginTop = s10.translateY + "px", y2.style.marginTop = s10.translateY + "px"), b2 && (b2.style.marginTop = s10.translateY + "px");
          }
        }
        redrawElements() {
          let t10 = this.chart, {
            inputBoxHeight: e10,
            inputBoxBorderColor: i10
          } = this.options;
          if (this.maxDateBox?.attr({
            height: e10
          }), this.minDateBox?.attr({
            height: e10
          }), t10.styledMode || (this.maxDateBox?.attr({
            stroke: i10
          }), this.minDateBox?.attr({
            stroke: i10
          })), this.isDirty) {
            this.isDirty = false, this.isCollapsed = void 0;
            let t11 = this.options.buttons ?? [], e11 = Math.min(t11.length, this.buttonOptions.length), {
              dropdown: i11,
              options: s10
            } = this, o10 = cV(s10.buttonTheme), r10 = o10 && o10.states, n10 = o10.width || 28;
            if (t11.length < this.buttonOptions.length) for (let e12 = this.buttonOptions.length - 1; e12 >= t11.length; e12--) {
              let t12 = this.buttons.pop();
              t12?.destroy(), this.dropdown?.options.remove(e12 + 1);
            }
            for (let s11 = e11 - 1; s11 >= 0; s11--) if (0 !== Object.keys(cH(t11[s11], this.buttonOptions[s11])).length) {
              let e12 = t11[s11];
              this.buttons[s11].destroy(), i11?.options.remove(s11 + 1), this.createButton(e12, s11, n10, r10), this.computeButtonRange(e12);
            }
            if (t11.length > this.buttonOptions.length) for (let e12 = this.buttonOptions.length; e12 < t11.length; e12++) this.createButton(t11[e12], e12, n10, r10), this.computeButtonRange(t11[e12]);
            this.buttonOptions = this.options.buttons ?? [], cW(this.options.selected) && this.buttons.length && this.clickButton(this.options.selected, false);
          }
        }
        alignButtonGroup(t10, e10) {
          let {
            chart: i10,
            options: s10,
            buttonGroup: o10,
            dropdown: r10,
            dropdownLabel: n10
          } = this, {
            buttonPosition: a10
          } = s10, h10 = i10.plotLeft - i10.spacing[3], l10 = a10.x - i10.spacing[3], d10 = i10.plotLeft;
          "right" === a10.align ? (l10 += t10 - h10, this.hasVisibleDropdown && (d10 = i10.chartWidth + t10 - this.maxButtonWidth() - 20)) : "center" === a10.align && (l10 -= h10 / 2, this.hasVisibleDropdown && (d10 = i10.chartWidth / 2 - this.maxButtonWidth())), r10 && cz(r10, {
            left: d10 + "px",
            top: o10?.translateY + "px"
          }), n10?.attr({
            x: d10
          }), o10 && o10.align({
            y: a10.y,
            width: c_(e10, this.initialButtonGroupWidth),
            align: a10.align,
            x: l10
          }, true, i10.spacingBox);
        }
        positionButtons() {
          let {
            buttons: t10,
            chart: e10,
            options: i10,
            zoomText: s10
          } = this, o10 = e10.hasLoaded ? "animate" : "attr", {
            buttonPosition: r10
          } = i10, n10 = e10.plotLeft, a10 = n10;
          s10 && "hidden" !== s10.visibility && (s10[o10]({
            x: c_(n10 + r10.x, n10)
          }), a10 += r10.x + s10.getBBox().width + 5);
          for (let e11 = 0, s11 = this.buttonOptions.length; e11 < s11; ++e11) "hidden" !== t10[e11].visibility ? (t10[e11][o10]({
            x: a10
          }), a10 += (t10[e11].width || 0) + i10.buttonSpacing) : t10[e11][o10]({
            x: n10
          });
        }
        handleCollision(t10) {
          let {
            chart: e10,
            buttonGroup: i10,
            inputGroup: s10,
            initialButtonGroupWidth: o10
          } = this, {
            buttonPosition: r10,
            dropdown: n10,
            inputPosition: a10
          } = this.options, h10 = () => {
            s10 && i10 && s10.attr({
              translateX: s10.alignAttr.translateX + (e10.axisOffset[1] >= -t10 ? 0 : -t10),
              translateY: s10.alignAttr.translateY + i10.getBBox().height + 10
            });
          };
          s10 && i10 ? a10.align === r10.align ? (h10(), o10 > e10.plotWidth + t10 - 20 ? this.collapseButtons() : this.expandButtons()) : o10 - t10 + s10.getBBox().width > e10.plotWidth ? "responsive" === n10 ? this.collapseButtons() : h10() : this.expandButtons() : i10 && "responsive" === n10 && (o10 > e10.plotWidth ? this.collapseButtons() : this.expandButtons()), i10 && ("always" === n10 && this.collapseButtons(), "never" === n10 && this.expandButtons()), this.alignButtonGroup(t10);
        }
        collapseButtons() {
          let {
            buttons: t10,
            zoomText: e10
          } = this;
          true !== this.isCollapsed && (this.isCollapsed = true, e10.hide(), t10.forEach((t11) => void t11.hide()), this.showDropdown());
        }
        expandButtons() {
          let {
            buttons: t10,
            zoomText: e10
          } = this;
          false !== this.isCollapsed && (this.isCollapsed = false, this.hideDropdown(), e10.show(), t10.forEach((t11) => void t11.show()), this.positionButtons());
        }
        showDropdown() {
          let {
            buttonGroup: t10,
            dropdownLabel: e10,
            dropdown: i10
          } = this;
          t10 && i10 && (e10.show(), cz(i10, {
            visibility: "inherit"
          }), this.hasVisibleDropdown = true);
        }
        hideDropdown() {
          let {
            dropdown: t10
          } = this;
          t10 && (this.dropdownLabel.hide(), cz(t10, {
            visibility: "hidden",
            width: "1px",
            height: "1px"
          }), this.hasVisibleDropdown = false);
        }
        getHeight() {
          let t10 = this.options, e10 = this.group, i10 = t10.inputPosition, s10 = t10.buttonPosition, o10 = t10.y, r10 = s10.y, n10 = i10.y, a10 = 0;
          if (t10.height) return t10.height;
          this.alignElements(), a10 = e10 ? e10.getBBox(true).height + 13 + o10 : 0;
          let h10 = Math.min(n10, r10);
          return (n10 < 0 && r10 < 0 || n10 > 0 && r10 > 0) && (a10 += Math.abs(h10)), a10;
        }
        titleCollision(t10) {
          return !(t10.options.title.text || t10.options.subtitle.text);
        }
        update(t10, e10 = true) {
          let i10 = this.chart;
          if (cV(true, this.options, t10), this.options.selected && this.options.selected >= this.options.buttons.length && (this.options.selected = void 0, i10.options.rangeSelector.selected = void 0), cW(t10.enabled)) return this.destroy(), this.init(i10);
          this.isDirty = !!t10.buttons, e10 && this.render();
        }
        destroy() {
          let t10 = this, e10 = t10.minInput, i10 = t10.maxInput;
          t10.eventsToUnbind && (t10.eventsToUnbind.forEach((t11) => t11()), t10.eventsToUnbind = void 0), cG(t10.buttons), e10 && (e10.onfocus = e10.onblur = e10.onchange = null), i10 && (i10.onfocus = i10.onblur = i10.onchange = null), c$(t10, function(e11, i11) {
            e11 && "chart" !== i11 && (e11 instanceof eJ ? e11.destroy() : e11 instanceof window.HTMLElement && cF(e11), delete t10[i11]), e11 !== cK.prototype[i11] && (t10[i11] = null);
          }, this), this.buttons = [];
        }
      }
      cX(cK.prototype, {
        inputTypeFormats: {
          "datetime-local": "%Y-%m-%dT%H:%M:%S",
          date: "%Y-%m-%d",
          time: "%H:%M:%S"
        }
      });
      let cJ = {
        applyRadius: function(t10, e10) {
          let i10 = [];
          for (let s10 = 0; s10 < t10.length; s10++) {
            let o10 = t10[s10][1], r10 = t10[s10][2];
            if ("number" == typeof o10 && "number" == typeof r10) {
              if (0 === s10) i10.push(["M", o10, r10]);
              else if (s10 === t10.length - 1) i10.push(["L", o10, r10]);
              else if (e10) {
                let n10 = t10[s10 - 1], a10 = t10[s10 + 1];
                if (n10 && a10) {
                  let t11 = n10[1], s11 = n10[2], h10 = a10[1], l10 = a10[2];
                  if ("number" == typeof t11 && "number" == typeof h10 && "number" == typeof s11 && "number" == typeof l10 && t11 !== h10 && s11 !== l10) {
                    let n11 = t11 < h10 ? 1 : -1, a11 = s11 < l10 ? 1 : -1;
                    i10.push(["L", o10 - n11 * Math.min(Math.abs(o10 - t11), e10), r10 - a11 * Math.min(Math.abs(r10 - s11), e10)], ["C", o10, r10, o10, r10, o10 + n11 * Math.min(Math.abs(o10 - h10), e10), r10 + a11 * Math.min(Math.abs(r10 - l10), e10)]);
                  }
                }
              } else i10.push(["L", o10, r10]);
            }
          }
          return i10;
        }
      }, {
        pick: cQ
      } = tt, {
        min: c0,
        max: c1,
        abs: c2
      } = Math;
      function c3(t10, e10, i10) {
        let s10 = e10 - 1e-7, o10 = i10 || 0, r10 = t10.length - 1, n10, a10;
        for (; o10 <= r10; ) if ((a10 = s10 - t10[n10 = r10 + o10 >> 1].xMin) > 0) o10 = n10 + 1;
        else {
          if (!(a10 < 0)) return n10;
          r10 = n10 - 1;
        }
        return o10 > 0 ? o10 - 1 : 0;
      }
      function c5(t10, e10) {
        let i10 = c3(t10, e10.x + 1) + 1;
        for (; i10--; ) {
          var s10;
          if (t10[i10].xMax >= e10.x && (s10 = t10[i10], e10.x <= s10.xMax && e10.x >= s10.xMin && e10.y <= s10.yMax && e10.y >= s10.yMin)) return i10;
        }
        return -1;
      }
      function c6(t10) {
        let e10 = [];
        if (t10.length) {
          e10.push(["M", t10[0].start.x, t10[0].start.y]);
          for (let i10 = 0; i10 < t10.length; ++i10) e10.push(["L", t10[i10].end.x, t10[i10].end.y]);
        }
        return e10;
      }
      function c9(t10, e10) {
        t10.yMin = c1(t10.yMin, e10.yMin), t10.yMax = c0(t10.yMax, e10.yMax), t10.xMin = c1(t10.xMin, e10.xMin), t10.xMax = c0(t10.xMax, e10.xMax);
      }
      let c4 = function(t10, e10, i10) {
        let s10 = [], o10 = i10.chartObstacles, r10 = c5(o10, t10), n10 = c5(o10, e10), a10, h10 = cQ(i10.startDirectionX, c2(e10.x - t10.x) > c2(e10.y - t10.y)) ? "x" : "y", l10, d10, c10, p10;
        function u10(t11, e11, i11, s11, o11) {
          let r11 = {
            x: t11.x,
            y: t11.y
          };
          return r11[e11] = i11[s11 || e11] + (o11 || 0), r11;
        }
        function g2(t11, e11, i11) {
          let s11 = c2(e11[i11] - t11[i11 + "Min"]) > c2(e11[i11] - t11[i11 + "Max"]);
          return u10(e11, i11, t11, i11 + (s11 ? "Max" : "Min"), s11 ? 1 : -1);
        }
        n10 > -1 ? (a10 = {
          start: d10 = g2(o10[n10], e10, h10),
          end: e10
        }, p10 = d10) : p10 = e10, r10 > -1 && (d10 = g2(l10 = o10[r10], t10, h10), s10.push({
          start: t10,
          end: d10
        }), d10[h10] >= t10[h10] == d10[h10] >= p10[h10] && (c10 = t10[h10 = "y" === h10 ? "x" : "y"] < e10[h10], s10.push({
          start: d10,
          end: u10(d10, h10, l10, h10 + (c10 ? "Max" : "Min"), c10 ? 1 : -1)
        }), h10 = "y" === h10 ? "x" : "y"));
        let f2 = s10.length ? s10[s10.length - 1].end : t10;
        d10 = u10(f2, h10, p10), s10.push({
          start: f2,
          end: d10
        });
        let m2 = u10(d10, h10 = "y" === h10 ? "x" : "y", p10);
        return s10.push({
          start: d10,
          end: m2
        }), s10.push(a10), {
          path: cJ.applyRadius(c6(s10), i10.radius),
          obstacles: s10
        };
      };
      function c8(t10, e10, i10) {
        let s10 = cQ(i10.startDirectionX, c2(e10.x - t10.x) > c2(e10.y - t10.y)), o10 = s10 ? "x" : "y", r10 = [], n10 = i10.obstacleMetrics, a10 = c0(t10.x, e10.x) - n10.maxWidth - 10, h10 = c1(t10.x, e10.x) + n10.maxWidth + 10, l10 = c0(t10.y, e10.y) - n10.maxHeight - 10, d10 = c1(t10.y, e10.y) + n10.maxHeight + 10, c10, p10, u10, g2 = false, f2 = i10.chartObstacles, m2 = c3(f2, h10), x2 = c3(f2, a10);
        function y2(t11, e11, i11) {
          let s11, o11, r11, n11;
          let a11 = t11.x < e11.x ? 1 : -1;
          t11.x < e11.x ? (s11 = t11, o11 = e11) : (s11 = e11, o11 = t11), t11.y < e11.y ? (n11 = t11, r11 = e11) : (n11 = e11, r11 = t11);
          let h11 = a11 < 0 ? c0(c3(f2, o11.x), f2.length - 1) : 0;
          for (; f2[h11] && (a11 > 0 && f2[h11].xMin <= o11.x || a11 < 0 && f2[h11].xMax >= s11.x); ) {
            if (f2[h11].xMin <= o11.x && f2[h11].xMax >= s11.x && f2[h11].yMin <= r11.y && f2[h11].yMax >= n11.y) {
              if (i11) return {
                y: t11.y,
                x: t11.x < e11.x ? f2[h11].xMin - 1 : f2[h11].xMax + 1,
                obstacle: f2[h11]
              };
              return {
                x: t11.x,
                y: t11.y < e11.y ? f2[h11].yMin - 1 : f2[h11].yMax + 1,
                obstacle: f2[h11]
              };
            }
            h11 += a11;
          }
          return e11;
        }
        function b2(t11, e11, i11, s11, o11) {
          let r11 = o11.soft, n11 = o11.hard, a11 = s11 ? "x" : "y", h11 = {
            x: e11.x,
            y: e11.y
          }, l11 = {
            x: e11.x,
            y: e11.y
          }, d11 = t11[a11 + "Max"] >= r11[a11 + "Max"], c11 = t11[a11 + "Min"] <= r11[a11 + "Min"], p11 = t11[a11 + "Max"] >= n11[a11 + "Max"], u11 = t11[a11 + "Min"] <= n11[a11 + "Min"], g3 = c2(t11[a11 + "Min"] - e11[a11]), f3 = c2(t11[a11 + "Max"] - e11[a11]), m3 = 10 > c2(g3 - f3) ? e11[a11] < i11[a11] : f3 < g3;
          l11[a11] = t11[a11 + "Min"], h11[a11] = t11[a11 + "Max"];
          let x3 = y2(e11, l11, s11)[a11] !== l11[a11], b3 = y2(e11, h11, s11)[a11] !== h11[a11];
          return m3 = x3 ? !b3 || m3 : !b3 && m3, m3 = c11 ? !d11 || m3 : !d11 && m3, m3 = u11 ? !p11 || m3 : !p11 && m3;
        }
        for ((m2 = c5(f2 = f2.slice(x2, m2 + 1), e10)) > -1 && (u10 = function(t11, e11, s11) {
          let o11 = c0(t11.xMax - e11.x, e11.x - t11.xMin) < c0(t11.yMax - e11.y, e11.y - t11.yMin), r11 = b2(t11, e11, s11, o11, {
            soft: i10.hardBounds,
            hard: i10.hardBounds
          });
          return o11 ? {
            y: e11.y,
            x: t11[r11 ? "xMax" : "xMin"] + (r11 ? 1 : -1)
          } : {
            x: e11.x,
            y: t11[r11 ? "yMax" : "yMin"] + (r11 ? 1 : -1)
          };
        }(f2[m2], e10, t10), r10.push({
          end: e10,
          start: u10
        }), e10 = u10); (m2 = c5(f2, e10)) > -1; ) p10 = e10[o10] - t10[o10] < 0, (u10 = {
          x: e10.x,
          y: e10.y
        })[o10] = f2[m2][p10 ? o10 + "Max" : o10 + "Min"] + (p10 ? 1 : -1), r10.push({
          end: e10,
          start: u10
        }), e10 = u10;
        return {
          path: c6(c10 = (c10 = function t11(e11, s11, o11) {
            let r11, n11, c11, p11, u11, m3, x3;
            if (e11.x === s11.x && e11.y === s11.y) return [];
            let v2 = o11 ? "x" : "y", M2 = i10.obstacleOptions.margin, k2 = {
              soft: {
                xMin: a10,
                xMax: h10,
                yMin: l10,
                yMax: d10
              },
              hard: i10.hardBounds
            };
            return (u11 = c5(f2, e11)) > -1 ? (p11 = b2(u11 = f2[u11], e11, s11, o11, k2), c9(u11, i10.hardBounds), x3 = o11 ? {
              y: e11.y,
              x: u11[p11 ? "xMax" : "xMin"] + (p11 ? 1 : -1)
            } : {
              x: e11.x,
              y: u11[p11 ? "yMax" : "yMin"] + (p11 ? 1 : -1)
            }, (m3 = c5(f2, x3)) > -1 && (c9(m3 = f2[m3], i10.hardBounds), x3[v2] = p11 ? c1(u11[v2 + "Max"] - M2 + 1, (m3[v2 + "Min"] + u11[v2 + "Max"]) / 2) : c0(u11[v2 + "Min"] + M2 - 1, (m3[v2 + "Max"] + u11[v2 + "Min"]) / 2), e11.x === x3.x && e11.y === x3.y ? (g2 && (x3[v2] = p11 ? c1(u11[v2 + "Max"], m3[v2 + "Max"]) + 1 : c0(u11[v2 + "Min"], m3[v2 + "Min"]) - 1), g2 = !g2) : g2 = false), n11 = [{
              start: e11,
              end: x3
            }]) : (r11 = y2(e11, {
              x: o11 ? s11.x : e11.x,
              y: o11 ? e11.y : s11.y
            }, o11), n11 = [{
              start: e11,
              end: {
                x: r11.x,
                y: r11.y
              }
            }], r11[o11 ? "x" : "y"] !== s11[o11 ? "x" : "y"] && (p11 = b2(r11.obstacle, r11, s11, !o11, k2), c9(r11.obstacle, i10.hardBounds), c11 = {
              x: o11 ? r11.x : r11.obstacle[p11 ? "xMax" : "xMin"] + (p11 ? 1 : -1),
              y: o11 ? r11.obstacle[p11 ? "yMax" : "yMin"] + (p11 ? 1 : -1) : r11.y
            }, o11 = !o11, n11 = n11.concat(t11({
              x: r11.x,
              y: r11.y
            }, c11, o11)))), n11 = n11.concat(t11(n11[n11.length - 1].end, s11, !o11));
          }(t10, e10, s10)).concat(r10.reverse())),
          obstacles: c10
        };
      }
      c4.requiresObstacles = true, c8.requiresObstacles = true;
      let c7 = {
        connectors: {
          type: "straight",
          radius: 0,
          lineWidth: 1,
          marker: {
            enabled: false,
            align: "center",
            verticalAlign: "middle",
            inside: false,
            lineWidth: 1
          },
          startMarker: {
            symbol: "diamond"
          },
          endMarker: {
            symbol: "arrow-filled"
          }
        }
      }, {
        setOptions: pt
      } = tS, {
        defined: pe,
        error: pi,
        merge: ps
      } = tt;
      function po(t10) {
        let e10 = t10.shapeArgs;
        if (e10) return {
          xMin: e10.x || 0,
          xMax: (e10.x || 0) + (e10.width || 0),
          yMin: e10.y || 0,
          yMax: (e10.y || 0) + (e10.height || 0)
        };
        let i10 = t10.graphic && t10.graphic.getBBox();
        return i10 ? {
          xMin: t10.plotX - i10.width / 2,
          xMax: t10.plotX + i10.width / 2,
          yMin: t10.plotY - i10.height / 2,
          yMax: t10.plotY + i10.height / 2
        } : null;
      }
      !function(t10) {
        function e10(t11) {
          let e11, i11;
          let s11 = po(this);
          switch (t11.align) {
            case "right":
              e11 = "xMax";
              break;
            case "left":
              e11 = "xMin";
          }
          switch (t11.verticalAlign) {
            case "top":
              i11 = "yMin";
              break;
            case "bottom":
              i11 = "yMax";
          }
          return {
            x: e11 ? s11[e11] : (s11.xMin + s11.xMax) / 2,
            y: i11 ? s11[i11] : (s11.yMin + s11.yMax) / 2
          };
        }
        function i10(t11, e11) {
          let i11;
          return !pe(e11) && (i11 = po(this)) && (e11 = {
            x: (i11.xMin + i11.xMax) / 2,
            y: (i11.yMin + i11.yMax) / 2
          }), Math.atan2(e11.y - t11.y, t11.x - e11.x);
        }
        function s10(t11, e11, i11) {
          let s11 = 2 * Math.PI, o10 = po(this), r10 = o10.xMax - o10.xMin, n10 = o10.yMax - o10.yMin, a10 = Math.atan2(n10, r10), h10 = r10 / 2, l10 = n10 / 2, d10 = o10.xMin + h10, c10 = o10.yMin + l10, p10 = {
            x: d10,
            y: c10
          }, u10 = t11, g2 = 1, f2 = false, m2 = 1, x2 = 1;
          for (; u10 < -Math.PI; ) u10 += s11;
          for (; u10 > Math.PI; ) u10 -= s11;
          return g2 = Math.tan(u10), u10 > -a10 && u10 <= a10 ? (x2 = -1, f2 = true) : u10 > a10 && u10 <= Math.PI - a10 ? x2 = -1 : u10 > Math.PI - a10 || u10 <= -(Math.PI - a10) ? (m2 = -1, f2 = true) : m2 = -1, f2 ? (p10.x += m2 * h10, p10.y += x2 * h10 * g2) : (p10.x += n10 / (2 * g2) * m2, p10.y += x2 * l10), i11.x !== d10 && (p10.x = i11.x), i11.y !== c10 && (p10.y = i11.y), {
            x: p10.x + e11 * Math.cos(u10),
            y: p10.y - e11 * Math.sin(u10)
          };
        }
        t10.compose = function(t11, o10, r10) {
          let n10 = r10.prototype;
          n10.getPathfinderAnchorPoint || (t11.prototype.callbacks.push(function(t12) {
            false !== t12.options.connectors.enabled && ((t12.options.pathfinder || t12.series.reduce(function(t13, e11) {
              return e11.options && ps(true, e11.options.connectors = e11.options.connectors || {}, e11.options.pathfinder), t13 || e11.options && e11.options.pathfinder;
            }, false)) && (ps(true, t12.options.connectors = t12.options.connectors || {}, t12.options.pathfinder), pi('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.')), this.pathfinder = new o10(this), this.pathfinder.update(true));
          }), n10.getMarkerVector = s10, n10.getPathfinderAnchorPoint = e10, n10.getRadiansToVector = i10, pt(c7));
        };
      }(S || (S = {}));
      let pr = S, {
        addEvent: pn,
        defined: pa,
        pick: ph,
        splat: pl
      } = tt, pd = Math.max, pc = Math.min;
      class pp {
        static compose(t10, e10) {
          pr.compose(t10, pp, e10);
        }
        constructor(t10) {
          this.init(t10);
        }
        init(t10) {
          this.chart = t10, this.connections = [], pn(t10, "redraw", function() {
            this.pathfinder.update();
          });
        }
        update(t10) {
          let e10 = this.chart, i10 = this, s10 = i10.connections;
          i10.connections = [], e10.series.forEach(function(t11) {
            t11.visible && !t11.options.isInternal && t11.points.forEach(function(t12) {
              let s11;
              let o10 = t12.options;
              o10 && o10.dependency && (o10.connect = o10.dependency);
              let r10 = t12.options?.connect ? pl(t12.options.connect) : [];
              t12.visible && false !== t12.isInside && r10.forEach((o11) => {
                let r11 = "string" == typeof o11 ? o11 : o11.to;
                r11 && (s11 = e10.get(r11)), s11 instanceof oq && s11.series.visible && s11.visible && false !== s11.isInside && i10.connections.push(new lH(t12, s11, "string" == typeof o11 ? {} : o11));
              });
            });
          });
          for (let t11 = 0, e11, o10, r10 = s10.length, n10 = i10.connections.length; t11 < r10; ++t11) {
            o10 = false;
            let r11 = s10[t11];
            for (e11 = 0; e11 < n10; ++e11) {
              let t12 = i10.connections[e11];
              if ((r11.options && r11.options.type) === (t12.options && t12.options.type) && r11.fromPoint === t12.fromPoint && r11.toPoint === t12.toPoint) {
                t12.graphics = r11.graphics, o10 = true;
                break;
              }
            }
            o10 || r11.destroy();
          }
          delete this.chartObstacles, delete this.lineObstacles, i10.renderConnections(t10);
        }
        renderConnections(t10) {
          t10 ? this.chart.series.forEach(function(t11) {
            let e10 = function() {
              let e11 = t11.chart.pathfinder;
              (e11 && e11.connections || []).forEach(function(e12) {
                e12.fromPoint && e12.fromPoint.series === t11 && e12.render();
              }), t11.pathfinderRemoveRenderEvent && (t11.pathfinderRemoveRenderEvent(), delete t11.pathfinderRemoveRenderEvent);
            };
            false === t11.options.animation ? e10() : t11.pathfinderRemoveRenderEvent = pn(t11, "afterAnimate", e10);
          }) : this.connections.forEach(function(t11) {
            t11.render();
          });
        }
        getChartObstacles(t10) {
          let e10 = this.chart.series, i10 = ph(t10.algorithmMargin, 0), s10 = [], o10;
          for (let t11 = 0, o11 = e10.length; t11 < o11; ++t11) if (e10[t11].visible && !e10[t11].options.isInternal) for (let o12 = 0, r10 = e10[t11].points.length, n10, a10; o12 < r10; ++o12) (a10 = e10[t11].points[o12]).visible && (n10 = function(t12) {
            let e11 = t12.shapeArgs;
            if (e11) return {
              xMin: e11.x || 0,
              xMax: (e11.x || 0) + (e11.width || 0),
              yMin: e11.y || 0,
              yMax: (e11.y || 0) + (e11.height || 0)
            };
            let i11 = t12.graphic && t12.graphic.getBBox();
            return i11 ? {
              xMin: t12.plotX - i11.width / 2,
              xMax: t12.plotX + i11.width / 2,
              yMin: t12.plotY - i11.height / 2,
              yMax: t12.plotY + i11.height / 2
            } : null;
          }(a10)) && s10.push({
            xMin: n10.xMin - i10,
            xMax: n10.xMax + i10,
            yMin: n10.yMin - i10,
            yMax: n10.yMax + i10
          });
          return s10 = s10.sort(function(t11, e11) {
            return t11.xMin - e11.xMin;
          }), pa(t10.algorithmMargin) || (o10 = t10.algorithmMargin = function(t11) {
            let e11;
            let i11 = t11.length, s11 = [];
            for (let o11 = 0; o11 < i11; ++o11) for (let r10 = o11 + 1; r10 < i11; ++r10) (e11 = function t12(e12, i12, s12) {
              let o12 = ph(s12, 10), r11 = e12.yMax + o12 > i12.yMin - o12 && e12.yMin - o12 < i12.yMax + o12, n10 = e12.xMax + o12 > i12.xMin - o12 && e12.xMin - o12 < i12.xMax + o12, a10 = r11 ? e12.xMin > i12.xMax ? e12.xMin - i12.xMax : i12.xMin - e12.xMax : 1 / 0, h10 = n10 ? e12.yMin > i12.yMax ? e12.yMin - i12.yMax : i12.yMin - e12.yMax : 1 / 0;
              return n10 && r11 ? o12 ? t12(e12, i12, Math.floor(o12 / 2)) : 1 / 0 : pc(a10, h10);
            }(t11[o11], t11[r10])) < 80 && s11.push(e11);
            return s11.push(80), pd(Math.floor(s11.sort(function(t12, e12) {
              return t12 - e12;
            })[Math.floor(s11.length / 10)] / 2 - 1), 1);
          }(s10), s10.forEach(function(t11) {
            t11.xMin -= o10, t11.xMax += o10, t11.yMin -= o10, t11.yMax += o10;
          })), s10;
        }
        getObstacleMetrics(t10) {
          let e10 = 0, i10 = 0, s10, o10, r10 = t10.length;
          for (; r10--; ) s10 = t10[r10].xMax - t10[r10].xMin, o10 = t10[r10].yMax - t10[r10].yMin, e10 < s10 && (e10 = s10), i10 < o10 && (i10 = o10);
          return {
            maxHeight: i10,
            maxWidth: e10
          };
        }
        getAlgorithmStartDirection(t10) {
          let e10 = "left" !== t10.align && "right" !== t10.align, i10 = "top" !== t10.verticalAlign && "bottom" !== t10.verticalAlign;
          return e10 ? !!i10 && void 0 : !!i10 || void 0;
        }
      }
      pp.prototype.algorithms = {
        fastAvoid: c8,
        straight: function(t10, e10) {
          return {
            path: [["M", t10.x, t10.y], ["L", e10.x, e10.y]],
            obstacles: [{
              start: t10,
              end: e10
            }]
          };
        },
        simpleConnect: c4
      }, O.Pathfinder = O.Pathfinder || pp, lB.compose(O.SVGRenderer), O.Pathfinder.compose(O.Chart, O.Point);
      let {
        addEvent: pu,
        defined: pg,
        isNumber: pf,
        pick: pm
      } = tt;
      function px() {
        let t10 = this.chart.options.chart;
        !this.horiz && pf(this.options.staticScale) && (!t10.height || t10.scrollablePlotArea && t10.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);
      }
      function py() {
        if ("adjustHeight" !== this.redrawTrigger) {
          for (let t10 of this.axes || []) {
            let e10 = t10.chart, i10 = !!e10.initiatedScale && e10.options.animation, s10 = t10.options.staticScale;
            if (t10.staticScale && pg(t10.min)) {
              let o10 = pm(t10.brokenAxis && t10.brokenAxis.unitLength, t10.max + t10.tickInterval - t10.min) * s10, r10 = (o10 = Math.max(o10, s10)) - e10.plotHeight;
              !e10.scrollablePixelsY && Math.abs(r10) >= 1 && (e10.plotHeight = o10, e10.redrawTrigger = "adjustHeight", e10.setSize(void 0, e10.chartHeight + r10, i10)), t10.series.forEach(function(t11) {
                let i11 = t11.sharedClipKey && e10.sharedClips[t11.sharedClipKey];
                i11 && i11.attr(e10.inverted ? {
                  width: e10.plotHeight
                } : {
                  height: e10.plotHeight
                });
              });
            }
          }
          this.initiatedScale = true;
        }
        this.redrawTrigger = null;
      }
      let pb = {
        compose: function(t10, e10) {
          let i10 = e10.prototype;
          i10.adjustHeight || (pu(t10, "afterSetOptions", px), i10.adjustHeight = py, pu(e10, "render", i10.adjustHeight));
        }
      };
      pb.compose(O.Axis, O.Chart);
      let {
        correctFloat: pv,
        isNumber: pM,
        isObject: pk
      } = tt, {
        column: {
          prototype: {
            pointClass: pw
          }
        }
      } = ry.seriesTypes, {
        extend: pS
      } = tt;
      class pA extends pw {
        static getColorByCategory(t10, e10) {
          let i10 = t10.options.colors || t10.chart.options.colors, s10 = i10 ? i10.length : t10.chart.options.chart.colorCount, o10 = e10.y % s10, r10 = i10 && i10[o10];
          return {
            colorIndex: o10,
            color: r10
          };
        }
        resolveColor() {
          let t10 = this.series;
          if (t10.options.colorByPoint && !this.options.color) {
            let e10 = pA.getColorByCategory(t10, this);
            t10.chart.styledMode || (this.color = e10.color), this.options.colorIndex || (this.colorIndex = e10.colorIndex);
          } else this.color = this.options.color || t10.color;
        }
        constructor(t10, e10) {
          super(t10, e10), this.y || (this.y = 0);
        }
        applyOptions(t10, e10) {
          return super.applyOptions(t10, e10), this.x2 = this.series.chart.time.parse(this.x2), this.isNull = !this.isValid?.(), this;
        }
        setState() {
          super.setState.apply(this, arguments), this.series.drawPoint(this, this.series.getAnimationVerb());
        }
        isValid() {
          return "number" == typeof this.x && "number" == typeof this.x2;
        }
      }
      pS(pA.prototype, {
        ttBelow: false,
        tooltipDateKeys: ["x", "x2"]
      });
      let {
        composed: pT,
        noop: pP
      } = O, {
        parse: pC
      } = tO, {
        column: pO
      } = ry.seriesTypes, {
        addEvent: pE,
        clamp: pL,
        crisp: pB,
        defined: pI,
        extend: pD,
        find: pR,
        isNumber: pN,
        isObject: pz,
        merge: pW,
        pick: pG,
        pushUnique: pH,
        relativeLength: pF
      } = tt;
      function pX() {
        let t10, e10;
        if (this.isXAxis) {
          for (let i10 of (t10 = pG(this.dataMax, -Number.MAX_VALUE), this.series)) {
            let s10 = i10.dataTable.getColumn("x2", true) || i10.dataTable.getColumn("end", true);
            if (s10) for (let i11 of s10) pN(i11) && i11 > t10 && (t10 = i11, e10 = true);
          }
          e10 && (this.dataMax = t10);
        }
      }
      class pY extends pO {
        static compose(t10) {
          pH(pT, "Series.XRange") && pE(t10, "afterGetSeriesExtremes", pX);
        }
        init() {
          super.init.apply(this, arguments), this.options.stacking = void 0;
        }
        getColumnMetrics() {
          let t10 = () => {
            for (let t11 of this.chart.series) {
              let e11 = t11.xAxis;
              t11.xAxis = t11.yAxis, t11.yAxis = e11;
            }
          };
          t10();
          let e10 = super.getColumnMetrics();
          return t10(), e10;
        }
        cropData(t10, e10, i10) {
          let s10 = t10.getColumn("x") || [], o10 = t10.getColumn("x2");
          t10.setColumn("x", o10, void 0, {
            silent: true
          });
          let r10 = super.cropData(t10, e10, i10);
          return t10.setColumn("x", s10.slice(r10.start, r10.end), void 0, {
            silent: true
          }), r10;
        }
        findPointIndex(t10) {
          let e10;
          let {
            cropStart: i10,
            points: s10
          } = this, {
            id: o10
          } = t10;
          if (o10) {
            let t11 = pR(s10, (t12) => t12.id === o10);
            e10 = t11 ? t11.index : void 0;
          }
          if (void 0 === e10) {
            let i11 = pR(s10, (e11) => e11.x === t10.x && e11.x2 === t10.x2 && !e11.touched);
            e10 = i11 ? i11.index : void 0;
          }
          return this.cropped && pN(e10) && pN(i10) && e10 >= i10 && (e10 -= i10), e10;
        }
        alignDataLabel(t10) {
          let e10 = t10.plotX;
          t10.plotX = pG(t10.dlBox && t10.dlBox.centerX, t10.plotX), t10.dataLabel && t10.shapeArgs?.width && t10.dataLabel.css({
            width: `${t10.shapeArgs.width}px`
          }), super.alignDataLabel.apply(this, arguments), t10.plotX = e10;
        }
        translatePoint(t10) {
          let e10 = this.xAxis, i10 = this.yAxis, s10 = this.columnMetrics, o10 = this.options, r10 = o10.minPointLength || 0, n10 = (t10.shapeArgs && t10.shapeArgs.width || 0) / 2, a10 = this.pointXOffset = s10.offset, h10 = pG(t10.x2, t10.x + (t10.len || 0)), l10 = o10.borderRadius, d10 = this.chart.plotTop, c10 = this.chart.plotLeft, p10 = t10.plotX, u10 = e10.translate(h10, 0, 0, 0, 1), g2 = Math.abs(u10 - p10), f2 = this.chart.inverted, m2 = pG(o10.borderWidth, 1), x2, y2, b2 = s10.offset, v2 = Math.round(s10.width), M2, k2, w2, S2;
          r10 && ((x2 = r10 - g2) < 0 && (x2 = 0), p10 -= x2 / 2, u10 += x2 / 2), p10 = Math.max(p10, -10), u10 = pL(u10, -10, e10.len + 10), pI(t10.options.pointWidth) && (b2 -= (Math.ceil(t10.options.pointWidth) - v2) / 2, v2 = Math.ceil(t10.options.pointWidth)), o10.pointPlacement && pN(t10.plotY) && i10.categories && (t10.plotY = i10.translate(t10.y, 0, 1, 0, 1, o10.pointPlacement));
          let A2 = pB(Math.min(p10, u10), m2), T2 = pB(Math.max(p10, u10), m2) - A2, P2 = Math.min(pF("object" == typeof l10 ? l10.radius : l10 || 0, v2), Math.min(T2, v2) / 2), C2 = {
            x: A2,
            y: pB((t10.plotY || 0) + b2, m2),
            width: T2,
            height: v2,
            r: P2
          };
          t10.shapeArgs = C2, f2 ? t10.tooltipPos[1] += a10 + n10 : t10.tooltipPos[0] -= n10 + a10 - C2.width / 2, k2 = (M2 = C2.x) + C2.width, M2 < 0 || k2 > e10.len ? (M2 = pL(M2, 0, e10.len), w2 = (k2 = pL(k2, 0, e10.len)) - M2, t10.dlBox = pW(C2, {
            x: M2,
            width: k2 - M2,
            centerX: w2 ? w2 / 2 : null
          })) : t10.dlBox = null;
          let O2 = t10.tooltipPos, E2 = f2 ? 1 : 0, L2 = f2 ? 0 : 1, B2 = this.columnMetrics ? this.columnMetrics.offset : -s10.width / 2;
          f2 ? O2[E2] += C2.width / 2 : O2[E2] = pL(O2[E2] + (e10.reversed ? -1 : 0) * C2.width, e10.left - c10, e10.left + e10.len - c10 - 1), O2[L2] = pL(O2[L2] + (f2 ? -1 : 1) * B2, i10.top - d10, i10.top + i10.len - d10 - 1), (y2 = t10.partialFill) && (pz(y2) && (y2 = y2.amount), pN(y2) || (y2 = 0), t10.partShapeArgs = pW(C2), S2 = Math.max(Math.round(g2 * y2 + t10.plotX - p10), 0), t10.clipRectArgs = {
            x: e10.reversed ? C2.x + g2 - S2 : C2.x,
            y: C2.y,
            width: S2,
            height: C2.height
          }), t10.key = t10.category || t10.name, t10.yCategory = i10.categories?.[t10.y ?? -1];
        }
        translate() {
          for (let t10 of (super.translate.apply(this, arguments), this.points)) this.translatePoint(t10);
        }
        drawPoint(t10, e10) {
          let i10 = this.options, s10 = this.chart.renderer, o10 = t10.shapeType, r10 = t10.shapeArgs, n10 = t10.partShapeArgs, a10 = t10.clipRectArgs, h10 = t10.state, l10 = i10.states[h10 || "normal"] || {}, d10 = void 0 === h10 ? "attr" : e10, c10 = this.pointAttribs(t10, h10), p10 = pG(this.chart.options.chart.animation, l10.animation), u10 = t10.graphic, g2 = t10.partialFill;
          if (t10.isNull || false === t10.visible) u10 && (t10.graphic = u10.destroy());
          else if (u10 ? u10.rect[e10](r10) : (t10.graphic = u10 = s10.g("point").addClass(t10.getClassName()).add(t10.group || this.group), u10.rect = s10[o10](pW(r10)).addClass(t10.getClassName()).addClass("highcharts-partfill-original").add(u10)), n10 && (u10.partRect ? (u10.partRect[e10](pW(n10)), u10.partialClipRect[e10](pW(a10))) : (u10.partialClipRect = s10.clipRect(a10.x, a10.y, a10.width, a10.height), u10.partRect = s10[o10](n10).addClass("highcharts-partfill-overlay").add(u10).clip(u10.partialClipRect))), !this.chart.styledMode && (u10.rect[e10](c10, p10).shadow(i10.shadow), n10)) {
            pz(g2) || (g2 = {}), pz(i10.partialFill) && (g2 = pW(i10.partialFill, g2));
            let e11 = g2.fill || pC(c10.fill).brighten(-0.3).get() || pC(t10.color || this.color).brighten(-0.3).get();
            c10.fill = e11, u10.partRect[d10](c10, p10).shadow(i10.shadow);
          }
        }
        drawPoints() {
          let t10 = this.getAnimationVerb();
          for (let e10 of this.points) this.drawPoint(e10, t10);
        }
        getAnimationVerb() {
          return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
        }
        isPointInside(t10) {
          let e10 = t10.shapeArgs, i10 = t10.plotX, s10 = t10.plotY;
          return e10 ? void 0 !== i10 && void 0 !== s10 && s10 >= 0 && s10 <= this.yAxis.len && (e10.x || 0) + (e10.width || 0) >= 0 && i10 <= this.xAxis.len : super.isPointInside.apply(this, arguments);
        }
      }
      pY.defaultOptions = pW(pO.defaultOptions, {
        colorByPoint: true,
        dataLabels: {
          formatter: function() {
            let t10 = this.partialFill;
            if (pk(t10) && (t10 = t10.amount), pM(t10) && t10 > 0) return pv(100 * t10) + "%";
          },
          inside: true,
          verticalAlign: "middle",
          style: {
            whiteSpace: "nowrap"
          }
        },
        tooltip: {
          headerFormat: '<span style="font-size: 0.8em">{ucfirst point.x} - {point.x2}</span><br/>',
          pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.yCategory}</b><br/>'
        },
        borderRadius: 3,
        pointRange: 0
      }), pD(pY.prototype, {
        pointClass: pA,
        pointArrayMap: ["x2", "y"],
        getExtremesFromAll: true,
        keysAffectYAxis: ["y"],
        parallelArrays: ["x", "x2", "y"],
        requireSorting: false,
        type: "xrange",
        animate: ry.series.prototype.animate,
        autoIncrement: pP,
        buildKDTree: pP
      }), ry.registerSeriesType("xrange", pY), pY.compose(O.Axis);
      let {
        xrange: {
          prototype: {
            pointClass: pj
          }
        }
      } = ry.seriesTypes;
      class pU extends pj {
        static setGanttPointAliases(t10, e10) {
          t10.x = t10.start = e10.time.parse(t10.start ?? t10.x), t10.x2 = t10.end = e10.time.parse(t10.end ?? t10.x2), t10.partialFill = t10.completed = t10.completed ?? t10.partialFill;
        }
        applyOptions(t10, e10) {
          let i10 = super.applyOptions(t10, e10);
          return pU.setGanttPointAliases(i10, i10.series.chart), this.isNull = !this.isValid?.(), i10;
        }
        isValid() {
          return ("number" == typeof this.start || "number" == typeof this.x) && ("number" == typeof this.end || "number" == typeof this.x2 || this.milestone);
        }
      }
      let {
        isNumber: pV
      } = tt, {
        addEvent: p$,
        find: p_,
        fireEvent: pq,
        isArray: pZ,
        isNumber: pK,
        pick: pJ
      } = tt;
      !function(t10) {
        function e10() {
          void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
        }
        function i10() {
          this.brokenAxis?.hasBreaks && (this.options.ordinal = false);
        }
        function s10() {
          let t11 = this.brokenAxis;
          if (t11?.hasBreaks) {
            let e11 = this.tickPositions, i11 = this.tickPositions.info, s11 = [];
            for (let i12 = 0; i12 < e11.length; i12++) t11.isInAnyBreak(e11[i12]) || s11.push(e11[i12]);
            this.tickPositions = s11, this.tickPositions.info = i11;
          }
        }
        function o10() {
          this.brokenAxis || (this.brokenAxis = new l10(this));
        }
        function r10() {
          let {
            isDirty: t11,
            options: {
              connectNulls: e11
            },
            points: i11,
            xAxis: s11,
            yAxis: o11
          } = this;
          if (t11) {
            let t12 = i11.length;
            for (; t12--; ) {
              let r11 = i11[t12], n11 = !(null === r11.y && false === e11) && (s11?.brokenAxis?.isInAnyBreak(r11.x, true) || o11?.brokenAxis?.isInAnyBreak(r11.y, true));
              r11.visible = !n11 && false !== r11.options.visible;
            }
          }
        }
        function n10() {
          this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, pJ(this.pointArrayMap, ["y"]));
        }
        function a10(t11, e11) {
          let i11, s11, o11;
          let r11 = this, n11 = r11.points;
          if (t11?.brokenAxis?.hasBreaks) {
            let a11 = t11.brokenAxis;
            e11.forEach(function(e12) {
              i11 = a11?.breakArray || [], s11 = t11.isXAxis ? t11.min : pJ(r11.options.threshold, t11.min);
              let h11 = t11?.options?.breaks?.filter(function(t12) {
                let e13 = true;
                for (let s12 = 0; s12 < i11.length; s12++) {
                  let o12 = i11[s12];
                  if (o12.from === t12.from && o12.to === t12.to) {
                    e13 = false;
                    break;
                  }
                }
                return e13;
              });
              n11.forEach(function(r12) {
                o11 = pJ(r12["stack" + e12.toUpperCase()], r12[e12]), i11.forEach(function(e13) {
                  if (pK(s11) && pK(o11)) {
                    let i12 = "";
                    s11 < e13.from && o11 > e13.to || s11 > e13.from && o11 < e13.from ? i12 = "pointBreak" : (s11 < e13.from && o11 > e13.from && o11 < e13.to || s11 > e13.from && o11 > e13.to && o11 < e13.from) && (i12 = "pointInBreak"), i12 && pq(t11, i12, {
                      point: r12,
                      brk: e13
                    });
                  }
                }), h11?.forEach(function(e13) {
                  pq(t11, "pointOutsideOfBreak", {
                    point: r12,
                    brk: e13
                  });
                });
              });
            });
          }
        }
        function h10() {
          let t11 = this.currentDataGrouping, e11 = t11?.gapSize, i11 = this.points.slice(), s11 = this.yAxis, o11 = this.options.gapSize, r11 = i11.length - 1;
          if (o11 && r11 > 0) {
            let t12, n11;
            for ("value" !== this.options.gapUnit && (o11 *= this.basePointRange), e11 && e11 > o11 && e11 >= this.basePointRange && (o11 = e11); r11--; ) if (n11 && false !== n11.visible || (n11 = i11[r11 + 1]), t12 = i11[r11], false !== n11.visible && false !== t12.visible) {
              if (n11.x - t12.x > o11) {
                let e12 = (t12.x + n11.x) / 2;
                i11.splice(r11 + 1, 0, {
                  isNull: true,
                  x: e12
                }), s11.stacking && this.options.stacking && ((s11.stacking.stacks[this.stackKey][e12] = new aa(s11, s11.options.stackLabels, false, e12, this.stack)).total = 0);
              }
              n11 = t12;
            }
          }
          return this.getGraphPath(i11);
        }
        t10.compose = function(t11, l11) {
          if (!t11.keepProps.includes("brokenAxis")) {
            t11.keepProps.push("brokenAxis"), p$(t11, "init", o10), p$(t11, "afterInit", e10), p$(t11, "afterSetTickPositions", s10), p$(t11, "afterSetOptions", i10);
            let d10 = l11.prototype;
            d10.drawBreaks = a10, d10.gappedPath = h10, p$(l11, "afterGeneratePoints", r10), p$(l11, "afterRender", n10);
          }
          return t11;
        };
        class l10 {
          static isInBreak(t11, e11) {
            let i11 = t11.repeat || 1 / 0, s11 = t11.from, o11 = t11.to - t11.from, r11 = e11 >= s11 ? (e11 - s11) % i11 : i11 - (s11 - e11) % i11;
            return t11.inclusive ? r11 <= o11 : r11 < o11 && 0 !== r11;
          }
          static lin2Val(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !pK(t11)) return t11;
            let s11 = t11, o11, r11;
            for (r11 = 0; r11 < i11.length && !((o11 = i11[r11]).from >= s11); r11++) o11.to < s11 ? s11 += o11.len : l10.isInBreak(o11, s11) && (s11 += o11.len);
            return s11;
          }
          static val2Lin(t11) {
            let e11 = this.brokenAxis, i11 = e11 && e11.breakArray;
            if (!i11 || !pK(t11)) return t11;
            let s11 = t11, o11, r11;
            for (r11 = 0; r11 < i11.length; r11++) if ((o11 = i11[r11]).to <= t11) s11 -= o11.len;
            else if (o11.from >= t11) break;
            else if (l10.isInBreak(o11, t11)) {
              s11 -= t11 - o11.from;
              break;
            }
            return s11;
          }
          constructor(t11) {
            this.hasBreaks = false, this.axis = t11;
          }
          findBreakAt(t11, e11) {
            return p_(e11, function(e12) {
              return e12.from < t11 && t11 < e12.to;
            });
          }
          isInAnyBreak(t11, e11) {
            let i11 = this.axis, s11 = i11.options.breaks || [], o11 = s11.length, r11, n11, a11;
            if (o11 && pK(t11)) {
              for (; o11--; ) l10.isInBreak(s11[o11], t11) && (r11 = true, n11 || (n11 = pJ(s11[o11].showPoints, !i11.isXAxis)));
              a11 = r11 && e11 ? r11 && !n11 : r11;
            }
            return a11;
          }
          setBreaks(t11, e11) {
            let i11 = this, s11 = i11.axis, o11 = s11.chart.time, r11 = pZ(t11) && !!t11.length && !!Object.keys(t11[0]).length;
            s11.isDirty = i11.hasBreaks !== r11, i11.hasBreaks = r11, t11?.forEach((t12) => {
              t12.from = o11.parse(t12.from) || 0, t12.to = o11.parse(t12.to) || 0;
            }), t11 !== s11.options.breaks && (s11.options.breaks = s11.userOptions.breaks = t11), s11.forceRedraw = true, s11.series.forEach(function(t12) {
              t12.isDirty = true;
            }), r11 || s11.val2lin !== l10.val2Lin || (delete s11.val2lin, delete s11.lin2val), r11 && (s11.userOptions.ordinal = false, s11.lin2val = l10.lin2Val, s11.val2lin = l10.val2Lin, s11.setExtremes = function(t12, e12, o12, r12, n11) {
              if (i11.hasBreaks) {
                let s12;
                let o13 = this.options.breaks || [];
                for (; s12 = i11.findBreakAt(t12, o13); ) t12 = s12.to;
                for (; s12 = i11.findBreakAt(e12, o13); ) e12 = s12.from;
                e12 < t12 && (e12 = t12);
              }
              s11.constructor.prototype.setExtremes.call(this, t12, e12, o12, r12, n11);
            }, s11.setAxisTranslation = function() {
              if (s11.constructor.prototype.setAxisTranslation.call(this), i11.unitLength = void 0, i11.hasBreaks) {
                let t12 = s11.options.breaks || [], e12 = [], o12 = [], r12 = pJ(s11.pointRangePadding, 0), n11 = 0, a11, h11, d10 = s11.userMin || s11.min, c10 = s11.userMax || s11.max, p10, u10;
                t12.forEach(function(t13) {
                  h11 = t13.repeat || 1 / 0, pK(d10) && pK(c10) && (l10.isInBreak(t13, d10) && (d10 += t13.to % h11 - d10 % h11), l10.isInBreak(t13, c10) && (c10 -= c10 % h11 - t13.from % h11));
                }), t12.forEach(function(t13) {
                  if (p10 = t13.from, h11 = t13.repeat || 1 / 0, pK(d10) && pK(c10)) {
                    for (; p10 - h11 > d10; ) p10 -= h11;
                    for (; p10 < d10; ) p10 += h11;
                    for (u10 = p10; u10 < c10; u10 += h11) e12.push({
                      value: u10,
                      move: "in"
                    }), e12.push({
                      value: u10 + t13.to - t13.from,
                      move: "out",
                      size: t13.breakSize
                    });
                  }
                }), e12.sort(function(t13, e13) {
                  return t13.value === e13.value ? ("in" === t13.move ? 0 : 1) - ("in" === e13.move ? 0 : 1) : t13.value - e13.value;
                }), a11 = 0, p10 = d10, e12.forEach(function(t13) {
                  1 === (a11 += "in" === t13.move ? 1 : -1) && "in" === t13.move && (p10 = t13.value), 0 === a11 && pK(p10) && (o12.push({
                    from: p10,
                    to: t13.value,
                    len: t13.value - p10 - (t13.size || 0)
                  }), n11 += t13.value - p10 - (t13.size || 0));
                }), i11.breakArray = o12, pK(d10) && pK(c10) && pK(s11.min) && (i11.unitLength = c10 - d10 - n11 + r12, pq(s11, "afterBreaks"), s11.staticScale ? s11.transA = s11.staticScale : i11.unitLength && (s11.transA *= (c10 - s11.min + r12) / i11.unitLength), r12 && (s11.minPixelPadding = s11.transA * (s11.minPointOffset || 0)), s11.min = d10, s11.max = c10);
              }
            }), pJ(e11, true) && s11.chart.redraw();
          }
        }
        t10.Additions = l10;
      }(A || (A = {}));
      let pQ = A, {
        dateFormats: p0
      } = O, {
        addEvent: p1,
        defined: p2,
        erase: p3,
        find: p5,
        isArray: p6,
        isNumber: p9,
        merge: p4,
        pick: p8,
        timeUnits: p7,
        wrap: ut
      } = tt;
      function ue(t10) {
        return tt.isObject(t10, true);
      }
      function ui(t10, e10) {
        let i10 = {
          width: 0,
          height: 0
        };
        if (e10.forEach(function(e11) {
          let s10 = t10[e11], o10 = 0, r10 = 0, n10;
          ue(s10) && (o10 = (n10 = ue(s10.label) ? s10.label : {}).getBBox ? n10.getBBox().height : 0, n10.textStr && !p9(n10.textPxLength) && (n10.textPxLength = n10.getBBox().width), r10 = p9(n10.textPxLength) ? Math.round(n10.textPxLength) : 0, n10.textStr && (r10 = Math.round(n10.getBBox().width)), i10.height = Math.max(o10, i10.height), i10.width = Math.max(r10, i10.width));
        }), "treegrid" === this.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode) {
          let t11 = this.treeGrid.mapOfPosToGridNode[-1].height || 0;
          i10.width += this.options.labels.indentation * (t11 - 1);
        }
        return i10;
      }
      function us(t10) {
        let {
          grid: e10
        } = this, i10 = 3 === this.side;
        if (i10 || t10.apply(this), !e10?.isColumn) {
          let t11 = e10?.columns || [];
          i10 && (t11 = t11.slice().reverse()), t11.forEach((t12) => {
            t12.getOffset();
          });
        }
        i10 && t10.apply(this);
      }
      function uo(t10) {
        if (true === (this.options.grid || {}).enabled) {
          let {
            axisTitle: e10,
            height: i10,
            horiz: s10,
            left: o10,
            offset: r10,
            opposite: n10,
            options: a10,
            top: h10,
            width: l10
          } = this, d10 = this.tickSize(), c10 = e10 && e10.getBBox().width, p10 = a10.title.x, u10 = a10.title.y, g2 = p8(a10.title.margin, s10 ? 5 : 10), f2 = e10 ? this.chart.renderer.fontMetrics(e10).f : 0, m2 = (s10 ? h10 + i10 : o10) + (s10 ? 1 : -1) * (n10 ? -1 : 1) * (d10 ? d10[0] / 2 : 0) + (this.side === T.bottom ? f2 : 0);
          t10.titlePosition.x = s10 ? o10 - (c10 || 0) / 2 - g2 + p10 : m2 + (n10 ? l10 : 0) + r10 + p10, t10.titlePosition.y = s10 ? m2 - (n10 ? i10 : 0) + (n10 ? f2 : -f2) / 2 + r10 + u10 : h10 - g2 + u10;
        }
      }
      function ur() {
        let {
          chart: t10,
          options: {
            grid: e10 = {}
          },
          userOptions: i10
        } = this;
        if (e10.enabled && function(t11) {
          let e11 = t11.options;
          e11.labels.align = p8(e11.labels.align, "center"), t11.categories || (e11.showLastLabel = false), t11.labelRotation = 0, e11.labels.rotation = 0, e11.minTickInterval = 1;
        }(this), e10.columns) {
          let s10 = this.grid.columns = [], o10 = this.grid.columnIndex = 0;
          for (; ++o10 < e10.columns.length; ) {
            let r10 = p4(i10, e10.columns[o10], {
              isInternal: true,
              linkedTo: 0,
              scrollbar: {
                enabled: false
              }
            }, {
              grid: {
                columns: void 0
              }
            }), n10 = new sU(this.chart, r10, "yAxis");
            n10.grid.isColumn = true, n10.grid.columnIndex = o10, p3(t10.axes, n10), p3(t10[this.coll] || [], n10), s10.push(n10);
          }
        }
      }
      function un() {
        let {
          axisTitle: t10,
          grid: e10,
          options: i10
        } = this;
        if (true === (i10.grid || {}).enabled) {
          let s10 = this.min || 0, o10 = this.max || 0, r10 = this.ticks[this.tickPositions[0]];
          if (t10 && !this.chart.styledMode && r10?.slotWidth && !this.options.title.style.width && t10.css({
            width: `${r10.slotWidth}px`
          }), this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions), this.rightWall && this.rightWall.destroy(), this.grid && this.grid.isOuterAxis() && this.axisLine) {
            let t11 = i10.lineWidth;
            if (t11) {
              let e11 = this.getLinePath(t11), r11 = e11[0], n10 = e11[1], a10 = (this.tickSize("tick") || [1])[0] * (this.side === T.top || this.side === T.left ? -1 : 1);
              if ("M" === r11[0] && "L" === n10[0] && (this.horiz ? (r11[2] += a10, n10[2] += a10) : (r11[1] += a10, n10[1] += a10)), !this.horiz && this.chart.marginRight) {
                let t12 = ["L", this.left, r11[2] || 0], e12 = [r11, t12], a11 = ["L", this.chart.chartWidth - this.chart.marginRight, this.toPixels(o10 + this.tickmarkOffset)], h10 = [["M", n10[1] || 0, this.toPixels(o10 + this.tickmarkOffset)], a11];
                this.grid.upperBorder || s10 % 1 == 0 || (this.grid.upperBorder = this.grid.renderBorder(e12)), this.grid.upperBorder && (this.grid.upperBorder.attr({
                  stroke: i10.lineColor,
                  "stroke-width": i10.lineWidth
                }), this.grid.upperBorder.animate({
                  d: e12
                })), this.grid.lowerBorder || o10 % 1 == 0 || (this.grid.lowerBorder = this.grid.renderBorder(h10)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({
                  stroke: i10.lineColor,
                  "stroke-width": i10.lineWidth
                }), this.grid.lowerBorder.animate({
                  d: h10
                }));
              }
              this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({
                stroke: i10.lineColor,
                "stroke-width": i10.lineWidth
              }), this.grid.axisLineExtra.animate({
                d: e11
              })) : this.grid.axisLineExtra = this.grid.renderBorder(e11), this.axisLine[this.showAxis ? "show" : "hide"]();
            }
          }
          if ((e10 && e10.columns || []).forEach((t11) => t11.render()), !this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar) && this.tickPositions.length) {
            let t11, e11;
            let i11 = this.tickmarkOffset, r11 = this.tickPositions[this.tickPositions.length - 1], n10 = this.tickPositions[0];
            for (; (t11 = this.hiddenLabels.pop()) && t11.element; ) t11.show();
            for (; (e11 = this.hiddenMarks.pop()) && e11.element; ) e11.show();
            (t11 = this.ticks[n10].label) && (s10 - n10 > i11 ? this.hiddenLabels.push(t11.hide()) : t11.show()), (t11 = this.ticks[r11].label) && (r11 - o10 > i11 ? this.hiddenLabels.push(t11.hide()) : t11.show());
            let a10 = this.ticks[r11].mark;
            a10 && r11 - o10 < i11 && r11 - o10 > 0 && this.ticks[r11].isLast && this.hiddenMarks.push(a10.hide());
          }
        }
      }
      function ua() {
        let t10 = this.tickPositions && this.tickPositions.info, e10 = this.options, i10 = e10.grid || {}, s10 = this.userOptions.labels || {};
        i10.enabled && (this.horiz ? (this.series.forEach((t11) => {
          t11.options.pointRange = 0;
        }), t10 && e10.dateTimeLabelFormats && e10.labels && !p2(s10.align) && (false === e10.dateTimeLabelFormats[t10.unitName].range || t10.count > 1) && (e10.labels.align = "left", p2(s10.x) || (e10.labels.x = 3))) : "treegrid" !== this.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));
      }
      function uh(t10) {
        let e10;
        let i10 = this.options, s10 = t10.userOptions, o10 = i10 && ue(i10.grid) ? i10.grid : {};
        true === o10.enabled && (e10 = p4(true, {
          className: "highcharts-grid-axis " + (s10.className || ""),
          dateTimeLabelFormats: {
            hour: {
              list: ["%[HM]", "%[H]"]
            },
            day: {
              list: ["%[AeB]", "%[aeb]", "%[E]"]
            },
            week: {
              list: ["Week %W", "W%W"]
            },
            month: {
              list: ["%[B]", "%[b]", "%o"]
            }
          },
          grid: {
            borderWidth: 1
          },
          labels: {
            padding: 2,
            style: {
              fontSize: "0.9em"
            }
          },
          margin: 0,
          title: {
            text: null,
            reserveSpace: false,
            rotation: 0,
            style: {
              textOverflow: "ellipsis"
            }
          },
          units: [["millisecond", [1, 10, 100]], ["second", [1, 10]], ["minute", [1, 5, 15]], ["hour", [1, 6]], ["day", [1]], ["week", [1]], ["month", [1]], ["year", null]]
        }, s10), "xAxis" !== this.coll || (p2(s10.linkedTo) && !p2(s10.tickPixelInterval) && (e10.tickPixelInterval = 350), !(!p2(s10.tickPixelInterval) && p2(s10.linkedTo)) || p2(s10.tickPositioner) || p2(s10.tickInterval) || p2(s10.units) || (e10.tickPositioner = function(t11, i11) {
          let s11 = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;
          if (s11) {
            let o11 = e10.units || [], r10, n10 = 1, a10 = "year";
            for (let t12 = 0; t12 < o11.length; t12++) {
              let e11 = o11[t12];
              if (e11 && e11[0] === s11.unitName) {
                r10 = t12;
                break;
              }
            }
            let h10 = p9(r10) && o11[r10 + 1];
            if (h10) {
              a10 = h10[0] || "year";
              let t12 = h10[1];
              n10 = t12 && t12[0] || 1;
            } else "year" === s11.unitName && (n10 = 10 * s11.count);
            let l10 = p7[a10];
            return this.tickInterval = l10 * n10, this.chart.time.getTimeTicks({
              unitRange: l10,
              count: n10,
              unitName: a10
            }, t11, i11, this.options.startOfWeek);
          }
        })), p4(true, this.options, e10), this.horiz && (i10.minPadding = p8(s10.minPadding, 0), i10.maxPadding = p8(s10.maxPadding, 0)), p9(i10.grid.borderWidth) && (i10.tickWidth = i10.lineWidth = o10.borderWidth));
      }
      function ul(t10) {
        let e10 = t10.userOptions, i10 = e10 && e10.grid || {}, s10 = i10.columns;
        i10.enabled && s10 && p4(true, this.options, s10[0]);
      }
      function ud() {
        (this.grid.columns || []).forEach((t10) => t10.setScale());
      }
      function uc(t10) {
        let {
          horiz: e10,
          maxLabelDimensions: i10,
          options: {
            grid: s10 = {}
          }
        } = this;
        if (s10.enabled && i10) {
          let o10 = 2 * this.options.labels.distance, r10 = e10 ? s10.cellHeight || o10 + i10.height : o10 + i10.width;
          p6(t10.tickSize) ? t10.tickSize[0] = r10 : t10.tickSize = [r10, 0];
        }
      }
      function up() {
        this.axes.forEach((t10) => {
          (t10.grid && t10.grid.columns || []).forEach((t11) => {
            t11.setAxisSize(), t11.setAxisTranslation();
          });
        });
      }
      function uu(t10) {
        let {
          grid: e10
        } = this;
        (e10.columns || []).forEach((e11) => e11.destroy(t10.keepEvents)), e10.columns = void 0;
      }
      function ug(t10) {
        let e10 = t10.userOptions || {}, i10 = e10.grid || {};
        i10.enabled && p2(i10.borderColor) && (e10.tickColor = e10.lineColor = i10.borderColor), this.grid || (this.grid = new ub(this)), this.hiddenLabels = [], this.hiddenMarks = [];
      }
      function uf(t10) {
        let e10 = this.label, i10 = this.axis, s10 = i10.reversed, o10 = i10.chart, r10 = i10.options.grid || {}, n10 = i10.options.labels, a10 = n10.align, h10 = T[i10.side], l10 = t10.tickmarkOffset, d10 = i10.tickPositions, c10 = this.pos - l10, p10 = p9(d10[t10.index + 1]) ? d10[t10.index + 1] - l10 : (i10.max || 0) + l10, u10 = i10.tickSize("tick"), g2 = u10 ? u10[0] : 0, f2 = u10 ? u10[1] / 2 : 0;
        if (true === r10.enabled) {
          let r11, l11, d11, u11;
          if ("top" === h10 ? l11 = (r11 = i10.top + i10.offset) - g2 : "bottom" === h10 ? r11 = (l11 = o10.chartHeight - i10.bottom + i10.offset) + g2 : (r11 = i10.top + i10.len - (i10.translate(s10 ? p10 : c10) || 0), l11 = i10.top + i10.len - (i10.translate(s10 ? c10 : p10) || 0)), "right" === h10 ? u11 = (d11 = o10.chartWidth - i10.right + i10.offset) + g2 : "left" === h10 ? d11 = (u11 = i10.left + i10.offset) - g2 : (d11 = Math.round(i10.left + (i10.translate(s10 ? p10 : c10) || 0)) - f2, u11 = Math.min(Math.round(i10.left + (i10.translate(s10 ? c10 : p10) || 0)) - f2, i10.left + i10.len)), this.slotWidth = u11 - d11, t10.pos.x = "left" === a10 ? d11 : "right" === a10 ? u11 : d11 + (u11 - d11) / 2, t10.pos.y = l11 + (r11 - l11) / 2, e10) {
            let i11 = o10.renderer.fontMetrics(e10), s11 = e10.getBBox().height;
            if (n10.useHTML) t10.pos.y += i11.b + -(s11 / 2);
            else {
              let e11 = Math.round(s11 / i11.h);
              t10.pos.y += (i11.b - (i11.h - i11.f)) / 2 + -((e11 - 1) * i11.h / 2);
            }
          }
          t10.pos.x += i10.horiz && n10.x || 0;
        }
      }
      function um(t10) {
        let {
          axis: e10,
          value: i10
        } = t10;
        if (e10.options.grid && e10.options.grid.enabled) {
          let s10;
          let o10 = e10.tickPositions, r10 = (e10.linkedParent || e10).series[0], n10 = i10 === o10[0], a10 = i10 === o10[o10.length - 1], h10 = r10 && p5(r10.options.data, function(t11) {
            return t11[e10.isXAxis ? "x" : "y"] === i10;
          });
          h10 && r10.is("gantt") && (s10 = p4(h10), O.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(s10, e10.chart)), t10.isFirst = n10, t10.isLast = a10, t10.point = s10;
        }
      }
      function ux() {
        let t10 = this.options, e10 = t10.grid || {}, i10 = this.categories, s10 = this.tickPositions, o10 = s10[0], r10 = s10[1], n10 = s10[s10.length - 1], a10 = s10[s10.length - 2], h10 = this.linkedParent && this.linkedParent.min, l10 = this.linkedParent && this.linkedParent.max, d10 = h10 || this.min, c10 = l10 || this.max, p10 = this.tickInterval, u10 = p9(d10) && d10 >= o10 + p10 && d10 < r10, g2 = p9(d10) && o10 < d10 && o10 + p10 > d10, f2 = p9(c10) && n10 > c10 && n10 - p10 < c10, m2 = p9(c10) && c10 <= n10 - p10 && c10 > a10;
        true === e10.enabled && !i10 && (this.isXAxis || this.isLinked) && ((g2 || u10) && !t10.startOnTick && (s10[0] = d10), (f2 || m2) && !t10.endOnTick && (s10[s10.length - 1] = c10));
      }
      function uy(t10) {
        var e10;
        let {
          options: {
            grid: i10 = {}
          }
        } = this;
        return true === i10.enabled && this.categories ? this.tickInterval : t10.apply(this, (e10 = arguments, Array.prototype.slice.call(e10, 1)));
      }
      !function(t10) {
        t10[t10.top = 0] = "top", t10[t10.right = 1] = "right", t10[t10.bottom = 2] = "bottom", t10[t10.left = 3] = "left";
      }(T || (T = {}));
      class ub {
        constructor(t10) {
          this.axis = t10;
        }
        isOuterAxis() {
          let t10 = this.axis, e10 = t10.chart, i10 = t10.grid.columnIndex, s10 = t10.linkedParent?.grid.columns || t10.grid.columns || [], o10 = i10 ? t10.linkedParent : t10, r10 = -1, n10 = 0;
          return 3 === t10.side && !e10.inverted && s10.length ? !t10.linkedParent : ((e10[t10.coll] || []).forEach((e11, i11) => {
            e11.side !== t10.side || e11.options.isInternal || (n10 = i11, e11 !== o10 || (r10 = i11));
          }), n10 === r10 && (!p9(i10) || s10.length === i10));
        }
        renderBorder(t10) {
          let e10 = this.axis, i10 = e10.chart.renderer, s10 = e10.options, o10 = i10.path(t10).addClass("highcharts-axis-line").add(e10.axisGroup);
          return i10.styledMode || o10.attr({
            stroke: s10.lineColor,
            "stroke-width": s10.lineWidth,
            zIndex: 7
          }), o10;
        }
      }
      p0.E = function(t10) {
        return this.dateFormat("%a", t10, true).charAt(0);
      }, p0.W = function(t10) {
        let e10 = this.toParts(t10), i10 = (e10[7] + 6) % 7, s10 = e10.slice(0);
        s10[2] = e10[2] - i10 + 3;
        let o10 = this.toParts(this.makeTime(s10[0], 0, 1));
        return 4 !== o10[7] && (e10[1] = 0, e10[2] = 1 + (11 - o10[7]) % 7), (1 + Math.floor((this.makeTime(s10[0], s10[1], s10[2]) - this.makeTime(o10[0], o10[1], o10[2])) / 6048e5)).toString();
      };
      let uv = {
        compose: function(t10, e10, i10) {
          return t10.keepProps.includes("grid") || (t10.keepProps.push("grid"), t10.prototype.getMaxLabelDimensions = ui, ut(t10.prototype, "unsquish", uy), ut(t10.prototype, "getOffset", us), p1(t10, "init", ug), p1(t10, "afterGetTitlePosition", uo), p1(t10, "afterInit", ur), p1(t10, "afterRender", un), p1(t10, "afterSetAxisTranslation", ua), p1(t10, "afterSetOptions", uh), p1(t10, "afterSetOptions", ul), p1(t10, "afterSetScale", ud), p1(t10, "afterTickSize", uc), p1(t10, "trimTicks", ux), p1(t10, "destroy", uu), p1(e10, "afterSetChartSize", up), p1(i10, "afterGetLabelPosition", uf), p1(i10, "labelFormat", um)), t10;
        }
      }, {
        extend: uM,
        isNumber: uk,
        pick: uw
      } = tt;
      function uS(t10, e10, i10, s10, o10, r10) {
        let n10 = r10 && r10.after, a10 = r10 && r10.before, h10 = {
          data: s10,
          depth: i10 - 1,
          id: t10,
          level: i10,
          parent: e10 || ""
        }, l10 = 0, d10 = 0, c10, p10;
        "function" == typeof a10 && a10(h10, r10);
        let u10 = (o10[t10] || []).map((e11) => {
          let s11 = uS(e11.id, t10, i10 + 1, e11, o10, r10), n11 = e11.start || NaN, a11 = true === e11.milestone ? n11 : e11.end || NaN;
          return c10 = !uk(c10) || n11 < c10 ? n11 : c10, p10 = !uk(p10) || a11 > p10 ? a11 : p10, l10 = l10 + 1 + s11.descendants, d10 = Math.max(s11.height + 1, d10), s11;
        });
        return s10 && (s10.start = uw(s10.start, c10), s10.end = uw(s10.end, p10)), uM(h10, {
          children: u10,
          descendants: l10,
          height: d10
        }), "function" == typeof n10 && n10(h10, r10), h10;
      }
      let uA = {
        getNode: uS,
        getTree: function(t10, e10) {
          return uS("", null, 1, null, function(t11) {
            let e11 = [], i10 = t11.reduce((t12, i11) => {
              let {
                parent: s10 = "",
                id: o10
              } = i11;
              return void 0 === t12[s10] && (t12[s10] = []), t12[s10].push(i11), o10 && e11.push(o10), t12;
            }, {});
            return Object.keys(i10).forEach((t12) => {
              if ("" !== t12 && -1 === e11.indexOf(t12)) {
                let e12 = i10[t12].map(function(t13) {
                  let e13 = __objRest(t13, []);
                  return e13;
                });
                i10[""].push(...e12), delete i10[t12];
              }
            }), i10;
          }(t10), e10);
        }
      }, {
        addEvent: uT,
        removeEvent: uP,
        isObject: uC,
        isNumber: uO,
        pick: uE,
        wrap: uL
      } = tt;
      function uB() {
        this.treeGrid || (this.treeGrid = new uR(this));
      }
      function uI(t10, e10, i10, s10, o10, r10, n10, a10, h10) {
        let l10, d10, c10;
        let p10 = uE(this.options && this.options.labels, r10), u10 = this.pos, g2 = this.axis, f2 = "treegrid" === g2.type, m2 = t10.apply(this, [e10, i10, s10, o10, p10, n10, a10, h10]);
        if (f2) {
          let {
            width: t11 = 0,
            padding: e11 = g2.linkedParent ? 0 : 5
          } = p10 && uC(p10.symbol, true) ? p10.symbol : {}, i11 = p10 && uO(p10.indentation) ? p10.indentation : 0;
          c10 = (d10 = (l10 = g2.treeGrid.mapOfPosToGridNode) && l10[u10]) && d10.depth || 1, m2.x += t11 + 2 * e11 + (c10 - 1) * i11;
        }
        return m2;
      }
      function uD(t10) {
        let e10, i10, s10;
        let {
          pos: o10,
          axis: r10,
          label: n10,
          treeGrid: a10,
          options: h10
        } = this, l10 = a10?.labelIcon, d10 = n10?.element, {
          treeGrid: c10,
          options: p10,
          chart: u10,
          tickPositions: g2
        } = r10, f2 = c10.mapOfPosToGridNode, m2 = uE(h10?.labels, p10?.labels), x2 = m2 && uC(m2.symbol, true) ? m2.symbol : {}, y2 = f2 && f2[o10], {
          descendants: b2,
          depth: v2
        } = y2 || {}, M2 = y2 && b2 && b2 > 0, k2 = "treegrid" === r10.type && d10, w2 = g2.indexOf(o10) > -1, S2 = "highcharts-treegrid-node-", A2 = S2 + "level-", T2 = u10.styledMode;
        k2 && y2 && n10.removeClass(RegExp(A2 + ".*")).addClass(A2 + v2), t10.apply(this, Array.prototype.slice.call(arguments, 1)), k2 && M2 ? (e10 = c10.isCollapsed(y2), function(t11, e11) {
          let i11 = t11.treeGrid, s11 = !i11.labelIcon, o11 = e11.renderer, r11 = e11.xy, n11 = e11.options, a11 = n11.width || 0, h11 = n11.height || 0, l11 = n11.padding ?? t11.axis.linkedParent ? 0 : 5, d11 = {
            x: r11.x - a11 / 2 - l11,
            y: r11.y - h11 / 2
          }, c11 = e11.collapsed ? 90 : 180, p11 = e11.show && uO(d11.y), u11 = i11.labelIcon;
          u11 || (i11.labelIcon = u11 = o11.path(o11.symbols[n11.type](n11.x || 0, n11.y || 0, a11, h11)).addClass("highcharts-label-icon").add(e11.group)), u11[p11 ? "show" : "hide"](), o11.styledMode || u11.attr({
            cursor: "pointer",
            fill: uE(e11.color, "#666666"),
            "stroke-width": 1,
            stroke: n11.lineColor,
            strokeWidth: n11.lineWidth || 0
          }), u11[s11 ? "attr" : "animate"]({
            translateX: d11.x,
            translateY: d11.y,
            rotation: c11
          });
        }(this, {
          color: !T2 && n10.styles.color || "",
          collapsed: e10,
          group: n10.parentGroup,
          options: x2,
          renderer: n10.renderer,
          show: w2,
          xy: n10.xy
        }), i10 = S2 + (e10 ? "collapsed" : "expanded"), s10 = S2 + (e10 ? "expanded" : "collapsed"), n10.addClass(i10).removeClass(s10), T2 || n10.css({
          cursor: "pointer"
        }), [n10, l10].forEach((t11) => {
          t11 && !t11.attachedTreeGridEvents && (uT(t11.element, "mouseover", function() {
            n10.addClass("highcharts-treegrid-node-active"), n10.renderer.styledMode || n10.css({
              textDecoration: "underline"
            });
          }), uT(t11.element, "mouseout", function() {
            !function(t12, e11) {
              let i11 = uC(e11.style) ? e11.style : {};
              t12.removeClass("highcharts-treegrid-node-active"), t12.renderer.styledMode || t12.css({
                textDecoration: i11.textDecoration || "none"
              });
            }(n10, m2);
          }), uT(t11.element, "click", function() {
            a10.toggleCollapse();
          }), t11.attachedTreeGridEvents = true);
        })) : l10 && (uP(d10), n10?.css({
          cursor: "default"
        }), l10.destroy());
      }
      class uR {
        static compose(t10) {
          let e10 = t10.prototype;
          e10.toggleCollapse || (uT(t10, "init", uB), uL(e10, "getLabelPosition", uI), uL(e10, "renderLabel", uD), e10.collapse = function(t11) {
            this.treeGrid.collapse(t11);
          }, e10.expand = function(t11) {
            this.treeGrid.expand(t11);
          }, e10.toggleCollapse = function(t11) {
            this.treeGrid.toggleCollapse(t11);
          });
        }
        constructor(t10) {
          this.tick = t10;
        }
        collapse(t10) {
          let e10 = this.tick, i10 = e10.axis, s10 = i10.brokenAxis;
          if (s10 && i10.treeGrid.mapOfPosToGridNode) {
            let o10 = e10.pos, r10 = i10.treeGrid.mapOfPosToGridNode[o10], n10 = i10.treeGrid.collapse(r10);
            s10.setBreaks(n10, uE(t10, true));
          }
        }
        destroy() {
          this.labelIcon && this.labelIcon.destroy();
        }
        expand(t10) {
          let {
            pos: e10,
            axis: i10
          } = this.tick, {
            treeGrid: s10,
            brokenAxis: o10
          } = i10, r10 = s10.mapOfPosToGridNode;
          if (o10 && r10) {
            let i11 = r10[e10], n10 = s10.expand(i11);
            o10.setBreaks(n10, uE(t10, true));
          }
        }
        toggleCollapse(t10) {
          let e10 = this.tick, i10 = e10.axis, s10 = i10.brokenAxis;
          if (s10 && i10.treeGrid.mapOfPosToGridNode) {
            let o10 = e10.pos, r10 = i10.treeGrid.mapOfPosToGridNode[o10], n10 = i10.treeGrid.toggleCollapse(r10);
            s10.setBreaks(n10, uE(t10, true));
          }
        }
      }
      let {
        extend: uN,
        isArray: uz,
        isNumber: uW,
        isObject: uG,
        merge: uH,
        pick: uF,
        relativeLength: uX
      } = tt, {
        getLevelOptions: uY
      } = {
        getColor: function(t10, e10) {
          let i10, s10, o10, r10, n10, a10;
          let h10 = e10.index, l10 = e10.mapOptionsToLevel, d10 = e10.parentColor, c10 = e10.parentColorIndex, p10 = e10.series, u10 = e10.colors, g2 = e10.siblings, f2 = p10.points, m2 = p10.chart.options.chart;
          return t10 && (i10 = f2[t10.i], s10 = l10[t10.level] || {}, i10 && s10.colorByPoint && (r10 = i10.index % (u10 ? u10.length : m2.colorCount), o10 = u10 && u10[r10]), p10.chart.styledMode || (n10 = uF(i10 && i10.options.color, s10 && s10.color, o10, d10 && ((t11) => {
            let e11 = s10 && s10.colorVariation;
            return e11 && "brightness" === e11.key && h10 && g2 ? tO.parse(t11).brighten(e11.to * (h10 / g2)).get() : t11;
          })(d10), p10.color)), a10 = uF(i10 && i10.options.colorIndex, s10 && s10.colorIndex, r10, c10, e10.colorIndex)), {
            color: n10,
            colorIndex: a10
          };
        },
        getLevelOptions: function(t10) {
          let e10, i10, s10, o10, r10, n10;
          let a10 = {};
          if (uG(t10)) for (o10 = uW(t10.from) ? t10.from : 1, n10 = t10.levels, i10 = {}, e10 = uG(t10.defaults) ? t10.defaults : {}, uz(n10) && (i10 = n10.reduce((t11, i11) => {
            let s11, r11, n11;
            return uG(i11) && uW(i11.level) && (r11 = uF((n11 = uH({}, i11)).levelIsConstant, e10.levelIsConstant), delete n11.levelIsConstant, delete n11.level, uG(t11[s11 = i11.level + (r11 ? 0 : o10 - 1)]) ? uH(true, t11[s11], n11) : t11[s11] = n11), t11;
          }, {})), r10 = uW(t10.to) ? t10.to : 1, s10 = 0; s10 <= r10; s10++) a10[s10] = uH({}, e10, uG(i10[s10]) ? i10[s10] : {});
          return a10;
        },
        getNodeWidth: function(t10, e10) {
          let {
            chart: i10,
            options: s10
          } = t10, {
            nodeDistance: o10 = 0,
            nodeWidth: r10 = 0
          } = s10, {
            plotSizeX: n10 = 1
          } = i10;
          if ("auto" === r10) {
            if ("string" == typeof o10 && /%$/.test(o10)) return n10 / (e10 + parseFloat(o10) / 100 * (e10 - 1));
            let t11 = Number(o10);
            return (n10 + t11) / (e10 || 1) - t11;
          }
          return uX(r10, n10);
        },
        setTreeValues: function t10(e10, i10) {
          let s10 = i10.before, o10 = i10.idRoot, r10 = i10.mapIdToNode[o10], n10 = false !== i10.levelIsConstant, a10 = i10.points[e10.i], h10 = a10 && a10.options || {}, l10 = [], d10 = 0;
          e10.levelDynamic = e10.level - (n10 ? 0 : r10.level), e10.name = uF(a10 && a10.name, ""), e10.visible = o10 === e10.id || true === i10.visible, "function" == typeof s10 && (e10 = s10(e10, i10)), e10.children.forEach((s11, o11) => {
            let r11 = uN({}, i10);
            uN(r11, {
              index: o11,
              siblings: e10.children.length,
              visible: e10.visible
            }), s11 = t10(s11, r11), l10.push(s11), s11.visible && (d10 += s11.val);
          });
          let c10 = uF(h10.value, d10);
          return e10.visible = c10 >= 0 && (d10 > 0 || e10.visible), e10.children = l10, e10.childrenTotal = d10, e10.isLeaf = e10.visible && !d10, e10.val = c10, e10;
        },
        updateRootId: function(t10) {
          let e10, i10;
          return uG(t10) && (i10 = uG(t10.options) ? t10.options : {}, e10 = uF(t10.rootNode, i10.rootId, ""), uG(t10.userOptions) && (t10.userOptions.rootId = e10), t10.rootNode = e10), e10;
        }
      }, {
        addEvent: uj,
        isArray: uU,
        splat: uV,
        find: u$,
        fireEvent: u_,
        isObject: uq,
        isString: uZ,
        merge: uK,
        pick: uJ,
        removeEvent: uQ,
        wrap: u0
      } = tt;
      function u1(t10, e10) {
        let i10 = t10.collapseEnd || 0, s10 = t10.collapseStart || 0;
        return i10 >= e10 && (s10 -= 0.5), {
          from: s10,
          to: i10,
          showPoints: false
        };
      }
      function u2(t10, e10, i10) {
        let s10 = [], o10 = [], r10 = {}, n10 = e10 || false, a10 = {}, h10 = -1, l10 = uA.getTree(t10, {
          after: function(t11) {
            let e11 = a10[t11.pos], i11 = 0, s11 = 0;
            e11.children.forEach(function(t12) {
              s11 += (t12.descendants || 0) + 1, i11 = Math.max((t12.height || 0) + 1, i11);
            }), e11.descendants = s11, e11.height = i11, e11.collapsed && o10.push(e11);
          },
          before: function(t11) {
            let e11, i11;
            let o11 = uq(t11.data, true) ? t11.data : {}, l11 = uZ(o11.name) ? o11.name : "", d10 = r10[t11.parent], c10 = uq(d10, true) ? a10[d10.pos] : null;
            n10 && uq(c10, true) && (e11 = u$(c10.children, function(t12) {
              return t12.name === l11;
            })) ? (i11 = e11.pos, e11.nodes.push(t11)) : i11 = h10++, !a10[i11] && (a10[i11] = e11 = {
              depth: c10 ? c10.depth + 1 : 0,
              name: l11,
              id: o11.id,
              nodes: [t11],
              children: [],
              pos: i11
            }, -1 !== i11 && s10.push(l11), uq(c10, true) && c10.children.push(e11)), uZ(t11.id) && (r10[t11.id] = t11), e11 && true === o11.collapsed && (e11.collapsed = true), t11.pos = i11;
          }
        });
        return {
          categories: s10,
          mapOfIdToNode: r10,
          mapOfPosToGridNode: a10 = function(t11, e11) {
            let i11 = function(t12, s11, o11) {
              let r11 = t12.nodes, n11 = s11 + (-1 === s11 ? 0 : e11 - 1), a11 = (n11 - s11) / 2, h11 = s11 + a11;
              return r11.forEach(function(t13) {
                let e12 = t13.data;
                uq(e12, true) && (e12.y = s11 + (e12.seriesIndex || 0), delete e12.seriesIndex), t13.pos = h11;
              }), o11[h11] = t12, t12.pos = h11, t12.tickmarkOffset = a11 + 0.5, t12.collapseStart = n11 + 0.5, t12.children.forEach(function(t13) {
                i11(t13, n11 + 1, o11), n11 = (t13.collapseEnd || 0) - 0.5;
              }), t12.collapseEnd = n11 + 0.5, o11;
            };
            return i11(t11["-1"], -1, {});
          }(a10, i10),
          collapsedNodes: o10,
          tree: l10
        };
      }
      function u3(t10) {
        let e10 = t10.target;
        e10.axes.filter((t11) => "treegrid" === t11.type).forEach(function(i10) {
          let s10 = i10.options || {}, o10 = s10.labels, r10 = i10.uniqueNames, n10 = e10.time.parse(s10.max), a10 = !i10.treeGrid.mapOfPosToGridNode || i10.series.some(function(t11) {
            return !t11.hasRendered || t11.isDirtyData || t11.isDirty;
          }), h10 = 0, l10, d10;
          if (a10) {
            let s11 = [];
            if (l10 = i10.series.reduce(function(t11, i11) {
              let o11 = i11.options.data || [], n11 = o11[0], a11 = Array.isArray(n11) && !n11.find((t12) => "object" == typeof t12);
              return s11.push(a11), i11.visible && (o11.forEach(function(s12) {
                (a11 || i11.options.keys && i11.options.keys.length) && (s12 = i11.pointClass.prototype.optionsToObject.call({
                  series: i11
                }, s12), i11.pointClass.setGanttPointAliases(s12, e10)), uq(s12, true) && (s12.seriesIndex = h10, t11.push(s12));
              }), true === r10 && h10++), t11;
            }, []), n10 && l10.length < n10) for (let t11 = l10.length; t11 <= n10; t11++) l10.push({
              name: t11 + "​"
            });
            d10 = u2(l10, r10 || false, true === r10 ? h10 : 1), i10.categories = d10.categories, i10.treeGrid.mapOfPosToGridNode = d10.mapOfPosToGridNode, i10.hasNames = true, i10.treeGrid.tree = d10.tree, i10.series.forEach(function(t11, e11) {
              let i11 = (t11.options.data || []).map(function(i12) {
                return (s11[e11] || uU(i12) && t11.options.keys && t11.options.keys.length) && l10.forEach(function(t12) {
                  let e12 = uV(i12);
                  e12.indexOf(t12.x || 0) >= 0 && e12.indexOf(t12.x2 || 0) >= 0 && (i12 = t12);
                }), uq(i12, true) ? uK(i12) : i12;
              });
              t11.visible && t11.setData(i11, false);
            }), i10.treeGrid.mapOptionsToLevel = uY({
              defaults: o10,
              from: 1,
              levels: o10 && o10.levels,
              to: i10.treeGrid.tree && i10.treeGrid.tree.height
            }), "beforeRender" === t10.type && (i10.treeGrid.collapsedNodes = d10.collapsedNodes);
          }
        });
      }
      function u5(t10, e10) {
        let i10 = this.treeGrid.mapOptionsToLevel || {}, s10 = "treegrid" === this.type, r10 = this.ticks, n10 = r10[e10], a10, h10, l10;
        s10 && this.treeGrid.mapOfPosToGridNode ? ((a10 = i10[(l10 = this.treeGrid.mapOfPosToGridNode[e10]).depth]) && (h10 = {
          labels: a10
        }), !n10 && o ? r10[e10] = n10 = new o(this, e10, void 0, void 0, {
          category: l10.name,
          tickmarkOffset: l10.tickmarkOffset,
          options: h10
        }) : (n10.parameters.category = l10.name, n10.options = h10, n10.addLabel())) : t10.apply(this, Array.prototype.slice.call(arguments, 1));
      }
      function u6(t10, e10, i10, s10) {
        let o10 = this, r10 = "treegrid" === i10.type;
        o10.treeGrid || (o10.treeGrid = new u8(o10)), r10 && (uj(e10, "beforeRender", u3), uj(e10, "beforeRedraw", u3), uj(e10, "addSeries", function(t11) {
          if (t11.options.data) {
            let e11 = u2(t11.options.data, i10.uniqueNames || false, 1);
            o10.treeGrid.collapsedNodes = (o10.treeGrid.collapsedNodes || []).concat(e11.collapsedNodes);
          }
        }), uj(o10, "foundExtremes", function() {
          o10.treeGrid.collapsedNodes && o10.treeGrid.collapsedNodes.forEach(function(t11) {
            let e11 = o10.treeGrid.collapse(t11);
            o10.brokenAxis && (o10.brokenAxis.setBreaks(e11, false), o10.treeGrid.collapsedNodes && (o10.treeGrid.collapsedNodes = o10.treeGrid.collapsedNodes.filter((e12) => t11.collapseStart !== e12.collapseStart || t11.collapseEnd !== e12.collapseEnd)));
          });
        }), uj(o10, "afterBreaks", function() {
          "yAxis" === o10.coll && !o10.staticScale && o10.chart.options.chart.height && (o10.isDirty = true);
        }), i10 = uK({
          grid: {
            enabled: true
          },
          labels: {
            align: "left",
            levels: [{
              level: void 0
            }, {
              level: 1,
              style: {
                fontWeight: "bold"
              }
            }],
            symbol: {
              type: "triangle",
              x: -5,
              y: -5,
              height: 10,
              width: 10
            }
          },
          uniqueNames: false
        }, i10, {
          reversed: true
        })), t10.apply(o10, [e10, i10, s10]), r10 && (o10.hasNames = true, o10.options.showLastLabel = true);
      }
      function u9(t10) {
        let e10 = this.options, i10 = this.chart.time, s10 = "number" == typeof e10.linkedTo ? this.chart[this.coll]?.[e10.linkedTo] : void 0;
        if ("treegrid" === this.type) {
          if (this.min = this.userMin ?? i10.parse(e10.min) ?? this.dataMin, this.max = this.userMax ?? i10.parse(e10.max) ?? this.dataMax, u_(this, "foundExtremes"), this.setAxisTranslation(), this.tickInterval = 1, this.tickmarkOffset = 0.5, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : [], s10) {
            let t11 = s10.getExtremes();
            this.min = uJ(t11.min, t11.dataMin), this.max = uJ(t11.max, t11.dataMax), this.tickPositions = s10.tickPositions;
          }
          this.linkedParent = s10;
        } else t10.apply(this, Array.prototype.slice.call(arguments, 1));
      }
      function u4(t10) {
        let e10 = this;
        "treegrid" === this.type && e10.visible && e10.tickPositions.forEach(function(t11) {
          let i10 = e10.ticks[t11];
          i10.label && i10.label.attachedTreeGridEvents && (uQ(i10.label.element), i10.label.attachedTreeGridEvents = false);
        }), t10.apply(e10, Array.prototype.slice.call(arguments, 1));
      }
      class u8 {
        static compose(t10, e10, i10, s10) {
          if (!t10.keepProps.includes("treeGrid")) {
            let e11 = t10.prototype;
            t10.keepProps.push("treeGrid"), u0(e11, "generateTick", u5), u0(e11, "init", u6), u0(e11, "setTickInterval", u9), u0(e11, "redraw", u4), e11.utils = {
              getNode: uA.getNode
            }, o || (o = s10);
          }
          return uv.compose(t10, e10, s10), pQ.compose(t10, i10), uR.compose(s10), t10;
        }
        constructor(t10) {
          this.axis = t10;
        }
        setCollapsedStatus(t10) {
          let e10 = this.axis, i10 = e10.chart;
          e10.series.forEach(function(e11) {
            let s10 = e11.options.data;
            if (t10.id && s10) {
              let o10 = i10.get(t10.id), r10 = s10[e11.data.indexOf(o10)];
              o10 && r10 && (o10.collapsed = t10.collapsed, r10.collapsed = t10.collapsed);
            }
          });
        }
        collapse(t10) {
          let e10 = this.axis, i10 = e10.options.breaks || [], s10 = u1(t10, e10.max);
          return i10.push(s10), t10.collapsed = true, e10.treeGrid.setCollapsedStatus(t10), i10;
        }
        expand(t10) {
          let e10 = this.axis, i10 = e10.options.breaks || [], s10 = u1(t10, e10.max);
          return t10.collapsed = false, e10.treeGrid.setCollapsedStatus(t10), i10.reduce(function(t11, e11) {
            return (e11.to !== s10.to || e11.from !== s10.from) && t11.push(e11), t11;
          }, []);
        }
        getTickPositions() {
          let t10 = this.axis, e10 = Math.floor(t10.min / t10.tickInterval) * t10.tickInterval, i10 = Math.ceil(t10.max / t10.tickInterval) * t10.tickInterval;
          return Object.keys(t10.treeGrid.mapOfPosToGridNode || {}).reduce(function(s10, o10) {
            let r10 = +o10;
            return r10 >= e10 && r10 <= i10 && !(t10.brokenAxis && t10.brokenAxis.isInAnyBreak(r10)) && s10.push(r10), s10;
          }, []);
        }
        isCollapsed(t10) {
          let e10 = this.axis, i10 = e10.options.breaks || [], s10 = u1(t10, e10.max);
          return i10.some(function(t11) {
            return t11.from === s10.from && t11.to === s10.to;
          });
        }
        toggleCollapse(t10) {
          return this.isCollapsed(t10) ? this.expand(t10) : this.collapse(t10);
        }
      }
      let {
        series: u7,
        seriesTypes: {
          xrange: gt
        }
      } = ry, {
        extend: ge,
        isNumber: gi,
        merge: gs
      } = tt;
      class go extends gt {
        static compose(t10, e10, i10, s10) {
          gt.compose(t10), e10 && (pb.compose(t10, e10), i10) && (pp.compose(e10, i10.prototype.pointClass), s10 && u8.compose(t10, e10, i10, s10));
        }
        drawPoint(t10, e10) {
          let i10 = this.options, s10 = this.chart.renderer, o10 = t10.shapeArgs, r10 = t10.plotY, n10 = t10.selected && "select", a10 = i10.stacking && !i10.borderRadius, h10 = t10.graphic, l10;
          t10.options.milestone ? gi(r10) && null !== t10.y && false !== t10.visible ? (l10 = s10.symbols.diamond(o10.x || 0, o10.y || 0, o10.width || 0, o10.height || 0), h10 ? h10[e10]({
            d: l10
          }) : t10.graphic = h10 = s10.path(l10).addClass(t10.getClassName(), true).add(t10.group || this.group), this.chart.styledMode || t10.graphic.attr(this.pointAttribs(t10, n10)).shadow(i10.shadow, null, a10)) : h10 && (t10.graphic = h10.destroy()) : super.drawPoint(t10, e10);
        }
        translatePoint(t10) {
          let e10, i10;
          super.translatePoint(t10), t10.options.milestone && (i10 = (e10 = t10.shapeArgs).height || 0, t10.shapeArgs = {
            x: (e10.x || 0) - i10 / 2,
            y: e10.y,
            width: i10,
            height: i10
          });
        }
      }
      go.defaultOptions = gs(gt.defaultOptions, {
        grouping: false,
        dataLabels: {
          enabled: true
        },
        tooltip: {
          headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>',
          pointFormat: null,
          pointFormatter: function() {
            let t10 = this.series, e10 = t10.xAxis, i10 = t10.tooltipOptions.dateTimeLabelFormats, s10 = e10.options.startOfWeek, o10 = t10.tooltipOptions, r10 = this.options.milestone, n10 = o10.xDateFormat, a10 = "<b>" + (this.name || this.yCategory) + "</b>";
            if (o10.pointFormat) return this.tooltipFormatter(o10.pointFormat);
            !n10 && pV(this.start) && (n10 = t10.chart.time.getDateFormat(e10.closestPointRange, this.start, s10, i10 || {}));
            let h10 = t10.chart.time.dateFormat(n10, this.start), l10 = t10.chart.time.dateFormat(n10, this.end);
            return a10 += "<br/>", r10 ? a10 += h10 + "<br/>" : a10 += "Start: " + h10 + "<br/>End: " + l10 + "<br/>", a10;
          }
        },
        connectors: {
          type: "simpleConnect",
          animation: {
            reversed: true
          },
          radius: 0,
          startMarker: {
            enabled: true,
            symbol: "arrow-filled",
            radius: 4,
            fill: "#fa0",
            align: "left"
          },
          endMarker: {
            enabled: false,
            align: "right"
          }
        }
      }), ge(go.prototype, {
        pointArrayMap: ["start", "end", "y"],
        pointClass: pU,
        setData: u7.prototype.setData
      }), ry.registerSeriesType("gantt", go), O.Connection = O.Connection || lH, O.GanttChart = O.GanttChart || l1, O.Navigator = O.Navigator || cs, O.RangeSelector = O.RangeSelector || cK, O.Scrollbar = O.Scrollbar || d$, O.ganttChart = O.GanttChart.ganttChart, lB.compose(O.SVGRenderer), {
        compose: function(t10, e10) {
          lj(lF, "CurrentDateIndication") && (lX(t10, "afterSetOptions", l$), lX(e10, "render", l_), lU(e10.prototype, "getLabelText", lq));
        }
      }.compose(O.Axis, O.PlotLineOrBand), go.compose(O.Axis, O.Chart, O.Series, O.Tick), O.Navigator.compose(O.Chart, O.Axis, O.Series), O.RangeSelector.compose(O.Axis, O.Chart), O.Scrollbar.compose(O.Axis), /**
      * @license Highcharts Gantt JS v12.1.2 (2024-12-21)
      * @module highcharts/highcharts-gantt
      *
      * (c) 2017-2024 Lars Cabrera, Torstein Honsi, Jon Arild Nygard & Oystein Moseng
      *
      * License: www.highcharts.com/license
      */
      O.product = "Highcharts Gantt";
      let gr = O;
      return C.default;
    })());
  }
});

// node_modules/angular-highcharts/fesm2022/angular-highcharts.mjs
var Highcharts = __toESM(require_highcharts(), 1);
var Highmaps = __toESM(require_highmaps(), 1);
var Highstock = __toESM(require_highstock(), 1);
var Highcharts$1 = __toESM(require_highcharts_gantt(), 1);
var Chart = class {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  /**
   * Add Point
   * @param point         Highcharts.DataPoint, number touple or number
   * @param serieIndex    Index position of series. This defaults to 0.
   * @param redraw        Flag whether or not to redraw point. This defaults to true.
   * @param shift         Shift point to the start of series. This defaults to false.
   */
  addPoint(point, serieIndex = 0, redraw = true, shift = false) {
    this.ref$.subscribe((chart2) => {
      if (chart2.series.length > serieIndex) {
        chart2.series[serieIndex].addPoint(point, redraw, shift);
      }
    });
  }
  /**
   * Add Series
   * @param series        Series Configuration
   * @param redraw        Flag whether or not to redraw series. This defaults to true.
   * @param animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
   */
  addSeries(series, redraw = true, animation) {
    this.ref$.subscribe((chart2) => {
      chart2.addSeries(series, redraw, animation);
    });
  }
  /**
   * Remove Point
   * @param pointIndex    Index of Point
   * @param serieIndex    Specified Index of Series. Defaults to 0.
   */
  removePoint(pointIndex, serieIndex = 0) {
    this.ref$.subscribe((chart2) => {
      if (chart2.series.length > serieIndex && chart2.series[serieIndex].data.length > pointIndex) {
        chart2.series[serieIndex].removePoint(pointIndex, true);
      }
    });
  }
  /**
   * Remove Series
   * @param seriesIndex    Index position of series to remove.
   */
  removeSeries(seriesIndex) {
    this.ref$.subscribe((chart2) => {
      if (chart2.series.length > seriesIndex) {
        chart2.series[seriesIndex].remove(true);
      }
    });
  }
  init(el) {
    if (!this.ref) {
      Highcharts.chart(el.nativeElement, this.options, (chart2) => {
        if (!this.ref) {
          this.refSubject.next(chart2);
          this.ref = chart2;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = void 0;
      this.refSubject = new AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
};
var MapChart = class {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  init(el) {
    if (!this.ref) {
      Highmaps.mapChart(el.nativeElement, this.options, (chart2) => {
        if (!this.ref) {
          this.refSubject.next(chart2);
          this.ref = chart2;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = void 0;
      this.refSubject = new AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
};
var StockChart = class {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  init(el) {
    if (!this.ref) {
      Highstock.stockChart(el.nativeElement, this.options, (chart2) => {
        if (!this.ref) {
          this.refSubject.next(chart2);
          this.ref = chart2;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = void 0;
      this.refSubject = new AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
};
var HighchartsGantt = class {
  constructor(options = {
    series: []
  }) {
    this.options = options;
    this.refSubject = new AsyncSubject();
    this.ref$ = this.refSubject.asObservable();
  }
  init(el) {
    if (!this.ref) {
      Highcharts$1.ganttChart(el.nativeElement, this.options, (chart2) => {
        if (!this.ref) {
          this.refSubject.next(chart2);
          this.ref = chart2;
          this.refSubject.complete();
        }
      });
    }
  }
  destroy() {
    if (this.ref) {
      this.options = this.ref.options;
      this.ref.destroy();
      this.ref = void 0;
      this.refSubject = new AsyncSubject();
      this.ref$ = this.refSubject.asObservable();
    }
  }
};
var ChartDirective = class _ChartDirective {
  constructor(el) {
    this.el = el;
  }
  ngOnChanges(changes) {
    if (!changes["chart"]?.isFirstChange()) {
      this.destroy();
      this.init();
    }
  }
  ngOnInit() {
    this.init();
  }
  ngOnDestroy() {
    this.destroy();
  }
  init() {
    if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
      this.chart.init(this.el);
    }
  }
  destroy() {
    if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
      this.chart.destroy();
    }
  }
  static {
    this.ɵfac = function ChartDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChartDirective)(ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _ChartDirective,
      selectors: [["", "chart", ""]],
      inputs: {
        chart: "chart"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartDirective, [{
    type: Directive,
    args: [{
      selector: "[chart]"
    }]
  }], () => [{
    type: ElementRef
  }], {
    chart: [{
      type: Input
    }]
  });
})();
var HIGHCHARTS_MODULES = new InjectionToken("HighchartsModules");
var ChartService = class _ChartService {
  constructor(chartModules) {
    this.chartModules = chartModules;
  }
  initModules() {
    this.chartModules.forEach((chartModule) => {
      [Highcharts, Highstock, Highmaps, Highcharts$1].forEach(chartModule);
    });
  }
  static {
    this.ɵfac = function ChartService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChartService)(ɵɵinject(HIGHCHARTS_MODULES));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ChartService,
      factory: _ChartService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [HIGHCHARTS_MODULES]
    }]
  }], null);
})();
var ChartModule = class _ChartModule {
  constructor(cs) {
    this.cs = cs;
    this.cs.initModules();
  }
  static {
    this.ɵfac = function ChartModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChartModule)(ɵɵinject(ChartService));
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _ChartModule,
      declarations: [ChartDirective],
      exports: [ChartDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [{
        provide: HIGHCHARTS_MODULES,
        useValue: []
      }, ChartService]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartModule, [{
    type: NgModule,
    args: [{
      exports: [ChartDirective],
      declarations: [ChartDirective],
      providers: [{
        provide: HIGHCHARTS_MODULES,
        useValue: []
      }, ChartService]
    }]
  }], () => [{
    type: ChartService
  }], null);
})();
export {
  Chart,
  ChartDirective,
  ChartModule,
  HIGHCHARTS_MODULES,
  HighchartsGantt,
  MapChart,
  StockChart
};
/*! Bundled license information:

angular-highcharts/fesm2022/angular-highcharts.mjs:
  (**
   * @license
   * Copyright Felix Itzenplitz. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at
   * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
   *)
  (**
   * @license
   * Copyright Felix Itzenplitz. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at
   * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
   *
   * @author Felix Itzenplitz
   * @author Timothy A. Perez (contributor)
   *)
*/
//# sourceMappingURL=angular-highcharts.js.map
